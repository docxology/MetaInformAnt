{"AtomIterator": [{"docstring": "Return SeqRecords from Structure objects.\n\nBase function for sequence parsers that read structures Bio.PDB parsers.\n\nOnce a parser from Bio.PDB has been used to load a structure into a\nBio.PDB.Structure.Structure object, there is no difference in how the\nsequence parser interprets the residue sequence. The functions in this\nmodule may be used by SeqIO modules wishing to parse sequences from lists\nof residues.\n\nCalling functions must pass a Bio.PDB.Structure.Structure object.\n\n\nSee Bio.SeqIO.PdbIO.PdbAtomIterator and Bio.SeqIO.PdbIO.CifAtomIterator for\ndetails.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/PdbIO.py", "line_number": 37, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.PdbIO", "name": "AtomIterator", "signature": "(pdb_id, structure)", "symbol_type": "function"}], "BgzfBlocks": [{"docstring": "Low level debugging function to inspect BGZF blocks.\n\nExpects a BGZF compressed file opened in binary read mode using\nthe builtin open function. Do not use a handle from this bgzf\nmodule or the gzip module's open function which will decompress\nthe file.\n\nReturns the block start offset (see virtual offsets), the block\nlength (add these for the start of the next block), and the\ndecompressed length of the blocks contents (limited to 65536 in\nBGZF), as an iterator - one tuple per BGZF block.\n\n>>> from builtins import open\n>>> handle = open(\"SamBam/ex1.bam\", \"rb\")\n>>> for values in BgzfBlocks(handle):\n...     print(\"Raw start %i, raw length %i; data start %i, data length %i\" % values)\nRaw start 0, raw length 18239; data start 0, data length 65536\nRaw start 18239, raw length 18223; data start 65536, data length 65536\nRaw start 36462, raw length 18017; data start 131072, data length 65536\nRaw start 54479, raw length 17342; data start 196608, data length 65536\nRaw start 71821, raw length 17715; data start 262144, data length 65536\nRaw start 89536, raw length 17728; data start 327680, data length 65536\nRaw start 107264, raw length 17292; data start 393216, data length 63398\nRaw start 124556, raw length 28; data start 456614, data length 0\n>>> handle.close()\n\nIndirectly we can tell this file came from an old version of\nsamtools because all the blocks (except the final one and the\ndummy empty EOF marker block) are 65536 bytes.  Later versions\navoid splitting a read between two blocks, and give the header\nits own block (useful to speed up replacing the header). You\ncan see this in ex1_refresh.bam created using samtools 0.1.18:\n\nsamtools view -b ex1.bam > ex1_refresh.bam\n\n>>> handle = open(\"SamBam/ex1_refresh.bam\", \"rb\")\n>>> for values in BgzfBlocks(handle):\n...     print(\"Raw start %i, raw length %i; data start %i, data length %i\" % values)\nRaw start 0, raw length 53; data start 0, data length 38\nRaw start 53, raw length 18195; data start 38, data length 65434\nRaw start 18248, raw length 18190; data start 65472, data length 65409\nRaw start 36438, raw length 18004; data start 130881, data length 65483\nRaw start 54442, raw length 17353; data start 196364, data length 65519\nRaw start 71795, raw length 17708; data start 261883, data length 65411\nRaw start 89503, raw length 17709; data start 327294, data length 65466\nRaw start 107212, raw length 17390; data start 392760, data length 63854\nRaw start 124602, raw length 28; data start 456614, data length 0\n>>> handle.close()\n\nThe above example has no embedded SAM header (thus the first block\nis very small at just 38 bytes of decompressed data), while the next\nexample does (a larger block of 103 bytes). Notice that the rest of\nthe blocks show the same sizes (they contain the same read data):\n\n>>> handle = open(\"SamBam/ex1_header.bam\", \"rb\")\n>>> for values in BgzfBlocks(handle):\n...     print(\"Raw start %i, raw length %i; data start %i, data length %i\" % values)\nRaw start 0, raw length 104; data start 0, data length 103\nRaw start 104, raw length 18195; data start 103, data length 65434\nRaw start 18299, raw length 18190; data start 65537, data length 65409\nRaw start 36489, raw length 18004; data start 130946, data length 65483\nRaw start 54493, raw length 17353; data start 196429, data length 65519\nRaw start 71846, raw length 17708; data start 261948, data length 65411\nRaw start 89554, raw length 17709; data start 327359, data length 65466\nRaw start 107263, raw length 17390; data start 392825, data length 63854\nRaw start 124653, raw length 28; data start 456679, data length 0\n>>> handle.close()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 348, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "BgzfBlocks", "signature": "(handle)", "symbol_type": "function"}], "CheckAssemblyAvailability": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 339, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "CheckAssemblyAvailability", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 474, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "CheckAssemblyAvailability", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 550, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "CheckAssemblyAvailability", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 707, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "CheckAssemblyAvailability", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "CheckVirusAvailability": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 824, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "CheckVirusAvailability", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 959, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "CheckVirusAvailability", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1035, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "CheckVirusAvailability", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1192, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "CheckVirusAvailability", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "CsvIterator": [{"docstring": "Iterate over PM csv records as PlateRecord objects.\n\nArguments:\n - handle - input file", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/phen_micro.py", "line_number": 1000, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.phen_micro", "name": "CsvIterator", "signature": "(handle)", "symbol_type": "function"}], "DELETE": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/rest.py", "line_number": 255, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.rest", "name": "DELETE", "signature": "(self, url, headers = None, query_params = None, body = None, _preload_content = True, _request_timeout = None)", "symbol_type": "function"}], "FastaM10Iterator": [{"docstring": "Alignment iterator for the FASTA tool's pairwise alignment output.\n\nThis is for reading the pairwise alignments output by Bill Pearson's\nFASTA program when called with the -m 10 command line option for machine\nreadable output.  For more details about the FASTA tools, see the website\nhttp://fasta.bioch.virginia.edu/ and the paper:\n\n     W.R. Pearson & D.J. Lipman PNAS (1988) 85:2444-2448\n\nThis class is intended to be used via the Bio.AlignIO.parse() function\nby specifying the format as \"fasta-m10\" as shown in the following code::\n\n    from Bio import AlignIO\n    handle = ...\n    for a in AlignIO.parse(handle, \"fasta-m10\"):\n        assert len(a) == 2, \"Should be pairwise!\"\n        print(\"Alignment length %i\" % a.get_alignment_length())\n        for record in a:\n            print(\"%s %s %s\" % (record.seq, record.name, record.id))\n\nNote that this is not a full blown parser for all the information\nin the FASTA output - for example, most of the header and all of the\nfooter is ignored.  Also, the alignments are not batched according to\nthe input queries.\n\nAlso note that there can be up to about 30 letters of flanking region\nincluded in the raw FASTA output as contextual information.  This is NOT\npart of the alignment itself, and is not included in the resulting\nMultipleSeqAlignment objects returned.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/FastaIO.py", "line_number": 62, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.FastaIO", "name": "FastaM10Iterator", "signature": "(handle, seq_count = None)", "symbol_type": "function"}], "FastaTwoLineParser": [{"docstring": "Iterate over no-wrapping Fasta records as string tuples.\n\nArguments:\n - handle - input stream opened in text mode\n\nFunctionally the same as SimpleFastaParser but with a strict\ninterpretation of the FASTA format as exactly two lines per\nrecord, the greater-than-sign identifier with description,\nand the sequence with no line wrapping.\n\nAny line wrapping will raise an exception, as will excess blank\nlines (other than the special case of a zero-length sequence\nas the second line of a record).\n\nExamples\n--------\nThis file uses two lines per FASTA record:\n\n>>> with open(\"Fasta/aster_no_wrap.pro\") as handle:\n...     for title, seq in FastaTwoLineParser(handle):\n...         print(\"%s = %s...\" % (title, seq[:3]))\n...\ngi|3298468|dbj|BAA31520.1| SAMIPF = GGH...\n\nThis equivalent file uses line wrapping:\n\n>>> with open(\"Fasta/aster.pro\") as handle:\n...     for title, seq in FastaTwoLineParser(handle):\n...         print(\"%s = %s...\" % (title, seq[:3]))\n...\nTraceback (most recent call last):\n   ...\nValueError: Expected FASTA record starting with '>' character. Perhaps this file is using FASTA line wrapping? Got: 'MTFGLVYTVYATAIDPKKGSLGTIAPIAIGFIVGANI'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/FastaIO.py", "line_number": 77, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.FastaIO", "name": "FastaTwoLineParser", "signature": "(handle)", "symbol_type": "function"}], "FastqGeneralIterator": [{"docstring": "Iterate over Fastq records as string tuples (not as SeqRecord objects).\n\nArguments:\n - source - input stream opened in text mode, or a path to a file\n\nThis code does not try to interpret the quality string numerically.  It\njust returns tuples of the title, sequence and quality as strings.  For\nthe sequence and quality, any whitespace (such as new lines) is removed.\n\nOur SeqRecord based FASTQ iterators call this function internally, and then\nturn the strings into a SeqRecord objects, mapping the quality string into\na list of numerical scores.  If you want to do a custom quality mapping,\nthen you might consider calling this function directly.\n\nFor parsing FASTQ files, the title string from the \"@\" line at the start\nof each record can optionally be omitted on the \"+\" lines.  If it is\nrepeated, it must be identical.\n\nThe sequence string and the quality string can optionally be split over\nmultiple lines, although several sources discourage this.  In comparison,\nfor the FASTA file format line breaks between 60 and 80 characters are\nthe norm.\n\n**WARNING** - Because the \"@\" character can appear in the quality string,\nthis can cause problems as this is also the marker for the start of\na new sequence.  In fact, the \"+\" sign can also appear as well.  Some\nsources recommended having no line breaks in the  quality to avoid this,\nbut even that is not enough, consider this example::\n\n    @071113_EAS56_0053:1:1:998:236\n    TTTCTTGCCCCCATAGACTGAGACCTTCCCTAAATA\n    +071113_EAS56_0053:1:1:998:236\n    IIIIIIIIIIIIIIIIIIIIIIIIIIIIICII+III\n    @071113_EAS56_0053:1:1:182:712\n    ACCCAGCTAATTTTTGTATTTTTGTTAGAGACAGTG\n    +\n    @IIIIIIIIIIIIIIICDIIIII<%<6&-*).(*%+\n    @071113_EAS56_0053:1:1:153:10\n    TGTTCTGAAGGAAGGTGTGCGTGCGTGTGTGTGTGT\n    +\n    IIIIIIIIIIIICIIGIIIII>IAIIIE65I=II:6\n    @071113_EAS56_0053:1:3:990:501\n    TGGGAGGTTTTATGTGGA\n    AAGCAGCAATGTACAAGA\n    +\n    IIIIIII.IIIIII1@44\n    @-7.%<&+/$/%4(++(%\n\nThis is four PHRED encoded FASTQ entries originally from an NCBI source\n(given the read length of 36, these are probably Solexa Illumina reads where\nthe quality has been mapped onto the PHRED values).\n\nThis example has been edited to illustrate some of the nasty things allowed\nin the FASTQ format.  Firstly, on the \"+\" lines most but not all of the\n(redundant) identifiers are omitted.  In real files it is likely that all or\nnone of these extra identifiers will be present.\n\nSecondly, while the first three sequences have been shown without line\nbreaks, the last has been split over multiple lines.  In real files any line\nbreaks are likely to be consistent.\n\nThirdly, some of the quality string lines start with an \"@\" character.  For\nthe second record this is unavoidable.  However for the fourth sequence this\nonly happens because its quality string is split over two lines.  A naive\nparser could wrongly treat any line starting with an \"@\" as the beginning of\na new sequence!  This code copes with this possible ambiguity by keeping\ntrack of the length of the sequence which gives the expected length of the\nquality string.\n\nUsing this tricky example file as input, this short bit of code demonstrates\nwhat this parsing function would return:\n\n>>> with open(\"Quality/tricky.fastq\") as handle:\n...     for (title, sequence, quality) in FastqGeneralIterator(handle):\n...         print(title)\n...         print(\"%s %s\" % (sequence, quality))\n...\n071113_EAS56_0053:1:1:998:236\nTTTCTTGCCCCCATAGACTGAGACCTTCCCTAAATA IIIIIIIIIIIIIIIIIIIIIIIIIIIIICII+III\n071113_EAS56_0053:1:1:182:712\nACCCAGCTAATTTTTGTATTTTTGTTAGAGACAGTG @IIIIIIIIIIIIIIICDIIIII<%<6&-*).(*%+\n071113_EAS56_0053:1:1:153:10\nTGTTCTGAAGGAAGGTGTGCGTGCGTGTGTGTGTGT IIIIIIIIIIIICIIGIIIII>IAIIIE65I=II:6\n071113_EAS56_0053:1:3:990:501\nTGGGAGGTTTTATGTGGAAAGCAGCAATGTACAAGA IIIIIII.IIIIII1@44@-7.%<&+/$/%4(++(%\n\nFinally we note that some sources state that the quality string should\nstart with \"!\" (which using the PHRED mapping means the first letter always\nhas a quality score of zero).  This rather restrictive rule is not widely\nobserved, so is therefore ignored here.  One plus point about this \"!\" rule\nis that (provided there are no line breaks in the quality sequence) it\nwould prevent the above problem with the \"@\" character.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 839, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "FastqGeneralIterator", "signature": "(source: _TextIOSource) -> Iterator[tuple[str, str, str]]", "symbol_type": "function"}], "Fetch": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 995, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "Fetch", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 1020, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "Fetch", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1228, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "Fetch", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1253, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "Fetch", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GC123": [{"docstring": "Calculate G+C content: total, for first, second and third positions.\n\nReturns a tuple of four floats (percentages between 0 and 100) for the\nentire sequence, and the three codon positions.  e.g.\n\n>>> from Bio.SeqUtils import GC123\n>>> GC123(\"ACTGTN\")\n(40.0, 50.0, 50.0, 0.0)\n\nCopes with mixed case sequences, but does NOT deal with ambiguous\nnucleotides.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/__init__.py", "line_number": 150, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.__init__", "name": "GC123", "signature": "(seq)", "symbol_type": "function"}], "GC_skew": [{"docstring": "Calculate GC skew (G-C)/(G+C) for multiple windows along the sequence.\n\nReturns a list of ratios (floats), controlled by the length of the sequence\nand the size of the window.\n\nReturns 0 for windows without any G/C by handling zero division errors.\n\nDoes NOT look at any ambiguous nucleotides.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/__init__.py", "line_number": 192, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.__init__", "name": "GC_skew", "signature": "(seq, window = 100)", "symbol_type": "function"}], "GET": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/rest.py", "line_number": 229, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.rest", "name": "GET", "signature": "(self, url, headers = None, query_params = None, _preload_content = True, _request_timeout = None)", "symbol_type": "function"}], "GetAssemblyDataReports": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 139, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetAssemblyDataReports", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 252, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetAssemblyDataReports", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetAssemblyDatasetStream": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 309, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetAssemblyDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 389, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetAssemblyDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 514, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetAssemblyDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 605, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetAssemblyDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetAssemblyLinks": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 157, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetAssemblyLinks", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 303, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetAssemblyLinks", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetAssemblyMetadata": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 45, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetAssemblyMetadata", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 103, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetAssemblyMetadata", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetAssemblyRevisionHistory": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 145, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetAssemblyRevisionHistory", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 269, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetAssemblyRevisionHistory", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetBioSampleDataReports": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 37, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetBioSampleDataReports", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 62, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetBioSampleDataReports", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetCheckMHistogram": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 163, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetCheckMHistogram", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 320, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetCheckMHistogram", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetChromsomeSummaryForTaxonAndAnnotation": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 798, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetChromsomeSummaryForTaxonAndAnnotation", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 933, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetChromsomeSummaryForTaxonAndAnnotation", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetDownloadSummary": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 51, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 120, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 558, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 682, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 794, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 874, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 133, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 235, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 774, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 865, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 999, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1090, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1471, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1540, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetDownloadSummary", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetGeneCountsByTaxon": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 780, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGeneCountsByTaxon", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 882, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGeneCountsByTaxon", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetGeneDataReportsPaged": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 768, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGeneDataReportsPaged", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 848, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGeneDataReportsPaged", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetGeneDatasetStream": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 315, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetGeneDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 406, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetGeneDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 520, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGeneDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 622, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGeneDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetGeneDescriptors": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 540, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetGeneDescriptors", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 631, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetGeneDescriptors", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetGeneLinks": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 792, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGeneLinks", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 916, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGeneLinks", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetGeneMetadata": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 546, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetGeneMetadata", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 648, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetGeneMetadata", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetGenomeAnnotationDatasetStream": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 538, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGenomeAnnotationDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 673, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGenomeAnnotationDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetGenomeAnnotationSummary": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1465, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGenomeAnnotationSummary", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1523, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGenomeAnnotationSummary", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetGenomeAnnotations": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1459, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGenomeAnnotations", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1506, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetGenomeAnnotations", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetMicroBiggeDatasetStream": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 321, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetMicroBiggeDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 423, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetMicroBiggeDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 526, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetMicroBiggeDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 639, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetMicroBiggeDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetMinimumFilteredSubtree": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 1072, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetMinimumFilteredSubtree", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 1130, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetMinimumFilteredSubtree", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1620, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetMinimumFilteredSubtree", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1733, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetMinimumFilteredSubtree", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetOrganismsThatMatch": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 576, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetOrganismsThatMatch", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 733, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetOrganismsThatMatch", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 1078, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetOrganismsThatMatch", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 1147, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetOrganismsThatMatch", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1304, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetOrganismsThatMatch", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1362, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetOrganismsThatMatch", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetOrthologSet": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 564, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetOrthologSet", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 699, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetOrthologSet", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 786, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetOrthologSet", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 899, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetOrthologSet", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetProkaryoteGeneDatasetStream": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 333, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetProkaryoteGeneDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 457, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetProkaryoteGeneDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 532, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetProkaryoteGeneDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 656, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetProkaryoteGeneDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetRefGeneCatalogDatasetStream": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 327, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetRefGeneCatalogDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 440, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetRefGeneCatalogDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetRelatedTaxids": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1614, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetRelatedTaxids", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1716, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetRelatedTaxids", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetSars2ProteinDatasetStream": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 201, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetSars2ProteinDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 248, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetSars2ProteinDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 401, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetSars2ProteinDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 448, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetSars2ProteinDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetSars2ProteinDownloadSummary": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 800, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetSars2ProteinDownloadSummary", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 891, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetSars2ProteinDownloadSummary", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1005, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetSars2ProteinDownloadSummary", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1107, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetSars2ProteinDownloadSummary", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetSars2ProteinMetadataAsTable": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 812, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetSars2ProteinMetadataAsTable", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 925, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetSars2ProteinMetadataAsTable", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1017, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetSars2ProteinMetadataAsTable", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1141, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetSars2ProteinMetadataAsTable", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetSequenceReports": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 151, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetSequenceReports", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 286, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetSequenceReports", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetTaxTree": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 570, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetTaxTree", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 716, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetTaxTree", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetTaxonomyDataReportFor": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1602, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyDataReportFor", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1682, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyDataReportFor", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetTaxonomyDatasetStream": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 544, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 690, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetTaxonomyImage": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1316, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyImage", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1396, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyImage", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetTaxonomyImageMetadata": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1322, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyImageMetadata", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1413, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyImageMetadata", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetTaxonomyLinks": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1310, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyLinks", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1379, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyLinks", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetTaxonomyMetadataFor": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 1066, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetTaxonomyMetadataFor", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 1113, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetTaxonomyMetadataFor", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1596, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyMetadataFor", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1665, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyMetadataFor", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetTaxonomyNamesDataReportFor": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1608, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyNamesDataReportFor", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1699, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetTaxonomyNamesDataReportFor", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetVirusAnnotationReports": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1029, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetVirusAnnotationReports", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1175, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetVirusAnnotationReports", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetVirusDataReports": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 818, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetVirusDataReports", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 942, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetVirusDataReports", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1023, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetVirusDataReports", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1158, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetVirusDataReports", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetVirusDatasetStream": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 195, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetVirusDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 231, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetVirusDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 395, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetVirusDatasetStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 431, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetVirusDatasetStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "GetVirusGenomeMetadataAsTable": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 806, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetVirusGenomeMetadataAsTable", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 908, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "GetVirusGenomeMetadataAsTable", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1011, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetVirusGenomeMetadataAsTable", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1124, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "GetVirusGenomeMetadataAsTable", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "HEAD": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/rest.py", "line_number": 237, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.rest", "name": "HEAD", "signature": "(self, url, headers = None, query_params = None, _preload_content = True, _request_timeout = None)", "symbol_type": "function"}], "IC_duplicate": [{"docstring": "Duplicate structure entity with IC data, no atom coordinates.\n\nEmploys :func:`.write_PIC`, :func:`.read_PIC` with StringIO buffer.\nCalls :meth:`.Chain.atom_to_internal_coordinates` if needed.\n\n:param Entity entity: Biopython PDB Entity (will fail for Atom)\n:returns: Biopython PDBStructure, no Atom objects except initial coords", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/ic_rebuild.py", "line_number": 168, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.ic_rebuild", "name": "IC_duplicate", "signature": "(entity) -> Structure", "symbol_type": "function"}], "JsonIterator": [{"docstring": "Iterate over PM json records as PlateRecord objects.\n\nArguments:\n - handle - input file", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/phen_micro.py", "line_number": 912, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.phen_micro", "name": "JsonIterator", "signature": "(handle)", "symbol_type": "function"}], "MafIterator": [{"docstring": "Iterate over a MAF file handle as MultipleSeqAlignment objects.\n\nIterates over lines in a MAF file-like object (handle), yielding\nMultipleSeqAlignment objects. SeqRecord IDs generally correspond to\nspecies names.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/MafIO.py", "line_number": 129, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.MafIO", "name": "MafIterator", "signature": "(handle, seq_count = None)", "symbol_type": "function"}], "NexusIterator": [{"docstring": "Return SeqRecord objects from a Nexus file.\n\nThus uses the Bio.Nexus module to do the hard work.\n\nYou are expected to call this function via Bio.SeqIO or Bio.AlignIO\n(and not use it directly).\n\nNOTE - We only expect ONE alignment matrix per Nexus file,\nmeaning this iterator will only yield one MultipleSeqAlignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/NexusIO.py", "line_number": 31, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.NexusIO", "name": "NexusIterator", "signature": "(handle: IO[str], seq_count: int | None = None) -> Iterator[MultipleSeqAlignment]", "symbol_type": "function"}], "OPTIONS": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/rest.py", "line_number": 245, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.rest", "name": "OPTIONS", "signature": "(self, url, headers = None, query_params = None, post_params = None, body = None, _preload_content = True, _request_timeout = None)", "symbol_type": "function"}], "PATCH": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/rest.py", "line_number": 284, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.rest", "name": "PATCH", "signature": "(self, url, headers = None, query_params = None, post_params = None, body = None, _preload_content = True, _request_timeout = None)", "symbol_type": "function"}], "POST": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/rest.py", "line_number": 264, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.rest", "name": "POST", "signature": "(self, url, headers = None, query_params = None, post_params = None, body = None, _preload_content = True, _request_timeout = None)", "symbol_type": "function"}], "PUT": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/rest.py", "line_number": 274, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.rest", "name": "PUT", "signature": "(self, url, headers = None, query_params = None, post_params = None, body = None, _preload_content = True, _request_timeout = None)", "symbol_type": "function"}], "PairedFastaQualIterator": [{"docstring": "Iterate over matched FASTA and QUAL files as SeqRecord objects.\n\nFor example, consider this short QUAL file with PHRED quality scores::\n\n    >EAS54_6_R1_2_1_413_324\n    26 26 18 26 26 26 26 26 26 26 26 26 26 26 26 22 26 26 26 26\n    26 26 26 23 23\n    >EAS54_6_R1_2_1_540_792\n    26 26 26 26 26 26 26 26 26 26 26 22 26 26 26 26 26 12 26 26\n    26 18 26 23 18\n    >EAS54_6_R1_2_1_443_348\n    26 26 26 26 26 26 26 26 26 26 26 24 26 22 26 26 13 22 26 18\n    24 18 18 18 18\n\nAnd a matching FASTA file::\n\n    >EAS54_6_R1_2_1_413_324\n    CCCTTCTTGTCTTCAGCGTTTCTCC\n    >EAS54_6_R1_2_1_540_792\n    TTGGCAGGCCAAGGCCGATGGATCA\n    >EAS54_6_R1_2_1_443_348\n    GTTGCTTCTGGCGTGGGTGGGGGGG\n\nYou can parse these separately using Bio.SeqIO with the \"qual\" and\n\"fasta\" formats, but then you'll get a group of SeqRecord objects with\nno sequence, and a matching group with the sequence but not the\nqualities.  Because it only deals with one input file handle, Bio.SeqIO\ncan't be used to read the two files together - but this function can!\nFor example,\n\n>>> with open(\"Quality/example.fasta\") as f:\n...     with open(\"Quality/example.qual\") as q:\n...         for record in PairedFastaQualIterator(f, q):\n...             print(\"%s %s\" % (record.id, record.seq))\n...\nEAS54_6_R1_2_1_413_324 CCCTTCTTGTCTTCAGCGTTTCTCC\nEAS54_6_R1_2_1_540_792 TTGGCAGGCCAAGGCCGATGGATCA\nEAS54_6_R1_2_1_443_348 GTTGCTTCTGGCGTGGGTGGGGGGG\n\nAs with the FASTQ or QUAL parsers, if you want to look at the qualities,\nthey are in each record's per-letter-annotation dictionary as a simple\nlist of integers:\n\n>>> print(record.letter_annotations[\"phred_quality\"])\n[26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 24, 26, 22, 26, 26, 13, 22, 26, 18, 24, 18, 18, 18, 18]\n\nIf you have access to data as a FASTQ format file, using that directly\nwould be simpler and more straight forward.  Note that you can easily use\nthis function to convert paired FASTA and QUAL files into FASTQ files:\n\n>>> from Bio import SeqIO\n>>> with open(\"Quality/example.fasta\") as f:\n...     with open(\"Quality/example.qual\") as q:\n...         SeqIO.write(PairedFastaQualIterator(f, q), \"Quality/temp.fastq\", \"fastq\")\n...\n3\n\nAnd don't forget to clean up the temp file if you don't need it anymore:\n\n>>> import os\n>>> os.remove(\"Quality/temp.fastq\")", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 2017, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "PairedFastaQualIterator", "signature": "(fasta_source: _TextIOSource, qual_source: _TextIOSource, alphabet: None = None) -> Iterator[SeqRecord]", "symbol_type": "function"}], "ReadRocheXmlManifest": [{"docstring": "Read any Roche style XML manifest data in the SFF \"index\".\n\nThe SFF file format allows for multiple different index blocks, and Roche\ntook advantage of this to define their own index block which also embeds\nan XML manifest string. This is not a publicly documented extension to\nthe SFF file format, this was reverse engineered.\n\nThe handle should be to an SFF file opened in binary mode. This function\nwill use the handle seek/tell functions and leave the handle in an\narbitrary location.\n\nAny XML manifest found is returned as a Python string, which you can then\nparse as appropriate, or reuse when writing out SFF files with the\nSffWriter class.\n\nReturns a string, or raises a ValueError if an Roche manifest could not be\nfound.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SffIO.py", "line_number": 550, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SffIO", "name": "ReadRocheXmlManifest", "signature": "(handle)", "symbol_type": "function"}], "SimpleFastaParser": [{"docstring": "Iterate over Fasta records as string tuples.\n\nArguments:\n - handle - input stream opened in text mode\n\nFor each record a tuple of two strings is returned, the FASTA title\nline (without the leading '>' character), and the sequence (with any\nwhitespace removed). The title line is not divided up into an\nidentifier (the first word) and comment or description.\n\n>>> with open(\"Fasta/dups.fasta\") as handle:\n...     for values in SimpleFastaParser(handle):\n...         print(values)\n...\n('alpha', 'ACGTA')\n('beta', 'CGTC')\n('gamma', 'CCGCC')\n('alpha (again - this is a duplicate entry to test the indexing code)', 'ACGTA')\n('delta', 'CGCGC')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/FastaIO.py", "line_number": 30, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.FastaIO", "name": "SimpleFastaParser", "signature": "(handle)", "symbol_type": "function"}], "Sleep": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 57, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "Sleep", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 137, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "Sleep", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 169, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "Sleep", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 337, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "Sleep", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "SleepStream": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 63, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "SleepStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 154, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "SleepStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 175, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "SleepStream", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 354, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "SleepStream", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "StreamGeneMetadata": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 552, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "StreamGeneMetadata", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 665, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "StreamGeneMetadata", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "Tm_GC": [{"docstring": "Return the Tm using empirical formulas based on GC content.\n\nGeneral format: Tm = A + B(%GC) - C/N + salt correction - D(%mismatch)\n\nA, B, C, D: empirical constants, N: primer length\nD (amount of decrease in Tm per % mismatch) is often 1, but sometimes other\nvalues have been used (0.6-1.5). Use 'X' to indicate the mismatch position\nin the sequence. Note that this mismatch correction is a rough estimate.\n\n>>> from Bio.SeqUtils import MeltingTemp as mt\n>>> print(\"%0.2f\" % mt.Tm_GC('CTGCTGATXGCACGAGGTTATGG', valueset=2))\n69.20\n\nArguments:\n - valueset: A few often cited variants are included:\n\n    1. Tm = 69.3 + 0.41(%GC) - 650/N\n       (Marmur & Doty 1962, J Mol Biol 5: 109-118; Chester & Marshak 1993),\n       Anal Biochem 209: 284-290)\n    2. Tm = 81.5 + 0.41(%GC) - 675/N - %mismatch\n       'QuikChange' formula. Recommended (by the manufacturer) for the\n       design of primers for QuikChange mutagenesis.\n    3. Tm = 81.5 + 0.41(%GC) - 675/N + 16.6 x log[Na+]\n       (Marmur & Doty 1962, J Mol Biol 5: 109-118; Schildkraut & Lifson\n       1965, Biopolymers 3: 195-208)\n    4. Tm = 81.5 + 0.41(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x\n       [Na+])) - %mismatch\n       (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). This is the\n       standard formula in approximative mode of MELTING 4.3.\n    5. Tm = 78 + 0.7(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\n       - %mismatch\n       (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA.\n    6. Tm = 67 + 0.8(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\n       - %mismatch\n       (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA/DNA\n       hybrids.\n    7. Tm = 81.5 + 0.41(%GC) - 600/N + 16.6 x log[Na+]\n       Used by Primer3Plus to calculate the product Tm. Default set.\n    8. Tm = 77.1 + 0.41(%GC) - 528/N + 11.7 x log[Na+]\n       (von Ahsen et al. 2001, Clin Chem 47: 1956-1961). Recommended 'as a\n       tradeoff between accuracy and ease of use'.\n\n - userset: Tuple of four values for A, B, C, and D. Usersets override\n   valuesets.\n - Na, K, Tris, Mg, dNTPs: Concentration of the respective ions [mM]. If\n   any of K, Tris, Mg and dNTPS is non-zero, a 'sodium-equivalent'\n   concentration is calculated and used for salt correction (von Ahsen et\n   al., 2001).\n - saltcorr: Type of salt correction (see method salt_correction).\n   Default=0. 0 or None means no salt correction.\n - mismatch: If 'True' (default) every 'X' in the sequence is counted as\n   mismatch.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/MeltingTemp.py", "line_number": 692, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.MeltingTemp", "name": "Tm_GC", "signature": "(seq, check = True, strict = True, valueset = 7, userset = None, Na = 50, K = 0, Tris = 0, Mg = 0, dNTPs = 0, saltcorr = 0, mismatch = True)", "symbol_type": "function"}], "Tm_NN": [{"docstring": "Return the Tm using nearest neighbor thermodynamics.\n\nArguments:\n - seq: The primer/probe sequence as string or Biopython sequence object.\n   For RNA/DNA hybridizations seq must be the RNA sequence.\n - c_seq: Complementary sequence. The sequence of the template/target in\n   3'->5' direction. c_seq is necessary for mismatch correction and\n   dangling-ends correction. Both corrections will automatically be\n   applied if mismatches or dangling ends are present. Default=None.\n - shift: Shift of the primer/probe sequence on the template/target\n   sequence, e.g.::\n\n                       shift=0       shift=1        shift= -1\n    Primer (seq):      5' ATGC...    5'  ATGC...    5' ATGC...\n    Template (c_seq):  3' TACG...    3' CTACG...    3'  ACG...\n\n   The shift parameter is necessary to align seq and c_seq if they have\n   different lengths or if they should have dangling ends. Default=0\n - table: Thermodynamic NN values, eight tables are implemented:\n   For DNA/DNA hybridizations:\n\n    - DNA_NN1: values from Breslauer et al. (1986)\n    - DNA_NN2: values from Sugimoto et al. (1996)\n    - DNA_NN3: values from Allawi & SantaLucia (1997) (default)\n    - DNA_NN4: values from SantaLucia & Hicks (2004)\n\n   For RNA/RNA hybridizations:\n\n    - RNA_NN1: values from Freier et al. (1986)\n    - RNA_NN2: values from Xia et al. (1998)\n    - RNA_NN3: values from Chen et al. (2012)\n\n   For RNA/DNA hybridizations:\n\n    - R_DNA_NN1: values from Sugimoto et al. (1995)\n      Note that ``seq`` must be the RNA sequence.\n\n   Use the module's maketable method to make a new table or to update one\n   one of the implemented tables.\n - tmm_table: Thermodynamic values for terminal mismatches.\n   Default: DNA_TMM1 (SantaLucia & Peyret, 2001)\n - imm_table: Thermodynamic values for internal mismatches, may include\n   insosine mismatches. Default: DNA_IMM1 (Allawi & SantaLucia, 1997-1998;\n   Peyret et al., 1999; Watkins & SantaLucia, 2005)\n - de_table: Thermodynamic values for dangling ends:\n\n    - DNA_DE1: for DNA. Values from Bommarito et al. (2000) (default)\n    - RNA_DE1: for RNA. Values from Turner & Mathews (2010)\n\n - dnac1: Concentration of the higher concentrated strand [nM]. Typically\n   this will be the primer (for PCR) or the probe. Default=25.\n - dnac2: Concentration of the lower concentrated strand [nM]. In PCR this\n   is the template strand which concentration is typically very low and may\n   be ignored (dnac2=0). In oligo/oligo hybridization experiments, dnac1\n   equals dnac1. Default=25.\n   MELTING and Primer3Plus use k = [Oligo(Total)]/4 by default. To mimic\n   this behaviour, you have to divide [Oligo(Total)] by 2 and assign this\n   concentration to dnac1 and dnac2. E.g., Total oligo concentration of\n   50 nM in Primer3Plus means dnac1=25, dnac2=25.\n - selfcomp: Is the sequence self-complementary? Default=False. If 'True'\n   the primer is thought binding to itself, thus dnac2 is not considered.\n - Na, K, Tris, Mg, dNTPs: See method 'Tm_GC' for details. Defaults: Na=50,\n   K=0, Tris=0, Mg=0, dNTPs=0.\n - saltcorr: See method 'Tm_GC'. Default=5. 0 means no salt correction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/MeltingTemp.py", "line_number": 831, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.MeltingTemp", "name": "Tm_NN", "signature": "(seq, check = True, strict = True, c_seq = None, shift = 0, nn_table = None, tmm_table = None, imm_table = None, de_table = None, dnac1 = 25, dnac2 = 25, selfcomp = False, Na = 50, K = 0, Tris = 0, Mg = 0, dNTPs = 0, saltcorr = 5)", "symbol_type": "function"}], "Tm_Wallace": [{"docstring": "Calculate and return the Tm using the 'Wallace rule'.\n\nTm = 4 degC * (G + C) + 2 degC * (A+T)\n\nThe Wallace rule (Thein & Wallace 1986, in Human genetic diseases: a\npractical approach, 33-50) is often used as rule of thumb for approximate\nTm calculations for primers of 14 to 20 nt length.\n\nNon-DNA characters (e.g., E, F, J, !, 1, etc) are ignored by this method.\n\nExamples:\n    >>> from Bio.SeqUtils import MeltingTemp as mt\n    >>> mt.Tm_Wallace('ACGTTGCAATGCCGTA')\n    48.0\n    >>> mt.Tm_Wallace('ACGT TGCA ATGC CGTA')\n    48.0\n    >>> mt.Tm_Wallace('1ACGT2TGCA3ATGC4CGTA')\n    48.0", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/MeltingTemp.py", "line_number": 648, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.MeltingTemp", "name": "Tm_Wallace", "signature": "(seq, check = True, strict = True)", "symbol_type": "function"}], "Version": [{"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 1183, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "Version", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 1208, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "Version", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}, {"docstring": "Missing associated documentation comment in .proto file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1769, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "Version", "signature": "(self, request, context)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1794, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "Version", "signature": "(request, target, options = (), channel_credentials = None, call_credentials = None, insecure = False, compression = None, wait_for_ready = None, timeout = None, metadata = None)", "symbol_type": "function"}], "absorb": [{"docstring": "Add a Hit object to the end of QueryResult.\n\nIf the QueryResult already has a Hit with the same ID, append the new\nHit's HSPs into the existing Hit.\n\n:param hit: object to absorb\n:type hit: Hit\n\nThis method is used for file formats that may output the same Hit in\nseparate places, such as BLAT or Exonerate. In both formats, Hit\nwith different strands are put in different places. However, SearchIO\nconsiders them to be the same as a Hit object should be all database\nentries with the same ID, regardless of strand orientation.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 424, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "absorb", "signature": "(self, hit)", "symbol_type": "function"}], "accept_atom": [{"docstring": "Verify if atoms are not Hydrogen.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Dice.py", "line_number": 63, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Dice", "name": "accept_atom", "signature": "(self, atom)", "symbol_type": "function"}, {"docstring": "Overload this to reject atoms for output.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBIO.py", "line_number": 85, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBIO", "name": "accept_atom", "signature": "(self, atom)", "symbol_type": "function"}], "accept_chain": [{"docstring": "Verify if chain match chain identifier.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Dice.py", "line_number": 42, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Dice", "name": "accept_chain", "signature": "(self, chain)", "symbol_type": "function"}, {"docstring": "Overload this to reject chains for output.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBIO.py", "line_number": 77, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBIO", "name": "accept_chain", "signature": "(self, chain)", "symbol_type": "function"}], "accept_model": [{"docstring": "Verify if model match the model identifier.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Dice.py", "line_number": 35, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Dice", "name": "accept_model", "signature": "(self, model)", "symbol_type": "function"}, {"docstring": "Overload this to reject models for output.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBIO.py", "line_number": 73, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBIO", "name": "accept_model", "signature": "(self, model)", "symbol_type": "function"}], "accept_residue": [{"docstring": "Verify if a residue sequence is between the start and end sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Dice.py", "line_number": 48, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Dice", "name": "accept_residue", "signature": "(self, residue)", "symbol_type": "function"}, {"docstring": "Overload this to reject residues for output.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBIO.py", "line_number": 81, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBIO", "name": "accept_residue", "signature": "(self, residue)", "symbol_type": "function"}], "accession": [{"docstring": "Set the accession number as the id of the sequence.\n\nIf we have multiple accession numbers, the first one passed is\nused.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 389, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "accession", "signature": "(self, acc_num)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 930, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "accession", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": "Create accession object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 489, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "accession", "signature": "(self, elem)", "symbol_type": "function"}], "adam_consensus": [{"docstring": "Search Adam Consensus tree from multiple trees.\n\n:Parameters:\n    trees : list\n        list of trees to produce consensus tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/Consensus.py", "line_number": 378, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.Consensus", "name": "adam_consensus", "signature": "(trees)", "symbol_type": "function"}], "adapter_content": [{"docstring": "Detect adapter contamination.\n\nArgs:\n    reads: List of FASTQ records\n    adapters: Dictionary of adapter sequences {name: sequence}\n\nReturns:\n    Dictionary with adapter contamination analysis", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/fastq.py", "line_number": 281, "module": "src.metainformant.quality.fastq", "name": "adapter_content", "signature": "(reads: List[FastqRecord], adapters: Optional[Dict[str, str]] = None) -> Dict[str, Any]", "symbol_type": "function"}], "adapter_content_plot": [{"docstring": "Plot adapter content across read positions.\n\nArgs:\n    positions: Read positions\n    adapter_content: Adapter content percentage at each position\n    threshold: Threshold for adapter content warning\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import adapter_content_plot\n    >>> import numpy as np\n    >>> positions = np.arange(1, 101)\n    >>> content = np.random.uniform(0, 0.2, 100)\n    >>> ax = adapter_content_plot(positions, content)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/quality.py", "line_number": 182, "module": "src.metainformant.visualization.quality", "name": "adapter_content_plot", "signature": "(positions: Sequence[int], adapter_content: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "add": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1632, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "add", "signature": "(self, item)", "symbol_type": "function"}, {"docstring": "Add a sub_component to the list of components under this item.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/BasicChromosome.py", "line_number": 72, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.BasicChromosome", "name": "add", "signature": "(self, component)", "symbol_type": "function"}, {"docstring": "Add the given value to existing, in matrix's position.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 200, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "add", "signature": "(self, x, y, value)", "symbol_type": "function"}, {"docstring": "Attach node to another.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 47, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "add", "signature": "(self, node: 'Node', prev: int | None = None) -> int", "symbol_type": "function"}, {"docstring": "Add a child to the Entity.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 267, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "add", "signature": "(self, entity: _Child)", "symbol_type": "function"}, {"docstring": "Add an Atom object.\n\nChecks for adding duplicate atoms, and raises a\nPDBConstructionException if so.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Residue.py", "line_number": 74, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Residue", "name": "add", "signature": "(self, atom)", "symbol_type": "function"}, {"docstring": "Add atom to residue.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Residue.py", "line_number": 140, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Residue", "name": "add", "signature": "(self, atom)", "symbol_type": "function"}, {"docstring": "Add a restriction enzyme to the restriction batch.\n\nSafe set.add method. Verify that other is a RestrictionType or can be\nevaluated to a RestrictionType.\nRaise a ValueError if other can not be evaluated to a RestrictionType.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2120, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "add", "signature": "(self, other)", "symbol_type": "function"}], "addKeysFromRow": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1250, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "addKeysFromRow", "signature": "(self, alignment, recordIx)", "symbol_type": "function"}], "addOffsetSize": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1254, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "addOffsetSize", "signature": "(self, offset, size, startIx, endIx)", "symbol_type": "function"}], "addToCoverageDepth": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1689, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "addToCoverageDepth", "signature": "(self, alignment)", "symbol_type": "function"}], "add_AssemblyDatasetServicer_to_server": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "add_AssemblyDatasetServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 182, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "add_AssemblyDatasetServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}], "add_BioSampleDatasetServicer_to_server": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 44, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "add_BioSampleDatasetServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}], "add_DatasetDownloadServicer_to_server": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 346, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "add_DatasetDownloadServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 557, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "add_DatasetDownloadServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}], "add_GatewayServicer_to_server": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 1190, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "add_GatewayServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1776, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "add_GatewayServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}], "add_GeneDatasetServicer_to_server": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 583, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "add_GeneDatasetServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 805, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "add_GeneDatasetServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}], "add_GenomeAnnotationDatasetServicer_to_server": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1478, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "add_GenomeAnnotationDatasetServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}], "add_HttpDatafileServicer_to_server": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 1002, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "add_HttpDatafileServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1235, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "add_HttpDatafileServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}], "add_TaxonomyCppDatasetServicer_to_server": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1627, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "add_TaxonomyCppDatasetServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}], "add_TaxonomyDatasetServicer_to_server": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 1085, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "add_TaxonomyDatasetServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1329, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "add_TaxonomyDatasetServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}], "add_VirusDatasetServicer_to_server": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 831, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "add_VirusDatasetServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 1042, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "add_VirusDatasetServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}], "add_VirusDownloadServicer_to_server": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v1/datasets_service_pb2_grpc.py", "line_number": 208, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v1.datasets_service_pb2_grpc", "name": "add_VirusDownloadServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/v2/datasets_service_pb2_grpc.py", "line_number": 408, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.v2.datasets_service_pb2_grpc", "name": "add_VirusDownloadServicer_to_server", "signature": "(servicer, server)", "symbol_type": "function"}], "add_annotation": [{"docstring": "Add annotations for the NeXML parser.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NeXMLIO.py", "line_number": 107, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NeXMLIO", "name": "add_annotation", "signature": "(self, node_dict, meta_node)", "symbol_type": "function"}], "add_component": [{"docstring": "Add an element to the entry.\n\nIf the Entry is already part of a pathway, make sure\nthe component already exists.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 307, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "add_component", "signature": "(self, element)", "symbol_type": "function"}], "add_constructor": [{"docstring": "Add a constructor for the given tag.\nConstructor is a function that accepts a Loader instance\nand a node object and produces the corresponding Python object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 302, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "add_constructor", "signature": "(tag, constructor, Loader = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 160, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "add_constructor", "signature": "(cls, tag, constructor)", "symbol_type": "function"}, {"docstring": "Add a constructor for the given tag.\nConstructor is a function that accepts a Loader instance\nand a node object and produces the corresponding Python object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 302, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "add_constructor", "signature": "(tag, constructor, Loader = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 160, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "add_constructor", "signature": "(cls, tag, constructor)", "symbol_type": "function"}], "add_count": [{"docstring": "Add counts to the given segment name.\n\nArguments:\n - segment_name - The name of the segment we should add counts to.\n   If the name is not present, a KeyError will be raised.\n - count - The counts to add the current segment. This defaults to\n   a single count.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/DisplayRepresentation.py", "line_number": 67, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.DisplayRepresentation", "name": "add_count", "signature": "(self, segment_name, count = 1)", "symbol_type": "function"}], "add_edge": [{"docstring": "Add an edge between two nodes with optional weight.\n\nAutomatically adds nodes if they don't exist. For undirected networks,\nthe edge (A, B) is equivalent to (B, A). For directed networks,\nedges have direction from node1 to node2.\n\nArgs:\n    node1: First node identifier\n    node2: Second node identifier\n    weight: Edge weight (default 1.0). Can represent interaction\n        strength, confidence, or other quantitative measure.\n        \nExamples:\n    >>> network = BiologicalNetwork(directed=False)\n    >>> network.add_edge(\"Gene1\", \"Gene2\", weight=0.8)\n    >>> network.get_edge_weight(\"Gene2\", \"Gene1\")  # Undirected\n    0.8\n    \n    >>> dir_net = BiologicalNetwork(directed=True)\n    >>> dir_net.add_edge(\"TF1\", \"Gene1\", weight=0.9)\n    >>> dir_net.get_edge_weight(\"Gene1\", \"TF1\")  # Reverse direction\n    None", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 67, "module": "src.metainformant.networks.graph", "name": "add_edge", "signature": "(self, node1: str, node2: str, weight: float = 1.0) -> None", "symbol_type": "function"}, {"docstring": "Add an edge to this graph.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/Graph.py", "line_number": 66, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.Graph", "name": "add_edge", "signature": "(self, source, to, label = None)", "symbol_type": "function"}, {"docstring": "Add an edge to this graph.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/MultiGraph.py", "line_number": 63, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.MultiGraph", "name": "add_edge", "signature": "(self, source, to, label = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 42, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "add_edge", "signature": "(graph, n1, n2)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 61, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "add_edge", "signature": "(graph, n1, n2)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 66, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "add_edge", "signature": "(graph, n1, n2)", "symbol_type": "function"}], "add_edges_from_correlation": [{"docstring": "Add edges to network based on correlation matrix.\n\nConstructs network edges from pairwise correlations between nodes.\nOnly correlations above the threshold are added as edges, with edge\nweight equal to the absolute correlation value.\n\nArgs:\n    network: BiologicalNetwork object to add edges to (nodes should exist)\n    correlation_matrix: Square NumPy array of shape (n, n) containing\n        pairwise correlations. Must be symmetric for undirected networks.\n    node_names: List of node identifiers corresponding to matrix\n        rows/columns. Length must equal matrix dimension.\n    threshold: Minimum absolute correlation value (0-1) to create an edge.\n        Default 0.7. Only |correlation| >= threshold creates edges.\n        \nRaises:\n    ValueError: If correlation matrix dimensions don't match node_names length\n    \nExamples:\n    >>> network = create_network([\"GENE1\", \"GENE2\", \"GENE3\"], directed=False)\n    >>> corr_matrix = np.array([[1.0, 0.8, 0.3], [0.8, 1.0, 0.2], [0.3, 0.2, 1.0]])\n    >>> add_edges_from_correlation(network, corr_matrix, [\"GENE1\", \"GENE2\", \"GENE3\"], threshold=0.7)\n    >>> network.num_edges()\n    1  # Only GENE1-GENE2 above threshold", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 242, "module": "src.metainformant.networks.graph", "name": "add_edges_from_correlation", "signature": "(network: BiologicalNetwork, correlation_matrix: np.ndarray, node_names: List[str], threshold: float = 0.7) -> None", "symbol_type": "function"}], "add_edges_from_interactions": [{"docstring": "Add edges to network from a list of interactions.\n\nConvenience function to add multiple edges at once from a structured\ninteraction list. Automatically adds nodes if they don't exist.\n\nArgs:\n    network: BiologicalNetwork object to add edges to\n    interactions: List of tuples, each containing (node1, node2, weight).\n        Node identifiers are strings, weight is float.\n        \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\"], directed=False)\n    >>> interactions = [(\"A\", \"B\", 0.8), (\"B\", \"C\", 0.6), (\"A\", \"C\", 0.9)]\n    >>> add_edges_from_interactions(network, interactions)\n    >>> network.num_edges()\n    3", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 282, "module": "src.metainformant.networks.graph", "name": "add_edges_from_interactions", "signature": "(network: BiologicalNetwork, interactions: List[Tuple[str, str, float]]) -> None", "symbol_type": "function"}], "add_entry": [{"docstring": "Add an Entry element to the pathway.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 92, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "add_entry", "signature": "(self, entry)", "symbol_type": "function"}], "add_feature": [{"docstring": "Add a new feature.\n\nArguments:\n - feature: Bio.SeqFeature object\n - kwargs: Keyword arguments for Feature.  Named attributes\n   of the Feature\n\nAdd a Bio.SeqFeature object to the diagram (will be stored\ninternally in a Feature wrapper).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_FeatureSet.py", "line_number": 49, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._FeatureSet", "name": "add_feature", "signature": "(self, feature, **kwargs)", "symbol_type": "function"}], "add_gene_metadata": [{"docstring": "Add or update metadata for a gene.\n\nStores gene annotations such as function, expression patterns, or\nother properties. Useful for enriching regulatory network analysis.\n\nArgs:\n    gene_id: Gene identifier (must match IDs used in regulations)\n    **metadata: Keyword arguments for gene metadata. Common fields:\n        - function: Gene function description\n        - expression_level: Expression level category\n        - pathway: Pathways the gene participates in\n        - chromosome: Chromosomal location\n        \nExamples:\n    >>> grn = GeneRegulatoryNetwork()\n    >>> grn.add_gene_metadata(\n    ...     \"GENE1\",\n    ...     function=\"cell cycle regulation\",\n    ...     pathway=\"p53 signaling\"\n    ... )\n    >>> grn.gene_metadata[\"GENE1\"][\"function\"]\n    'cell cycle regulation'", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 131, "module": "src.metainformant.networks.regulatory", "name": "add_gene_metadata", "signature": "(self, gene_id: str, **metadata) -> None", "symbol_type": "function"}], "add_graphics": [{"docstring": "Add the Graphics entry.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 324, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "add_graphics", "signature": "(self, entry)", "symbol_type": "function"}], "add_implicit_resolver": [{"docstring": "Add an implicit scalar detector.\nIf an implicit scalar value matches the given regexp,\nthe corresponding tag is assigned to the scalar.\nfirst is a sequence of possible initial characters or None.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 271, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "add_implicit_resolver", "signature": "(tag, regexp, first = None, Loader = None, Dumper = Dumper)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/resolver.py", "line_number": 26, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.resolver", "name": "add_implicit_resolver", "signature": "(cls, tag, regexp, first)", "symbol_type": "function"}, {"docstring": "Add an implicit scalar detector.\nIf an implicit scalar value matches the given regexp,\nthe corresponding tag is assigned to the scalar.\nfirst is a sequence of possible initial characters or None.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 271, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "add_implicit_resolver", "signature": "(tag, regexp, first = None, Loader = None, Dumper = Dumper)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/resolver.py", "line_number": 26, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.resolver", "name": "add_implicit_resolver", "signature": "(cls, tag, regexp, first)", "symbol_type": "function"}], "add_indent": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 349, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "add_indent", "signature": "(self, column)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 349, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "add_indent", "signature": "(self, column)", "symbol_type": "function"}], "add_interaction": [{"docstring": "Add a protein-protein interaction to the network.\n\nRecords an interaction between two proteins with confidence score,\nevidence types, and optional metadata. Automatically adds proteins\nto the network if they don't exist.\n\nArgs:\n    protein1: First protein identifier (UniProt ID, gene symbol, etc.)\n    protein2: Second protein identifier\n    confidence: Interaction confidence score in [0, 1]. Higher values\n        indicate stronger evidence. Default 1.0 (maximum confidence).\n    evidence_types: Optional list of evidence type strings (e.g.,\n        [\"experimental\", \"database\", \"textmining\"]). Common types:\n        \"experimental\", \"database\", \"coexpression\", \"textmining\"\n    **metadata: Additional keyword arguments for interaction metadata\n        (e.g., publication_id=\"PMID:12345\", method=\"yeast_two_hybrid\")\n        \nExamples:\n    >>> ppi = ProteinNetwork()\n    >>> ppi.add_interaction(\n    ...     \"P12345\", \"P67890\",\n    ...     confidence=0.85,\n    ...     evidence_types=[\"experimental\", \"database\"],\n    ...     publication_id=\"PMID:12345\"\n    ... )\n    >>> len(ppi.interactions)\n    1\n    >>> \"P12345\" in ppi.proteins\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 50, "module": "src.metainformant.networks.ppi", "name": "add_interaction", "signature": "(self, protein1: str, protein2: str, confidence: float = 1.0, evidence_types: Optional[List[str]] = None, **metadata) -> None", "symbol_type": "function"}, {"docstring": "Add interaction to this network.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 288, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "add_interaction", "signature": "(self, source, sink, interaction)", "symbol_type": "function"}], "add_label": [{"docstring": "Add a label to a specific segment.\n\nRaises a KeyError is the specified segment name is not found.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/DisplayRepresentation.py", "line_number": 93, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.DisplayRepresentation", "name": "add_label", "signature": "(self, segment_name, label)", "symbol_type": "function"}], "add_math_selection_subparser": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/cli.py", "line_number": 156, "module": "src.metainformant.math.selection_experiments.cli", "name": "add_math_selection_subparser", "signature": "(subparsers: argparse._SubParsersAction[argparse.ArgumentParser]) -> None", "symbol_type": "function"}], "add_multi_constructor": [{"docstring": "Add a multi-constructor for the given tag prefix.\nMulti-constructor is called for a node if its tag starts with tag_prefix.\nMulti-constructor accepts a Loader instance, a tag suffix,\nand a node object and produces the corresponding Python object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 315, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "add_multi_constructor", "signature": "(tag_prefix, multi_constructor, Loader = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 166, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "add_multi_constructor", "signature": "(cls, tag_prefix, multi_constructor)", "symbol_type": "function"}, {"docstring": "Add a multi-constructor for the given tag prefix.\nMulti-constructor is called for a node if its tag starts with tag_prefix.\nMulti-constructor accepts a Loader instance, a tag suffix,\nand a node object and produces the corresponding Python object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 315, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "add_multi_constructor", "signature": "(tag_prefix, multi_constructor, Loader = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 166, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "add_multi_constructor", "signature": "(cls, tag_prefix, multi_constructor)", "symbol_type": "function"}], "add_multi_representer": [{"docstring": "Add a representer for the given type.\nMulti-representer is a function accepting a Dumper instance\nand an instance of the given data type or subtype\nand producing the corresponding representation node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 338, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "add_multi_representer", "signature": "(data_type, multi_representer, Dumper = Dumper)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 72, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "add_multi_representer", "signature": "(cls, data_type, representer)", "symbol_type": "function"}, {"docstring": "Add a representer for the given type.\nMulti-representer is a function accepting a Dumper instance\nand an instance of the given data type or subtype\nand producing the corresponding representation node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 338, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "add_multi_representer", "signature": "(data_type, multi_representer, Dumper = Dumper)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 72, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "add_multi_representer", "signature": "(cls, data_type, representer)", "symbol_type": "function"}], "add_nocheck": [{"docstring": "Add restriction enzyme to batch without checking its type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2129, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "add_nocheck", "signature": "(self, other)", "symbol_type": "function"}], "add_node": [{"docstring": "Add a node to the network with optional attributes.\n\nArgs:\n    node: Node identifier (string)\n    **attrs: Optional keyword arguments for node attributes\n        (e.g., function=\"transcription\", compartment=\"nucleus\")\n        \nExamples:\n    >>> network = BiologicalNetwork()\n    >>> network.add_node(\"Gene1\", function=\"transcription\", compartment=\"nucleus\")\n    >>> \"Gene1\" in network.nodes\n    True\n    >>> network.node_attrs[\"Gene1\"][\"function\"]\n    'transcription'", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 47, "module": "src.metainformant.networks.graph", "name": "add_node", "signature": "(self, node: str, **attrs) -> None", "symbol_type": "function"}, {"docstring": "Add a node to this graph.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/Graph.py", "line_number": 61, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.Graph", "name": "add_node", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": "Add a node to this graph.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/MultiGraph.py", "line_number": 58, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.MultiGraph", "name": "add_node", "signature": "(self, node)", "symbol_type": "function"}], "add_path_resolver": [{"docstring": "Add a path based resolver for the given tag.\nA path is a list of keys that forms a path\nto a node in the representation tree.\nKeys can be string values, integers, or None.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 287, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "add_path_resolver", "signature": "(tag, path, kind = None, Loader = None, Dumper = Dumper)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/resolver.py", "line_number": 38, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.resolver", "name": "add_path_resolver", "signature": "(cls, tag, path, kind = None)", "symbol_type": "function"}, {"docstring": "Add a path based resolver for the given tag.\nA path is a list of keys that forms a path\nto a node in the representation tree.\nKeys can be string values, integers, or None.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 287, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "add_path_resolver", "signature": "(tag, path, kind = None, Loader = None, Dumper = Dumper)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/resolver.py", "line_number": 38, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.resolver", "name": "add_path_resolver", "signature": "(cls, tag, path, kind = None)", "symbol_type": "function"}], "add_pathway": [{"docstring": "Add a pathway with its associated genes.\n\nAdds a biological pathway to the network and automatically updates\ngene-pathway mappings. Pathway metadata can include name, description,\nor other annotations.\n\nArgs:\n    pathway_id: Unique pathway identifier (e.g., \"KEGG_PATH:00010\")\n    genes: List of gene identifiers in the pathway\n    metadata: Optional dictionary of pathway metadata (e.g.,\n        {\"name\": \"Glycolysis\", \"source\": \"KEGG\", \"category\": \"Metabolism\"})\n        \nExamples:\n    >>> pn = PathwayNetwork()\n    >>> pn.add_pathway(\n    ...     \"path:00010\",\n    ...     [\"GENE1\", \"GENE2\", \"GENE3\"],\n    ...     metadata={\"name\": \"Glycolysis\", \"source\": \"KEGG\"}\n    ... )\n    >>> len(pn.get_pathway_genes(\"path:00010\"))\n    3", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 47, "module": "src.metainformant.networks.pathway", "name": "add_pathway", "signature": "(self, pathway_id: str, genes: List[str], metadata: Optional[Dict[str, Any]] = None) -> None", "symbol_type": "function"}], "add_point": [{"docstring": "Add a single point to the set of data as a (position, value) tuple.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Graph.py", "line_number": 106, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Graph", "name": "add_point", "signature": "(self, point)", "symbol_type": "function"}], "add_primer_set": [{"docstring": "Add primer information to the record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Emboss/PrimerSearch.py", "line_number": 29, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Emboss.PrimerSearch", "name": "add_primer_set", "signature": "(self, primer_name, first_primer_seq, second_primer_seq)", "symbol_type": "function"}], "add_product": [{"docstring": "Add a product, identified by its node ID, to the reaction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 698, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "add_product", "signature": "(self, product_id)", "symbol_type": "function"}], "add_protein_metadata": [{"docstring": "Add or update metadata for a protein.\n\nStores protein annotations such as function, localization, or other\nproperties. Useful for enriching network analysis with functional\ncontext.\n\nArgs:\n    protein_id: Protein identifier (must match IDs used in interactions)\n    **metadata: Keyword arguments for protein metadata. Common fields:\n        - function: Protein function description\n        - localization: Subcellular location\n        - pathway: Pathways the protein participates in\n        - disease: Disease associations\n        \nExamples:\n    >>> ppi = ProteinNetwork()\n    >>> ppi.add_protein_metadata(\n    ...     \"P12345\",\n    ...     function=\"transcription factor\",\n    ...     localization=\"nucleus\",\n    ...     pathway=\"signaling\"\n    ... )\n    >>> ppi.protein_metadata[\"P12345\"][\"function\"]\n    'transcription factor'", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 97, "module": "src.metainformant.networks.ppi", "name": "add_protein_metadata", "signature": "(self, protein_id: str, **metadata) -> None", "symbol_type": "function"}], "add_reaction": [{"docstring": "Add a Reaction element to the pathway.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 113, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "add_reaction", "signature": "(self, reaction)", "symbol_type": "function"}, {"docstring": "Add reaction to self.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 180, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "add_reaction", "signature": "(self, reaction)", "symbol_type": "function"}], "add_regulation": [{"docstring": "Add a regulatory interaction to the network.\n\nRecords a directed regulatory relationship where a regulator (e.g.,\ntranscription factor) controls a target gene. Automatically marks\nthe regulator as a transcription factor.\n\nArgs:\n    regulator: Regulator identifier (transcription factor, miRNA, etc.)\n    target: Target gene identifier\n    regulation_type: Type of regulation:\n        - \"activation\": Positive regulation (upregulation)\n        - \"repression\": Negative regulation (downregulation)\n        - \"unknown\": Unknown or mixed effect (default)\n    strength: Regulatory strength in [0, 1] or arbitrary scale.\n        Higher values indicate stronger regulatory effect. Default 1.0.\n    confidence: Confidence in the interaction [0, 1]. Default 1.0.\n    **metadata: Additional keyword arguments for regulatory metadata\n        (e.g., condition=\"stress\", timepoint=\"t0\", binding_site=\"promoter\")\n        \nExamples:\n    >>> grn = GeneRegulatoryNetwork()\n    >>> grn.add_regulation(\n    ...     \"TF1\", \"GENE1\",\n    ...     regulation_type=\"activation\",\n    ...     strength=0.85,\n    ...     confidence=0.9,\n    ...     binding_site=\"promoter\"\n    ... )\n    >>> \"TF1\" in grn.transcription_factors\n    True\n    >>> len(grn.regulations)\n    1", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 56, "module": "src.metainformant.networks.regulatory", "name": "add_regulation", "signature": "(self, regulator: str, target: str, regulation_type: str = 'unknown', strength: float = 1.0, confidence: float = 1.0, **metadata) -> None", "symbol_type": "function"}], "add_relation": [{"docstring": "Add a Relation element to the pathway.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 136, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "add_relation", "signature": "(self, relation)", "symbol_type": "function"}], "add_representer": [{"docstring": "Add a representer for the given type.\nRepresenter is a function accepting a Dumper instance\nand an instance of the given data type\nand producing the corresponding representation node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 329, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "add_representer", "signature": "(data_type, representer, Dumper = Dumper)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 66, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "add_representer", "signature": "(cls, data_type, representer)", "symbol_type": "function"}, {"docstring": "Add a representer for the given type.\nRepresenter is a function accepting a Dumper instance\nand an instance of the given data type\nand producing the corresponding representation node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 329, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "add_representer", "signature": "(data_type, representer, Dumper = Dumper)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 66, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "add_representer", "signature": "(cls, data_type, representer)", "symbol_type": "function"}], "add_residue": [{"docstring": "Add a residue.\n\n:param resname: residue name (eg. GLY).\n:type resname: string\n\n:param ca_coord: the c-alpha coordinates of the residues\n:type ca_coord: NumPy array with length 3", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/FragmentMapper.py", "line_number": 142, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.FragmentMapper", "name": "add_residue", "signature": "(self, resname, ca_coord)", "symbol_type": "function"}], "add_sequence": [{"docstring": "Add event sequence to database.\n\nArgs:\n    sequence: EventSequence to add", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 255, "module": "src.metainformant.life_events.events", "name": "add_sequence", "signature": "(self, sequence: EventSequence) -> None", "symbol_type": "function"}, {"docstring": "Add a sequence (string) to the matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 1959, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "add_sequence", "signature": "(self, name, sequence)", "symbol_type": "function"}], "add_set": [{"docstring": "Add a preexisting FeatureSet or GraphSet object to the track.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Track.py", "line_number": 203, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Track", "name": "add_set", "signature": "(self, set)", "symbol_type": "function"}], "add_shared_axis_labels": [{"docstring": "Add shared axis labels to a multi-panel figure.\n\nArgs:\n    fig: Matplotlib figure\n    xlabel: Shared x-axis label\n    ylabel: Shared y-axis label\n\nExample:\n    >>> from metainformant.visualization.layout import add_shared_axis_labels\n    >>> fig, axes = create_multi_panel(4)\n    >>> add_shared_axis_labels(fig, xlabel='Time', ylabel='Value')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/layout.py", "line_number": 111, "module": "src.metainformant.visualization.layout", "name": "add_shared_axis_labels", "signature": "(fig: plt.Figure, xlabel: str | None = None, ylabel: str | None = None)", "symbol_type": "function"}], "add_space": [{"docstring": "Add a space before a capital letter.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/Loader.py", "line_number": 321, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.Loader", "name": "add_space", "signature": "(letter)", "symbol_type": "function"}], "add_species": [{"docstring": "Add species to this network.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 284, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "add_species", "signature": "(self, species)", "symbol_type": "function"}], "add_stmt_to_handle": [{"docstring": "Add URI prefix to handle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 307, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "add_stmt_to_handle", "signature": "(self, handle, stmt)", "symbol_type": "function"}], "add_substrate": [{"docstring": "Add a substrate, identified by its node ID, to the reaction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 688, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "add_substrate", "signature": "(self, substrate_id)", "symbol_type": "function"}], "add_subtree": [{"docstring": "Add edges from this subtree, breath-first.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 124, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "add_subtree", "signature": "(node, n_node, counter, edges, edge_attrs, vertex_attrs)", "symbol_type": "function"}], "add_succ": [{"docstring": "Add a node id to the node's successors.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 153, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "add_succ", "signature": "(self, id)", "symbol_type": "function"}], "add_supplier": [{"docstring": "Add all enzymes from a given supplier to batch.\n\nletter represents the suppliers as defined in the dictionary\nRestrictionDictionary.suppliers\nReturns None.\nRaise a KeyError if letter is not a supplier code.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2071, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "add_supplier", "signature": "(self, letter)", "symbol_type": "function"}], "add_temporal_noise": [{"docstring": "Add realistic temporal noise to event sequence.\n\nIntroduces temporal uncertainty by:\n- Shifting event timestamps randomly\n- Optionally removing some events (missing data)\n\nArgs:\n    sequence: Original EventSequence\n    noise_level: Fraction of events to modify (0.0 to 1.0)\n    max_days_shift: Maximum days to shift events forward/backward\n    missing_probability: Probability of removing each event (0.0 to 1.0)\n    random_state: Random seed for reproducibility\n    \nReturns:\n    New EventSequence with noise applied\n    \nExamples:\n    >>> seq = EventSequence(\"p1\", [Event(\"degree\", datetime(2010, 1, 1), \"education\")])\n    >>> noisy_seq = add_temporal_noise(seq, noise_level=0.5, max_days_shift=7, random_state=42)\n    >>> len(noisy_seq.events) <= len(seq.events)\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/utils.py", "line_number": 468, "module": "src.metainformant.life_events.utils", "name": "add_temporal_noise", "signature": "(sequence: EventSequence, noise_level: float = 0.1, max_days_shift: int = 30, missing_probability: float = 0.0, random_state: Optional[int] = None) -> EventSequence", "symbol_type": "function"}], "add_term": [{"docstring": "Add a term to the ontology and update parent/child relationships.\n\nUpdates both is_a relationships and other relationship types stored in\nterm.relationships. Maintains parent/child mappings for is_a relationships.\n\nArgs:\n    term: Term object to add\n    \nRaises:\n    ValidationError: If term_id is empty, name is empty, or term_id already exists", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/types.py", "line_number": 101, "module": "src.metainformant.ontology.types", "name": "add_term", "signature": "(self, term: Term) -> None", "symbol_type": "function"}], "add_track": [{"docstring": "Add a Track object to the diagram.\n\nIt also accepts instructions to place it at a particular level on the\ndiagram.\n\nArguments:\n    - track          - Track object to draw.\n    - track_level    - an integer. The level at which the track will be\n      drawn (above an arbitrary baseline).\n\nadd_track(self, track, track_level)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Diagram.py", "line_number": 270, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Diagram", "name": "add_track", "signature": "(self, track, track_level)", "symbol_type": "function"}], "add_transcription_factor": [{"docstring": "Explicitly mark a gene as a transcription factor.\n\nConvenience method to add a transcription factor without requiring\na regulatory interaction. Useful for pre-annotating known TFs.\n\nArgs:\n    tf_id: Transcription factor gene identifier\n    **metadata: Optional keyword arguments for TF metadata\n        (e.g., tf_family=\"bHLH\", domain=\"homeodomain\")\n\nExamples:\n    >>> grn = GeneRegulatoryNetwork()\n    >>> grn.add_transcription_factor(\"TF1\", tf_family=\"bHLH\")\n    >>> \"TF1\" in grn.transcription_factors\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 107, "module": "src.metainformant.networks.regulatory", "name": "add_transcription_factor", "signature": "(self, tf_id: str, **metadata: Any) -> None", "symbol_type": "function"}], "add_wgs_scafld": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 423, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "add_wgs_scafld", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 903, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "add_wgs_scafld", "signature": "(self, content)", "symbol_type": "function"}], "additional_properties_type": [{"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_assembly_completeness.py", "line_number": 65, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_assembly_completeness", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_peptide.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_peptide", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_bio_project_lineage.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_bio_project_lineage", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request_content_type.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request_content_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_prokaryote_gene_request.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_prokaryote_gene_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_gene.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_gene", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response_edges_entry.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response_edges_entry", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_dataset_request.py", "line_number": 72, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_dataset_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_error_virus_error_code.py", "line_number": 63, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_error_virus_error_code", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_filter.py", "line_number": 72, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_filter", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptor_chromosome.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptor_chromosome", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_genomic_region_genomic_region_type.py", "line_number": 67, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_genomic_region_genomic_region_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sci_name_and_ids.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sci_name_and_ids", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_metadata_response.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_metadata_response", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_message.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_message", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_filter_assembly_source.py", "line_number": 65, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_filter_assembly_source", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_project.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_project", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_feature_counts.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_feature_counts", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_query_request_tax_rank_filter.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_query_request_tax_rank_filter", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request_sort_field.py", "line_number": 66, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request_sort_field", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_match.py", "line_number": 72, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_match", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotated_assemblies.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotated_assemblies", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_prokaryote_gene_request_gene_flank_config.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_prokaryote_gene_request_gene_flank_config", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_table_format.py", "line_number": 65, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_table_format", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_conserved_domain.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_conserved_domain", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_query_request.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_query_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_assembly_status.py", "line_number": 67, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_assembly_status", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_warning.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_warning", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request_sort.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request_sort", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_query_request_taxon_resource_filter.py", "line_number": 65, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_query_request_taxon_resource_filter", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_micro_bigge_dataset_request_file_type.py", "line_number": 67, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_micro_bigge_dataset_request_file_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_match.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_match", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_attribute.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_attribute", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_prokaryote_gene_location_completeness.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_prokaryote_gene_location_completeness", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata_request.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_mature_peptide.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_mature_peptide", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_availability_request.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_availability_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response_edge_child_status.py", "line_number": 65, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response_edge_child_status", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ortholog_request.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ortholog_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_filter_assembly_level.py", "line_number": 66, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_filter_assembly_level", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptor_rna_type.py", "line_number": 65, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptor_rna_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sleep_request.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sleep_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sort_direction.py", "line_number": 65, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sort_direction", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_id.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_id", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_request_resolution.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_request_resolution", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_transcript.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_transcript", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary_dehydrated.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary_dehydrated", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_counts.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_counts", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_gene_descriptor_gene_type.py", "line_number": 75, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_gene_descriptor_gene_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_count_by_type.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_count_by_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_group.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_group", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_fasta.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_fasta", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_peptide_uni_prot_id.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_peptide_uni_prot_id", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptor.py", "line_number": 76, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptor", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_range.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_range", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_range.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_range", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_error_assembly_error_code.py", "line_number": 67, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_error_assembly_error_code", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_transcript_transcript_type.py", "line_number": 67, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_transcript_transcript_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_element_flank_config.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_element_flank_config", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_availability.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_availability", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_error_gene_error_code.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_error_gene_error_code", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_genomic_region.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_genomic_region", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_assembly_type.py", "line_number": 72, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_assembly_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_dataset_request.py", "line_number": 72, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_dataset_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ref_gene_catalog_dataset_request.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ref_gene_catalog_dataset_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_tax_tree_request.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_tax_tree_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_micro_bigge_dataset_request.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_micro_bigge_dataset_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_busco_stat.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_busco_stat", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_availability.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_availability", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_assembly.py", "line_number": 80, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_assembly", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_data_report_request_content_type.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_data_report_request_content_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_assembly_collection_location.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_assembly_collection_location", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_table_field.py", "line_number": 84, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_table_field", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_request.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_metadata_request.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_metadata_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_protein.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_protein", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary.py", "line_number": 76, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_match.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_match", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_virus_type.py", "line_number": 69, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_virus_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response.py", "line_number": 72, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_description.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_description", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_purpose_of_sampling.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_purpose_of_sampling", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_seq_range_set.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_seq_range_set", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_genomic_location.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_genomic_location", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_request_content_type.py", "line_number": 65, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_request_content_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_orientation.py", "line_number": 65, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_orientation", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata_request_bioprojects.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata_request_bioprojects", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_seq_range_set_fasta.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_seq_range_set_fasta", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_contact.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_contact", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_warning_replaced_id.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_warning_replaced_id", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_lineage_organism.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_lineage_organism", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sars2_protein_dataset_request.py", "line_number": 72, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sars2_protein_dataset_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_assembly_file.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_assembly_file", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_filter_assembly_version.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_filter_assembly_version", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_rank_type.py", "line_number": 107, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_rank_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_metadata_request_content_type.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_metadata_request_content_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_error.py", "line_number": 72, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_error", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_count_type.py", "line_number": 77, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_count_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary_file_summary.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary_file_summary", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_linked_assembly_linked_assembly_type.py", "line_number": 72, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_linked_assembly_linked_assembly_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ortholog_set.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ortholog_set", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_data_report_page.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_data_report_page", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_method_payload_request.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_method_payload_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_node_count_by_type.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_node_count_by_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/rpc_status.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.rpc_status", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_data_report_request.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_data_report_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptor.py", "line_number": 86, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptor", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sleep_reply.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sleep_reply", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_counts.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_counts", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_tabular_output.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_tabular_output", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism.py", "line_number": 72, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_bio_project.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_bio_project", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sci_name_and_ids_sci_name_and_id.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sci_name_and_ids_sci_name_and_id", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_nomenclature_authority.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_nomenclature_authority", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_descriptor.py", "line_number": 78, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_descriptor", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_metadata.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_metadata", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_genomic_region_genomic_region_type.py", "line_number": 67, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_genomic_region_genomic_region_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_annotation.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_annotation", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_organism.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_organism", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_transcript_transcript_type.py", "line_number": 67, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_transcript_transcript_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary_hydrated.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary_hydrated", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_status.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_status", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_assembly.py", "line_number": 72, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_assembly", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_warning_gene_warning_code.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_warning_gene_warning_code", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_orientation.py", "line_number": 65, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_orientation", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_gene_descriptor_rna_type.py", "line_number": 65, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_gene_descriptor_rna_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_request.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_request", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_version_reply.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_version_reply", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptor_gene_type.py", "line_number": 75, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptor_gene_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_owner.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_owner", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/protobuf_any.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.protobuf_any", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_dataset_filter.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_dataset_filter", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request_symbols_for_taxon.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request_symbols_for_taxon", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_accessions.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_accessions", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptors.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptors", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata_request_content_type.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata_request_content_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_assembly_isolate.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_assembly_isolate", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ref_gene_catalog_dataset_request_file_type.py", "line_number": 66, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ref_gene_catalog_dataset_request_file_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary_available_files.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary_available_files", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response_edge.py", "line_number": 68, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response_edge", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_node.py", "line_number": 70, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_node", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ortholog_request_content_type.py", "line_number": 64, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ortholog_request_content_type", "name": "additional_properties_type", "signature": "()", "symbol_type": "function"}], "adjust_spacing": [{"docstring": "Adjust spacing in a multi-panel figure.\n\nArgs:\n    fig: Matplotlib figure\n    hspace: Height spacing between subplots\n    wspace: Width spacing between subplots\n    top: Top margin\n    bottom: Bottom margin\n    left: Left margin\n    right: Right margin\n\nExample:\n    >>> from metainformant.visualization.layout import adjust_spacing\n    >>> fig, axes = create_multi_panel(4)\n    >>> adjust_spacing(fig, hspace=0.3, wspace=0.2)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/layout.py", "line_number": 155, "module": "src.metainformant.visualization.layout", "name": "adjust_spacing", "signature": "(fig: plt.Figure)", "symbol_type": "function"}], "admixture_plot": [{"docstring": "Admixture plot showing ancestry proportions.\n\nStacked bar plot of inferred ancestry components per sample.\nRequires ADMIXTURE or similar software output.\n\nArgs:\n    admixture_file: Path to admixture proportions file\n    output_path: Output path\n    k: Number of ancestral populations\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_population.py", "line_number": 316, "module": "src.metainformant.gwas.visualization_population", "name": "admixture_plot", "signature": "(admixture_file: Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "aggregate_temporal_phenotypes": [{"docstring": "Aggregate phenotypes across time windows.\n\nGroups events from multiple sequences into temporal windows and computes\naggregate statistics per window.\n\nArgs:\n    sequences: List of EventSequence objects (not phenotypes dicts)\n    time_window_years: Size of time windows in years (must be positive)\n    \nReturns:\n    Dictionary with temporal phenotype aggregations:\n    - time_windows: List of window statistics\n    - aggregates: Overall statistics (total_events, total_people, time_span_years)\n    \nRaises:\n    ImportError: If life_events module is not available\n    ValidationError: If sequences is invalid or time_window_years is invalid\n    \nExamples:\n    >>> from metainformant.life_events import EventSequence, Event\n    >>> from datetime import datetime\n    >>> from metainformant.phenotype import aggregate_temporal_phenotypes\n    >>> seq1 = EventSequence(\"p1\", [Event(\"degree\", datetime(2010, 1, 1), \"education\")])\n    >>> seq2 = EventSequence(\"p2\", [Event(\"job\", datetime(2015, 1, 1), \"occupation\")])\n    >>> result = aggregate_temporal_phenotypes([seq1, seq2], time_window_years=5.0)\n    >>> \"time_windows\" in result\n    True\n    >>> result[\"aggregates\"][\"total_people\"]\n    2", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/phenotype/life_course.py", "line_number": 152, "module": "src.metainformant.phenotype.life_course", "name": "aggregate_temporal_phenotypes", "signature": "(sequences: List[EventSequence], time_window_years: float = 5.0) -> Dict[str, Any]", "symbol_type": "function"}], "ak_add": [{"docstring": "Allocate edron key AtomKeys to current residue as appropriate.\n\nA hedron or dihedron may span a backbone amide bond, this routine\nallocates atoms in the (h/di)edron to the ric residue or saves them\nfor a residue yet to be processed.\n\n:param set ek: AtomKeys in edron\n:param IC_Residue ric: current residue to assign AtomKeys to", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 546, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "ak_add", "signature": "(ek: tuple, ric: IC_Residue) -> None", "symbol_type": "function"}], "ak_expand": [{"docstring": "Expand AtomKey list with altlocs, all combinatorics.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 469, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "ak_expand", "signature": "(eLst: list) -> list", "symbol_type": "function"}], "akcache": [{"docstring": "Maintain dictionary of AtomKeys seen while reading this PIC file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 166, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "akcache", "signature": "(akstr: str) -> AtomKey", "symbol_type": "function"}], "ake_recurse": [{"docstring": "Build combinatorics of AtomKey lists.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 450, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "ake_recurse", "signature": "(akList: list) -> list", "symbol_type": "function"}], "align": [{"docstring": "Return the alignments of two sequences using PairwiseAligner.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 4449, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "align", "signature": "(self, seqA, seqB, strand = '+')", "symbol_type": "function"}, {"docstring": "Align a nucleotide sequence to its corresponding protein sequence.\n\nArguments:\n - seqA  - the protein sequence of amino acids (plain string, Seq,\n   MutableSeq, or SeqRecord).\n - seqB  - the nucleotide sequence (plain string, Seq, MutableSeq, or\n   SeqRecord); both DNA and RNA sequences are accepted.\n\nReturns an iterator of Alignment objects.\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqRecord import SeqRecord\n>>> aligner = CodonAligner()\n>>> dna = SeqRecord(Seq('ATGTCTCGT'), id='dna')\n>>> pro = SeqRecord(Seq('MSR'), id='pro')\n>>> alignments = aligner.align(pro, dna)\n>>> alignment = alignments[0]\n>>> print(alignment)\npro               0 M  S  R   3\ndna               0 ATGTCTCGT 9\n<BLANKLINE>\n>>> rna = SeqRecord(Seq('AUGUCUCGU'), id='rna')\n>>> alignments = aligner.align(pro, rna)\n>>> alignment = alignments[0]\n>>> print(alignment)\npro               0 M  S  R   3\nrna               0 AUGUCUCGU 9\n<BLANKLINE>\n\nThis is an example with a frame shift in the DNA sequence:\n\n>>> dna = \"ATGCTGGGCTCGAACGAGTCCGTGTATGCCCTAAGCTGAGCCCGTCG\"\n>>> pro = \"MLGSNESRVCPKLSPS\"\n>>> alignments = aligner.align(pro, dna)\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            0 M  L  G  S  N  E  S   7\nquery             0 ATGCTGGGCTCGAACGAGTCC 21\n<BLANKLINE>\ntarget            7 R  V  C  P  K  L  S  P  S   16\nquery            20 CGTGTATGCCCTAAGCTGAGCCCGTCG 47\n<BLANKLINE>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 4732, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "align", "signature": "(self, seqA, seqB)", "symbol_type": "function"}, {"docstring": "Align the input structure onto the reference structure.\n\nParameters\n----------\ntransform: bool, optional\n    If True (default), apply the rotation/translation that minimizes\n    the RMSD between the two structures to the input structure. If\n    False, the structure is not modified but the optimal RMSD will\n    still be calculated.\nfinal_optimization: bool, optional\n    If True (default), apply additional optimization to statistically\n    significant alignments.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/cealign.py", "line_number": 92, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.cealign", "name": "align", "signature": "(self, structure, transform = True)", "symbol_type": "function"}], "align_msa": [{"docstring": "Very small MSA utility using progressive pairwise alignment.\n\nThis avoids external binary dependencies (MUSCLE/Clustal) while keeping tests lightweight.\nNot intended for large datasets.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/msa.py", "line_number": 13, "module": "src.metainformant.dna.msa", "name": "align_msa", "signature": "(id_to_seq: Dict[str, str], method: str = 'auto') -> Dict[str, str]", "symbol_type": "function"}], "align_reads": [{"docstring": "Align FASTQ reads to reference genome using BWA.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/run_genome_scale_gwas.py", "line_number": 84, "module": "scripts.gwas.run_genome_scale_gwas", "name": "align_reads", "signature": "(fastq_dir: Path, reference: Path, output_dir: Path, threads: int = 8)", "symbol_type": "function"}], "align_with_cli": [{"docstring": "Align with external CLI (MUSCLE/Clustal Omega) if present.\n\nRequires the tool to be available in PATH. Writes temporary FASTA and reads back.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/msa.py", "line_number": 73, "module": "src.metainformant.dna.msa", "name": "align_with_cli", "signature": "(id_to_seq: Dict[str, str], tool: str = 'muscle') -> Dict[str, str]", "symbol_type": "function"}], "aligned": [{"docstring": "Return the indices of subsequences aligned to each other.\n\nThis property returns the start and end indices of subsequences\nin the target and query sequence that were aligned to each other.\nIf the alignment between target (t) and query (q) consists of N\nchunks, you get two tuples of length N:\n\n    (((t_start1, t_end1), (t_start2, t_end2), ..., (t_startN, t_endN)),\n     ((q_start1, q_end1), (q_start2, q_end2), ..., (q_startN, q_endN)))\n\nFor example,\n\n>>> from Bio import Align\n>>> aligner = Align.PairwiseAligner()\n>>> alignments = aligner.align(\"GAACT\", \"GAT\")\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            0 GAACT 5\n                  0 ||--| 5\nquery             0 GA--T 3\n<BLANKLINE>\n>>> alignment.aligned\narray([[[0, 2],\n        [4, 5]],\n<BLANKLINE>\n       [[0, 2],\n        [2, 3]]])\n>>> alignment = alignments[1]\n>>> print(alignment)\ntarget            0 GAACT 5\n                  0 |-|-| 5\nquery             0 G-A-T 3\n<BLANKLINE>\n>>> alignment.aligned\narray([[[0, 1],\n        [2, 3],\n        [4, 5]],\n<BLANKLINE>\n       [[0, 1],\n        [1, 2],\n        [2, 3]]])\n\nNote that different alignments may have the same subsequences\naligned to each other. In particular, this may occur if alignments\ndiffer from each other in terms of their gap placement only:\n\n>>> aligner.mismatch_score = -10\n>>> alignments = aligner.align(\"AAACAAA\", \"AAAGAAA\")\n>>> len(alignments)\n2\n>>> print(alignments[0])\ntarget            0 AAAC-AAA 7\n                  0 |||--||| 8\nquery             0 AAA-GAAA 7\n<BLANKLINE>\n>>> alignments[0].aligned\narray([[[0, 3],\n        [4, 7]],\n<BLANKLINE>\n       [[0, 3],\n        [4, 7]]])\n>>> print(alignments[1])\ntarget            0 AAA-CAAA 7\n                  0 |||--||| 8\nquery             0 AAAG-AAA 7\n<BLANKLINE>\n>>> alignments[1].aligned\narray([[[0, 3],\n        [4, 7]],\n<BLANKLINE>\n       [[0, 3],\n        [4, 7]]])\n\nThe property can be used to identify alignments that are identical\nto each other in terms of their aligned sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 2997, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "aligned", "signature": "(self)", "symbol_type": "function"}], "alignment": [{"docstring": "Return an Alignment object based on the MultipleSeqAlignment object.\n\nThis makes a copy of each SeqRecord with a gap-less sequence. Any\nfuture changes to the original records in the MultipleSeqAlignment will\nnot affect the new records in the Alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 965, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "alignment", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Construct an Alignment object from the aligned sequences in this tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 260, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "alignment", "signature": "(self)", "symbol_type": "function"}], "alignment_statistics": [{"docstring": "Calculate comprehensive statistics for an alignment.\n\nArgs:\n    alignment: AlignmentResult from global_align or local_align\n\nReturns:\n    Dictionary with alignment statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/alignment.py", "line_number": 152, "module": "src.metainformant.dna.alignment", "name": "alignment_statistics", "signature": "(alignment: AlignmentResult) -> dict[str, float]", "symbol_type": "function"}], "all_ids": [{"docstring": "Return a list of all node ids.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 43, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "all_ids", "signature": "(self) -> list[int]", "symbol_type": "function"}], "all_suppliers": [{"docstring": "Print all the suppliers of restriction enzyme.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 571, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "all_suppliers", "signature": "(cls)", "symbol_type": "function"}], "allele_frequencies": [{"docstring": "Compute frequency of allele '1' per site.\n\nCalculates the frequency of the alternate allele (encoded as 1) at each\nsite across all individuals in the genotype matrix.\n\nArgs:\n    genotype_matrix: List of lists where rows are individuals, columns\n        are sites. Values should be 0 (reference allele) or 1 (alternate allele).\n        All rows must have the same length.\n\nReturns:\n    List of frequencies per site (float values in [0, 1]). Returns empty\n    list if input is empty.\n\nRaises:\n    ValueError: If genotype matrix has inconsistent row lengths or invalid values.\n\nExamples:\n    >>> genotypes = [[0, 1, 0], [0, 1, 1], [1, 0, 1]]\n    >>> freqs = allele_frequencies(genotypes)\n    >>> freqs[0]  # Frequency at first site\n    0.333...\n    >>> freqs[1]  # Frequency at second site\n    0.666...", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population.py", "line_number": 7, "module": "src.metainformant.dna.population", "name": "allele_frequencies", "signature": "(genotype_matrix: Sequence[Sequence[int]]) -> list[float]", "symbol_type": "function"}], "allelic_series_plot": [{"docstring": "Allelic series plot for multiple alleles at a locus.\n\nShows dose-response relationship for variants with multiple alleles.\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    gene_region: (chrom, start, end) for gene region\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_effects.py", "line_number": 312, "module": "src.metainformant.gwas.visualization_effects", "name": "allelic_series_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "allitems": [{"docstring": "Property for fetching attribute from all entries of container.\n\nReturns a property that fetches the given attributes from\nall items in a SearchIO container object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 84, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "allitems", "signature": "(attr = None, doc = '')", "symbol_type": "function"}], "allows_single_value_input": [{"docstring": "This function returns True if the input composed schema model or any\ndescendant model allows a value only input\nThis is true for cases where oneOf contains items like:\noneOf:\n  - float\n  - NumberWithValidation\n  - StringEnum\n  - ArrayModel\n  - null\nTODO: lru_cache this", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 69, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "allows_single_value_input", "signature": "(cls)", "symbol_type": "function"}], "altloc_match": [{"docstring": "Test AtomKey match to other discounting occupancy and altloc.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4755, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "altloc_match", "signature": "(self, other: 'AtomKey') -> bool", "symbol_type": "function"}], "amino_acids_percent": [{"docstring": "Get the amino acid content in percentages.\n\nThe same as count_amino_acids only returns the Number in percentage of\nentire sequence. Returns a dictionary of {AminoAcid:percentage}.\n\nUnlike the deprecated get_amino_acids_percent method, this attribute\nreturns percentages in the range 0-100.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/ProtParam.py", "line_number": 116, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.ProtParam", "name": "amino_acids_percent", "signature": "(self)", "symbol_type": "function"}], "analyze_alignment": [{"docstring": "Perform pairwise alignment analysis.\n\nArgs:\n    sequences: Dictionary of sequence ID to sequence string\n    output_dir: Output directory for results\n    \nReturns:\n    Dictionary with alignment results", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/protein/run_protein_analysis.py", "line_number": 221, "module": "scripts.protein.run_protein_analysis", "name": "analyze_alignment", "signature": "(sequences: dict[str, str], output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "analyze_centrality": [{"docstring": "Calculate centrality measures.\n\nArgs:\n    network: BiologicalNetwork object\n    output_dir: Output directory for results\n    \nReturns:\n    Dictionary with centrality measures", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/networks/run_network_analysis.py", "line_number": 164, "module": "scripts.networks.run_network_analysis", "name": "analyze_centrality", "signature": "(network, output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "analyze_composition": [{"docstring": "Analyze sequence composition.\n\nArgs:\n    sequences: Dictionary of sequence ID to sequence string\n    output_dir: Output directory for results\n    \nReturns:\n    Dictionary with composition analysis results", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/dna/run_dna_analysis.py", "line_number": 93, "module": "scripts.dna.run_dna_analysis", "name": "analyze_composition", "signature": "(sequences: dict[str, str], output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Analyze amino acid composition.\n\nArgs:\n    sequences: Dictionary of sequence ID to sequence string\n    output_dir: Output directory for results\n    \nReturns:\n    Dictionary with composition analysis results", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/protein/run_protein_analysis.py", "line_number": 93, "module": "scripts.protein.run_protein_analysis", "name": "analyze_composition", "signature": "(sequences: dict[str, str], output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "analyze_correlations": [{"docstring": "Calculate correlations between numeric traits.\n\nArgs:\n    data: Loaded phenotype data\n    output_dir: Output directory for results\n    \nReturns:\n    Dictionary with correlation results", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/phenotype/run_phenotype_analysis.py", "line_number": 195, "module": "scripts.phenotype.run_phenotype_analysis", "name": "analyze_correlations", "signature": "(data: dict[str, Any], output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "analyze_dataset": [{"docstring": "Perform comprehensive analysis on generated dataset.\n\nArgs:\n    dataset_info: Dataset metadata\n    output_dir: Output directory for results\n\nReturns:\n    Dictionary with analysis results", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/popgen/analysis.py", "line_number": 339, "module": "scripts.popgen.analysis", "name": "analyze_dataset", "signature": "(dataset_info: dict[str, Any], output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "analyze_environmental_gradient": [{"docstring": "Analyze species distributions along environmental gradients.\n\nPerforms ordination analysis to identify relationships between\nspecies composition and environmental variables.\n\nArgs:\n    species_abundances: DataFrame with sites as rows and species as columns\n    environmental_variables: DataFrame with sites as rows and environmental\n        variables as columns (e.g., temperature, pH, elevation)\n    method: Ordination method ('cca', 'rda', 'nmds')\n    \nReturns:\n    Dictionary with ordination results:\n    - 'scores': Site scores along environmental gradients\n    - 'species_scores': Species scores\n    - 'environmental_loadings': Environmental variable loadings\n    - 'explained_variance': Variance explained by each axis", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/environmental.py", "line_number": 15, "module": "src.metainformant.ecology.environmental", "name": "analyze_environmental_gradient", "signature": "(species_abundances: pd.DataFrame, environmental_variables: pd.DataFrame, method: str = 'cca') -> Dict[str, Any]", "symbol_type": "function"}], "analyze_fastq_quality": [{"docstring": "Comprehensive FASTQ quality analysis.\n\nArgs:\n    fastq_path: Path to FASTQ file (.fastq or .fastq.gz)\n    subsample: Number of reads to analyze (None for all)\n    seed: Random seed for subsampling\n\nReturns:\n    Dictionary with comprehensive quality metrics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/fastq.py", "line_number": 22, "module": "src.metainformant.quality.fastq", "name": "analyze_fastq_quality", "signature": "(fastq_path: Union[str, Path], subsample: Optional[int] = None, seed: int = 42) -> Dict[str, Any]", "symbol_type": "function"}], "analyze_life_course": [{"docstring": "Complete workflow from raw event sequences to predictions.\n\nPerforms:\n1. Event sequence loading and validation\n2. Embedding learning\n3. Model training (if outcomes provided)\n4. Predictions and analysis\n\nArgs:\n    sequences: List of event sequences (must not be empty)\n    outcomes: Optional outcome labels/values for training (must match sequence length if provided)\n    config_path: Optional path to configuration file\n    output_dir: Output directory (defaults to output/life_events/)\n    \nReturns:\n    Dictionary with analysis results including embeddings path, model type, and predictions\n    \nRaises:\n    ValueError: If sequences is empty or outcomes length doesn't match sequences length\n    \nExamples:\n    >>> from metainformant.life_events import EventSequence, Event, analyze_life_course\n    >>> from datetime import datetime\n    >>> seq = EventSequence(\"p1\", [Event(\"degree\", datetime(2010, 1, 1), \"education\")])\n    >>> results = analyze_life_course([seq], output_dir=\"output/test\")\n    >>> \"embeddings\" in results\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/workflow.py", "line_number": 24, "module": "src.metainformant.life_events.workflow", "name": "analyze_life_course", "signature": "(sequences: List[EventSequence], outcomes: Optional[NDArray] = None, config_path: Optional[str | Path] = None, config_obj: Optional[LifeEventsWorkflowConfig | Dict[str, Any]] = None, output_dir: Optional[str | Path] = None) -> Dict[str, Any]", "symbol_type": "function"}], "analyze_metrics": [{"docstring": "Calculate network metrics.\n\nArgs:\n    network: BiologicalNetwork object\n    output_dir: Output directory for results\n    \nReturns:\n    Dictionary with network metrics", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/networks/run_network_analysis.py", "line_number": 136, "module": "scripts.networks.run_network_analysis", "name": "analyze_metrics", "signature": "(network, output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "analyze_peak_overlap": [{"docstring": "Analyze overlap between two sets of peaks.\n\nArgs:\n    peaks1: First peak set (must have 'chrom', 'start', 'end' columns)\n    peaks2: Second peak set (must have 'chrom', 'start', 'end' columns)\n    \nReturns:\n    Dictionary with overlap statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/chipseq.py", "line_number": 140, "module": "src.metainformant.epigenome.chipseq", "name": "analyze_peak_overlap", "signature": "(peaks1: pd.DataFrame, peaks2: pd.DataFrame) -> dict[str, Any]", "symbol_type": "function"}], "analyze_phylogeny": [{"docstring": "Perform phylogenetic analysis.\n\nArgs:\n    sequences: Dictionary of sequence ID to sequence string\n    output_dir: Output directory for results\n    \nReturns:\n    Dictionary with phylogenetic results", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/dna/run_dna_analysis.py", "line_number": 194, "module": "scripts.dna.run_dna_analysis", "name": "analyze_phylogeny", "signature": "(sequences: dict[str, str], output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "analyze_population": [{"docstring": "Analyze population genetics metrics.\n\nArgs:\n    sequences: Dictionary of sequence ID to sequence string\n    output_dir: Output directory for results\n    \nReturns:\n    Dictionary with population genetics results", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/dna/run_dna_analysis.py", "line_number": 147, "module": "scripts.dna.run_dna_analysis", "name": "analyze_population", "signature": "(sequences: dict[str, str], output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "analyze_post_translational_modifications": [{"docstring": "Analyze post-translational modification sites.\n\nIdentifies potential PTM sites (phosphorylation, glycosylation, etc.)\nfrom sequence patterns.\n\nArgs:\n    sequence: Protein sequence\n    modification_sites: Optional dictionary mapping modification types to site positions\n    \nReturns:\n    Dictionary with PTM analysis results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/structure_analysis.py", "line_number": 191, "module": "src.metainformant.protein.structure_analysis", "name": "analyze_post_translational_modifications", "signature": "(sequence: str, modification_sites: Dict[str, List[int]] | None = None) -> Dict[str, Any]", "symbol_type": "function"}], "analyze_protein_stability": [{"docstring": "Analyze protein stability from sequence or structure.\n\nCalculates stability-related metrics such as:\n- Hydrophobicity\n- Charge distribution\n- Flexibility\n\nArgs:\n    sequence: Protein sequence\n    structure_coords: Optional 3D coordinates (N x 3 array)\n    \nReturns:\n    Dictionary with stability metrics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/structure_analysis.py", "line_number": 95, "module": "src.metainformant.protein.structure_analysis", "name": "analyze_protein_stability", "signature": "(sequence: str, structure_coords: np.ndarray | None = None) -> Dict[str, float]", "symbol_type": "function"}], "analyze_scalar": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 626, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "analyze_scalar", "signature": "(self, scalar)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 626, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "analyze_scalar", "signature": "(self, scalar)", "symbol_type": "function"}], "analyze_secondary": [{"docstring": "Analyze secondary structure propensity.\n\nArgs:\n    sequences: Dictionary of sequence ID to sequence string\n    output_dir: Output directory for results\n    \nReturns:\n    Dictionary with secondary structure analysis results", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/protein/run_protein_analysis.py", "line_number": 163, "module": "scripts.protein.run_protein_analysis", "name": "analyze_secondary", "signature": "(sequences: dict[str, str], output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "analyze_sequence_information": [{"docstring": "Analyze information content of a single sequence.\n\nArgs:\n    sequence: Sequence to analyze\n    k_values: List of k-mer sizes to analyze (default: [1, 2, 3])\n    \nReturns:\n    Dictionary with information analysis results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/analysis.py", "line_number": 152, "module": "src.metainformant.information.analysis", "name": "analyze_sequence_information", "signature": "(sequence: str, k_values: list[int] | None = None) -> dict[str, Any]", "symbol_type": "function"}], "analyze_species_status": [{"docstring": "Comprehensive analysis of species workflow status.\n\nArgs:\n    config_path: Path to species workflow config file\n    \nReturns:\n    Dictionary with comprehensive status information:\n    - total_in_metadata: int\n    - quantified: int\n    - quantified_and_deleted: int\n    - quantified_not_deleted: int\n    - downloading: int\n    - failed_download: int\n    - undownloaded: int\n    - categories: dict mapping category -> list of sample_ids", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/monitoring.py", "line_number": 140, "module": "src.metainformant.rna.monitoring", "name": "analyze_species_status", "signature": "(config_path: Path) -> dict[str, Any]", "symbol_type": "function"}], "analyze_statistics": [{"docstring": "Calculate basic statistics for numeric traits.\n\nArgs:\n    data: Loaded phenotype data\n    output_dir: Output directory for results\n    \nReturns:\n    Dictionary with statistics results", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/phenotype/run_phenotype_analysis.py", "line_number": 126, "module": "scripts.phenotype.run_phenotype_analysis", "name": "analyze_statistics", "signature": "(data: dict[str, Any], output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "ancestors": [{"docstring": "Get all ancestor terms (transitive parents) of a given term.\n\nReturns the complete set of parent terms reachable via is_a relationships,\nexcluding the term itself. Useful for finding all broader terms.\n\nArgs:\n    onto: Ontology object containing terms\n    term_id: Identifier of the term (e.g., \"GO:0008150\")\n    use_cache: If True, use cached result if available\n    \nReturns:\n    Set of ancestor term IDs. Returns empty set if term not found or has no parents.\n    \nRaises:\n    ValueError: If term_id is empty or not found in ontology\n    \nExamples:\n    >>> onto = load_go_obo(\"go.obo\")\n    >>> ancestors(onto, \"GO:0008150\")  # biological_process\n    {'GO:0008150', 'GO:0003674', ...}", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/query.py", "line_number": 79, "module": "src.metainformant.ontology.query", "name": "ancestors", "signature": "(onto: Ontology, term_id: str, use_cache: bool = True) -> Set[str]", "symbol_type": "function"}], "anchor_node": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/serializer.py", "line_number": 60, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.serializer", "name": "anchor_node", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/serializer.py", "line_number": 60, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.serializer", "name": "anchor_node", "signature": "(self, node)", "symbol_type": "function"}], "angle": [{"docstring": "Get this hedron angle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4170, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "angle", "signature": "(self) -> float", "symbol_type": "function"}, {"docstring": "Set this hedron angle; sets needs_update.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4183, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "angle", "signature": "(self, angle_deg) -> None", "symbol_type": "function"}, {"docstring": "Get dihedral angle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4400, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "angle", "signature": "(self) -> float", "symbol_type": "function"}, {"docstring": "Save new dihedral angle; sets needs_update.\n\nFaster to modify IC_Chain level arrays directly.\n\nThis is probably not the routine you are looking for.  See\n:meth:`IC_Residue.set_angle` or :meth:`IC_Residue.bond_rotate` to change\na dihedral angle along with its overlapping dihedra, i.e. without\nclashing atoms.\n\nN.B. dihedron (i-1)C-N-CA-CB is ignored if O exists.\nC-beta is by default placed using O-C-CA-CB, but O is missing\nin some PDB file residues, which means the sidechain cannot be\nplaced.  The alternate CB path (i-1)C-N-CA-CB is provided to\ncircumvent this, but if this is needed then it must be adjusted in\nconjunction with PHI ((i-1)C-N-CA-C) as they overlap.  This is handled\nby the `IC_Residue` routines above.\n\n:param float dangle_deg: new dihedral angle in degrees", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4411, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "angle", "signature": "(self, dangle_deg_in: float) -> None", "symbol_type": "function"}, {"docstring": "Return angle between two vectors.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 354, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "angle", "signature": "(self, other)", "symbol_type": "function"}], "angle2trig": [{"docstring": "Convert angle to a reportlab ready tuple.\n\nArguments:\n - theta -  Angle in degrees, counter clockwise from horizontal\n\nReturns a representation of the passed angle in a format suitable\nfor ReportLab rotations (i.e. cos(theta), sin(theta), -sin(theta),\ncos(theta) tuple)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_AbstractDrawer.py", "line_number": 333, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._AbstractDrawer", "name": "angle2trig", "signature": "(theta)", "symbol_type": "function"}], "angle_avg": [{"docstring": "Get average of list of +/-180 angles.\n\n:param List alst: list of angles to average\n:param bool in_rads: input values are in radians\n:param bool out_rads: report result in radians", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4457, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "angle_avg", "signature": "(alst: list, in_rads: bool = False, out_rads: bool = False)", "symbol_type": "function"}], "angle_dif": [{"docstring": "Get angle difference between two +/- 180 angles.\n\nhttps://stackoverflow.com/a/36001014/2783487", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4449, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "angle_dif", "signature": "(a1: float | np.ndarray, a2: float | np.ndarray)", "symbol_type": "function"}], "angle_pop_sd": [{"docstring": "Get population standard deviation for list of +/-180 angles.\n\nshould be sample std dev but avoid len(alst)=1 -> div by 0", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4469, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "angle_pop_sd", "signature": "(alst: list, avg: float)", "symbol_type": "function"}], "animate_clustering": [{"docstring": "Animate clustering iterations.\n\nArgs:\n    iterations: List of dictionaries with iteration data ('points', 'centers', 'labels')\n    interval_ms: Animation interval in milliseconds\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments\n\nReturns:\n    Tuple of (figure, animation)\n\nExample:\n    >>> from metainformant.visualization import animate_clustering\n    >>> import numpy as np\n    >>> iterations = [\n    ...     {'points': np.random.random((50, 2)), 'centers': np.random.random((3, 2))},\n    ...     {'points': np.random.random((50, 2)), 'centers': np.random.random((3, 2))}\n    ... ]\n    >>> fig, anim = animate_clustering(iterations)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 151, "module": "src.metainformant.visualization.animations", "name": "animate_clustering", "signature": "(iterations: Sequence[dict[str, np.ndarray]], **kwargs) -> tuple[plt.Figure, FuncAnimation]", "symbol_type": "function"}], "animate_evolution": [{"docstring": "Animate evolutionary process over generations.\n\nArgs:\n    generations: List of dictionaries with generation data\n    interval_ms: Animation interval in milliseconds\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments\n\nReturns:\n    Tuple of (figure, animation)\n\nExample:\n    >>> from metainformant.visualization import animate_evolution\n    >>> generations = [\n    ...     {'fitness': [0.5, 0.6, 0.4]},\n    ...     {'fitness': [0.6, 0.7, 0.5]},\n    ...     {'fitness': [0.7, 0.8, 0.6]}\n    ... ]\n    >>> fig, anim = animate_evolution(generations)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 81, "module": "src.metainformant.visualization.animations", "name": "animate_evolution", "signature": "(generations: Sequence[dict[str, Sequence[float]]], **kwargs) -> tuple[plt.Figure, FuncAnimation]", "symbol_type": "function"}], "animate_network": [{"docstring": "Animate network evolution over time.\n\nArgs:\n    network_states: List of network state dictionaries\n    interval_ms: Animation interval in milliseconds\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments\n\nReturns:\n    Tuple of (figure, animation)\n\nExample:\n    >>> from metainformant.visualization import animate_network\n    >>> network_states = [\n    ...     {'nodes': ['A', 'B'], 'edges': [('A', 'B')]},\n    ...     {'nodes': ['A', 'B', 'C'], 'edges': [('A', 'B'), ('B', 'C')]}\n    ... ]\n    >>> fig, anim = animate_network(network_states)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 225, "module": "src.metainformant.visualization.animations", "name": "animate_network", "signature": "(network_states: Sequence[dict[str, Any]], **kwargs) -> tuple[plt.Figure, FuncAnimation]", "symbol_type": "function"}], "animate_time_series": [{"docstring": "Animate a time series as a growing line.\n\nArgs:\n    series: Time series data\n    interval_ms: Animation interval in milliseconds\n    repeat: Whether to repeat animation\n    init_points: Number of initial points to show\n    ax: Matplotlib axes (creates new if None)\n\nReturns:\n    Tuple of (figure, animation)\n\nExample:\n    >>> from metainformant.visualization import animate_time_series\n    >>> data = [1, 2, 3, 2, 4, 5, 3, 6]\n    >>> fig, anim = animate_time_series(data, interval_ms=200)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 20, "module": "src.metainformant.visualization.animations", "name": "animate_time_series", "signature": "(series: Sequence[float]) -> tuple[plt.Figure, FuncAnimation]", "symbol_type": "function"}], "animate_trajectory": [{"docstring": "Animate trajectory inference over time.\n\nArgs:\n    trajectory_data: List of trajectory state dictionaries\n    interval_ms: Animation interval in milliseconds\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments\n\nReturns:\n    Tuple of (figure, animation)\n\nExample:\n    >>> from metainformant.visualization import animate_trajectory\n    >>> import numpy as np\n    >>> trajectory_data = [\n    ...     {'positions': np.random.random((10, 2))},\n    ...     {'positions': np.random.random((10, 2))}\n    ... ]\n    >>> fig, anim = animate_trajectory(trajectory_data)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 300, "module": "src.metainformant.visualization.animations", "name": "animate_trajectory", "signature": "(trajectory_data: Sequence[dict[str, np.ndarray]], **kwargs) -> tuple[plt.Figure, FuncAnimation]", "symbol_type": "function"}], "annotate": [{"docstring": "Apply secondary structure information to residues in model.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PSEA.py", "line_number": 84, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PSEA", "name": "annotate", "signature": "(m, ss_seq)", "symbol_type": "function"}], "annotation": [{"docstring": "Create annotation object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 493, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "annotation", "signature": "(self, elem)", "symbol_type": "function"}], "annotations": [{"docstring": "Annotations.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeq.py", "line_number": 573, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeq", "name": "annotations", "signature": "(self) -> SeqRecord._AnnotationsDict", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeq.py", "line_number": 586, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeq", "name": "annotations", "signature": "(self, value: Optional[SeqRecord._AnnotationsDict]) -> None", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeq.py", "line_number": 593, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeq", "name": "annotations", "signature": "(self) -> None", "symbol_type": "function"}], "anticonsensus": [{"docstring": "Return the least probable pattern to be generated from this motif.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/__init__.py", "line_number": 419, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.__init__", "name": "anticonsensus", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the anticonsensus sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 151, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "anticonsensus", "signature": "(self)", "symbol_type": "function"}], "append": [{"docstring": "Add a subsequence to the mutable sequence object.\n\n>>> my_seq = MutableSeq('ACTCGACGTCG')\n>>> my_seq.append('A')\n>>> my_seq\nMutableSeq('ACTCGACGTCGA')\n\nNo return value.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2256, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "append", "signature": "(self, c)", "symbol_type": "function"}, {"docstring": "Add one more SeqRecord object to the alignment as a new row.\n\nThis must have the same length as the original alignment (unless this is\nthe first record).\n\n>>> from Bio import AlignIO\n>>> align = AlignIO.read(\"Clustalw/opuntia.aln\", \"clustal\")\n>>> print(align)\nAlignment with 7 rows and 156 columns\nTATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273285|gb|AF191659.1|AF191\nTATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273284|gb|AF191658.1|AF191\nTATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273287|gb|AF191661.1|AF191\nTATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273286|gb|AF191660.1|AF191\nTATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273290|gb|AF191664.1|AF191\nTATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273289|gb|AF191663.1|AF191\nTATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273291|gb|AF191665.1|AF191\n>>> len(align)\n7\n\nWe'll now construct a dummy record to append as an example:\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqRecord import SeqRecord\n>>> dummy = SeqRecord(Seq(\"N\"*156), id=\"dummy\")\n\nNow append this to the alignment,\n\n>>> align.append(dummy)\n>>> print(align)\nAlignment with 8 rows and 156 columns\nTATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273285|gb|AF191659.1|AF191\nTATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273284|gb|AF191658.1|AF191\nTATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273287|gb|AF191661.1|AF191\nTATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273286|gb|AF191660.1|AF191\nTATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273290|gb|AF191664.1|AF191\nTATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273289|gb|AF191663.1|AF191\nTATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273291|gb|AF191665.1|AF191\nNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN...NNN dummy\n>>> len(align)\n8", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 499, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "append", "signature": "(self, record)", "symbol_type": "function"}, {"docstring": "Append another Res object onto the list of residue mappings.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/Raf.py", "line_number": 203, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.Raf", "name": "append", "signature": "(self, res)", "symbol_type": "function"}, {"docstring": "Add a HSP object to the end of Hit.\n\nParameters\nhsp -- HSP object to append.\n\nAny HSP object appended must have the same ``hit_id`` property as the\nHit object's ``id`` property and the same ``query_id`` property as the\nHit object's ``query_id`` property.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/hit.py", "line_number": 347, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.hit", "name": "append", "signature": "(self, hsp)", "symbol_type": "function"}, {"docstring": "Add a Hit object to the end of QueryResult.\n\n:param hit: object to append\n:type hit: Hit\n\nAny Hit object appended must have the same ``query_id`` property as the\nQueryResult's ``id`` property. If the hit key already exists, a\n``ValueError`` will be raised.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 447, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "append", "signature": "(self, hit)", "symbol_type": "function"}], "append_item": [{"docstring": "Add a description extended record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIXML.py", "line_number": 117, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIXML", "name": "append_item", "signature": "(self, item)", "symbol_type": "function"}], "append_sets": [{"docstring": "Return a sets block.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 1670, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "append_sets", "signature": "(self, exclude = (), delete = (), mrbayes = False, include_codons = True, codons_only = False)", "symbol_type": "function"}], "apply": [{"docstring": "Rotate/translate a list of atoms.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Superimposer.py", "line_number": 48, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Superimposer", "name": "apply", "signature": "(self, atom_list)", "symbol_type": "function"}, {"docstring": "Apply the QCP rotation matrix/translation vector to a set of atoms.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/qcprot.py", "line_number": 280, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.qcprot", "name": "apply", "signature": "(self, atom_list)", "symbol_type": "function"}], "applyMtx": [{"docstring": "Apply matrix to atom_coords for this IC_Residue.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 3857, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "applyMtx", "signature": "(self, mtx: np.array) -> None", "symbol_type": "function"}], "apply_env_overrides": [{"docstring": "Apply simple environment overrides to a shallow config mapping.\n\nSupported keys via env:\n- {prefix}_THREADS -> int\n- {prefix}_WORK_DIR -> str\n- {prefix}_LOG_DIR -> str", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 253, "module": "src.metainformant.core.config", "name": "apply_env_overrides", "signature": "(config: Mapping[str, Any]) -> dict[str, Any]", "symbol_type": "function"}], "apply_point_mutations": [{"docstring": "Apply point mutations specified by a mapping index->new_base.\n\nIndices are 0-based. Out-of-range indices are ignored. The new base is\ninserted as given (case preserved).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/mutations.py", "line_number": 7, "module": "src.metainformant.dna.mutations", "name": "apply_point_mutations", "signature": "(seq: str, changes: Dict[int, str]) -> str", "symbol_type": "function"}], "apply_publication_style": [{"docstring": "Apply publication-quality style settings.\n\nArgs:\n    **overrides: Style parameter overrides\n\nExample:\n    >>> from metainformant.visualization.style import apply_publication_style\n    >>> apply_publication_style(font.size=12)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/style.py", "line_number": 65, "module": "src.metainformant.visualization.style", "name": "apply_publication_style", "signature": "(**overrides) -> None", "symbol_type": "function"}], "apply_qc_filters": [{"docstring": "Apply all quality control filters to VCF file.\n\nArgs:\n    vcf_path: Path to input VCF file\n    config: QC configuration dictionary with thresholds\n    output_vcf: Optional path to output filtered VCF\n\nReturns:\n    Dictionary with QC results and statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/quality.py", "line_number": 298, "module": "src.metainformant.gwas.quality", "name": "apply_qc_filters", "signature": "(vcf_path: str | Path, config: dict[str, Any], output_vcf: str | Path | None = None) -> dict[str, Any]", "symbol_type": "function"}], "apply_style": [{"docstring": "Apply a named matplotlib style.\n\nArgs:\n    style_name: Style name (e.g., 'seaborn', 'ggplot', 'classic')\n\nExample:\n    >>> from metainformant.visualization.style import apply_style\n    >>> apply_style('seaborn-v0_8')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/style.py", "line_number": 148, "module": "src.metainformant.visualization.style", "name": "apply_style", "signature": "(style_name: str) -> None", "symbol_type": "function"}], "area_plot": [{"docstring": "Create an area plot (filled line plot).\n\nArgs:\n    x: X-axis values\n    y: Y-axis values\n    ax: Matplotlib axes (creates new if None)\n    color: Fill color\n    alpha: Fill transparency\n    xlabel: X-axis label\n    ylabel: Y-axis label\n    title: Plot title\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import area_plot\n    >>> ax = area_plot([1, 2, 3, 4], [1, 4, 2, 3])", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/basic.py", "line_number": 248, "module": "src.metainformant.visualization.basic", "name": "area_plot", "signature": "(x: Sequence[float], y: Sequence[float]) -> plt.Axes", "symbol_type": "function"}], "aromaticity": [{"docstring": "Calculate the aromaticity according to Lobry, 1994.\n\nCalculates the aromaticity value of a protein according to Lobry, 1994.\nIt is simply the relative frequency of Phe+Trp+Tyr.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/ProtParam.py", "line_number": 138, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.ProtParam", "name": "aromaticity", "signature": "(self)", "symbol_type": "function"}], "artemis_color": [{"docstring": "Artemis color (integer) to ReportLab Color object.\n\nArguments:\n - value: An int representing a functional class in the Artemis\n   color scheme (see www.sanger.ac.uk for a description),\n   or a string from a GenBank feature annotation for the\n   color which may be dot delimited (in which case the\n   first value is used).\n\nTakes an int representing a functional class in the Artemis color\nscheme, and returns the appropriate colors.Color object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Colors.py", "line_number": 161, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Colors", "name": "artemis_color", "signature": "(self, value)", "symbol_type": "function"}], "as_fasta": [{"docstring": "Turn a SeqRecord into a FASTA formatted string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/FastaIO.py", "line_number": 654, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.FastaIO", "name": "as_fasta", "signature": "(record)", "symbol_type": "function"}], "as_fasta_2line": [{"docstring": "Turn a SeqRecord into a two-line FASTA formatted string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/FastaIO.py", "line_number": 673, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.FastaIO", "name": "as_fasta_2line", "signature": "(record)", "symbol_type": "function"}], "as_fastq": [{"docstring": "Turn a SeqRecord into a Sanger FASTQ formatted string, and return it.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1652, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "as_fastq", "signature": "(record: SeqRecord) -> str", "symbol_type": "function"}], "as_fastq_illumina": [{"docstring": "Turn a SeqRecord into an Illumina FASTQ formatted string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1998, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "as_fastq_illumina", "signature": "(record: SeqRecord) -> str", "symbol_type": "function"}], "as_fastq_solexa": [{"docstring": "Turn a SeqRecord into a Solexa FASTQ formatted string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1920, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "as_fastq_solexa", "signature": "(record: SeqRecord) -> str", "symbol_type": "function"}], "as_handle": [{"docstring": "Context manager to ensure we are using a handle.\n\nContext manager for arguments that can be passed to SeqIO and AlignIO read, write,\nand parse methods: either file objects or path-like objects (strings, pathlib.Path\ninstances, or more generally, anything that can be handled by the builtin 'open'\nfunction).\n\nWhen given a path-like object, returns an open file handle to that path, with provided\nmode, which will be closed when the manager exits.\n\nAll other inputs are returned, and are *not* closed.\n\nArguments:\n - handleish  - Either a file handle or path-like object (anything which can be\n                passed to the builtin 'open' function, such as str, bytes,\n                pathlib.Path, and os.DirEntry objects)\n - mode       - Mode to open handleish (used only if handleish is a string)\n - kwargs     - Further arguments to pass to open(...)\n\nExamples\n--------\n>>> from Bio import File\n>>> import os\n>>> with File.as_handle('seqs.fasta', 'w') as fp:\n...     fp.write('>test\\nACGT')\n...\n10\n>>> fp.closed\nTrue\n\n>>> handle = open('seqs.fasta', 'w')\n>>> with File.as_handle(handle) as fp:\n...     fp.write('>test\\nACGT')\n...\n10\n>>> fp.closed\nFalse\n>>> fp.close()\n>>> os.remove(\"seqs.fasta\")  # tidy up", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/File.py", "line_number": 29, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.File", "name": "as_handle", "signature": "(handleish, mode = 'r', **kwargs)", "symbol_type": "function"}], "as_phyloxml": [{"docstring": "Convert this tree to a PhyloXML-compatible Phylogeny.\n\nThis lets you use the additional annotation types PhyloXML defines, and\nsave this information when you write this tree as 'phyloxml'.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 797, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "as_phyloxml", "signature": "(self, **kwargs)", "symbol_type": "function"}, {"docstring": "Return this tree, a PhyloXML-compatible Phylogeny object.\n\nOverrides the ``BaseTree`` method.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 236, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "as_phyloxml", "signature": "(self)", "symbol_type": "function"}], "as_qual": [{"docstring": "Turn a SeqRecord into a QUAL formatted string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1818, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "as_qual", "signature": "(record: SeqRecord) -> str", "symbol_type": "function"}], "as_string": [{"docstring": "List the names of the enzymes of the RestrictionBatch.\n\nReturn a list of the name of the elements of the batch.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2191, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "as_string", "signature": "(self)", "symbol_type": "function"}], "as_tab": [{"docstring": "Return record as tab separated (id(tab)seq) string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/TabIO.py", "line_number": 135, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.TabIO", "name": "as_tab", "signature": "(record)", "symbol_type": "function"}], "ascend_resolver": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/resolver.py", "line_number": 114, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.resolver", "name": "ascend_resolver", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/resolver.py", "line_number": 114, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.resolver", "name": "ascend_resolver", "signature": "(self)", "symbol_type": "function"}], "assemble": [{"docstring": "Compute atom coordinates for this residue from internal coordinates.\n\nThis is the IC_Residue part of the :meth:`.assemble_residues_ser` serial\nversion, see :meth:`.assemble_residues` for numpy vectorized approach\nwhich works at the :class:`IC_Chain` level.\n\nJoin prepared dihedra starting from N-CA-C and N-CA-CB hedrons,\ncomputing protein space coordinates for backbone and sidechain atoms\n\nSets forward and reverse transforms on each Dihedron to convert from\nprotein coordinates to dihedron space coordinates for first three\natoms (see :data:`IC_Chain.dCoordSpace`)\n\nCall :meth:`.init_atom_coords` to update any modified di/hedra before\ncoming here, this only assembles dihedra into protein coordinate space.\n\n**Algorithm**\n\nForm double-ended queue, start with c-ca-n, o-c-ca, n-ca-cb, n-ca-c.\n\nif resetLocation=True, use initial coords from generating dihedron\nfor n-ca-c initial positions (result in dihedron coordinate space)\n\nwhile queue not empty\n    get 3-atom hedron key\n\n    for each dihedron starting with hedron key (1st hedron of dihedron)\n\n        if have coordinates for all 4 atoms already\n            add 2nd hedron key to back of queue\n        else if have coordinates for 1st 3 atoms\n            compute forward and reverse transforms to take 1st 3 atoms\n            to/from dihedron initial coordinate space\n\n            use reverse transform to get position of 4th atom in\n            current coordinates from dihedron initial coordinates\n\n            add 2nd hedron key to back of queue\n        else\n            ordering failed, put hedron key at back of queue and hope\n            next time we have 1st 3 atom positions (should not happen)\n\nloop terminates (queue drains) as hedron keys which do not start any\ndihedra are removed without action\n\n:param bool resetLocation: default False.\n    - Option to ignore start location and orient so initial N-Ca-C\n    hedron at origin.\n\n:returns:\n    Dict of AtomKey -> homogeneous atom coords for residue in protein\n    space relative to previous residue\n\n    **Also** directly updates :data:`IC_Chain.atomArray` as\n    :meth:`.assemble_residues` does.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 2779, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "assemble", "signature": "(self, resetLocation: bool = False, verbose: bool = False) -> dict['AtomKey', np.array] | dict[HKT, np.array] | None", "symbol_type": "function"}], "assemble_residues": [{"docstring": "Generate atom coords from internal coords (vectorised).\n\nThis is the 'Numpy parallel' version of :meth:`.assemble_residues_ser`.\n\nStarting with dihedra already formed by :meth:`.init_atom_coords`, transform\neach from dihedron local coordinate space into protein chain coordinate\nspace.  Iterate until all dependencies satisfied.\n\nDoes not update :data:`dCoordSpace` as :meth:`assemble_residues_ser`\ndoes.  Call :meth:`.update_dCoordSpace` if needed.  Faster to do in\nsingle operation once all atom coordinates finished.\n\n:param bool verbose: default False.\n    Report number of iterations to compute changed dihedra\n\ngenerates:\n    self.dSet: AAsiz x dihedraLen x 4\n        maps atoms in dihedra to atomArray\n    self.dSetValid : [dihedraLen][4] of bool\n        map of valid atoms into dihedra to detect 3 or 4 atoms valid\n\nOutput coordinates written to :data:`atomArray`.  Biopython\n:class:`Bio.PDB.Atom` coordinates are a view on this data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 1120, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "assemble_residues", "signature": "(self, verbose: bool = False) -> None", "symbol_type": "function"}], "assemble_residues_ser": [{"docstring": "Generate IC_Residue atom coords from internal coordinates (serial).\n\nSee :meth:`.assemble_residues` for 'numpy parallel' version.\n\nFilter positions between start and fin if set, find appropriate start\ncoordinates for each residue and pass to :meth:`.assemble`\n\n:param bool verbose: default False.\n    Describe runtime problems\n:param int start,fin: default None.\n    Sequence position for begin, end of subregion to generate coords\n    for.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 1226, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "assemble_residues_ser", "signature": "(self, verbose: bool = False, start: int | None = None, fin: int | None = None) -> None", "symbol_type": "function"}], "assembly_descriptors_by_accessions": [{"docstring": "Get genome metadata by accession  # noqa: E501\n\nGet detailed metadata for assembled genomes by accession in a JSON output format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.assembly_descriptors_by_accessions(accessions, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    accessions ([str]):\n\nKeyword Args:\n    filters_reference_only (bool): If true, only return reference and representative (GCF_ and GCA_) genome assemblies.. [optional] if omitted the server will use the default value of False\n    filters_assembly_source (V1AssemblyDatasetDescriptorsFilterAssemblySource): Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies. [optional]\n    filters_has_annotation (bool): Return only annotated genome assemblies. [optional] if omitted the server will use the default value of False\n    filters_exclude_atypical (bool): If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical. [optional] if omitted the server will use the default value of False\n    filters_assembly_level ([V1AssemblyDatasetDescriptorsFilterAssemblyLevel]): Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.. [optional]\n    filters_first_release_date (datetime): Only return genome assemblies that were released on or after the specified date By default, do not filter.. [optional]\n    filters_last_release_date (datetime): Only return genome assemblies that were released on or before to the specified date By default, do not filter.. [optional]\n    filters_search_text ([str]): Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter. [optional]\n    page_size (int): The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.. [optional] if omitted the server will use the default value of 20\n    page_token (str): A page token is returned from an `AssemblyMetadataRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyMetadataRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1AssemblyMetadata\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/genome_api.py", "line_number": 811, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.genome_api", "name": "assembly_descriptors_by_accessions", "signature": "(self, accessions, **kwargs)", "symbol_type": "function"}], "assembly_descriptors_by_bioproject": [{"docstring": "Get genome metadata by bioproject accession  # noqa: E501\n\nGet detailed metadata for assembled genomes by bioproject accession in a JSON output format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.assembly_descriptors_by_bioproject(accessions, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    accessions ([str]):\n\nKeyword Args:\n    filters_reference_only (bool): If true, only return reference and representative (GCF_ and GCA_) genome assemblies.. [optional] if omitted the server will use the default value of False\n    filters_assembly_source (V1AssemblyDatasetDescriptorsFilterAssemblySource): Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies. [optional]\n    filters_has_annotation (bool): Return only annotated genome assemblies. [optional] if omitted the server will use the default value of False\n    filters_exclude_paired_reports (bool): For paired (GCA/GCF) records, only return the primary record. [optional] if omitted the server will use the default value of False\n    filters_exclude_atypical (bool): If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical. [optional] if omitted the server will use the default value of False\n    filters_assembly_version (V1AssemblyDatasetDescriptorsFilterAssemblyVersion): Return all assemblies, including replaced and suppressed, or only current assemblies. [optional]\n    filters_assembly_level ([V1AssemblyDatasetDescriptorsFilterAssemblyLevel]): Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.. [optional]\n    filters_first_release_date (datetime): Only return genome assemblies that were released on or after the specified date By default, do not filter.. [optional]\n    filters_last_release_date (datetime): Only return genome assemblies that were released on or before to the specified date By default, do not filter.. [optional]\n    filters_search_text ([str]): Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter. [optional]\n    returned_content (V1AssemblyMetadataRequestContentType): Return either assembly accessions, or entire assembly-metadata records. [optional]\n    page_size (int): The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.. [optional] if omitted the server will use the default value of 20\n    page_token (str): A page token is returned from an `AssemblyMetadataRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyMetadataRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1AssemblyMetadata\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/genome_api.py", "line_number": 896, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.genome_api", "name": "assembly_descriptors_by_bioproject", "signature": "(self, accessions, **kwargs)", "symbol_type": "function"}], "assembly_descriptors_by_taxon": [{"docstring": "Get genome metadata by taxonomic identifier  # noqa: E501\n\nGet detailed metadata on all assembled genomes for a specified NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.assembly_descriptors_by_taxon(taxon, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    taxon (str): NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank\n\nKeyword Args:\n    filters_reference_only (bool): If true, only return reference and representative (GCF_ and GCA_) genome assemblies.. [optional] if omitted the server will use the default value of False\n    filters_assembly_source (V1AssemblyDatasetDescriptorsFilterAssemblySource): Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies. [optional]\n    filters_has_annotation (bool): Return only annotated genome assemblies. [optional] if omitted the server will use the default value of False\n    filters_exclude_paired_reports (bool): For paired (GCA/GCF) records, only return the primary record. [optional] if omitted the server will use the default value of False\n    filters_exclude_atypical (bool): If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical. [optional] if omitted the server will use the default value of False\n    filters_assembly_version (V1AssemblyDatasetDescriptorsFilterAssemblyVersion): Return all assemblies, including replaced and suppressed, or only current assemblies. [optional]\n    filters_assembly_level ([V1AssemblyDatasetDescriptorsFilterAssemblyLevel]): Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.. [optional]\n    filters_first_release_date (datetime): Only return genome assemblies that were released on or after the specified date By default, do not filter.. [optional]\n    filters_last_release_date (datetime): Only return genome assemblies that were released on or before to the specified date By default, do not filter.. [optional]\n    filters_search_text ([str]): Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter. [optional]\n    tax_exact_match (bool): If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. Ignored for assembly_accession request.. [optional] if omitted the server will use the default value of False\n    returned_content (V1AssemblyMetadataRequestContentType): Return either assembly accessions, or entire assembly-metadata records. [optional]\n    page_size (int): The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.. [optional] if omitted the server will use the default value of 20\n    page_token (str): A page token is returned from an `AssemblyMetadataRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyMetadataRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1AssemblyMetadata\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/genome_api.py", "line_number": 984, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.genome_api", "name": "assembly_descriptors_by_taxon", "signature": "(self, taxon, **kwargs)", "symbol_type": "function"}], "assembly_values_by_fields": [{"docstring": "Filters assembly descriptor for provided `fields`\n\nArgs:\n    assembly_descriptor: A single assembly descriptor record returned by the API\n    fields: List of top-level fields to allow into returned dict\n\nReturns:\n    dict of supplied fields to their values\n\nSide Effects:\n    Prints report to stdout.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/metadata/genome.py", "line_number": 27, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.metadata.genome", "name": "assembly_values_by_fields", "signature": "(assembly: V1AssemblyDatasetDescriptor, fields = List[str])", "symbol_type": "function"}], "assess_all_species_progress": [{"docstring": "Assess progress for all species in config directory.\n\nArgs:\n    config_dir: Directory containing amalgkit config files\n    repo_root: Repository root directory (optional)\n\nReturns:\n    Dictionary mapping species_id -> progress information", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/monitoring.py", "line_number": 409, "module": "src.metainformant.rna.monitoring", "name": "assess_all_species_progress", "signature": "(config_dir: Path) -> dict[str, dict[str, Any]]", "symbol_type": "function"}], "association_test_linear": [{"docstring": "Test association using linear regression.\n\nModel: phenotype ~ genotype + covariates\n\nArgs:\n    genotypes: Genotype vector for one variant (0/1/2/-1 encoding)\n    phenotypes: Phenotype values\n    covariates: Optional covariates matrix (list of lists, one per covariate)\n\nReturns:\n    Dictionary with:\n    - beta: Effect size (regression coefficient)\n    - se: Standard error\n    - p_value: P-value\n    - r_squared: R-squared for the model", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/association.py", "line_number": 27, "module": "src.metainformant.gwas.association", "name": "association_test_linear", "signature": "(genotypes: list[int], phenotypes: list[float], covariates: list[list[float]] | None = None) -> dict[str, Any]", "symbol_type": "function"}], "association_test_logistic": [{"docstring": "Test association using logistic regression for binary traits.\n\nModel: logit(P(Y=1)) = beta0 + beta_geno * genotype + covariates\n\nArgs:\n    genotypes: Genotype vector for one variant (0/1/2/-1 encoding)\n    phenotypes: Binary phenotype values (0/1)\n    covariates: Optional covariates matrix\n    max_iter: Maximum iterations for logistic regression\n\nReturns:\n    Dictionary with:\n    - beta: Log odds ratio (coefficient)\n    - se: Standard error\n    - p_value: P-value\n    - odds_ratio: Odds ratio (exp(beta))", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/association.py", "line_number": 148, "module": "src.metainformant.gwas.association", "name": "association_test_logistic", "signature": "(genotypes: list[int], phenotypes: list[int], covariates: list[list[float]] | None = None, max_iter: int = 100) -> dict[str, Any]", "symbol_type": "function"}], "atm": [{"docstring": "Return atom name : N, CA, CB, O etc.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4766, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "atm", "signature": "(self) -> str", "symbol_type": "function"}], "atom_to_internal_coordinates": [{"docstring": "Create/update internal coordinates from Atom X,Y,Z coordinates.\n\nInternal coordinates are bond length, angle and dihedral angles.\n\n:param verbose bool: default False\n    describe runtime problems", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Chain.py", "line_number": 189, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Chain", "name": "atom_to_internal_coordinates", "signature": "(self, verbose: bool = False) -> None", "symbol_type": "function"}, {"docstring": "Create/update internal coordinates from Atom X,Y,Z coordinates.\n\nInternal coordinates are bond length, angle and dihedral angles.\n\n:param verbose bool: default False\n    describe runtime problems", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Model.py", "line_number": 60, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Model", "name": "atom_to_internal_coordinates", "signature": "(self, verbose: bool = False) -> None", "symbol_type": "function"}, {"docstring": "Create/update internal coordinates from Atom X,Y,Z coordinates.\n\nInternal coordinates are bond length, angle and dihedral angles.\n\n:param verbose bool: default False\n    describe runtime problems", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Structure.py", "line_number": 49, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Structure", "name": "atom_to_internal_coordinates", "signature": "(self, verbose: bool = False) -> None", "symbol_type": "function"}, {"docstring": "Calculate dihedrals, angles, bond lengths for Atom data.\n\nGenerates atomArray (through init_edra), value arrays for hedra and\ndihedra, and coordinate space transforms for dihedra.\n\nGenerates Gly C-beta if specified, see :data:`IC_Residue.gly_Cbeta`\n\n:param bool verbose: default False.\n    describe runtime problems", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 1619, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "atom_to_internal_coordinates", "signature": "(self, verbose: bool = False) -> None", "symbol_type": "function"}], "attempt_convert_item": [{"docstring": "Args:\n    input_value (any): the data to convert\n    valid_classes (any): the classes that are valid\n    path_to_item (list): the path to the item to convert\n    configuration (Configuration): the instance to use to convert files\n    spec_property_naming (bool): True if the variable names in the input\n        data are serialized names as specified in the OpenAPI document.\n        False if the variables names in the input data are python\n        variable names in PEP-8 snake case.\n    key_type (bool): if True we need to convert a key type (not supported)\n    must_convert (bool): if True we must convert\n    check_type (bool): if True we check the type or the returned data in\n        ModelComposed/ModelNormal/ModelSimple instances\n\nReturns:\n    instance (any) the fixed item\n\nRaises:\n    ApiTypeError\n    ApiValueError\n    ApiKeyError", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1415, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "attempt_convert_item", "signature": "(input_value, valid_classes, path_to_item, configuration, spec_property_naming, key_type = False, must_convert = False, check_type = True)", "symbol_type": "function"}], "attention_weights": [{"docstring": "Extract attention weights from transformer models.\n\nNote: Full implementation requires transformer models with attention.\nThis is a placeholder for future implementation.\n\nArgs:\n    model: Trained model with attention mechanism\n    sequences: List of event sequences\n    event_embeddings: Event embeddings dictionary\n    \nReturns:\n    Attention weight matrix", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/interpretability.py", "line_number": 23, "module": "src.metainformant.life_events.interpretability", "name": "attention_weights", "signature": "(model: Any, sequences: List[List[str]], event_embeddings: Dict[str, NDArray]) -> NDArray", "symbol_type": "function"}], "audit_file": [{"docstring": "Audit a Python file for missing docstrings.\n\nArgs:\n    file_path: Path to Python file to audit\n    \nReturns:\n    Dictionary with audit results", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/audit_docstrings.py", "line_number": 11, "module": "scripts.audit_docstrings", "name": "audit_file", "signature": "(file_path: Path) -> dict[str, Any]", "symbol_type": "function"}], "auth_settings": [{"docstring": "Gets Auth Settings dict for api client.\n\n:return: The Auth Settings information dict.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 383, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "auth_settings", "signature": "(self)", "symbol_type": "function"}], "authors": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 630, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "authors", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1018, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "authors", "signature": "(self, content)", "symbol_type": "function"}], "autocommit": [{"docstring": "Set the autocommit mode. True values enable; False value disable.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 363, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "autocommit", "signature": "(self, y = True)", "symbol_type": "function"}, {"docstring": "Set autocommit on the database connection.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/DBUtils.py", "line_number": 50, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.DBUtils", "name": "autocommit", "signature": "(self, conn, y = 1)", "symbol_type": "function"}, {"docstring": "Set autocommit on the database connection.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/DBUtils.py", "line_number": 120, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.DBUtils", "name": "autocommit", "signature": "(self, conn, y = True)", "symbol_type": "function"}, {"docstring": "Set autocommit on the database connection. Currently not implemented.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/DBUtils.py", "line_number": 140, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.DBUtils", "name": "autocommit", "signature": "(self, conn, y = True)", "symbol_type": "function"}], "autocorrelation_plot": [{"docstring": "Create an autocorrelation plot.\n\nArgs:\n    data: Time series data\n    max_lag: Maximum lag to plot (if None, uses len(data) // 2)\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import autocorrelation_plot\n    >>> import numpy as np\n    >>> data = np.sin(np.arange(0, 100, 0.1))\n    >>> ax = autocorrelation_plot(data)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/timeseries.py", "line_number": 64, "module": "src.metainformant.visualization.timeseries", "name": "autocorrelation_plot", "signature": "(data: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "average_phred_by_position": [{"docstring": "Compute average Phred+33 quality score at each position across reads.\n\n- Streams the file (supports ``.gz``) via ``open_text_auto``\n- Truncates to the shortest read length encountered for safety\n- Ignores incomplete trailing records", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/fastq.py", "line_number": 14, "module": "src.metainformant.dna.fastq", "name": "average_phred_by_position", "signature": "(path: Path | str) -> list[float]", "symbol_type": "function"}], "back_transcribe": [{"docstring": "Return the RNA sequence back-transcribed into DNA.\n\nIf given a string, returns a new string object.\n\nGiven a Seq or MutableSeq, returns a new Seq object.\n\ne.g.\n\n>>> back_transcribe(\"ACUGN\")\n'ACTGN'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2716, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "back_transcribe", "signature": "(rna)", "symbol_type": "function"}, {"docstring": "Return the DNA sequence from an RNA sequence by creating a new Seq object.\n\n>>> from Bio.Seq import Seq\n>>> messenger_rna = Seq(\"AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG\")\n>>> messenger_rna\nSeq('AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG')\n>>> messenger_rna.back_transcribe()\nSeq('ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG')\n\nThe sequence is modified in-place and returned if inplace is True:\n\n>>> sequence = MutableSeq(\"AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG\")\n>>> sequence\nMutableSeq('AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG')\n>>> sequence.back_transcribe()\nMutableSeq('ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG')\n>>> sequence\nMutableSeq('AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG')\n\n>>> sequence.back_transcribe(inplace=True)\nMutableSeq('ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG')\n>>> sequence\nMutableSeq('ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if\n``transcribe`` is called on a ``Seq`` object with ``inplace=True``.\n\nTrying to back-transcribe DNA has no effect, If you have a nucleotide\nsequence which might be DNA or RNA (or even a mixture), calling the\nback-transcribe method will ensure any U becomes T.\n\nTrying to back-transcribe a protein sequence will replace any U for\nSelenocysteine with T for Threonine, which is biologically meaningless.\n\n>>> from Bio.Seq import Seq\n>>> my_protein = Seq(\"MAIVMGRU\")\n>>> my_protein.back_transcribe()\nSeq('MAIVMGRT')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1868, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "back_transcribe", "signature": "(self, inplace = False)", "symbol_type": "function"}], "bar_plot": [{"docstring": "Create a bar plot.\n\nArgs:\n    x: Categories or x-axis values\n    y: Bar heights\n    ax: Matplotlib axes (creates new if None)\n    color: Bar color(s)\n    alpha: Bar transparency\n    xlabel: X-axis label\n    ylabel: Y-axis label\n    title: Plot title\n    horizontal: Whether to create horizontal bars\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import bar_plot\n    >>> ax = bar_plot([\"A\", \"B\", \"C\"], [10, 20, 15])", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/basic.py", "line_number": 160, "module": "src.metainformant.visualization.basic", "name": "bar_plot", "signature": "(x: Sequence[str] | Sequence[float], y: Sequence[float]) -> plt.Axes", "symbol_type": "function"}], "base_count": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 799, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "base_count", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1133, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "base_count", "signature": "(self, content)", "symbol_type": "function"}], "base_id": [{"docstring": "Return the JASPAR base matrix ID.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/jaspar/__init__.py", "line_number": 62, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.jaspar.__init__", "name": "base_id", "signature": "(self)", "symbol_type": "function"}], "base_number": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 802, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "base_number", "signature": "(self, content)", "symbol_type": "function"}], "basic_reproduction_number": [{"docstring": "Calculate basic reproduction number R0 for SIR model.\n\nR0 represents the expected number of secondary infections from a single\ninfected individual in a fully susceptible population. Critical threshold:\nR0 > 1 indicates epidemic potential, R0 < 1 indicates outbreak extinction.\n\nArgs:\n    beta: Transmission rate (contact rate * transmission probability)\n    gamma: Recovery rate (1 / average infectious period)\n    \nReturns:\n    Basic reproduction number R0 = beta / gamma. Returns 0.0 if gamma <= 0.\n    \nExamples:\n    >>> basic_reproduction_number(beta=0.3, gamma=0.1)\n    3.0\n    >>> basic_reproduction_number(beta=0.1, gamma=0.2)\n    0.5\n    \nReferences:\n    Diekmann, O., Heesterbeek, J. A. P., & Roberts, M. G. (2010). The construction\n    of next-generation matrices for compartmental epidemic models. Journal of the\n    Royal Society Interface, 7(47), 873-885.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/epidemiology.py", "line_number": 49, "module": "src.metainformant.math.epidemiology", "name": "basic_reproduction_number", "signature": "(beta: float, gamma: float) -> float", "symbol_type": "function"}], "basic_statistics": [{"docstring": "Calculate basic FASTQ statistics.\n\nArgs:\n    reads: List of FASTQ records\n\nReturns:\n    Dictionary with basic statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/fastq.py", "line_number": 89, "module": "src.metainformant.quality.fastq", "name": "basic_statistics", "signature": "(reads: List[FastqRecord]) -> Dict[str, Any]", "symbol_type": "function"}], "basic_tree_stats": [{"docstring": "Return simple stats for a Phylo tree: number of terminals and clades.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/phylogeny.py", "line_number": 145, "module": "src.metainformant.dna.phylogeny", "name": "basic_tree_stats", "signature": "(tree) -> Dict[str, int]", "symbol_type": "function"}], "batch_correction": [{"docstring": "Perform batch correction on single-cell data.\n\nArgs:\n    data: SingleCellData object\n    batch_key: Column name in obs indicating batch\n    method: Batch correction method ('combat', 'mnn', 'scaling')\n    n_components: Number of components for dimensionality-based methods\n\nReturns:\n    SingleCellData with batch-corrected expression", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/integration.py", "line_number": 37, "module": "src.metainformant.singlecell.integration", "name": "batch_correction", "signature": "(data: SingleCellData, batch_key: str, method: str = 'combat', n_components: int = 50) -> SingleCellData", "symbol_type": "function"}], "batch_download": [{"docstring": "Download multiple files in batch.\n\nArgs:\n    urls: List of URLs to download\n    dest_dir: Directory to save files to\n    timeout: Request timeout in seconds\n    \nReturns:\n    Dictionary mapping URLs to success status", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 454, "module": "src.metainformant.core.io", "name": "batch_download", "signature": "(urls: list[str], dest_dir: str | Path) -> dict[str, bool]", "symbol_type": "function"}], "batch_entropy_analysis": [{"docstring": "Perform entropy analysis on multiple sequences.\n\nArgs:\n    sequences: List of sequences to analyze\n    k: K-mer size for analysis\n    output_dir: Optional output directory for saving results\n    \nReturns:\n    Dictionary with analysis results for each sequence\n    \nRaises:\n    ValueError: If sequences list is empty or k is invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/workflows.py", "line_number": 27, "module": "src.metainformant.information.workflows", "name": "batch_entropy_analysis", "signature": "(sequences: list[str], k: int = 1, output_dir: Path | None = None) -> dict[str, Any]", "symbol_type": "function"}], "batch_export_figures": [{"docstring": "Batch export multiple figures.\n\nArgs:\n    figures: Dictionary mapping names to figures\n    output_dir: Output directory\n    formats: List of formats to save\n    dpi: Resolution for raster formats\n    **kwargs: Additional arguments for savefig\n\nReturns:\n    Dictionary mapping names to lists of saved paths\n\nExample:\n    >>> from metainformant.visualization.export import batch_export_figures\n    >>> import matplotlib.pyplot as plt\n    >>> figs = {\n    ...     'plot1': plt.figure(),\n    ...     'plot2': plt.figure()\n    ... }\n    >>> paths = batch_export_figures(figs, 'output/plots')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/export.py", "line_number": 101, "module": "src.metainformant.visualization.export", "name": "batch_export_figures", "signature": "(figures: dict[str, plt.Figure], output_dir: str | Path, **kwargs) -> dict[str, list[Path]]", "symbol_type": "function"}], "bc_getter": [{"docstring": "Get binary characters from subnodes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 506, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "bc_getter", "signature": "(elem)", "symbol_type": "function"}], "beta_diversity_partitioning": [{"docstring": "Partition beta diversity into turnover and nestedness components.\n\nFollowing Baselga (2010) framework.\n\nArgs:\n    site_abundances: List of abundance vectors, one per site\n\nReturns:\n    Dictionary with beta diversity components", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/community.py", "line_number": 274, "module": "src.metainformant.ecology.community", "name": "beta_diversity_partitioning", "signature": "(site_abundances: List[Sequence[float]]) -> Dict[str, float]", "symbol_type": "function"}], "between": [{"docstring": "Return only results from enzymes that cut at least within borders.\n\nEnzymes that cut the sequence at least in between start and end.\nThey may cut outside as well.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2469, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "between", "signature": "(self, start, end, dct = None)", "symbol_type": "function"}], "bf_search": [{"docstring": "Breadth first search of g.\n\nReturns a list of all nodes that can be reached from the root node\nin breadth-first order.\n\nIf root is not given, the search will be rooted at an arbitrary node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/MultiGraph.py", "line_number": 172, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.MultiGraph", "name": "bf_search", "signature": "(graph, root = None)", "symbol_type": "function"}], "bias_correction": [{"docstring": "Apply bias correction to entropy/MI estimates.\n\nArgs:\n    estimate: Uncorrected estimate\n    n_samples: Number of samples\n    n_bins: Number of bins/symbols\n    measure: Type of measure (\"entropy\", \"mutual_information\")\n    \nReturns:\n    Bias-corrected estimate", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/estimation.py", "line_number": 249, "module": "src.metainformant.information.estimation", "name": "bias_correction", "signature": "(estimate: float, n_samples: int, n_bins: int, measure: str = 'entropy') -> float", "symbol_type": "function"}], "binary_characters": [{"docstring": "Create binary characters object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 503, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "binary_characters", "signature": "(self, elem)", "symbol_type": "function"}, {"docstring": "Serialize a binary_characters node and its subnodes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 792, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "binary_characters", "signature": "(self, obj)", "symbol_type": "function"}], "biological_embedding": [{"docstring": "Create biological-aware dimensionality reduction.\n\nArgs:\n    X: Data matrix\n    method: Reduction method (\"pca\", \"umap\", \"tsne\")\n    n_components: Number of output dimensions\n    feature_weights: Weights for features (e.g., biological importance)\n    **kwargs: Method-specific parameters\n\nReturns:\n    Dictionary with embedding and metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/dimensionality.py", "line_number": 199, "module": "src.metainformant.ml.dimensionality", "name": "biological_embedding", "signature": "(X: np.ndarray, method: str = 'pca', n_components: int = 2, feature_weights: Optional[np.ndarray] = None, **kwargs) -> Dict[str, Any]", "symbol_type": "function"}], "biological_feature_ranking": [{"docstring": "Rank features considering biological relevance.\n\nArgs:\n    X: Feature matrix\n    y: Target vector\n    feature_names: Names of features (genes, proteins, etc.)\n    method: Ranking method (\"combined\", \"statistical\", \"biological\")\n    gene_weights: Prior biological weights for features\n\nReturns:\n    List of (index, name, score) tuples sorted by importance", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/features.py", "line_number": 173, "module": "src.metainformant.ml.features", "name": "biological_feature_ranking", "signature": "(X: np.ndarray, y: np.ndarray, feature_names: Optional[List[str]] = None, method: str = 'combined', gene_weights: Optional[Dict[str, float]] = None) -> List[Tuple[int, str, float]]", "symbol_type": "function"}], "biplot": [{"docstring": "Create a PCA biplot showing both samples and loadings.\n\nArgs:\n    scores: PCA scores (samples x components)\n    loadings: PCA loadings (features x components)\n    pc_x: Principal component for x-axis\n    pc_y: Principal component for y-axis\n    feature_names: Optional feature names\n    sample_names: Optional sample names\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import biplot\n    >>> import numpy as np\n    >>> scores = np.random.normal(0, 1, (20, 5))\n    >>> loadings = np.random.random((10, 5))\n    >>> ax = biplot(scores, loadings)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/dimred.py", "line_number": 346, "module": "src.metainformant.visualization.dimred", "name": "biplot", "signature": "(scores: pd.DataFrame | np.ndarray, loadings: pd.DataFrame | np.ndarray, **kwargs) -> plt.Axes", "symbol_type": "function"}], "bits": [{"docstring": "Get :data:`IC_Residue.pic_flags` bitmasks for self is psi, omg, phi, pomg, chiX.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4480, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "bits", "signature": "(self) -> int", "symbol_type": "function"}], "blunt": [{"docstring": "Return only cuts that have blunt ends.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2386, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "blunt", "signature": "(self, dct = None)", "symbol_type": "function"}], "bond_rotate": [{"docstring": "Rotate set of overlapping dihedrals by delta degrees.\n\nChanges a dihedral angle by a given delta, i.e.\nnew_angle = current_angle + delta\nValues are adjusted so new_angle will be within +/-180.\n\nChanges overlapping dihedra as in :meth:`.set_angle`\n\nSee :meth:`.pick_angle` for key specifications.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 3755, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "bond_rotate", "signature": "(self, angle_key: EKT | str, delta: float)", "symbol_type": "function"}], "bond_set": [{"docstring": "Set dihedron to val, update overlapping dihedra by same amount.\n\nRedundant to :meth:`.set_angle`, retained for compatibility.  Unlike\n:meth:`.set_angle` this is for dihedra only and no option to not update\noverlapping dihedra.\n\nSee :meth:`.pick_angle` for key specifications.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 3770, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "bond_set", "signature": "(self, angle_key: EKT | str, val: float)", "symbol_type": "function"}], "bonferroni_correction": [{"docstring": "Apply Bonferroni correction for multiple testing.\n\nArgs:\n    pvalues: List of p-values\n    alpha: Significance level\n\nReturns:\n    Dictionary with:\n    - corrected_alpha: Bonferroni-corrected significance threshold\n    - significant_count: Number of significant results\n    - significant_indices: Indices of significant results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/correction.py", "line_number": 24, "module": "src.metainformant.gwas.correction", "name": "bonferroni_correction", "signature": "(pvalues: list[float], alpha: float = 0.05) -> dict[str, Any]", "symbol_type": "function"}], "bootstrap": [{"docstring": "Return a bootstrapped matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 1934, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "bootstrap", "signature": "(self, matrix = None, delete = (), exclude = ())", "symbol_type": "function"}, {"docstring": "Generate bootstrap replicates from a multiple sequence alignment (OBSOLETE).\n\n:Parameters:\n    msa : MultipleSeqAlignment\n        multiple sequence alignment to generate replicates.\n    times : int\n        number of bootstrap times.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/Consensus.py", "line_number": 541, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.Consensus", "name": "bootstrap", "signature": "(msa, times)", "symbol_type": "function"}], "bootstrap_confidence_interval": [{"docstring": "Calculate bootstrap confidence interval for a statistic.\n\nUses bootstrap resampling to estimate confidence intervals for any statistic.\nSupports percentile and BCa (bias-corrected and accelerated) methods.\n\nArgs:\n    data: Observed data values\n    statistic_func: Function that computes the statistic from data\n    n_bootstrap: Number of bootstrap replicates\n    confidence_level: Confidence level (e.g., 0.95 for 95% CI)\n    method: Method for CI calculation (\"percentile\" or \"bca\")\n    random_state: Random seed for reproducibility\n\nReturns:\n    Dictionary with:\n    - statistic: Observed statistic value\n    - ci_lower: Lower bound of confidence interval\n    - ci_upper: Upper bound of confidence interval\n    - confidence_level: Confidence level used\n    - n_bootstrap: Number of bootstrap replicates\n    \nExamples:\n    >>> data = [1.0, 2.0, 3.0, 4.0, 5.0]\n    >>> result = bootstrap_confidence_interval(data, np.mean, n_bootstrap=100)\n    >>> \"ci_lower\" in result\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen_stats.py", "line_number": 15, "module": "src.metainformant.math.popgen_stats", "name": "bootstrap_confidence_interval", "signature": "(data: Sequence[float], statistic_func: Callable[[Sequence[float]], float], n_bootstrap: int = 1000, confidence_level: float = 0.95, method: str = 'percentile', random_state: int | None = None) -> dict[str, float]", "symbol_type": "function"}], "bootstrap_consensus": [{"docstring": "Consensus tree of a series of bootstrap trees for a multiple sequence alignment.\n\n:Parameters:\n    alignment : Alignment or MultipleSeqAlignment object\n        Multiple sequence alignment to generate replicates.\n    times : int\n        Number of bootstrap times.\n    tree_constructor : TreeConstructor\n        Tree constructor to be used to build trees.\n    consensus : function\n        Consensus method in this module: ``strict_consensus``,\n        ``majority_consensus``, ``adam_consensus``.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/Consensus.py", "line_number": 597, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.Consensus", "name": "bootstrap_consensus", "signature": "(alignment, times, tree_constructor, consensus)", "symbol_type": "function"}], "bootstrap_support": [{"docstring": "Simple bootstrap with optional deterministic seed.\n\nReturns mapping of clade name (sorted, semicolon-joined) to support fraction.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/phylogeny.py", "line_number": 85, "module": "src.metainformant.dna.phylogeny", "name": "bootstrap_support", "signature": "(id_to_seq: Dict[str, str], n_replicates: int = 100, method: str = 'nj', random_state: int | None = None) -> Dict[str, float]", "symbol_type": "function"}, {"docstring": "Bootstrap clade support using simple column resampling.\n\nReturns a mapping from clade (as frozenset of leaf names) to support in [0,1].", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/phylogeny.py", "line_number": 153, "module": "src.metainformant.dna.phylogeny", "name": "bootstrap_support", "signature": "(id_to_seq: Dict[str, str]) -> Dict[frozenset[str], float]", "symbol_type": "function"}], "bootstrap_trees": [{"docstring": "Generate bootstrap replicate trees from a multiple sequence alignment.\n\n:Parameters:\n    alignment : Alignment or MultipleSeqAlignment object\n        multiple sequence alignment to generate replicates.\n    times : int\n        number of bootstrap times.\n    tree_constructor : TreeConstructor\n        tree constructor to be used to build trees.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/Consensus.py", "line_number": 565, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.Consensus", "name": "bootstrap_trees", "signature": "(alignment, times, tree_constructor)", "symbol_type": "function"}], "bootstrap_validate": [{"docstring": "Perform bootstrap validation.\n\nArgs:\n    model_func: Function that returns trained model (can accept X_train, y_train, X_test, y_test)\n    X: Feature matrix\n    y: Target vector\n    n_bootstrap: Number of bootstrap iterations\n    sample_size: Size of bootstrap samples\n    scoring: Scoring metric\n    random_state: Random seed\n    **model_kwargs: Parameters for model_func\n\nReturns:\n    Dictionary with bootstrap validation results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/validation.py", "line_number": 241, "module": "src.metainformant.ml.validation", "name": "bootstrap_validate", "signature": "(model_func: Callable = None, X: np.ndarray = None, y: np.ndarray = None, n_bootstrap: int = 100, sample_size: Optional[int] = None, scoring: str = 'accuracy', random_state: Optional[int] = None, **model_kwargs) -> Dict[str, Any]", "symbol_type": "function"}], "bottleneck_effective_size": [{"docstring": "Calculate effective population size through a bottleneck.\n\nModels a population bottleneck where the population size drops to a\nsmall value for a period, then may recover. The effective size is\ndominated by the bottleneck period.\n\nArgs:\n    pre_bottleneck_size: Population size before bottleneck (N_pre)\n    bottleneck_size: Population size during bottleneck (N_b)\n    bottleneck_duration: Number of generations at bottleneck size\n    recovery_generations: Number of generations after bottleneck (default: 0)\n        If > 0, assumes recovery to pre_bottleneck_size\n\nReturns:\n    Effective population size (harmonic mean). Heavily weighted by\n    bottleneck period.\n    \nExamples:\n    >>> # Severe bottleneck: 10000 \u2192 100 for 5 generations\n    >>> bottleneck_effective_size(10000, 100, 5)\n    109...\n    \n    >>> # With recovery\n    >>> bottleneck_effective_size(10000, 100, 5, recovery_generations=10)\n    200...\n    \nReferences:\n    Nei, M., Maruyama, T., & Chakraborty, R. (1975). The bottleneck\n    effect and genetic variability in populations. Evolution, 29(1), 1-10.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/demography.py", "line_number": 67, "module": "src.metainformant.math.demography", "name": "bottleneck_effective_size", "signature": "(pre_bottleneck_size: int, bottleneck_size: int, bottleneck_duration: int, recovery_generations: int = 0) -> float", "symbol_type": "function"}], "bounds": [{"docstring": "Coordinate bounds for all Graphics elements in the Pathway.\n\nReturns the [(xmin, ymin), (xmax, ymax)] coordinates for all\nGraphics elements in the Pathway", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 245, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "bounds", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Coordinate bounds for all Graphics elements in the Entry.\n\nReturn the [(xmin, ymin), (xmax, ymax)] coordinates for the Entry\nGraphics elements.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 397, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "bounds", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Coordinate bounds for the Graphics element.\n\nReturn the bounds of the Graphics object as an [(xmin, ymin),\n(xmax, ymax)] tuple.  Coordinates give the centre of the\ncircle, rectangle, roundrectangle elements, so we have to\nadjust for the relevant width/height.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 625, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "bounds", "signature": "(self)", "symbol_type": "function"}], "box_plot": [{"docstring": "Create a box plot.\n\nArgs:\n    data: Data to plot (single array or list of arrays)\n    ax: Matplotlib axes (creates new if None)\n    positions: Box positions\n    labels: Box labels\n    xlabel: X-axis label\n    ylabel: Y-axis label\n    title: Plot title\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import box_plot\n    >>> import numpy as np\n    >>> data = [np.random.normal(0, 1, 100) for _ in range(3)]\n    >>> ax = box_plot(data, labels=[\"A\", \"B\", \"C\"])", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/statistical.py", "line_number": 78, "module": "src.metainformant.visualization.statistical", "name": "box_plot", "signature": "(data: Sequence[float] | Sequence[Sequence[float]]) -> plt.Axes", "symbol_type": "function"}], "branchlength2support": [{"docstring": "Move values stored in data.branchlength to data.support, and set branchlength to 0.0.\n\nThis is necessary when support has been stored as branchlength (e.g. paup), and has thus\nbeen read in as branchlength.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 539, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "branchlength2support", "signature": "(self)", "symbol_type": "function"}], "bray_curtis_dissimilarity": [{"docstring": "Calculate Bray-Curtis dissimilarity between two sites.\n\nBC = \u03a3|x1i - x2i| / \u03a3(x1i + x2i)\n\nArgs:\n    site1, site2: Species abundance vectors for two sites\n\nReturns:\n    Bray-Curtis dissimilarity (0 = identical, 1 = completely different)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/community.py", "line_number": 113, "module": "src.metainformant.ecology.community", "name": "bray_curtis_dissimilarity", "signature": "(site1: Sequence[float], site2: Sequence[float]) -> float", "symbol_type": "function"}], "breeders_equation_response": [{"docstring": "Calculate response to selection using breeder's equation: R = h\u00b2 \u00d7 S.\n\nThe breeder's equation predicts the change in mean phenotype after\none generation of selection, given selection differential and heritability.\n\nArgs:\n    selection_differential: Difference between mean of selected parents\n        and population mean (S)\n    heritability: Narrow-sense heritability (h\u00b2), clamped to [0, 1]\n        \nReturns:\n    Expected response to selection (R)\n    \nExamples:\n    >>> breeders_equation_response(selection_differential=2.0, heritability=0.5)\n    1.0\n    >>> breeders_equation_response(selection_differential=1.5, heritability=0.8)\n    1.2\n    \nReferences:\n    Lush, J. L. (1937). Animal breeding plans. Iowa State College Press.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/quantgen.py", "line_number": 43, "module": "src.metainformant.math.quantgen", "name": "breeders_equation_response", "signature": "(selection_differential: float, heritability: float) -> float", "symbol_type": "function"}], "buffers": [{"docstring": "Return the recommended buffer of the supplier for this enzyme.\n\nNot implemented yet.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1933, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "buffers", "signature": "(cls, supplier)", "symbol_type": "function"}, {"docstring": "Return the recommended buffer of the supplier for this enzyme.\n\nNot implemented yet.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1965, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "buffers", "signature": "(cls, supplier)", "symbol_type": "function"}], "build": [{"docstring": "Build a codon alignment from protein alignment and corresponding nucleotides.\n\nArguments:\n - pro_align  - a protein MultipleSeqAlignment object\n - nucl_seqs - an object returned by SeqIO.parse or SeqIO.index\n   or a collection of SeqRecord.\n - corr_dict  - a dict that maps protein id to nucleotide id\n - complete_protein - whether the sequence begins with a start\n   codon\n\nReturn a CodonAlignment object.\n\nThe example below answers this Biostars question: https://www.biostars.org/p/89741/\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqRecord import SeqRecord\n>>> from Bio.Align import MultipleSeqAlignment\n>>> from Bio.codonalign import build\n>>> seq1 = SeqRecord(Seq('ATGTCTCGT'), id='pro1')\n>>> seq2 = SeqRecord(Seq('ATGCGT'), id='pro2')\n>>> pro1 = SeqRecord(Seq('MSR'), id='pro1')\n>>> pro2 = SeqRecord(Seq('M-R'), id='pro2')\n>>> aln = MultipleSeqAlignment([pro1, pro2])\n>>> codon_aln = build(aln, [seq1, seq2])\n>>> print(codon_aln)\nCodonAlignment with 2 rows and 9 columns (3 codons)\nATGTCTCGT pro1\nATG---CGT pro2", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/__init__.py", "line_number": 28, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.__init__", "name": "build", "signature": "(pro_align, nucl_seqs, corr_dict = None, gap_char = '-', unknown = 'X', codon_table = None, complete_protein = False, anchor_len = 10, max_score = 10)", "symbol_type": "function"}], "build_alphafold_url": [{"docstring": "Build AlphaFold database URL for a UniProt accession.\n\nArgs:\n    uniprot_acc: UniProt accession identifier\n    version: AlphaFold model version (default: 4)\n    fmt: Format, either \"pdb\" or \"cif\" (default: \"pdb\")\n    \nReturns:\n    URL string for AlphaFold model\n    \nRaises:\n    ValueError: If fmt is not \"pdb\" or \"cif\"", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/alphafold.py", "line_number": 8, "module": "src.metainformant.protein.alphafold", "name": "build_alphafold_url", "signature": "(uniprot_acc: str) -> str", "symbol_type": "function"}], "build_amalgkit_command": [{"docstring": "Prepare the `amalgkit` CLI command as a token list.\n\nExample: build_amalgkit_command(\"metadata\", {\"threads\": 8}) \u2192\n    [\"amalgkit\", \"metadata\", \"--threads\", \"8\"]", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 130, "module": "src.metainformant.rna.amalgkit", "name": "build_amalgkit_command", "signature": "(subcommand: str, params: AmalgkitParams | None = None) -> list[str]", "symbol_type": "function"}], "build_atomArray": [{"docstring": "Build :class:`IC_Chain` numpy coordinate array from biopython atoms.\n\nSee also :meth:`.init_edra` for more complete initialization of IC_Chain.\n\nInputs:\n    self.akset : set\n        :class:`AtomKey` s in this chain\n\nGenerates:\n    self.AAsiz : int\n        number of atoms in chain (len(akset))\n    self.aktuple : AAsiz x AtomKeys\n        sorted akset AtomKeys\n    self.atomArrayIndex : [AAsiz] of int\n        numerical index for each AtomKey in aktuple\n    self.atomArrayValid : AAsiz x bool\n        atomArray coordinates current with internal coordinates if True\n    self.atomArray : AAsiz x np.float64[4]\n        homogeneous atom coordinates; Biopython :class:`.Atom`\n        coordinates are view into this array after execution\n    rak_cache : dict\n        lookup cache for AtomKeys for each residue", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 771, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "build_atomArray", "signature": "(self) -> None", "symbol_type": "function"}], "build_call_graph": [{"docstring": "Build function call graph from an entry point.\n\nArgs:\n    entry_point: Path to entry point module or function name\n    repo_root: Root directory of repository (for resolving imports)\n\nReturns:\n    Dictionary mapping function names to lists of called functions", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/discovery.py", "line_number": 375, "module": "src.metainformant.core.discovery", "name": "build_call_graph", "signature": "(entry_point: str | Path, repo_root: str | Path | None = None) -> dict[str, list[str]]", "symbol_type": "function"}], "build_cli_args": [{"docstring": "Convert a params mapping into a flat list of CLI args for `amalgkit`.\n\nRules:\n- None values are skipped\n- For most flags: bool True adds a flag (e.g., {dry_run: True} \u2192 [\"--dry-run\"]) ; False is skipped\n- For certain flags that require explicit values (e.g., {redo: True|False}),\n  emit yes/no as a value pair (e.g., [\"--redo\", \"yes\"]).\n- list/tuple produces repeated pairs (e.g., {species: [a,b]} \u2192 [--species a --species b])\n- Path values are stringified\n- other scalars are appended as flag + value", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 84, "module": "src.metainformant.rna.amalgkit", "name": "build_cli_args", "signature": "(params: AmalgkitParams | None) -> list[str]", "symbol_type": "function"}], "build_edraArrays": [{"docstring": "Build chain level hedra and dihedra arrays.\n\nUsed by :meth:`init_edra` and :meth:`_hedraDict2chain`.  Should be\nprivate method but exposed for documentation.\n\nInputs:\n    self.dihedraLen : int\n        number of dihedra needed\n    self.hedraLen : int\n        number of hedra needed\n    self.AAsiz : int\n        length of atomArray\n    self.hedraNdx : dict\n        maps hedron keys to range(hedraLen)\n    self.dihedraNdx : dict\n        maps dihedron keys to range(dihedraLen)\n    self.hedra : dict\n        maps Hedra keys to Hedra for chain\n    self.atomArray : AAsiz x np.float64[4]\n        homogeneous atom coordinates for chain\n    self.atomArrayIndex : dict\n        maps AtomKeys to atomArray\n    self.atomArrayValid : AAsiz x bool\n        indicates coord is up-to-date\n\nGenerates:\n    self.dCoordSpace : [2][dihedraLen][4][4]\n        transforms to/from dihedron coordinate space\n    self.dcsValid : dihedraLen x bool\n        indicates dCoordSpace is current\n    self.hAtoms : hedraLen x 3 x np.float64[4]\n        atom coordinates in hCoordSpace\n    self.hAtomsR : hedraLen x 3 x np.float64[4]\n        hAtoms in reverse order (trading space for time)\n    self.hAtoms_needs_update : hedraLen x bool\n        indicates hAtoms, hAtoms current\n    self.a2h_map : AAsiz x [int ...]\n        maps atomArrayIndex to hedraNdx's with that atom\n    self.a2ha_map : [hedraLen x 3]\n        AtomNdx's in hedraNdx order\n    self.h2aa : hedraLen x [int ...]\n        maps hedraNdx to atomNdx's in hedron (reshaped later)\n    Hedron.ndx : int\n        self.hedraNdx value stored inside Hedron object\n    self.dRev : dihedraLen x bool\n        dihedron reversed if true\n    self.dH1ndx, dH2ndx : [dihedraLen]\n        hedraNdx's for 1st and 2nd hedra\n    self.h1d_map : hedraLen x []\n        hedraNdx -> [dihedra using hedron]\n    Dihedron.h1key, h2key : [AtomKey ...]\n        hedron keys for dihedron, reversed as needed\n    Dihedron.hedron1, hedron2 : Hedron\n        references inside dihedron to hedra\n    Dihedron.ndx : int\n        self.dihedraNdx info inside Dihedron object\n    Dihedron.cst, rcst : np.float64p4][4]\n        dCoordSpace references inside Dihedron\n    self.a2da_map : [dihedraLen x 4]\n        AtomNdx's in dihedraNdx order\n    self.d2a_map : [dihedraLen x [4]]\n        AtomNdx's for each dihedron (reshaped a2da_map)\n    self.dFwd : bool\n        dihedron is not Reversed if True\n    self.a2d_map : AAsiz x [[dihedraNdx]\n        [atom ndx 0-3 of atom in dihedron]], maps atom indexes to\n        dihedra and atoms in them\n    self.dAtoms_needs_update : dihedraLen x bool\n        atoms in h1, h2 are current if False", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 834, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "build_edraArrays", "signature": "(self) -> None", "symbol_type": "function"}], "build_hsp": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/FastaIO.py", "line_number": 101, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.FastaIO", "name": "build_hsp", "signature": "()", "symbol_type": "function"}], "build_interaction_network": [{"docstring": "Build species interaction network from interaction matrix.\n\nCreates a network representation of species interactions (competition,\nmutualism, predation, etc.) from pairwise interaction strengths.\n\nArgs:\n    interaction_matrix: DataFrame with species as rows and columns,\n        values represent interaction strengths\n    interaction_type: Type of interactions ('cooccurrence', 'competition', 'mutualism')\n    threshold: Minimum interaction strength to include edge\n    \nReturns:\n    Dictionary with network representation:\n    - 'nodes': List of species identifiers\n    - 'edges': List of (species1, species2, weight) tuples\n    - 'adjacency_matrix': Adjacency matrix representation\n    - 'n_nodes': Number of species\n    - 'n_edges': Number of interactions", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/interactions.py", "line_number": 15, "module": "src.metainformant.ecology.interactions", "name": "build_interaction_network", "signature": "(interaction_matrix: pd.DataFrame, interaction_type: str = 'cooccurrence', threshold: float = 0.5) -> Dict[str, Any]", "symbol_type": "function"}], "build_kallisto_index": [{"docstring": "Build kallisto index from transcriptome FASTA file.\n\nArgs:\n    fasta_path: Path to transcriptome FASTA file\n    index_path: Path where index should be created\n    kmer_size: k-mer size for index (default: 31)\n    check_existing: If True, skip if index already exists\n    \nReturns:\n    True if index was built successfully or already exists, False otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/genome_prep.py", "line_number": 559, "module": "src.metainformant.rna.genome_prep", "name": "build_kallisto_index", "signature": "(fasta_path: Path, index_path: Path) -> bool", "symbol_type": "function"}], "build_peptides": [{"docstring": "Build and return a list of Polypeptide objects.\n\n:param entity: polypeptides are searched for in this object\n:type entity: L{Structure}, L{Model} or L{Chain}\n\n:param aa_only: if 1, the residue needs to be a standard AA\n:type aa_only: int", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Polypeptide.py", "line_number": 331, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Polypeptide", "name": "build_peptides", "signature": "(self, entity, aa_only = 1)", "symbol_type": "function"}], "build_postgres_url": [{"docstring": "Build PostgreSQL connection URL.\n\nArgs:\n    host: Database host\n    port: Database port\n    database: Database name\n    user: Username\n    password: Password\n\nReturns:\n    PostgreSQL connection URL", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/db.py", "line_number": 41, "module": "src.metainformant.core.db", "name": "build_postgres_url", "signature": "(host: str, port: int, database: str, user: str, password: str) -> str", "symbol_type": "function"}], "build_step_params": [{"docstring": "Construct a per-step parameters map from high-level species/tissue layout.\n\nThis function only builds parameter dictionaries; it does not validate the\nexact amalgkit flags. The values are converted to CLI flags by the wrapper.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/configs.py", "line_number": 64, "module": "src.metainformant.rna.configs", "name": "build_step_params", "signature": "(species: SpeciesProfile, layout: AmalgkitRunLayout) -> dict[str, AmalgkitParams]", "symbol_type": "function"}], "build_structure": [{"docstring": "Recursively build structure.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 374, "module": "src.metainformant.core.paths", "name": "build_structure", "signature": "(path: Path, rel_path: Path) -> dict[str, Any]", "symbol_type": "function"}], "build_subgraph": [{"docstring": "Walk down the Tree, building graphs, edges and nodes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 69, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "build_subgraph", "signature": "(graph, top)", "symbol_type": "function"}], "build_tree": [{"docstring": "Build tree from resampled sequences.\n\nArgs:\n    resampled: Dictionary of resampled sequences\n    \nReturns:\n    Phylogenetic tree", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/phylogeny.py", "line_number": 101, "module": "src.metainformant.dna.phylogeny", "name": "build_tree", "signature": "(resampled: Dict[str, str])", "symbol_type": "function"}, {"docstring": "Build tree from sequence data using specified method.\n\nArgs:\n    data: Dictionary of sequences\n    \nReturns:\n    Phylogenetic tree", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/phylogeny.py", "line_number": 171, "module": "src.metainformant.dna.phylogeny", "name": "build_tree", "signature": "(data: Dict[str, str])", "symbol_type": "function"}, {"docstring": "Caller to build the tree from an Alignment or MultipleSeqAlignment object.\n\nThis should be implemented in subclass.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/TreeConstruction.py", "line_number": 580, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.TreeConstruction", "name": "build_tree", "signature": "(self, msa)", "symbol_type": "function"}, {"docstring": "Construct and return a Tree, Neighbor Joining or UPGMA.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/TreeConstruction.py", "line_number": 695, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.TreeConstruction", "name": "build_tree", "signature": "(self, msa)", "symbol_type": "function"}, {"docstring": "Build the tree.\n\n:Parameters:\n    alignment : MultipleSeqAlignment\n        multiple sequence alignment to calculate parsimony tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/TreeConstruction.py", "line_number": 1270, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.TreeConstruction", "name": "build_tree", "signature": "(self, alignment)", "symbol_type": "function"}], "ca_depth": [{"docstring": "Return CA depth.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/ResidueDepth.py", "line_number": 578, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.ResidueDepth", "name": "ca_depth", "signature": "(residue, surface)", "symbol_type": "function"}], "cache_json": [{"docstring": "Cache an object as JSON with thread-safe access.\n\nArgs:\n    cache_dir: Cache directory\n    key: Cache key\n    obj: Object to cache\n    \nReturns:\n    Path to cached file", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/cache.py", "line_number": 35, "module": "src.metainformant.core.cache", "name": "cache_json", "signature": "(cache_dir: Path, key: str, obj: Any) -> Path", "symbol_type": "function"}], "cal_dn_ds": [{"docstring": "Calculate dN and dS of the given two sequences.\n\nAvailable methods:\n    - NG86  - `Nei and Gojobori (1986)`_ (PMID 3444411).\n    - LWL85 - `Li et al. (1985)`_ (PMID 3916709).\n    - ML    - `Goldman and Yang (1994)`_ (PMID 7968486).\n    - YN00  - `Yang and Nielsen (2000)`_ (PMID 10666704).\n\n.. _`Nei and Gojobori (1986)`: http://www.ncbi.nlm.nih.gov/pubmed/3444411\n.. _`Li et al. (1985)`: http://www.ncbi.nlm.nih.gov/pubmed/3916709\n.. _`Goldman and Yang (1994)`: http://mbe.oxfordjournals.org/content/11/5/725\n.. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\n\nArguments:\n - codon_seq1 - CodonSeq or or SeqRecord that contains a CodonSeq\n - codon_seq2 - CodonSeq or or SeqRecord that contains a CodonSeq\n - w  - transition/transversion ratio\n - cfreq - Current codon frequency vector can only be specified\n   when you are using ML method. Possible ways of\n   getting cfreq are: F1x4, F3x4 and F61.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 281, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "cal_dn_ds", "signature": "(codon_seq1, codon_seq2, method = 'NG86', codon_table = None, k = 1, cfreq = None)", "symbol_type": "function"}], "calcLevelSizes": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1505, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "calcLevelSizes", "signature": "(self, levelSizes, level)", "symbol_type": "function"}], "calc_2nd_ranges": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 446, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "calc_2nd_ranges", "signature": "(metadata)", "symbol_type": "function"}], "calc_affine_penalty": [{"docstring": "Calculate a penalty score for the gap function.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/pairwise2.py", "line_number": 1323, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.pairwise2", "name": "calc_affine_penalty", "signature": "(length, open, extend, penalize_extend_when_opening)", "symbol_type": "function"}], "calc_angle": [{"docstring": "Calculate angle method.\n\nCalculate the angle between 3 vectors\nrepresenting 3 connected points.\n\n:param v1, v2, v3: the tree points that define the angle\n:type v1, v2, v3: L{Vector}\n\n:return: angle\n:rtype: float", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 209, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "calc_angle", "signature": "(v1, v2, v3)", "symbol_type": "function"}], "calc_dihedral": [{"docstring": "Calculate dihedral angle method.\n\nCalculate the dihedral angle between 4 vectors\nrepresenting 4 connected points. The angle is in\n]-pi, pi].\n\n:param v1, v2, v3, v4: the four points that define the dihedral angle\n:type v1, v2, v3, v4: L{Vector}", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 226, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "calc_dihedral", "signature": "(v1, v2, v3, v4)", "symbol_type": "function"}], "calc_row": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 237, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "calc_row", "signature": "(clade)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 446, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "calc_row", "signature": "(clade)", "symbol_type": "function"}], "calculate": [{"docstring": "Calculate and return the CAI (float) for the provided DNA sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/__init__.py", "line_number": 640, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.__init__", "name": "calculate", "signature": "(self, sequence)", "symbol_type": "function"}, {"docstring": "Return the PWM score for a given sequence for all positions.\n\nNotes:\n - the sequence can only be a DNA sequence\n - the search is performed only on one strand\n - if the sequence and the motif have the same length, a single\n   number is returned\n - otherwise, the result is a one-dimensional numpy array", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 402, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "calculate", "signature": "(self, sequence)", "symbol_type": "function"}], "calculate_aa_composition": [{"docstring": "Calculate amino acid composition (frequencies) of a protein sequence.\n\nArgs:\n    seq: Protein sequence string\n    \nReturns:\n    Dictionary mapping amino acid codes to their frequencies (0.0 to 1.0)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/sequences.py", "line_number": 52, "module": "src.metainformant.protein.sequences", "name": "calculate_aa_composition", "signature": "(seq: str) -> Dict[str, float]", "symbol_type": "function"}], "calculate_accessibility_scores": [{"docstring": "Calculate accessibility scores for genomic regions.\n\nArgs:\n    signal: ATAC-seq signal DataFrame with 'chrom', 'start', 'end', 'value'\n    regions: Genomic regions DataFrame with 'chrom', 'start', 'end'\n    \nReturns:\n    DataFrame with regions and their accessibility scores", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/atac.py", "line_number": 112, "module": "src.metainformant.epigenome.atac", "name": "calculate_accessibility_scores", "signature": "(signal: pd.DataFrame, regions: pd.DataFrame) -> pd.DataFrame", "symbol_type": "function"}], "calculate_alignment_identity": [{"docstring": "Calculate percent identity of an alignment.\n\nArgs:\n    alignment: AlignmentResult from global_align or local_align\n\nReturns:\n    Percent identity (0-100)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/alignment.py", "line_number": 97, "module": "src.metainformant.dna.alignment", "name": "calculate_alignment_identity", "signature": "(alignment: AlignmentResult) -> float", "symbol_type": "function"}], "calculate_at_skew": [{"docstring": "Calculate AT skew: (A - T) / (A + T).\n\nArgs:\n    seq: DNA sequence to analyze\n    \nReturns:\n    AT skew value (-1 to 1)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 299, "module": "src.metainformant.dna.sequences", "name": "calculate_at_skew", "signature": "(seq: str) -> float", "symbol_type": "function"}], "calculate_codon_usage": [{"docstring": "Calculate codon usage frequencies.\n\nArgs:\n    seq: DNA sequence (must be divisible by 3)\n    \nReturns:\n    Dictionary mapping codons to their frequencies", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 379, "module": "src.metainformant.dna.sequences", "name": "calculate_codon_usage", "signature": "(seq: str) -> dict[str, float]", "symbol_type": "function"}], "calculate_complexity_metrics": [{"docstring": "Calculate sequence complexity metrics.\n\nArgs:\n    sequences: List of sequences to analyze\n\nReturns:\n    Dict containing complexity metrics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/metrics.py", "line_number": 166, "module": "src.metainformant.quality.metrics", "name": "calculate_complexity_metrics", "signature": "(sequences: List[str]) -> Dict[str, float]", "symbol_type": "function"}], "calculate_confidence_intervals": [{"docstring": "Calculate confidence intervals for population genetics statistics.\n\nComputes confidence intervals for statistics like \u03c0, \u03b8, Fst using\nnormal approximation or bootstrap methods.\n\nArgs:\n    statistics: Dictionary of statistic names to values\n    data: Optional raw data for bootstrap method\n    method: Method for CI calculation (\"normal\" or \"bootstrap\")\n    confidence_level: Confidence level (e.g., 0.95)\n\nReturns:\n    Dictionary mapping statistic names to CI dictionaries\n    \nExamples:\n    >>> stats = {\"pi\": 0.01, \"theta\": 0.01}\n    >>> result = calculate_confidence_intervals(stats)\n    >>> \"pi\" in result\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen_stats.py", "line_number": 441, "module": "src.metainformant.math.popgen_stats", "name": "calculate_confidence_intervals", "signature": "(statistics: dict[str, float], data: Sequence[Sequence[float]] | None = None, method: str = 'normal', confidence_level: float = 0.95) -> dict[str, dict[str, float]]", "symbol_type": "function"}], "calculate_consensus": [{"docstring": "Return the consensus sequence (as a string) for the given parameters.\n\nThis function largely follows the conventions of the EMBOSS `cons` tool.\n\nArguments:\n - substitution_matrix - the scoring matrix used when comparing\n   sequences. By default, it is None, in which case we simply count the\n   frequency of each letter.\n   Instead of the default value, you can use the substitution matrices\n   available in Bio.Align.substitution_matrices. Common choices are\n   BLOSUM62 (also known as EBLOSUM62) for protein, and NUC.4.4 (also\n   known as EDNAFULL) for nucleotides. NOTE: This has not yet been\n   implemented.\n - plurality           - threshold value for the number of positive\n   matches, divided by the total count in a column, required to reach\n   consensus. If substitution_matrix is None, then this argument must\n   be None, and is ignored; a ValueError is raised otherwise. If\n   substitution_matrix is not None, then the default value of the\n   plurality is 0.5.\n - identity            - number of identities, divided by the total\n   count in a column, required to define a consensus value. If the\n   number of identities is less than identity * total count in a column,\n   then the undefined character ('N' for nucleotides and 'X' for amino\n   acid sequences) is used in the consensus sequence. If identity is\n   1.0, then only columns of identical letters contribute to the\n   consensus. Default value is zero.\n - setcase             - threshold for the positive matches, divided by\n   the total count in a column, above which the consensus is in\n   upper-case and below which the consensus is in lower-case. By\n   default, this is equal to 0.5.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 218, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "calculate_consensus", "signature": "(self, substitution_matrix = None, plurality = None, identity = 0, setcase = None)", "symbol_type": "function"}], "calculate_cooccurrence_statistics": [{"docstring": "Calculate event co-occurrence statistics.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/generate_statistical_summary.py", "line_number": 122, "module": "scripts.life_events.generate_statistical_summary", "name": "calculate_cooccurrence_statistics", "signature": "(sequences: List[EventSequence]) -> Dict[str, Any]", "symbol_type": "function"}], "calculate_coverage_metrics": [{"docstring": "Calculate coverage-related quality metrics.\n\nArgs:\n    coverage_values: List of coverage values\n    target_coverage: Expected target coverage\n\nReturns:\n    Dict containing coverage quality metrics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/metrics.py", "line_number": 207, "module": "src.metainformant.quality.metrics", "name": "calculate_coverage_metrics", "signature": "(coverage_values: List[float], target_coverage: float = 30.0) -> Dict[str, float]", "symbol_type": "function"}], "calculate_dn_ds": [{"docstring": "Calculate dN and dS of the given two sequences.\n\nAvailable methods:\n    - NG86  - `Nei and Gojobori (1986)`_ (PMID 3444411).\n    - LWL85 - `Li et al. (1985)`_ (PMID 3916709).\n    - ML    - `Goldman and Yang (1994)`_ (PMID 7968486).\n    - YN00  - `Yang and Nielsen (2000)`_ (PMID 10666704).\n\n.. _`Nei and Gojobori (1986)`: http://www.ncbi.nlm.nih.gov/pubmed/3444411\n.. _`Li et al. (1985)`: http://www.ncbi.nlm.nih.gov/pubmed/3916709\n.. _`Goldman and Yang (1994)`: http://mbe.oxfordjournals.org/content/11/5/725\n.. _`Yang and Nielsen (2000)`: https://doi.org/10.1093/oxfordjournals.molbev.a026236\n\nArguments:\n - k  - transition/transversion rate ratio\n - cfreq - Current codon frequency vector can only be specified\n   when you are using ML method. Possible ways of\n   getting cfreq are: F1x4, F3x4 and F61.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/analysis.py", "line_number": 27, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.analysis", "name": "calculate_dn_ds", "signature": "(alignment, method = 'NG86', codon_table = None, k = 1, cfreq = None)", "symbol_type": "function"}], "calculate_dn_ds_matrix": [{"docstring": "Calculate dN and dS pairwise for the multiple alignment, and return as matrices.\n\nArgument:\n - method       - Available methods include NG86, LWL85, YN00 and ML.\n - codon_table  - Codon table to use for forward translation.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/analysis.py", "line_number": 1004, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.analysis", "name": "calculate_dn_ds_matrix", "signature": "(alignment, method = 'NG86', codon_table = None)", "symbol_type": "function"}], "calculate_duplication_metrics": [{"docstring": "Calculate duplication-related quality metrics.\n\nArgs:\n    duplication_levels: Dict mapping duplication level to count\n\nReturns:\n    Dict containing duplication quality metrics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/metrics.py", "line_number": 128, "module": "src.metainformant.quality.metrics", "name": "calculate_duplication_metrics", "signature": "(duplication_levels: Dict[int, int]) -> Dict[str, float]", "symbol_type": "function"}], "calculate_gc": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 242, "module": "tests.test_dna_comprehensive", "name": "calculate_gc", "signature": "(s)", "symbol_type": "function"}], "calculate_gc_content": [{"docstring": "Calculate GC content directly.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 30, "module": "tests.test_dna_comprehensive", "name": "calculate_gc_content", "signature": "(seq: str) -> float", "symbol_type": "function"}], "calculate_gc_metrics": [{"docstring": "Calculate GC content related quality metrics.\n\nArgs:\n    gc_content: List of GC content percentages per sequence\n\nReturns:\n    Dict containing GC-related quality metrics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/metrics.py", "line_number": 52, "module": "src.metainformant.quality.metrics", "name": "calculate_gc_metrics", "signature": "(gc_content: List[float]) -> Dict[str, float]", "symbol_type": "function"}], "calculate_gc_skew": [{"docstring": "Calculate GC skew: (G - C) / (G + C).\n\nArgs:\n    seq: DNA sequence to analyze\n    \nReturns:\n    GC skew value (-1 to 1)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 277, "module": "src.metainformant.dna.sequences", "name": "calculate_gc_skew", "signature": "(seq: str) -> float", "symbol_type": "function"}], "calculate_interaction_strength": [{"docstring": "Calculate interaction strength between two species.\n\nMeasures the strength of interaction (positive or negative) between\ntwo species based on their abundance patterns across sites.\n\nArgs:\n    abundance1: Abundance values for species 1 across sites\n    abundance2: Abundance values for species 2 across sites\n    method: Method for calculating strength ('correlation', 'mutual_information')\n    \nReturns:\n    Interaction strength value (positive = positive interaction, negative = negative interaction)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/interactions.py", "line_number": 79, "module": "src.metainformant.ecology.interactions", "name": "calculate_interaction_strength", "signature": "(abundance1: List[float], abundance2: List[float], method: str = 'correlation') -> float", "symbol_type": "function"}], "calculate_length_metrics": [{"docstring": "Calculate sequence length related quality metrics.\n\nArgs:\n    sequence_lengths: List of sequence lengths\n\nReturns:\n    Dict containing length-related quality metrics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/metrics.py", "line_number": 89, "module": "src.metainformant.quality.metrics", "name": "calculate_length_metrics", "signature": "(sequence_lengths: List[int]) -> Dict[str, float]", "symbol_type": "function"}], "calculate_melting_temperature": [{"docstring": "Calculate DNA melting temperature.\n\nArgs:\n    seq: DNA sequence\n    method: Method to use ('wallace' or 'enhanced')\n    \nReturns:\n    Melting temperature in Celsius", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 346, "module": "src.metainformant.dna.sequences", "name": "calculate_melting_temperature", "signature": "(seq: str, method: str = 'wallace') -> float", "symbol_type": "function"}], "calculate_pseudocounts": [{"docstring": "Calculate pseudocounts.\n\nComputes the root square of the total number of sequences multiplied by\nthe background nucleotide.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/jaspar/__init__.py", "line_number": 325, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.jaspar.__init__", "name": "calculate_pseudocounts", "signature": "(motif)", "symbol_type": "function"}], "calculate_qc_metrics": [{"docstring": "Calculate quality control metrics for single-cell data.\n\nComputes standard QC metrics including:\n- Number of genes per cell (n_genes)\n- Total UMI/read counts per cell (total_counts)\n- Percentage of mitochondrial gene expression (pct_mt)\n- Percentage of ribosomal gene expression (pct_ribo)\n- Number of cells expressing each gene (n_cells)\n- Mean expression per gene (mean_expression)\n\nArgs:\n    data: SingleCellData object\n\nReturns:\n    Updated SingleCellData with QC metrics in obs and var", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/preprocessing.py", "line_number": 197, "module": "src.metainformant.singlecell.preprocessing", "name": "calculate_qc_metrics", "signature": "(data: SingleCellData) -> SingleCellData", "symbol_type": "function"}], "calculate_quality_metrics": [{"docstring": "Calculate comprehensive quality metrics from per-position quality scores.\n\nArgs:\n    quality_scores: List of lists containing quality scores per position\n\nReturns:\n    Dict containing various quality metrics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/metrics.py", "line_number": 11, "module": "src.metainformant.quality.metrics", "name": "calculate_quality_metrics", "signature": "(quality_scores: List[List[int]]) -> Dict[str, float]", "symbol_type": "function"}], "calculate_reductions": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1348, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "calculate_reductions", "signature": "(cls, aveSize)", "symbol_type": "function"}], "calculate_sequence_complexity": [{"docstring": "Calculate sequence complexity based on k-mer diversity.\n\nArgs:\n    seq: DNA sequence to analyze\n\nReturns:\n    Complexity score (0-1, where 1 is maximum diversity)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 172, "module": "src.metainformant.dna.sequences", "name": "calculate_sequence_complexity", "signature": "(seq: str) -> float", "symbol_type": "function"}], "calculate_sequence_entropy": [{"docstring": "Calculate Shannon entropy of k-mer frequencies.\n\nArgs:\n    seq: DNA sequence to analyze\n    k: K-mer size for entropy calculation\n\nReturns:\n    Shannon entropy value", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 221, "module": "src.metainformant.dna.sequences", "name": "calculate_sequence_entropy", "signature": "(seq: str, k: int = 1) -> float", "symbol_type": "function"}], "calculate_sequence_statistics": [{"docstring": "Calculate comprehensive sequence statistics.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/generate_statistical_summary.py", "line_number": 29, "module": "scripts.life_events.generate_statistical_summary", "name": "calculate_sequence_statistics", "signature": "(sequences: List[EventSequence]) -> Dict[str, Any]", "symbol_type": "function"}], "calculate_summary_statistics": [{"docstring": "Calculate comprehensive population genetics summary statistics.\n\nThis function computes multiple population genetics statistics in a single\ncall, providing a convenient way to get a complete overview of genetic\ndiversity and structure.\n\nArgs:\n    sequences: Optional sequence of DNA sequences (strings). If provided,\n        calculates sequence-based statistics (\u03c0, S, \u03b8_W, Tajima's D).\n    genotype_matrix: Optional genotype matrix (individuals \u00d7 sites) with\n        values 0/1. If provided, calculates allele frequency and heterozygosity\n        statistics.\n\nReturns:\n    Dictionary containing:\n    - nucleotide_diversity: Average pairwise nucleotide differences per site (\u03c0)\n    - segregating_sites: Number of polymorphic sites\n    - wattersons_theta: Watterson's theta per site\n    - tajimas_d: Tajima's D statistic (simplified)\n    - allele_frequencies: List of allele frequencies per site (if genotype_matrix provided)\n    - observed_heterozygosity: Proportion of heterozygous individuals (if genotype_matrix provided)\n    - sample_size: Number of sequences/individuals\n    - sequence_length: Length of sequences (if sequences provided)\n\nExamples:\n    >>> seqs = [\"AAAA\", \"AAAT\", \"AATT\", \"ATTT\"]\n    >>> stats = calculate_summary_statistics(sequences=seqs)\n    >>> stats[\"nucleotide_diversity\"]\n    0.5...\n    >>> stats[\"segregating_sites\"]\n    3\n    \n    >>> genotypes = [[0, 1, 0], [0, 1, 1], [1, 0, 1]]\n    >>> stats = calculate_summary_statistics(genotype_matrix=genotypes)\n    >>> stats[\"allele_frequencies\"]\n    [0.333..., 0.666..., 0.666...]", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_analysis.py", "line_number": 19, "module": "src.metainformant.dna.population_analysis", "name": "calculate_summary_statistics", "signature": "(sequences: Sequence[str] | None = None, genotype_matrix: Sequence[Sequence[int]] | None = None) -> dict[str, Any]", "symbol_type": "function"}], "calculate_temporal_statistics": [{"docstring": "Calculate temporal pattern statistics.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/generate_statistical_summary.py", "line_number": 78, "module": "scripts.life_events.generate_statistical_summary", "name": "calculate_temporal_statistics", "signature": "(sequences: List[EventSequence]) -> Dict[str, Any]", "symbol_type": "function"}], "calculate_translation_efficiency": [{"docstring": "Calculate translation efficiency from RNA and protein data.\n\nTranslation efficiency measures how efficiently mRNA is translated into protein.\nCommon metrics include protein/mRNA ratio or correlation-based measures.\n\nArgs:\n    rna_expression: DataFrame with samples as rows and genes as columns (mRNA levels)\n    protein_abundance: DataFrame with samples as rows and proteins as columns\n    method: Method for calculating efficiency ('ratio', 'correlation', 'slope')\n    \nReturns:\n    DataFrame with translation efficiency metrics:\n    - 'gene_id': Gene/protein identifier\n    - 'efficiency': Translation efficiency value\n    - 'method': Method used", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/protein_integration.py", "line_number": 16, "module": "src.metainformant.rna.protein_integration", "name": "calculate_translation_efficiency", "signature": "(rna_expression: pd.DataFrame, protein_abundance: pd.DataFrame, method: str = 'correlation') -> pd.DataFrame", "symbol_type": "function"}], "call_api": [{"docstring": "Makes the HTTP request (synchronous) and returns deserialized data.\n\nTo make an async_req request, set the async_req parameter.\n\n:param resource_path: Path to method endpoint.\n:param method: Method to call.\n:param path_params: Path parameters in the url.\n:param query_params: Query parameters in the url.\n:param header_params: Header parameters to be\n    placed in the request header.\n:param body: Request body.\n:param post_params dict: Request post form parameters,\n    for `application/x-www-form-urlencoded`, `multipart/form-data`.\n:param auth_settings list: Auth Settings names for the request.\n:param response_type: For the response, a tuple containing:\n    valid classes\n    a list containing valid classes (for list schemas)\n    a dict containing a tuple of valid classes as the value\n    Example values:\n    (str,)\n    (Pet,)\n    (float, none_type)\n    ([int, none_type],)\n    ({str: (bool, str, int, float, date, datetime, str, none_type)},)\n:param files: key -> field name, value -> a list of open file\n    objects for `multipart/form-data`.\n:type files: dict\n:param async_req bool: execute request asynchronously\n:type async_req: bool, optional\n:param _return_http_data_only: response data without head status code\n                               and headers\n:type _return_http_data_only: bool, optional\n:param collection_formats: dict of collection formats for path, query,\n    header, and post parameters.\n:type collection_formats: dict, optional\n:param _preload_content: if False, the urllib3.HTTPResponse object will\n                         be returned without reading/decoding response\n                         data. Default is True.\n:type _preload_content: bool, optional\n:param _request_timeout: timeout setting for this request. If one\n                         number provided, it will be total request\n                         timeout. It can also be a pair (tuple) of\n                         (connection, read) timeouts.\n:param _check_type: boolean describing if the data back from the server\n    should have its type checked.\n:type _check_type: bool, optional\n:return:\n    If async_req parameter is True,\n    the request will be called asynchronously.\n    The method will return the request thread.\n    If parameter async_req is False or missing,\n    then the method will return the response directly.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 334, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "call_api", "signature": "(self, resource_path: str, method: str, path_params: typing.Optional[typing.Dict[str, typing.Any]] = None, query_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None, header_params: typing.Optional[typing.Dict[str, typing.Any]] = None, body: typing.Optional[typing.Any] = None, post_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None, files: typing.Optional[typing.Dict[str, typing.List[io.IOBase]]] = None, response_type: typing.Optional[typing.Tuple[typing.Any]] = None, auth_settings: typing.Optional[typing.List[str]] = None, async_req: typing.Optional[bool] = None, _return_http_data_only: typing.Optional[bool] = None, collection_formats: typing.Optional[typing.Dict[str, str]] = None, _preload_content: bool = True, _request_timeout: typing.Optional[typing.Union[int, float, typing.Tuple]] = None, _host: typing.Optional[str] = None, _check_type: typing.Optional[bool] = None)", "symbol_type": "function"}], "call_kallisto": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/quant.py", "line_number": 18, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.quant", "name": "call_kallisto", "signature": "(args, in_files, metadata, sra_stat, output_dir, index)", "symbol_type": "function"}], "call_peaks_simple": [{"docstring": "Call peaks from ChIP-seq signal using simple threshold-based method.\n\nIdentifies regions where signal exceeds threshold and merges nearby peaks.\n\nArgs:\n    signal: DataFrame with columns ['chrom', 'start', 'end', 'value']\n    chrom: Chromosome to analyze\n    threshold: Signal threshold for peak calling. If None, uses median + 2*MAD\n    min_width: Minimum peak width in base pairs\n    min_gap: Minimum gap between peaks in base pairs\n    \nReturns:\n    DataFrame with columns ['chrom', 'start', 'end', 'peak_id', 'max_value', 'sum_value']", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/chipseq.py", "line_number": 18, "module": "src.metainformant.epigenome.chipseq", "name": "call_peaks_simple", "signature": "(signal: pd.DataFrame, chrom: str, threshold: float | None = None, min_width: int = 100, min_gap: int = 200) -> pd.DataFrame", "symbol_type": "function"}], "call_variants": [{"docstring": "Call variants from aligned BAM files using bcftools.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/run_genome_scale_gwas.py", "line_number": 131, "module": "scripts.gwas.run_genome_scale_gwas", "name": "call_variants", "signature": "(bam_files: list[Path], reference: Path, output_vcf: Path, threads: int = 8)", "symbol_type": "function"}], "call_variants_bcftools": [{"docstring": "Call variants using bcftools mpileup and call.\n\nArgs:\n    bam_files: List of BAM/CRAM file paths\n    reference: Path to reference genome FASTA\n    output_vcf: Path to output VCF file\n    threads: Number of threads to use\n    region: Optional genomic region (chr:start-end)\n\nReturns:\n    Dictionary with calling metadata and result status", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/calling.py", "line_number": 43, "module": "src.metainformant.gwas.calling", "name": "call_variants_bcftools", "signature": "(bam_files: list[str | Path], reference: str | Path, output_vcf: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "call_variants_gatk": [{"docstring": "Call variants using GATK HaplotypeCaller.\n\nArgs:\n    bam_files: List of BAM file paths\n    reference: Path to reference genome FASTA\n    output_vcf: Path to output VCF file\n    intervals: Optional intervals file for targeted calling\n    threads: Number of threads to use\n\nReturns:\n    Dictionary with calling metadata and result status\n\nNote:\n    GATK requires the reference to have a .dict and .fai index.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/calling.py", "line_number": 167, "module": "src.metainformant.gwas.calling", "name": "call_variants_gatk", "signature": "(bam_files: list[str | Path], reference: str | Path, output_vcf: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "call_with_http_info": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 773, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "call_with_http_info", "signature": "(self, **kwargs)", "symbol_type": "function"}], "canonical_correlation": [{"docstring": "Perform Canonical Correlation Analysis between two omics layers.\n\nCCA finds linear combinations of features in each layer that are maximally\ncorrelated. Useful for identifying shared patterns between omics data types.\n\nArgs:\n    omics_data: Multi-omics data object with aligned samples\n    layer_pair: Tuple of (layer1_name, layer2_name) to analyze. Both layers\n        must exist in omics_data.layer_names\n    n_components: Number of canonical variate pairs to extract\n    regularization: Ridge regularization parameter for covariance matrices\n        (prevents singular matrix issues)\n        \nReturns:\n    Tuple containing:\n    - X_canonical: Canonical variates for first layer (n_samples, n_components)\n    - Y_canonical: Canonical variates for second layer (n_samples, n_components)\n    - X_weights: Feature weights for first layer (n_features_X, n_components)\n    - Y_weights: Feature weights for second layer (n_features_Y, n_components)\n    - correlations: Canonical correlations for each component pair\n    \nRaises:\n    ValueError: If layer names not found in omics_data\n    \nExamples:\n    >>> X_c, Y_c, X_w, Y_w, corr = canonical_correlation(\n    ...     omics_data, (\"genomics\", \"transcriptomics\"), n_components=5\n    ... )\n    >>> corr[0]  # First canonical correlation\n    0.85...", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 523, "module": "src.metainformant.multiomics.integration", "name": "canonical_correlation", "signature": "(omics_data: MultiOmicsData, layer_pair: Tuple[str, str], n_components: int = 10, regularization: float = 0.01) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]", "symbol_type": "function"}], "canvas_angle": [{"docstring": "Given base-pair position, return (angle, cosine, sin) (PRIVATE).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 1068, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "canvas_angle", "signature": "(self, base)", "symbol_type": "function"}], "canvas_location": [{"docstring": "Canvas location of a base on the genome.\n\nArguments:\n - base      The base number on the genome sequence\n\nReturns the x-coordinate and fragment number of a base on the\ngenome sequence, in the context of the current drawing setup", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 1445, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "canvas_location", "signature": "(self, base)", "symbol_type": "function"}], "catalyse": [{"docstring": "List the sequence fragments after cutting dna with enzyme.\n\nReturn a tuple of dna as will be produced by using RE to restrict the\ndna.\n\ndna must be a Bio.Seq.Seq instance or a Bio.Seq.MutableSeq instance.\n\nIf linear is False, the sequence is considered to be circular and the\noutput will be modified accordingly.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1037, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "catalyse", "signature": "(cls, dna, linear = True)", "symbol_type": "function"}, {"docstring": "List the sequence fragments after cutting dna with enzyme.\n\nReturn a tuple of dna as will be produced by using RE to restrict the\ndna.\n\ndna must be a Bio.Seq.Seq instance or a Bio.Seq.MutableSeq instance.\n\nIf linear is False, the sequence is considered to be circular and the\noutput will be modified accordingly.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1131, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "catalyse", "signature": "(cls, dna, linear = True)", "symbol_type": "function"}, {"docstring": "List the sequence fragments after cutting dna with enzyme.\n\nReturn a tuple of dna as will be produced by using RE to restrict the\ndna.\n\ndna must be a Bio.Seq.Seq instance or a Bio.Seq.MutableSeq instance.\n\nIf linear is False, the sequence is considered to be circular and the\noutput will be modified accordingly.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1261, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "catalyse", "signature": "(cls, dna, linear = True)", "symbol_type": "function"}, {"docstring": "List the sequence fragments after cutting dna with enzyme.\n\nReturn a tuple of dna as will be produced by using RE to restrict the\ndna.\n\ndna must be a Bio.Seq.Seq instance or a Bio.Seq.MutableSeq instance.\n\nIf linear is False, the sequence is considered to be circular and the\noutput will be modified accordingly.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1394, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "catalyse", "signature": "(cls, dna, linear = True)", "symbol_type": "function"}], "cdao_to_obo": [{"docstring": "Optionally converts a CDAO-prefixed URI into an OBO-prefixed URI.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NeXMLIO.py", "line_number": 48, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NeXMLIO", "name": "cdao_to_obo", "signature": "(s)", "symbol_type": "function"}], "cdf_chi2": [{"docstring": "Compute p-value, from distribution function and test statistics.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/chi2.py", "line_number": 21, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.chi2", "name": "cdf_chi2", "signature": "(df, stat)", "symbol_type": "function"}], "center_of_mass": [{"docstring": "Return the center of mass of the DisorderedAtom as a numpy array.\n\nAssumes all child atoms have the same mass (same element).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 540, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "center_of_mass", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the center of mass of the Entity as a numpy array.\n\nIf geometric is True, returns the center of geometry instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 352, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "center_of_mass", "signature": "(self, geometric = False)", "symbol_type": "function"}], "centrality_measures": [{"docstring": "Calculate multiple centrality measures for all nodes.\n\nComputes degree, closeness, betweenness, and eigenvector centralities\nfor each node in the network. These measures identify important/hub nodes.\n\nArgs:\n    network: Input biological network\n    \nReturns:\n    Dictionary mapping centrality type to nested dictionary of\n    node -> centrality_value. Centrality types:\n    - \"degree\": Normalized degree centrality (0 to 1)\n    - \"closeness\": Inverse of average shortest path distance\n    - \"betweenness\": Fraction of shortest paths passing through node\n    - \"eigenvector\": Importance based on connections to important nodes\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\", \"D\"])\n    >>> network.add_edge(\"A\", \"B\"); network.add_edge(\"A\", \"C\")\n    >>> network.add_edge(\"B\", \"D\")\n    >>> centralities = centrality_measures(network)\n    >>> centralities[\"degree\"][\"A\"]\n    0.666...", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 354, "module": "src.metainformant.networks.graph", "name": "centrality_measures", "signature": "(network: BiologicalNetwork) -> Dict[str, Dict[str, float]]", "symbol_type": "function"}], "centre": [{"docstring": "Return the centre of the Graphics object as an (x, y) tuple.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 644, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "centre", "signature": "(self)", "symbol_type": "function"}], "change": [{"docstring": "Change parameters of print output.\n\nIt is possible to change the width of the shell by setting\nself.ConsoleWidth to what you want.\nself.NameWidth refer to the maximal length of the enzyme name.\n\nChanging one of these parameters here might not give the results\nyou expect. In which case, you can settle back to a 80 columns shell\nor try to change self.Cmodulo and self.PrefWidth in PrintFormat until\nyou get it right.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2345, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "change", "signature": "(self, **what)", "symbol_type": "function"}], "change_extension": [{"docstring": "Change file extension.\n\nArgs:\n    path: Original file path\n    new_extension: New extension (with or without dot)\n\nReturns:\n    Path with new extension", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 75, "module": "src.metainformant.core.paths", "name": "change_extension", "signature": "(path: str, new_extension: str) -> Path", "symbol_type": "function"}], "change_keys_js_to_python": [{"docstring": "Converts from javascript_key keys in the input_dict to python_keys in\nthe output dict using the mapping in model_class.\nIf the input_dict contains a key which does not declared in the model_class,\nthe key is added to the output dict as is. The assumption is the model_class\nmay have undeclared properties (additionalProperties attribute in the OAS\ndocument).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1193, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "change_keys_js_to_python", "signature": "(input_dict, model_class)", "symbol_type": "function"}], "chao1_estimator": [{"docstring": "Estimate total species richness using Chao1 estimator.\n\nSest = Sobs + (f1^2)/(2*f2)\nwhere f1 = singletons, f2 = doubletons\n\nArgs:\n    abundances: Species abundance counts (integers)\n\nReturns:\n    Estimated total species richness", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/community.py", "line_number": 86, "module": "src.metainformant.ecology.community", "name": "chao1_estimator", "signature": "(abundances: Sequence[int]) -> float", "symbol_type": "function"}], "characterDataHandlerEscape": [{"docstring": "Handle character data by encoding it.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 859, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "characterDataHandlerEscape", "signature": "(self, content)", "symbol_type": "function"}], "characterDataHandlerRaw": [{"docstring": "Handle character data as-is (raw).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 855, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "characterDataHandlerRaw", "signature": "(self, content)", "symbol_type": "function"}], "characteristic": [{"docstring": "Return a list of the enzyme's characteristics as tuple.\n\nthe tuple contains the attributes:\n\n- fst5 -> first 5' cut ((current strand) or None\n- fst3 -> first 3' cut (complementary strand) or None\n- scd5 -> second 5' cut (current strand) or None\n- scd5 -> second 3' cut (complementary strand) or None\n- site -> recognition site.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 749, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "characteristic", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return a list of the enzyme's characteristics as tuple.\n\nThe tuple contains the attributes:\n\n- fst5 -> first 5' cut ((current strand) or None\n- fst3 -> first 3' cut (complementary strand) or None\n- scd5 -> second 5' cut (current strand) or None\n- scd5 -> second 3' cut (complementary strand) or None\n- site -> recognition site.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 828, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "characteristic", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return a list of the enzyme's characteristics as tuple.\n\nthe tuple contains the attributes:\n\n- fst5 -> first 5' cut ((current strand) or None\n- fst3 -> first 3' cut (complementary strand) or None\n- scd5 -> second 5' cut (current strand) or None\n- scd5 -> second 3' cut (complementary strand) or None\n- site -> recognition site.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 909, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "characteristic", "signature": "(cls)", "symbol_type": "function"}], "characters": [{"docstring": "Found some text.\n\nArguments:\n - ch -- characters read", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIXML.py", "line_number": 536, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIXML", "name": "characters", "signature": "(self, ch)", "symbol_type": "function"}, {"docstring": "Store the record content.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/ScanProsite.py", "line_number": 145, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.ScanProsite", "name": "characters", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": "Replace quotes and apostrophe.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlastIO/blast_xml.py", "line_number": 740, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlastIO.blast_xml", "name": "characters", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": "Handle character data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 424, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "characters", "signature": "(self, data)", "symbol_type": "function"}], "charge_at_pH": [{"docstring": "Calculate the charge of a protein at given pH.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/IsoelectricPoint.py", "line_number": 114, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.IsoelectricPoint", "name": "charge_at_pH", "signature": "(self, pH)", "symbol_type": "function"}, {"docstring": "Calculate the charge of a protein at given pH.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/ProtParam.py", "line_number": 320, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.ProtParam", "name": "charge_at_pH", "signature": "(self, pH)", "symbol_type": "function"}], "check_active_downloads": [{"docstring": "Check for samples currently being downloaded.\n\nReturns:\n    Set of sample IDs that are actively downloading", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/monitoring.py", "line_number": 295, "module": "src.metainformant.rna.monitoring", "name": "check_active_downloads", "signature": "() -> set[str]", "symbol_type": "function"}], "check_allowed_values": [{"docstring": "Raises an exception if the input_values are not allowed\n\nArgs:\n    allowed_values (dict): the allowed_values dict\n    input_variable_path (tuple): the path to the input variable\n    input_values (list/str/int/float/date/datetime): the values that we\n        are checking to see if they are in allowed_values", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 834, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "check_allowed_values", "signature": "(allowed_values, input_variable_path, input_values)", "symbol_type": "function"}], "check_amalgkit": [{"docstring": "Check if amalgkit is available and get version.\n\nReturns:\n    Tuple of (is_available: bool, message: str)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/environment.py", "line_number": 20, "module": "src.metainformant.rna.environment", "name": "check_amalgkit", "signature": "() -> tuple[bool, str]", "symbol_type": "function"}], "check_assembly_availability": [{"docstring": "Check the validity of genome accessions  # noqa: E501\n\nThe 'GET' version of check is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.check_assembly_availability(accessions, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    accessions ([str]): NCBI genome assembly accessions\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1AssemblyDatasetAvailability\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/genome_api.py", "line_number": 1073, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.genome_api", "name": "check_assembly_availability", "signature": "(self, accessions, **kwargs)", "symbol_type": "function"}], "check_assembly_availability_post": [{"docstring": "Check the validity of many genome accessions in a single request  # noqa: E501\n\nThe 'GET' version of check is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.check_assembly_availability_post(v1_assembly_dataset_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_assembly_dataset_request (V1AssemblyDatasetRequest):\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1AssemblyDatasetAvailability\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/genome_api.py", "line_number": 1148, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.genome_api", "name": "check_assembly_availability_post", "signature": "(self, v1_assembly_dataset_request, **kwargs)", "symbol_type": "function"}], "check_bcftools_available": [{"docstring": "Check if bcftools is available on PATH.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/calling.py", "line_number": 15, "module": "src.metainformant.gwas.calling", "name": "check_bcftools_available", "signature": "() -> bool", "symbol_type": "function"}], "check_block_entry": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 706, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "check_block_entry", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 706, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "check_block_entry", "signature": "(self)", "symbol_type": "function"}], "check_cli_available": [{"docstring": "Check if `amalgkit` is available on PATH.\n\nReturns a tuple: (is_available, help_or_version_text_or_error_message)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 140, "module": "src.metainformant.rna.amalgkit", "name": "check_cli_available", "signature": "() -> tuple[bool, str]", "symbol_type": "function"}], "check_code_example_executable": [{"docstring": "Check if a code example can be compiled/executed.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/triple_check_rna.py", "line_number": 101, "module": "scripts.triple_check_rna", "name": "check_code_example_executable", "signature": "(code: str, context: dict[str, Any] = None) -> tuple[bool, str | None]", "symbol_type": "function"}], "check_code_example_syntax": [{"docstring": "Check if a code example is syntactically valid.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/verify_rna.py", "line_number": 48, "module": "scripts.verify_rna", "name": "check_code_example_syntax", "signature": "(code: str, file_path: Path, line_num: int) -> list[str]", "symbol_type": "function"}], "check_config_dir": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 606, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "check_config_dir", "signature": "(dir_path, mode)", "symbol_type": "function"}], "check_data": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 30, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "check_data", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 30, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "check_data", "signature": "(self)", "symbol_type": "function"}], "check_dependencies": [{"docstring": "Check if required bioinformatics tools are available.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/run_genome_scale_gwas.py", "line_number": 39, "module": "scripts.gwas.run_genome_scale_gwas", "name": "check_dependencies", "signature": "()", "symbol_type": "function"}, {"docstring": "Check all required dependencies for RNA-seq workflows.\n\nReturns:\n    Dictionary mapping dependency name -> (is_available: bool, message: str)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/environment.py", "line_number": 162, "module": "src.metainformant.rna.environment", "name": "check_dependencies", "signature": "() -> dict[str, tuple[bool, str]]", "symbol_type": "function"}], "check_directive": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 683, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "check_directive", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 683, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "check_directive", "signature": "(self)", "symbol_type": "function"}], "check_directory": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/config.py", "line_number": 11, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.config", "name": "check_directory", "signature": "(args)", "symbol_type": "function"}], "check_disk_space": [{"docstring": "Check if sufficient disk space is available.\n\nArgs:\n    path: Path to check disk space for\n    min_free_gb: Minimum free space required in GB\n    min_free_percent: Minimum free space required as percentage\n    \nReturns:\n    Tuple of (is_sufficient: bool, message: str)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/disk.py", "line_number": 77, "module": "src.metainformant.core.disk", "name": "check_disk_space", "signature": "(path: Path, min_free_gb: float = 10.0, min_free_percent: float = 5.0) -> tuple[bool, str]", "symbol_type": "function"}], "check_doc_examples": [{"docstring": "Check code examples in documentation files.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/verify_rna_docs.py", "line_number": 79, "module": "scripts.verify_rna_docs", "name": "check_doc_examples", "signature": "(file_path: Path) -> list[str]", "symbol_type": "function"}, {"docstring": "Check code examples in documentation files.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/verify_rna.py", "line_number": 136, "module": "scripts.verify_rna", "name": "check_doc_examples", "signature": "(file_path: Path) -> list[str]", "symbol_type": "function"}], "check_doc_links": [{"docstring": "Check internal markdown links in documentation.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/verify_rna_docs.py", "line_number": 136, "module": "scripts.verify_rna_docs", "name": "check_doc_links", "signature": "(doc_file: Path) -> list[str]", "symbol_type": "function"}, {"docstring": "Check internal markdown links in documentation.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/verify_rna.py", "line_number": 76, "module": "scripts.verify_rna", "name": "check_doc_links", "signature": "(doc_file: Path) -> list[str]", "symbol_type": "function"}], "check_document_end": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 698, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "check_document_end", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 698, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "check_document_end", "signature": "(self)", "symbol_type": "function"}], "check_document_start": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 690, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "check_document_start", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 690, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "check_document_start", "signature": "(self)", "symbol_type": "function"}], "check_empty_document": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 430, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "check_empty_document", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 430, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "check_empty_document", "signature": "(self)", "symbol_type": "function"}], "check_empty_mapping": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 426, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "check_empty_mapping", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 426, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "check_empty_mapping", "signature": "(self)", "symbol_type": "function"}], "check_empty_sequence": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 422, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "check_empty_sequence", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 422, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "check_empty_sequence", "signature": "(self)", "symbol_type": "function"}], "check_environment": [{"docstring": "Check that all required tools are available.\n\nUses uv-based venv discovery to handle filesystem limitations.\n\nReturns:\n    Tuple of (success: bool, missing: list[str], warnings: list[str])", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/_setup_utils.py", "line_number": 299, "module": "scripts.rna._setup_utils", "name": "check_environment", "signature": "() -> tuple[bool, list[str], list[str]]", "symbol_type": "function"}], "check_environment_or_exit": [{"docstring": "Check environment and exit if critical dependencies are missing.\n\nArgs:\n    auto_setup: If True, automatically setup missing components", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/_setup_utils.py", "line_number": 361, "module": "scripts.rna._setup_utils", "name": "check_environment_or_exit", "signature": "(auto_setup: bool = True) -> None", "symbol_type": "function"}], "check_event": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 94, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "check_event", "signature": "(self, *choices)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 94, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "check_event", "signature": "(self, *choices)", "symbol_type": "function"}], "check_file_exists": [{"docstring": "Check if a file exists.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/verify_rna_docs.py", "line_number": 131, "module": "scripts.verify_rna_docs", "name": "check_file_exists", "signature": "(file_path: Path) -> bool", "symbol_type": "function"}], "check_fragment_exists": [{"docstring": "Check if a fragment anchor exists in a markdown file.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/verify_rna.py", "line_number": 29, "module": "scripts.verify_rna", "name": "check_fragment_exists", "signature": "(doc_file: Path, fragment: str) -> bool", "symbol_type": "function"}, {"docstring": "Check if fragment anchor exists in file.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/triple_check_rna.py", "line_number": 152, "module": "scripts.triple_check_rna", "name": "check_fragment_exists", "signature": "(file_path: Path, fragment: str) -> bool", "symbol_type": "function"}], "check_gatk_available": [{"docstring": "Check if GATK is available on PATH or as gatk command.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/calling.py", "line_number": 29, "module": "src.metainformant.gwas.calling", "name": "check_gatk_available", "signature": "() -> bool", "symbol_type": "function"}], "check_getfastq_dependency": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 282, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "check_getfastq_dependency", "signature": "(args)", "symbol_type": "function"}], "check_getfastq_outputs": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/sanity.py", "line_number": 40, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.sanity", "name": "check_getfastq_outputs", "signature": "(args, sra_ids, metadata, output_dir)", "symbol_type": "function"}], "check_imports_exist": [{"docstring": "Check if a module can be imported.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/verify_rna_docs.py", "line_number": 70, "module": "scripts.verify_rna_docs", "name": "check_imports_exist", "signature": "(module_name: str) -> bool", "symbol_type": "function"}], "check_in_path": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 390, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "check_in_path", "signature": "(v)", "symbol_type": "function"}], "check_kallisto": [{"docstring": "Check if kallisto is installed.\n\nReturns:\n    Tuple of (is_available: bool, message: str)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/environment.py", "line_number": 78, "module": "src.metainformant.rna.environment", "name": "check_kallisto", "signature": "() -> tuple[bool, str]", "symbol_type": "function"}], "check_kallisto_dependency": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/quant.py", "line_number": 72, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.quant", "name": "check_kallisto_dependency", "signature": "()", "symbol_type": "function"}], "check_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 711, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "check_key", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 711, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "check_key", "signature": "(self)", "symbol_type": "function"}], "check_layout_mismatch": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/quant.py", "line_number": 79, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.quant", "name": "check_layout_mismatch", "signature": "(sra_stat, output_dir)", "symbol_type": "function"}], "check_metadata_validity": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 732, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "check_metadata_validity", "signature": "(metadata)", "symbol_type": "function"}], "check_metainformant": [{"docstring": "Check if metainformant package is installed.\n\nReturns:\n    Tuple of (is_available: bool, message: str)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/environment.py", "line_number": 103, "module": "src.metainformant.rna.environment", "name": "check_metainformant", "signature": "() -> tuple[bool, str]", "symbol_type": "function"}], "check_method_signature_match": [{"docstring": "Check if method signature matches documentation.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/triple_check_rna.py", "line_number": 60, "module": "scripts.triple_check_rna", "name": "check_method_signature_match", "signature": "(func, docstring: str) -> list[str]", "symbol_type": "function"}], "check_module_docstrings": [{"docstring": "Check that all public functions/classes have docstrings.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/verify_rna_docs.py", "line_number": 28, "module": "scripts.verify_rna_docs", "name": "check_module_docstrings", "signature": "(module_path: Path, module_name: str) -> list[str]", "symbol_type": "function"}], "check_node": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/composer.py", "line_number": 16, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.composer", "name": "check_node", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/composer.py", "line_number": 16, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.composer", "name": "check_node", "signature": "(self)", "symbol_type": "function"}], "check_ortholog_parameter_compatibility": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 563, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "check_ortholog_parameter_compatibility", "signature": "(args)", "symbol_type": "function"}], "check_plain": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 731, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "check_plain", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 731, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "check_plain", "signature": "(self)", "symbol_type": "function"}], "check_printable": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/reader.py", "line_number": 138, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.reader", "name": "check_printable", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/reader.py", "line_number": 138, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.reader", "name": "check_printable", "signature": "(self, data)", "symbol_type": "function"}], "check_quant_index": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/sanity.py", "line_number": 92, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.sanity", "name": "check_quant_index", "signature": "(args, uni_species, output_dir)", "symbol_type": "function"}], "check_quant_output": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/sanity.py", "line_number": 150, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.sanity", "name": "check_quant_output", "signature": "(args, sra_ids, output_dir)", "symbol_type": "function"}], "check_resolver_prefix": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/resolver.py", "line_number": 120, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.resolver", "name": "check_resolver_prefix", "signature": "(self, depth, path, kind, current_node, current_index)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/resolver.py", "line_number": 120, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.resolver", "name": "check_resolver_prefix", "signature": "(self, depth, path, kind, current_node, current_index)", "symbol_type": "function"}], "check_rscript": [{"docstring": "Check if Rscript is available.\n\nReturns:\n    Tuple of (is_available: bool, message: str)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/environment.py", "line_number": 136, "module": "src.metainformant.rna.environment", "name": "check_rscript", "signature": "() -> tuple[bool, str]", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 538, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "check_rscript", "signature": "()", "symbol_type": "function"}], "check_script_syntax": [{"docstring": "Check that a script has valid Python syntax.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/verify_rna_docs.py", "line_number": 115, "module": "scripts.verify_rna_docs", "name": "check_script_syntax", "signature": "(script_path: Path) -> list[str]", "symbol_type": "function"}], "check_seqkit_dependency": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 632, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "check_seqkit_dependency", "signature": "()", "symbol_type": "function"}], "check_simple_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 437, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "check_simple_key", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 437, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "check_simple_key", "signature": "(self)", "symbol_type": "function"}], "check_sra_toolkit": [{"docstring": "Check if SRA Toolkit is installed.\n\nReturns:\n    Tuple of (is_available: bool, message: str)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/environment.py", "line_number": 50, "module": "src.metainformant.rna.environment", "name": "check_sra_toolkit", "signature": "() -> tuple[bool, str]", "symbol_type": "function"}], "check_sra_tools_available": [{"docstring": "Check if SRA Toolkit is available.\n\nReturns:\n    True if fastq-dump or fasterq-dump is available", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/sra_download.py", "line_number": 15, "module": "src.metainformant.gwas.sra_download", "name": "check_sra_tools_available", "signature": "() -> bool", "symbol_type": "function"}], "check_state_key": [{"docstring": "Block special attributes/methods from being set in a newly created\nobject, to prevent user-controlled methods from being called during\ndeserialization", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 34, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "check_state_key", "signature": "(self, key)", "symbol_type": "function"}, {"docstring": "Block special attributes/methods from being set in a newly created\nobject, to prevent user-controlled methods from being called during\ndeserialization", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 34, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "check_state_key", "signature": "(self, key)", "symbol_type": "function"}], "check_step_dependencies": [{"docstring": "Return external CLI availability for a given step.\n\nSteps and their checks:\n- metadata, integrate, config, select, merge, sanity: rely on `amalgkit` which\n  is checked separately in the workflow preflight; no extra hard deps here.\n- getfastq: require at least one of parallel-fastq-dump or sra-tools utilities\n  (prefetch/fastq-dump/fasterq-dump).\n- quant: require at least one of salmon or kallisto.\n- cstmm/curate/csca: require R (Rscript available) for plotting/stats.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/deps.py", "line_number": 49, "module": "src.metainformant.rna.deps", "name": "check_step_dependencies", "signature": "(step: str) -> StepDependencyStatus", "symbol_type": "function"}], "check_token": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 113, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "check_token", "signature": "(self, *choices)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 113, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "check_token", "signature": "(self, *choices)", "symbol_type": "function"}], "check_validations": [{"docstring": "Raises an exception if the input_values are invalid\n\nArgs:\n    validations (dict): the validation dictionary.\n    input_variable_path (tuple): the path to the input variable.\n    input_values (list/str/int/float/date/datetime): the values that we\n        are checking.\n    configuration (Configuration): the configuration class.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 897, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "check_validations", "signature": "(validations, input_variable_path, input_values, configuration = None)", "symbol_type": "function"}], "check_value": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 721, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "check_value", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 721, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "check_value", "signature": "(self)", "symbol_type": "function"}], "check_virtual_env": [{"docstring": "Check if running inside a virtual environment.\n\nReturns:\n    Tuple of (is_in_venv: bool, message: str)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/environment.py", "line_number": 117, "module": "src.metainformant.rna.environment", "name": "check_virtual_env", "signature": "() -> tuple[bool, str]", "symbol_type": "function"}], "check_virtual_environment": [{"docstring": "Check if virtual environment exists and is properly set up.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/validate_all_species_workflow.py", "line_number": 24, "module": "scripts.validate_all_species_workflow", "name": "check_virtual_environment", "signature": "() -> Tuple[bool, str]", "symbol_type": "function"}], "check_workflow_continuation": [{"docstring": "Test that workflow can continue from checkpoints.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/validate_all_species_workflow.py", "line_number": 166, "module": "scripts.validate_all_species_workflow", "name": "check_workflow_continuation", "signature": "(config_path: Path) -> Tuple[bool, str]", "symbol_type": "function"}], "check_workflow_progress": [{"docstring": "Get workflow progress summary for a species.\n\nArgs:\n    config_path: Path to species workflow config file\n    \nReturns:\n    Dictionary with progress information:\n    - quantified: int\n    - total: int\n    - percentage: float\n    - remaining: int\n    - downloading: int (number of samples currently downloading)\n    - has_files: int (number of samples with downloaded files but not quantified)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/monitoring.py", "line_number": 351, "module": "src.metainformant.rna.monitoring", "name": "check_workflow_progress", "signature": "(config_path: Path) -> dict[str, Any]", "symbol_type": "function"}], "check_workflow_status": [{"docstring": "Check workflow status for a species.\n\nArgs:\n    config_path: Path to species workflow config file\n    detailed: If True, include detailed sample categories\n\nReturns:\n    Dictionary with status information", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/orchestration.py", "line_number": 420, "module": "src.metainformant.rna.orchestration", "name": "check_workflow_status", "signature": "(config_path: Path, detailed: bool = False) -> dict[str, Any]", "symbol_type": "function"}], "chem_correction": [{"docstring": "Correct a given Tm for DMSO and formamide.\n\nPlease note that these corrections are +/- rough approximations.\n\nArguments:\n - melting_temp: Melting temperature.\n - DMSO: Percent DMSO.\n - fmd: Formamide concentration in %(fmdmethod=1) or molar (fmdmethod=2).\n - DMSOfactor: How much should Tm decreases per percent DMSO. Default=0.65\n   (von Ahsen et al. 2001). Other published values are 0.5, 0.6 and 0.675.\n - fmdfactor: How much should Tm decrease per percent formamide.\n   Default=0.65. Several papers report factors between 0.6 and 0.72.\n - fmdmethod:\n\n     1. Tm = Tm - factor(%formamide) (Default)\n     2. Tm = Tm + (0.453(f(GC)) - 2.88) x [formamide]\n\n   Here f(GC) is fraction of GC.\n   Note (again) that in fmdmethod=1 formamide concentration is given in %,\n   while in fmdmethod=2 it is given in molar.\n - GC: GC content in percent.\n\nExamples:\n    >>> from Bio.SeqUtils import MeltingTemp as mt\n    >>> mt.chem_correction(70)\n    70\n    >>> print('%0.2f' % mt.chem_correction(70, DMSO=3))\n    67.75\n    >>> print('%0.2f' % mt.chem_correction(70, fmd=5))\n    66.75\n    >>> print('%0.2f' % mt.chem_correction(70, fmdmethod=2, fmd=1.25,\n    ...                                    GC=50))\n    66.68", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/MeltingTemp.py", "line_number": 592, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.MeltingTemp", "name": "chem_correction", "signature": "(melting_temp, DMSO = 0, fmd = 0, DMSOfactor = 0.75, fmdfactor = 0.65, fmdmethod = 1, GC = None)", "symbol_type": "function"}], "child_edges": [{"docstring": "Return a list of (child, label) pairs for parent.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/Graph.py", "line_number": 80, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.Graph", "name": "child_edges", "signature": "(self, parent)", "symbol_type": "function"}, {"docstring": "Return a list of (child, label) pairs for parent.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/MultiGraph.py", "line_number": 75, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.MultiGraph", "name": "child_edges", "signature": "(self, parent)", "symbol_type": "function"}], "children": [{"docstring": "Return a list of unique children for parent.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/Graph.py", "line_number": 89, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.Graph", "name": "children", "signature": "(self, parent)", "symbol_type": "function"}, {"docstring": "Return a list of unique children for parent.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/MultiGraph.py", "line_number": 81, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.MultiGraph", "name": "children", "signature": "(self, parent)", "symbol_type": "function"}], "choose_scalar_style": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 494, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "choose_scalar_style", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 494, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "choose_scalar_style", "signature": "(self)", "symbol_type": "function"}], "chromosome_ideogram": [{"docstring": "Chromosome ideogram with significant loci marked.\n\nShows chromosome structure with bands indicating significant variants.\nUseful for visualizing distribution of associations across genome.\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    significance_threshold: Significance threshold\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_genome.py", "line_number": 335, "module": "src.metainformant.gwas.visualization_genome", "name": "chromosome_ideogram", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Create a chromosome ideogram with marked positions.\n\nArgs:\n    chromosomes: List of chromosome names\n    positions: List of positions on chromosomes\n    values: Values to visualize (e.g., p-values, effect sizes)\n    threshold: Optional threshold for highlighting\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import chromosome_ideogram\n    >>> ax = chromosome_ideogram(\n    ...     ['chr1', 'chr2'],\n    ...     [1000000, 2000000],\n    ...     [5.0, 6.0],\n    ...     threshold=5.0\n    ... )", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/genomics.py", "line_number": 352, "module": "src.metainformant.visualization.genomics", "name": "chromosome_ideogram", "signature": "(chromosomes: list[str], positions: list[int], values: list[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "circular_manhattan_plot": [{"docstring": "Circular Manhattan plot for genome-wide view.\n\nArranges chromosomes in a circle with -log10(p) as radial distance.\nUseful for visualizing genome-wide patterns and cross-chromosome effects.\n\nArgs:\n    results: Association results or path to file\n    output_path: Output path\n    significance_threshold: Significance threshold\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_genome.py", "line_number": 214, "module": "src.metainformant.gwas.visualization_genome", "name": "circular_manhattan_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Create a circular Manhattan plot for genome-wide visualization.\n\nArgs:\n    data: DataFrame with genomic positions and p-values\n    x_col: Column name for x-axis (genomic position)\n    y_col: Column name for y-axis (usually -log10(p-value))\n    chromosome_col: Column name for chromosome information\n    p_threshold: P-value threshold for significance\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import circular_manhattan_plot\n    >>> import pandas as pd\n    >>> data = pd.DataFrame({\n    ...     'position': [1000, 2000, 3000],\n    ...     'pvalue': [1e-6, 1e-9, 0.01],\n    ...     'chromosome': ['chr1', 'chr1', 'chr2']\n    ... })\n    >>> data['neg_log10_p'] = -np.log10(data['pvalue'])\n    >>> ax = circular_manhattan_plot(data, 'position', 'neg_log10_p', 'chromosome')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/genomics.py", "line_number": 267, "module": "src.metainformant.visualization.genomics", "name": "circular_manhattan_plot", "signature": "(data: pd.DataFrame, x_col: str, y_col: str, chromosome_col: str = 'chromosome', **kwargs) -> plt.Axes", "symbol_type": "function"}], "circular_network_plot": [{"docstring": "Create a circular network plot.\n\nArgs:\n    nodes: List of node names\n    edges: List of (source, target) edge tuples\n    node_sizes: Optional list of node sizes\n    node_colors: Optional list of node colors\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import circular_network_plot\n    >>> nodes = ['A', 'B', 'C', 'D']\n    >>> edges = [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'A')]\n    >>> ax = circular_network_plot(nodes, edges)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/networks.py", "line_number": 84, "module": "src.metainformant.visualization.networks", "name": "circular_network_plot", "signature": "(nodes: list[str], edges: list[tuple[str, str]], **kwargs) -> plt.Axes", "symbol_type": "function"}], "circular_tree_plot": [{"docstring": "Plot a phylogenetic tree in circular layout.\n\nArgs:\n    tree: Biopython Phylo tree object\n    ax: Matplotlib axes (creates new if None, with polar projection)\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import circular_tree_plot\n    >>> from Bio import Phylo\n    >>> tree = Phylo.read(\"tree.nwk\", \"newick\")\n    >>> ax = circular_tree_plot(tree)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/trees.py", "line_number": 51, "module": "src.metainformant.visualization.trees", "name": "circular_tree_plot", "signature": "(tree: Any) -> plt.Axes", "symbol_type": "function"}], "circularise": [{"docstring": "Circularise sequence in place.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 191, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "circularise", "signature": "(self)", "symbol_type": "function"}], "clade": [{"docstring": "Return first clade in this tree (not itself).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 793, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "clade", "signature": "(self)", "symbol_type": "function"}], "clade_relation": [{"docstring": "Create clade relationship object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 523, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "clade_relation", "signature": "(self, elem)", "symbol_type": "function"}], "clade_splits": [{"docstring": "Extract clade splits as frozensets of leaf names.\n\nArgs:\n    tree: Phylogenetic tree\n    \nReturns:\n    Set of frozensets, each representing a clade (non-trivial splits only)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/phylogeny.py", "line_number": 182, "module": "src.metainformant.dna.phylogeny", "name": "clade_splits", "signature": "(tree) -> set[frozenset[str]]", "symbol_type": "function"}], "clean": [{"docstring": "Use this to avoid getting newlines in the output.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/Interfaces.py", "line_number": 101, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.Interfaces", "name": "clean", "signature": "(self, text)", "symbol_type": "function"}, {"docstring": "Use this to avoid getting newlines in the output.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/Interfaces.py", "line_number": 207, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.Interfaces", "name": "clean", "signature": "(self, text: str) -> str", "symbol_type": "function"}], "clean_dict": [{"docstring": "Remove None-valued items from a dictionary.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 1221, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "clean_dict", "signature": "(dct)", "symbol_type": "function"}], "clean_environment": [{"docstring": "Provide clean environment for tests by clearing relevant env vars.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 87, "module": "tests.conftest", "name": "clean_environment", "signature": "(monkeypatch) -> Iterator[None]", "symbol_type": "function"}], "clean_sequence_id": [{"docstring": "Clean sequence ID to extract main identifier.\n\nArgs:\n    sequence_id: Raw sequence ID (e.g., from FASTA header)\n\nReturns:\n    Cleaned sequence identifier", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/text.py", "line_number": 90, "module": "src.metainformant.core.text", "name": "clean_sequence_id", "signature": "(sequence_id: str) -> str", "symbol_type": "function"}], "clean_value": [{"docstring": "Clean the specified value and return it.\n\nIf the value is not specified to be dealt with, the original value\nwill be returned.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/utils.py", "line_number": 43, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.utils", "name": "clean_value", "signature": "(self, key_name, value)", "symbol_type": "function"}], "clean_whitespace": [{"docstring": "Clean excessive whitespace from text.\n\nArgs:\n    text: Text to clean\n\nReturns:\n    Text with normalized whitespace", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/text.py", "line_number": 31, "module": "src.metainformant.core.text", "name": "clean_whitespace", "signature": "(text: str) -> str", "symbol_type": "function"}], "cleanup_partial_downloads": [{"docstring": "Clean up partial downloads for a species.\n\nArgs:\n    config_path: Path to species workflow config file\n    dry_run: If True, only report what would be deleted\n\nReturns:\n    Dictionary with 'deleted', 'freed_mb', 'errors' keys", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/cleanup.py", "line_number": 87, "module": "src.metainformant.rna.cleanup", "name": "cleanup_partial_downloads", "signature": "(config_path: Path) -> dict[str, Any]", "symbol_type": "function"}], "cleanup_unquantified_samples": [{"docstring": "Quantify downloaded samples and cleanup FASTQs.\n\nArgs:\n    config_path: Path to species workflow config file\n    log_dir: Optional log directory\n\nReturns:\n    Tuple of (quantified_count, failed_count)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/orchestration.py", "line_number": 439, "module": "src.metainformant.rna.orchestration", "name": "cleanup_unquantified_samples", "signature": "(config_path: Path) -> tuple[int, int]", "symbol_type": "function"}], "clear": [{"docstring": "Clear all items from cache.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/cache.py", "line_number": 231, "module": "src.metainformant.core.cache", "name": "clear", "signature": "(self) -> None", "symbol_type": "function"}], "clear_cache": [{"docstring": "Clear all cached traversal results.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/query.py", "line_number": 50, "module": "src.metainformant.ontology.query", "name": "clear_cache", "signature": "() -> None", "symbol_type": "function"}], "clear_cache_dir": [{"docstring": "Clear all cache files in a directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/cache.py", "line_number": 112, "module": "src.metainformant.core.cache", "name": "clear_cache_dir", "signature": "(cache_dir: Path) -> None", "symbol_type": "function"}], "clear_ic": [{"docstring": "Clear residue internal_coord settings for this chain.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 675, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "clear_ic", "signature": "(self)", "symbol_type": "function"}], "clear_transforms": [{"docstring": "Invalidate dihedra coordinate space attributes before assemble().\n\nCoordinate space attributes are Dihedron.cst and .rcst, and\n:data:`IC_Chain.dCoordSpace`", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 2770, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "clear_transforms", "signature": "(self)", "symbol_type": "function"}], "close": [{"docstring": "Close progress bar and cleanup.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/download_progress.py", "line_number": 215, "module": "src.metainformant.rna.steps.download_progress", "name": "close", "signature": "(self) -> None", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 87, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "close", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/serializer.py", "line_number": 36, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.serializer", "name": "close", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/serializer.py", "line_number": 36, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.serializer", "name": "close", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Close the file handle being used to read the data.\n\nOnce called, further use of the index won't work. The sole purpose\nof this method is to allow explicit handle closure - for example\nif you wish to delete the file, on Windows you must first close\nall open handles to that file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/File.py", "line_number": 256, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.File", "name": "close", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Close any open file handles.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/File.py", "line_number": 622, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.File", "name": "close", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Close BGZF file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 766, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "close", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Flush data, write 28 bytes BGZF EOF marker, and close BGZF file.\n\nsamtools will look for a magic EOF marker, just a 28 byte empty BGZF\nblock, and if it is missing warns the BAM file may be truncated. In\naddition to samtools writing this block, so too does bgzip - so this\nimplementation does too.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 889, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "close", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Close the file handle being used to read the data.\n\nOnce called, further use of the index won't work. The sole\npurpose of this method is to allow explicit handle closure\n- for example if you wish to delete the file, on Windows\nyou must first close all open handles to that file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/MafIO.py", "line_number": 308, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.MafIO", "name": "close", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Close the connection. No further activity possible.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 292, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "close", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Close the connection. No further activity possible.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 375, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "close", "signature": "(self)", "symbol_type": "function"}], "clustercentroids": [{"docstring": "Calculate and return the centroid of each cluster.\n\nThe clustercentroids routine calculates the cluster centroids, given to\nwhich cluster each item belongs. The centroid is defined as either\nthe mean or the median over all items for each dimension.\n\nKeyword arguments:\n - data: nrows x ncolumns array containing the data values.\n - mask: nrows x ncolumns array of integers, showing which data are\n   missing. If mask[i, j]==0, then data[i, j] is missing.\n - clusterid: array containing the cluster number for each item.\n   The cluster number should be non-negative.\n - method: specifies whether the centroid is calculated from the\n   arithmetic mean (method == 'a', default) or the median (method == 'm')\n   over each dimension.\n - transpose: if False, each row contains the data for one item;\n              if True, each column contains the data for one item.\n\nReturn values:\n - cdata: 2D array containing the cluster centroids.\n   If transpose is False, then the dimensions of cdata are\n   nclusters x ncolumns.\n   If transpose is True, then the dimensions of cdata are\n   nrows x nclusters.\n - cmask: 2D array of integers describing which items in cdata,\n   if any, are missing.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 472, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "clustercentroids", "signature": "(data, mask = None, clusterid = None, method = 'a', transpose = False)", "symbol_type": "function"}, {"docstring": "Calculate the cluster centroids and return a tuple (cdata, cmask).\n\nThe centroid is defined as either the mean or the median over all\nitems for each dimension.\n\nKeyword arguments:\n - data: nrows x ncolumns array containing the expression data\n - mask: nrows x ncolumns array of integers, showing which data\n   are missing. If mask[i, j]==0, then data[i, j] is missing.\n - transpose: if False, gene (row) clusters are considered;\n              if True, sample (column) clusters are considered.\n - clusterid: array containing the cluster number for each gene or\n   sample. The cluster number should be non-negative.\n - method: specifies how the centroid is calculated:\n   - method == 'a': arithmetic mean over each dimension. (default)\n   - method == 'm': median over each dimension.\n\nReturn values:\n - cdata: 2D array containing the cluster centroids. If transpose\n   is False, then the dimensions of cdata are nclusters x ncolumns.\n   If transpose is True, then the dimensions of cdata are nrows x\n   nclusters.\n - cmask: 2D array of integers describing which items in cdata,\n   if any, are missing.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 890, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "clustercentroids", "signature": "(self, clusterid = None, method = 'a', transpose = False)", "symbol_type": "function"}], "clusterdistance": [{"docstring": "Calculate and return the distance between two clusters.\n\nKeyword arguments:\n - data: nrows x ncolumns array containing the data values.\n - mask: nrows x ncolumns array of integers, showing which data are\n   missing. If mask[i, j]==0, then data[i, j] is missing.\n - weight: the weights to be used when calculating distances\n - index1: 1D array identifying which items belong to the\n   first cluster. If the cluster contains only one item, then\n   index1 can also be written as a single integer.\n - index2: 1D array identifying which items belong to the\n   second cluster. If the cluster contains only one item, then\n   index2 can also be written as a single integer.\n - dist: specifies the distance function to be used:\n   - dist == 'e': Euclidean distance\n   - dist == 'b': City Block distance\n   - dist == 'c': Pearson correlation\n   - dist == 'a': absolute value of the correlation\n   - dist == 'u': uncentered correlation\n   - dist == 'x': absolute uncentered correlation\n   - dist == 's': Spearman's rank correlation\n   - dist == 'k': Kendall's tau\n - method: specifies how the distance between two clusters is defined:\n   - method == 'a': the distance between the arithmetic means\n   of the two clusters\n   - method == 'm': the distance between the medians of the two clusters\n   - method == 's': the smallest pairwise distance between members\n   of the two clusters\n   - method == 'x': the largest pairwise distance between members\n   of the two clusters\n   - method == 'v': average of the pairwise distances between members\n   of the two clusters\n - transpose:\n   - if False: clusters of rows are considered;\n   - if True: clusters of columns are considered.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 414, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "clusterdistance", "signature": "(data, mask = None, weight = None, index1 = None, index2 = None, method = 'a', dist = 'e', transpose = False)", "symbol_type": "function"}, {"docstring": "Calculate the distance between two clusters.\n\nKeyword arguments:\n - index1: 1D array identifying which genes/samples belong to the\n   first cluster. If the cluster contains only one gene, then\n   index1 can also be written as a single integer.\n - index2: 1D array identifying which genes/samples belong to the\n   second cluster. If the cluster contains only one gene, then\n   index2 can also be written as a single integer.\n - transpose: if False, genes (rows) are clustered;\n              if True, samples (columns) are clustered.\n - dist: specifies the distance function to be used:\n   - dist == 'e': Euclidean distance\n   - dist == 'b': City Block distance\n   - dist == 'c': Pearson correlation\n   - dist == 'a': absolute value of the correlation\n   - dist == 'u': uncentered correlation\n   - dist == 'x': absolute uncentered correlation\n   - dist == 's': Spearman's rank correlation\n   - dist == 'k': Kendall's tau\n - method: specifies how the distance between two clusters is defined:\n   - method == 'a': the distance between the arithmetic means\n   of the two clusters\n   - method == 'm': the distance between the medians of the\n   two clusters\n   - method == 's': the smallest pairwise distance between members\n   of the two clusters\n   - method == 'x': the largest pairwise distance between members\n   of the two clusters\n   - method == 'v': average of the pairwise distances between members\n   of the two clusters\n - transpose: if False: clusters of rows are considered;\n              if True: clusters of columns are considered.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 918, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "clusterdistance", "signature": "(self, index1 = 0, index2 = 0, method = 'a', dist = 'e', transpose = False)", "symbol_type": "function"}], "cmp_sccs": [{"docstring": "Order SCOP concise classification strings (sccs).\n\na.4.5.1 < a.4.5.11 < b.1.1.1\n\nA sccs (e.g. a.4.5.11) compactly represents a domain's classification.\nThe letter represents the class, and the numbers are the fold,\nsuperfamily, and family, respectively.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 87, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "cmp_sccs", "signature": "(sccs1, sccs2)", "symbol_type": "function"}], "coalescent_time_to_mrca": [{"docstring": "Calculate expected time to most recent common ancestor (MRCA) under coalescent.\n\nComputes the expected number of generations until all sampled lineages\nhave coalesced to a single common ancestor. This is the height of the\ncoalescent tree.\n\nArgs:\n    sample_size: Number of sampled sequences (n)\n    effective_size: Effective population size (Ne)\n    \nReturns:\n    Expected time to MRCA in generations. Formula based on sum of\n    expected coalescent waiting times.\n    E[T_MRCA] \u2248 2Ne \u00d7 (1 - 1/n)\n    \nExamples:\n    >>> coalescent_time_to_mrca(sample_size=10, effective_size=1000)\n    1800.0...\n    >>> coalescent_time_to_mrca(sample_size=100, effective_size=10000)\n    19800.0...\n    \nReferences:\n    Kingman, J. F. C. (1982). On the genealogy of large populations.\n    Journal of Applied Probability, 19(A), 27-43.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 501, "module": "src.metainformant.math.popgen", "name": "coalescent_time_to_mrca", "signature": "(sample_size: int, effective_size: float) -> float", "symbol_type": "function"}], "codon_counts": [{"docstring": "Count complete codons in the sequence (ignore trailing partial triplets).\n\nReturns a mapping of codon -> count. Input is uppercased; only full triplets are counted.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/codon.py", "line_number": 6, "module": "src.metainformant.dna.codon", "name": "codon_counts", "signature": "(seq: str) -> dict[str, int]", "symbol_type": "function"}], "codon_frequencies": [{"docstring": "Compute relative frequencies of codons. Empty dict if there are no full codons.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/codon.py", "line_number": 20, "module": "src.metainformant.dna.codon", "name": "codon_frequencies", "signature": "(seq: str) -> dict[str, float]", "symbol_type": "function"}], "coerce_config_types": [{"docstring": "Coerce configuration values to specified types.\n\nArgs:\n    config: Configuration dictionary\n    type_map: Mapping of keys to expected types\n    \nReturns:\n    Configuration with coerced types\n    \nRaises:\n    ValueError: If type coercion fails", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 221, "module": "src.metainformant.core.config", "name": "coerce_config_types", "signature": "(config: dict[str, Any], type_map: dict[str, type]) -> dict[str, Any]", "symbol_type": "function"}], "collapse": [{"docstring": "Delete node from chain and relinks successors to predecessor.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 60, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "collapse", "signature": "(self, id)", "symbol_type": "function"}, {"docstring": "Delete target from the tree, relinking its children to its parent.\n\n:returns: the parent clade.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 580, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "collapse", "signature": "(self, target = None, **kwargs)", "symbol_type": "function"}], "collapse_all": [{"docstring": "Collapse all the descendents of this tree, leaving only terminals.\n\nTotal branch lengths are preserved, i.e. the distance to each terminal\nstays the same.\n\nFor example, this will safely collapse nodes with poor bootstrap\nsupport:\n\n    >>> from Bio import Phylo\n    >>> tree = Phylo.read('PhyloXML/apaf.xml', 'phyloxml')\n    >>> print(\"Total branch length %0.2f\" % tree.total_branch_length())\n    Total branch length 20.44\n    >>> tree.collapse_all(lambda c: c.confidence is not None and c.confidence < 70)\n    >>> print(\"Total branch length %0.2f\" % tree.total_branch_length())\n    Total branch length 21.37\n\nThis implementation avoids strange side-effects by using level-order\ntraversal and testing all clade properties (versus the target\nspecification) up front. In particular, if a clade meets the target\nspecification in the original tree, it will be collapsed.  For example,\nif the condition is:\n\n    >>> from Bio import Phylo\n    >>> tree = Phylo.read('PhyloXML/apaf.xml', 'phyloxml')\n    >>> print(\"Total branch length %0.2f\" % tree.total_branch_length())\n    Total branch length 20.44\n    >>> tree.collapse_all(lambda c: c.branch_length < 0.1)\n    >>> print(\"Total branch length %0.2f\" % tree.total_branch_length())\n    Total branch length 21.13\n\nCollapsing a clade's parent node adds the parent's branch length to the\nchild, so during the execution of collapse_all, a clade's branch_length\nmay increase. In this implementation, clades are collapsed according to\ntheir properties in the original tree, not the properties when tree\ntraversal reaches the clade. (It's easier to debug.) If you want the\nother behavior (incremental testing), modifying the source code of this\nfunction is straightforward.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 600, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "collapse_all", "signature": "(self, target = None, **kwargs)", "symbol_type": "function"}], "collapse_genera": [{"docstring": "Collapse all subtrees which belong to the same genus.\n\n(i.e share the same first word in their taxon name.)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 351, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "collapse_genera", "signature": "(self, space_equals_underscore = True)", "symbol_type": "function"}], "collect_block_list": [{"docstring": "Collect YAML block list items (lines starting with '- ').\n\nArgs:\n    start_index: Starting line index\n    parent_indent: Indentation level of parent key\n    \nReturns:\n    Tuple of (list of items, next line index after list)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 352, "module": "src.metainformant.core.config", "name": "collect_block_list", "signature": "(start_index: int, parent_indent: int) -> tuple[list[Any], int]", "symbol_type": "function"}], "collect_child_mapping": [{"docstring": "Collect nested YAML mapping (key-value pairs) with proper indentation.\n\nArgs:\n    start_index: Starting line index\n    parent_indent: Indentation level of parent key\n    depth: Maximum nesting depth (default: 1)\n    \nReturns:\n    Tuple of (child mapping dict, next line index after mapping)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 376, "module": "src.metainformant.core.config", "name": "collect_child_mapping", "signature": "(start_index: int, parent_indent: int, depth: int = 1) -> tuple[dict[str, Any], int]", "symbol_type": "function"}], "collect_result": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/parallel.py", "line_number": 92, "module": "src.metainformant.core.parallel", "name": "collect_result", "signature": "(future)", "symbol_type": "function"}], "color": [{"docstring": "Create branch color object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 533, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "color", "signature": "(self, elem)", "symbol_type": "function"}], "color_to_reportlab": [{"docstring": "Return the passed color in Reportlab Color format.\n\nWe allow colors to be specified as hex values, tuples, or Reportlab Color\nobjects, and with or without an alpha channel. This function acts as a\nRosetta stone for conversion of those formats to a Reportlab Color\nobject, with alpha value.\n\nAny other color specification is returned directly", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/KGML_vis.py", "line_number": 55, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.KGML_vis", "name": "color_to_reportlab", "signature": "(color)", "symbol_type": "function"}], "combine": [{"docstring": "Combine matrices in [(name,nexus-instance),...] and return new nexus instance.\n\ncombined_matrix=combine([(name1,nexus_instance1),(name2,nexus_instance2),...]\nCharacter sets, character partitions and taxon sets are prefixed, readjusted\nand present in the combined matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 376, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "combine", "signature": "(matrices)", "symbol_type": "function"}], "comment": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 671, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "comment", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1044, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "comment", "signature": "(self, content)", "symbol_type": "function"}], "commit": [{"docstring": "Commit the current transaction to the database.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 284, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "commit", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Commit the current transaction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 367, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "commit", "signature": "(self)", "symbol_type": "function"}], "common_ancestor": [{"docstring": "Return the common ancestor that connects two nodes.\n\nnode_id = common_ancestor(self,node1,node2)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 480, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "common_ancestor", "signature": "(self, node1, node2)", "symbol_type": "function"}, {"docstring": "Most recent common ancestor (clade) of all the given targets.\n\nEdge cases:\n - If no target is given, returns self.root\n - If 1 target is given, returns the target\n - If any target is not found in this tree, raises a ValueError", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 426, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "common_ancestor", "signature": "(self, targets, *more_targets)", "symbol_type": "function"}], "common_ancestors": [{"docstring": "Get common ancestor terms of two terms.\n\nFinds all terms that are ancestors of both term1 and term2.\n\nArgs:\n    onto: Ontology object containing terms\n    term1: First term identifier\n    term2: Second term identifier\n    \nReturns:\n    Set of common ancestor term IDs\n    \nRaises:\n    ValueError: If either term_id is empty or not found\n    \nExamples:\n    >>> onto = load_go_obo(\"go.obo\")\n    >>> common = common_ancestors(onto, \"GO:0009987\", \"GO:0008150\")\n    >>> len(common) > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/query.py", "line_number": 252, "module": "src.metainformant.ontology.query", "name": "common_ancestors", "signature": "(onto: Ontology, term1: str, term2: str) -> Set[str]", "symbol_type": "function"}], "community_metrics": [{"docstring": "Calculate comprehensive metrics for network community structure.\n\nEvaluates the quality and characteristics of a community partition,\nincluding community sizes, edge distribution, and modularity.\n\nArgs:\n    network: Input biological network\n    communities: Dictionary mapping node identifier to community ID\n    \nReturns:\n    Dictionary containing:\n    - num_communities: Number of distinct communities\n    - avg_community_size: Average number of nodes per community\n    - community_sizes: Dictionary mapping community_id -> size\n    - internal_edges: Number of edges within communities\n    - external_edges: Number of edges between communities\n    - internal_edge_ratio: Fraction of edges that are internal\n    - modularity: Modularity score of the partition\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\", \"D\"], directed=False)\n    >>> network.add_edge(\"A\", \"B\"); network.add_edge(\"C\", \"D\")\n    >>> communities = {\"A\": 0, \"B\": 0, \"C\": 1, \"D\": 1}\n    >>> metrics = community_metrics(network, communities)\n    >>> metrics[\"num_communities\"]\n    2\n    >>> metrics[\"internal_edge_ratio\"]\n    1.0  # All edges are internal", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/community.py", "line_number": 138, "module": "src.metainformant.networks.community", "name": "community_metrics", "signature": "(network: BiologicalNetwork, communities: Dict[str, int]) -> Dict[str, any]", "symbol_type": "function"}], "community_network_plot": [{"docstring": "Create a network plot colored by community membership.\n\nArgs:\n    nodes: List of node names\n    edges: List of (source, target) edge tuples\n    communities: Dictionary mapping node names to community IDs\n    node_sizes: Optional list of node sizes\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import community_network_plot\n    >>> nodes = ['A', 'B', 'C', 'D']\n    >>> edges = [('A', 'B'), ('B', 'C'), ('C', 'D')]\n    >>> communities = {'A': 0, 'B': 0, 'C': 1, 'D': 1}\n    >>> ax = community_network_plot(nodes, edges, communities)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/networks.py", "line_number": 266, "module": "src.metainformant.visualization.networks", "name": "community_network_plot", "signature": "(nodes: list[str], edges: list[tuple[str, str]], communities: dict[str, int] | None = None, **kwargs) -> plt.Axes", "symbol_type": "function"}], "community_stability": [{"docstring": "Assess stability of community detection across multiple runs.\n\nRuns community detection multiple times with different random seeds\nto assess how stable the community structure is. High stability indicates\nrobust community structure.\n\nArgs:\n    network: Input biological network\n    method: Community detection algorithm (default \"louvain\")\n    resolution: Resolution parameter for modularity optimization\n    n_runs: Number of runs to perform (default 10)\n    seed: Base random seed (will be incremented for each run)\n    \nReturns:\n    Dictionary containing:\n    - stability_score: Average normalized mutual information across runs\n    - modularity_scores: List of modularity values for each run\n    - avg_modularity: Average modularity across runs\n    - std_modularity: Standard deviation of modularity\n    - consensus_communities: Consensus partition (most common assignment)\n    - pairwise_agreement: Average pairwise agreement between runs\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"])\n    >>> stability = community_stability(network, n_runs=5)\n    >>> stability[\"stability_score\"] > 0.5\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/community.py", "line_number": 534, "module": "src.metainformant.networks.community", "name": "community_stability", "signature": "(network: BiologicalNetwork, method: str = 'louvain', resolution: float = 1.0, n_runs: int = 10, seed: Optional[int] = None) -> Dict[str, Any]", "symbol_type": "function"}], "compare_accessibility": [{"docstring": "Compare accessibility between two conditions.\n\nArgs:\n    signal1: ATAC-seq signal from condition 1\n    signal2: ATAC-seq signal from condition 2\n    regions: Optional regions to compare. If None, uses all overlapping regions\n    \nReturns:\n    Dictionary with comparison statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/atac.py", "line_number": 167, "module": "src.metainformant.epigenome.atac", "name": "compare_accessibility", "signature": "(signal1: pd.DataFrame, signal2: pd.DataFrame, regions: pd.DataFrame | None = None) -> dict[str, Any]", "symbol_type": "function"}], "compare_codon": [{"docstring": "Compare two codon accounting for different pathways.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/analysis.py", "line_number": 208, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.analysis", "name": "compare_codon", "signature": "(codon1, codon2, codon_table, weight = 1)", "symbol_type": "function"}, {"docstring": "Compare two codon accounting for different pathways.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 479, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "compare_codon", "signature": "(codon1, codon2, codon_table, weight = 1)", "symbol_type": "function"}], "compare_communities": [{"docstring": "Compare two community partitions.\n\nComputes similarity metrics between two community assignments\nto assess how similar they are.\n\nArgs:\n    communities1: First community partition (node -> community_id)\n    communities2: Second community partition (node -> community_id)\n    \nReturns:\n    Dictionary containing:\n    - normalized_mutual_information: NMI score (0 to 1, higher = more similar)\n    - adjusted_rand_index: ARI score (-1 to 1, higher = more similar)\n    - jaccard_similarity: Jaccard similarity of community assignments\n    \nExamples:\n    >>> comm1 = {\"A\": 0, \"B\": 0, \"C\": 1, \"D\": 1}\n    >>> comm2 = {\"A\": 0, \"B\": 1, \"C\": 1, \"D\": 1}\n    >>> comparison = compare_communities(comm1, comm2)\n    >>> comparison[\"normalized_mutual_information\"] > 0.0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/community.py", "line_number": 603, "module": "src.metainformant.networks.community", "name": "compare_communities", "signature": "(communities1: Dict[str, int], communities2: Dict[str, int]) -> Dict[str, float]", "symbol_type": "function"}], "compare_datasets": [{"docstring": "Compare two datasets using information measures.\n\nArgs:\n    dataset1: First dataset (sequences or data dictionary)\n    dataset2: Second dataset (sequences or data dictionary)\n    k: K-mer size for sequence analysis\n    method: Comparison method (\"entropy\", \"mutual_information\", \"kl_divergence\")\n    \nReturns:\n    Comparison results\n    \nRaises:\n    ValueError: If datasets are empty, k is invalid, or method is unknown", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/workflows.py", "line_number": 167, "module": "src.metainformant.information.workflows", "name": "compare_datasets", "signature": "(dataset1: list[str] | dict[str, Any], dataset2: list[str] | dict[str, Any], k: int = 1, method: str = 'entropy') -> dict[str, Any]", "symbol_type": "function"}], "compare_populations": [{"docstring": "Compare two populations using multiple statistics.\n\nCalculates within-population diversity and between-population differentiation\nfor two populations. Can use either sequence data or genotype matrices.\n\nArgs:\n    pop1_sequences: Sequences from population 1 (strings)\n    pop2_sequences: Sequences from population 2 (strings)\n    pop1_genotypes: Genotype matrix for population 1 (individuals \u00d7 sites)\n    pop2_genotypes: Genotype matrix for population 2 (individuals \u00d7 sites)\n\nReturns:\n    Dictionary containing:\n    - pop1_stats: Summary statistics for population 1\n    - pop2_stats: Summary statistics for population 2\n    - fst: Hudson's Fst between populations\n    - differentiation: Qualitative assessment (\"none\", \"low\", \"moderate\", \"high\")\n\nExamples:\n    >>> pop1 = [\"AAAA\", \"AAAA\", \"AAAT\"]\n    >>> pop2 = [\"TTTT\", \"TTTT\", \"TTTA\"]\n    >>> comparison = compare_populations(pop1_sequences=pop1, pop2_sequences=pop2)\n    >>> comparison[\"fst\"]\n    0.9...\n    >>> comparison[\"differentiation\"]\n    'high'", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_analysis.py", "line_number": 96, "module": "src.metainformant.dna.population_analysis", "name": "compare_populations", "signature": "(pop1_sequences: Sequence[str] | None = None, pop2_sequences: Sequence[str] | None = None, pop1_genotypes: Sequence[Sequence[int]] | None = None, pop2_genotypes: Sequence[Sequence[int]] | None = None) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Compare event patterns across two population groups.\n\nArgs:\n    sequences_group1: Event sequences for group 1 (must not be empty)\n    sequences_group2: Event sequences for group 2 (must not be empty)\n    output_dir: Output directory\n    \nReturns:\n    Dictionary with comparison statistics including event type overlaps and domain distributions\n    \nRaises:\n    ValueError: If either group is empty\n    \nExamples:\n    >>> from metainformant.life_events import EventSequence, Event, compare_populations\n    >>> from datetime import datetime\n    >>> group1 = [EventSequence(\"p1\", [Event(\"degree\", datetime(2010, 1, 1), \"education\")])]\n    >>> group2 = [EventSequence(\"p2\", [Event(\"job_change\", datetime(2015, 1, 1), \"occupation\")])]\n    >>> comparison = compare_populations(group1, group2)\n    >>> \"comparison\" in comparison\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/workflow.py", "line_number": 233, "module": "src.metainformant.life_events.workflow", "name": "compare_populations", "signature": "(sequences_group1: List[EventSequence], sequences_group2: List[EventSequence], output_dir: Optional[str | Path] = None) -> Dict[str, Any]", "symbol_type": "function"}], "compare_residues": [{"docstring": "Compare full IDs and atom coordinates for 2 Biopython PDB entities.\n\nSkip DNA and HETATMs.\n\n:param Entity e0,e1: Biopython PDB Entity objects (S, M or C).\n    Structures, Models or Chains to be compared\n:param bool verbose:\n    Whether to print mismatch info, default False\n:param bool quick: default False.\n    Only check atomArrays are identical, aCoordMatchCount=0 if different\n:param float rtol, atol: default 1e-03, 1e-03 or round to 3 places.\n    NumPy allclose parameters; default is to round atom coordinates to 3\n    places and test equal.  For 'quick' will use defaults above for\n    comparing atomArrays\n:returns dict:\n    Result counts for Residues, Full ID match Residues, Atoms,\n    Full ID match atoms, and Coordinate match atoms; report string;\n    error status (bool)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/ic_rebuild.py", "line_number": 342, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.ic_rebuild", "name": "compare_residues", "signature": "(e0: Structure | Model | Chain, e1: Structure | Model | Chain, verbose: bool = False, quick: bool = False, rtol: float = None, atol: float = None) -> dict[str, Any]", "symbol_type": "function"}], "compare_sequences_information": [{"docstring": "Compare two sequences using information-theoretic measures.\n\nArgs:\n    seq1: First sequence\n    seq2: Second sequence\n    k: K-mer size for comparison\n    \nReturns:\n    Dictionary containing:\n    - entropy_1, entropy_2: Individual entropies\n    - kl_divergence: KL divergence between k-mer distributions\n    - joint_entropy: Joint entropy of both sequences\n    - mutual_information: Mutual information between sequences", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/analysis.py", "line_number": 201, "module": "src.metainformant.information.analysis", "name": "compare_sequences_information", "signature": "(seq1: str, seq2: str, k: int = 1) -> dict[str, Any]", "symbol_type": "function"}], "compare_statistics": [{"docstring": "Compare statistics between two groups.\n\nPerforms statistical tests to compare distributions of statistics\nbetween two groups.\n\nArgs:\n    stat1: Statistics from first group\n    stat2: Statistics from second group\n    test_type: Type of test (\"mannwhitney\", \"ttest\", \"kruskal\")\n\nReturns:\n    Dictionary with:\n    - test_statistic: Test statistic value\n    - p_value: P-value\n    - test_type: Type of test performed\n    \nExamples:\n    >>> group1 = [1.0, 2.0, 3.0]\n    >>> group2 = [4.0, 5.0, 6.0]\n    >>> result = compare_statistics(group1, group2)\n    >>> result[\"p_value\"] < 0.05\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen_stats.py", "line_number": 333, "module": "src.metainformant.math.popgen_stats", "name": "compare_statistics", "signature": "(stat1: Sequence[float], stat2: Sequence[float], test_type: str = 'mannwhitney') -> dict[str, float]", "symbol_type": "function"}], "compatible_end": [{"docstring": "List all enzymes that produce compatible ends for the enzyme.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1106, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "compatible_end", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "List all enzymes that produce compatible ends for the enzyme.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1234, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "compatible_end", "signature": "(cls, batch = None)", "symbol_type": "function"}, {"docstring": "List all enzymes that produce compatible ends for the enzyme.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1364, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "compatible_end", "signature": "(cls, batch = None)", "symbol_type": "function"}, {"docstring": "List all enzymes that produce compatible ends for the enzyme.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1497, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "compatible_end", "signature": "(cls, batch = None)", "symbol_type": "function"}], "complement": [{"docstring": "Return the complement as a DNA sequence.\n\nIf given a string, returns a new string object.\nGiven a Seq object, returns a new Seq object.\nGiven a MutableSeq, returns a new MutableSeq object.\nGiven a SeqRecord object, returns a new SeqRecord object.\n\n>>> my_seq = \"CGA\"\n>>> complement(my_seq)\n'GCT'\n>>> my_seq = Seq(\"CGA\")\n>>> complement(my_seq)\nSeq('GCT')\n>>> my_seq = MutableSeq(\"CGA\")\n>>> complement(my_seq)\nMutableSeq('GCT')\n>>> my_seq\nMutableSeq('CGA')\n\nAny U in the sequence is treated as a T:\n\n>>> complement(Seq(\"CGAUT\"))\nSeq('GCTAA')\n\nIn contrast, ``complement_rna`` returns an RNA sequence:\n\n>>> complement_rna(Seq(\"CGAUT\"))\nSeq('GCUAA')\n\nSupports and lower- and upper-case characters, and unambiguous and\nambiguous nucleotides. All other characters are not converted:\n\n>>> complement(\"ACGTUacgtuXYZxyz\")\n'TGCAAtgcaaXRZxrz'\n\nThe sequence is modified in-place and returned if inplace is True:\n\n>>> my_seq = MutableSeq(\"CGA\")\n>>> complement(my_seq, inplace=True)\nMutableSeq('GCT')\n>>> my_seq\nMutableSeq('GCT')\n\nAs strings and ``Seq`` objects are immutable, a ``TypeError`` is\nraised if ``reverse_complement`` is called on a ``Seq`` object with\n``inplace=True``.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 3149, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "complement", "signature": "(sequence, inplace = False)", "symbol_type": "function"}, {"docstring": "Return the complement as a DNA sequence.\n\n>>> Seq(\"CGA\").complement()\nSeq('GCT')\n\nAny U in the sequence is treated as a T:\n\n>>> Seq(\"CGAUT\").complement()\nSeq('GCTAA')\n\nIn contrast, ``complement_rna`` returns an RNA sequence:\n\n>>> Seq(\"CGAUT\").complement_rna()\nSeq('GCUAA')\n\nThe sequence is modified in-place and returned if inplace is True:\n\n>>> my_seq = MutableSeq(\"CGA\")\n>>> my_seq\nMutableSeq('CGA')\n>>> my_seq.complement()\nMutableSeq('GCT')\n>>> my_seq\nMutableSeq('CGA')\n\n>>> my_seq.complement(inplace=True)\nMutableSeq('GCT')\n>>> my_seq\nMutableSeq('GCT')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if\n``complement_rna`` is called on a ``Seq`` object with ``inplace=True``.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1623, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "complement", "signature": "(self, inplace = False)", "symbol_type": "function"}], "complement_rna": [{"docstring": "Return the complement as an RNA sequence.\n\nIf given a string, returns a new string object.\nGiven a Seq object, returns a new Seq object.\nGiven a MutableSeq, returns a new MutableSeq object.\nGiven a SeqRecord object, returns a new SeqRecord object.\n\n>>> my_seq = \"CGA\"\n>>> complement_rna(my_seq)\n'GCU'\n>>> my_seq = Seq(\"CGA\")\n>>> complement_rna(my_seq)\nSeq('GCU')\n>>> my_seq = MutableSeq(\"CGA\")\n>>> complement_rna(my_seq)\nMutableSeq('GCU')\n>>> my_seq\nMutableSeq('CGA')\n\nAny T in the sequence is treated as a U:\n\n>>> complement_rna(Seq(\"CGAUT\"))\nSeq('GCUAA')\n\nIn contrast, ``complement`` returns a DNA sequence:\n\n>>> complement(Seq(\"CGAUT\"))\nSeq('GCTAA')\n\nSupports and lower- and upper-case characters, and unambiguous and\nambiguous nucleotides. All other characters are not converted:\n\n>>> complement_rna(\"ACGTUacgtuXYZxyz\")\n'UGCAAugcaaXRZxrz'\n\nThe sequence is modified in-place and returned if inplace is True:\n\n>>> my_seq = MutableSeq(\"CGA\")\n>>> complement(my_seq, inplace=True)\nMutableSeq('GCT')\n>>> my_seq\nMutableSeq('GCT')\n\nAs strings and ``Seq`` objects are immutable, a ``TypeError`` is\nraised if ``reverse_complement`` is called on a ``Seq`` object with\n``inplace=True``.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 3213, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "complement_rna", "signature": "(sequence, inplace = False)", "symbol_type": "function"}, {"docstring": "Return the complement as an RNA sequence.\n\n>>> Seq(\"CGA\").complement_rna()\nSeq('GCU')\n\nAny T in the sequence is treated as a U:\n\n>>> Seq(\"CGAUT\").complement_rna()\nSeq('GCUAA')\n\nIn contrast, ``complement`` returns a DNA sequence by default:\n\n>>> Seq(\"CGA\").complement()\nSeq('GCT')\n\nThe sequence is modified in-place and returned if inplace is True:\n\n>>> my_seq = MutableSeq(\"CGA\")\n>>> my_seq\nMutableSeq('CGA')\n>>> my_seq.complement_rna()\nMutableSeq('GCU')\n>>> my_seq\nMutableSeq('CGA')\n\n>>> my_seq.complement_rna(inplace=True)\nMutableSeq('GCU')\n>>> my_seq\nMutableSeq('GCU')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if\n``complement_rna`` is called on a ``Seq`` object with ``inplace=True``.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1671, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "complement_rna", "signature": "(self, inplace = False)", "symbol_type": "function"}], "compose": [{"docstring": "Parse the first YAML document in a stream\nand produce the corresponding representation tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 51, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "compose", "signature": "(stream, Loader = Loader)", "symbol_type": "function"}, {"docstring": "Parse the first YAML document in a stream\nand produce the corresponding representation tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 51, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "compose", "signature": "(stream, Loader = Loader)", "symbol_type": "function"}], "compose_all": [{"docstring": "Parse all YAML documents in a stream\nand produce corresponding representation trees.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 62, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "compose_all", "signature": "(stream, Loader = Loader)", "symbol_type": "function"}, {"docstring": "Parse all YAML documents in a stream\nand produce corresponding representation trees.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 62, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "compose_all", "signature": "(stream, Loader = Loader)", "symbol_type": "function"}], "compose_document": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/composer.py", "line_number": 50, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.composer", "name": "compose_document", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/composer.py", "line_number": 50, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.composer", "name": "compose_document", "signature": "(self)", "symbol_type": "function"}], "compose_mapping_node": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/composer.py", "line_number": 117, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.composer", "name": "compose_mapping_node", "signature": "(self, anchor)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/composer.py", "line_number": 117, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.composer", "name": "compose_mapping_node", "signature": "(self, anchor)", "symbol_type": "function"}], "compose_node": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/composer.py", "line_number": 63, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.composer", "name": "compose_node", "signature": "(self, parent, index)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/composer.py", "line_number": 63, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.composer", "name": "compose_node", "signature": "(self, parent, index)", "symbol_type": "function"}], "compose_scalar_node": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/composer.py", "line_number": 88, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.composer", "name": "compose_scalar_node", "signature": "(self, anchor)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/composer.py", "line_number": 88, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.composer", "name": "compose_scalar_node", "signature": "(self, anchor)", "symbol_type": "function"}], "compose_sequence_node": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/composer.py", "line_number": 99, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.composer", "name": "compose_sequence_node", "signature": "(self, anchor)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/composer.py", "line_number": 99, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.composer", "name": "compose_sequence_node", "signature": "(self, anchor)", "symbol_type": "function"}], "composed_model_input_classes": [{"docstring": "This function returns a list of the possible models that can be accepted as\ninputs.\nTODO: lru_cache this", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 93, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "composed_model_input_classes", "signature": "(cls)", "symbol_type": "function"}], "compounds": [{"docstring": "Get a list of entries of type compound.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 187, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "compounds", "signature": "(self)", "symbol_type": "function"}], "compute": [{"docstring": "Calculate surface accessibility surface area for an entity.\n\nThe resulting atomic surface accessibility values are attached to the\n.sasa attribute of each entity (or atom), depending on the level. For\nexample, if level=\"R\", all residues will have a .sasa attribute. Atoms\nwill always be assigned a .sasa attribute with their individual values.\n\n:param entity: input entity.\n:type entity: Bio.PDB.Entity, e.g. Residue, Chain, ...\n\n:param level: the level at which ASA values are assigned, which can be\n    one of \"A\" (Atom), \"R\" (Residue), \"C\" (Chain), \"M\" (Model), or\n    \"S\" (Structure). The ASA value of an entity is the sum of all ASA\n    values of its children. Defaults to \"A\".\n:type entity: Bio.PDB.Entity\n\n>>> from Bio.PDB import PDBParser\n>>> from Bio.PDB.SASA import ShrakeRupley\n>>> p = PDBParser(QUIET=1)\n>>> # This assumes you have a local copy of 1LCD.pdb in a directory called \"PDB\"\n>>> struct = p.get_structure(\"1LCD\", \"PDB/1LCD.pdb\")\n>>> sr = ShrakeRupley()\n>>> sr.compute(struct, level=\"S\")\n>>> print(round(struct.sasa, 2))\n7053.43\n>>> print(round(struct[0][\"A\"][11][\"OE1\"].sasa, 2))\n9.64", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/SASA.py", "line_number": 144, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.SASA", "name": "compute", "signature": "(self, entity, level = 'A')", "symbol_type": "function"}], "compute_beta_values": [{"docstring": "Compute beta = methylated / (methylated + unmethylated), safe for zeros.\n\nReturns a new DataFrame with an added 'beta' column.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/methylation.py", "line_number": 25, "module": "src.metainformant.epigenome.methylation", "name": "compute_beta_values", "signature": "(df: pd.DataFrame) -> pd.DataFrame", "symbol_type": "function"}], "compute_ca_contact_pairs": [{"docstring": "Return index pairs (i,j) with i<j for which Euclidean distance < threshold.\n\ncoords: iterable of (x,y,z). Threshold in Angstroms.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/contacts.py", "line_number": 6, "module": "src.metainformant.protein.contacts", "name": "compute_ca_contact_pairs", "signature": "(coords: Iterable[tuple[float, float, float]]) -> List[Tuple[int, int]]", "symbol_type": "function"}], "compute_cluster_composition": [{"docstring": "Compute cluster composition statistics.\n\nArgs:\n    data: SingleCellData object\n    groupby: Cluster column name\n    sample_key: Optional sample/batch column for composition analysis\n\nReturns:\n    DataFrame with cluster composition statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/clustering.py", "line_number": 450, "module": "src.metainformant.singlecell.clustering", "name": "compute_cluster_composition", "signature": "(data: SingleCellData, groupby: str, sample_key: Optional[str] = None) -> pd.DataFrame", "symbol_type": "function"}], "compute_cluster_silhouette": [{"docstring": "Compute silhouette scores for clusters.\n\nArgs:\n    data: SingleCellData object\n    groupby: Cluster column name\n    use_pca: Whether to use PCA coordinates\n    n_pcs: Number of PCs to use\n\nReturns:\n    Dictionary with silhouette scores per cluster", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/clustering.py", "line_number": 495, "module": "src.metainformant.singlecell.clustering", "name": "compute_cluster_silhouette", "signature": "(data: SingleCellData, groupby: str, use_pca: bool = True, n_pcs: int = 40) -> Dict[str, float]", "symbol_type": "function"}], "compute_diffusion_map": [{"docstring": "Compute diffusion map embedding for trajectory analysis.\n\nArgs:\n    data: SingleCellData with neighbor graph\n    n_components: Number of diffusion components\n    alpha: Diffusion parameter (higher values give more global structure)\n\nReturns:\n    SingleCellData with diffusion map coordinates in obsm", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/dimensionality.py", "line_number": 501, "module": "src.metainformant.singlecell.dimensionality", "name": "compute_diffusion_map", "signature": "(data: SingleCellData, n_components: int = 15, alpha: float = 1.0) -> SingleCellData", "symbol_type": "function"}], "compute_gene_trends": [{"docstring": "Compute gene expression trends along pseudotime.\n\nArgs:\n    data: SingleCellData with pseudotime\n    genes: Gene names to analyze (None for all genes)\n    method: Method for trend fitting ('spline', 'polynomial', 'loess')\n    n_knots: Number of knots for spline fitting\n\nReturns:\n    DataFrame with trend statistics for each gene", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/trajectory.py", "line_number": 423, "module": "src.metainformant.singlecell.trajectory", "name": "compute_gene_trends", "signature": "(data: SingleCellData, genes: Optional[Union[str, List[str]]] = None, method: str = 'spline', n_knots: int = 10) -> pd.DataFrame", "symbol_type": "function"}], "compute_kinship_matrix": [{"docstring": "Compute kinship matrix from genotype data.\n\nSupported methods:\n- vanraden: VanRaden method (default) - K = (M * M.T) / (2 * sum(p * (1-p)))\n  where M is centered genotypes\n- astle: Astle-Balding method\n- yang: Yang et al. method\n\nArgs:\n    genotype_matrix: Genotype matrix (samples x variants), encoded as 0/1/2/-1\n    method: Kinship computation method\n    missing_imputation: Method for handling missing data. Options:\n        - \"mean\": Mean imputation per variant (default)\n        - \"median\": Median imputation per variant\n        - \"mode\": Mode imputation per variant (most common genotype)\n        - \"skip\": Skip variants with missing data (set to 0)\n    max_missing_per_variant: Maximum fraction of missing data per variant.\n        Variants with higher missingness will be excluded. Default 0.5 (50%).\n\nReturns:\n    Dictionary with:\n    - kinship_matrix: Kinship matrix (samples x samples)\n    - method: Method used\n    - missing_data_stats: Statistics about missing data handling", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/structure.py", "line_number": 194, "module": "src.metainformant.gwas.structure", "name": "compute_kinship_matrix", "signature": "(genotype_matrix: list[list[int]], method: str = 'vanraden') -> dict[str, Any]", "symbol_type": "function"}], "compute_neighbors": [{"docstring": "Compute k-nearest neighbor graph.\n\nArgs:\n    data: SingleCellData object with PCA results\n    n_neighbors: Number of neighbors\n    n_pcs: Number of PCs to use for neighbor calculation\n    metric: Distance metric ('euclidean', 'cosine', 'manhattan')\n    method: Method for neighbor calculation ('umap', 'sklearn', 'gauss')\n\nReturns:\n    SingleCellData with neighbor graph in uns", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/dimensionality.py", "line_number": 225, "module": "src.metainformant.singlecell.dimensionality", "name": "compute_neighbors", "signature": "(data: SingleCellData, n_neighbors: int = 15, n_pcs: int = 40, metric: str = 'euclidean', method: str = 'umap') -> SingleCellData", "symbol_type": "function"}], "compute_pca": [{"docstring": "Compute Principal Component Analysis on genotype matrix.\n\nArgs:\n    genotype_matrix: Genotype matrix (samples x variants), encoded as 0/1/2/-1\n    n_components: Number of principal components to compute\n    missing_imputation: Method for handling missing data. Options:\n        - \"mean\": Mean imputation per variant (default)\n        - \"median\": Median imputation per variant\n        - \"mode\": Mode imputation per variant (most common genotype)\n        - \"skip\": Skip variants with missing data (set to 0)\n    max_missing_per_variant: Maximum fraction of missing data per variant.\n        Variants with higher missingness will be excluded. Default 0.5 (50%).\n\nReturns:\n    Dictionary with:\n    - pcs: Principal components (samples x n_components)\n    - explained_variance: Explained variance per component\n    - explained_variance_ratio: Explained variance ratio per component\n    - missing_data_stats: Statistics about missing data handling", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/structure.py", "line_number": 26, "module": "src.metainformant.gwas.structure", "name": "compute_pca", "signature": "(genotype_matrix: list[list[int]], n_components: int = 10) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Compute Principal Component Analysis.\n\nArgs:\n    data: SingleCellData object (should be scaled)\n    n_components: Number of principal components\n    use_hvgs: Whether to use only highly variable genes\n    svd_solver: SVD solver ('auto', 'full', 'arpack', 'randomized')\n\nReturns:\n    SingleCellData with PCA results in obsm and varm", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/dimensionality.py", "line_number": 159, "module": "src.metainformant.singlecell.dimensionality", "name": "compute_pca", "signature": "(data: SingleCellData, n_components: int = 50, use_hvgs: bool = True, svd_solver: str = 'arpack') -> SingleCellData", "symbol_type": "function"}], "compute_pseudotime": [{"docstring": "Compute pseudotime ordering of cells.\n\nArgs:\n    data: SingleCellData with neighbor graph or diffusion map\n    root_cells: Index/indices of root cell(s) (None for auto-detection)\n    method: Method for pseudotime ('diffusion', 'shortest_path')\n    n_components: Number of diffusion components to use\n\nReturns:\n    SingleCellData with pseudotime in obs['pseudotime']", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/trajectory.py", "line_number": 42, "module": "src.metainformant.singlecell.trajectory", "name": "compute_pseudotime", "signature": "(data: SingleCellData, root_cells: Optional[Union[int, List[int]]] = None, method: str = 'diffusion', n_components: int = 10) -> SingleCellData", "symbol_type": "function"}], "compute_rmsd_kabsch": [{"docstring": "Compute RMSD after optimal superposition using the Kabsch algorithm.\n\nShapes must be (N, 3) for both arrays. Returns RMSD as float.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/structure.py", "line_number": 6, "module": "src.metainformant.protein.structure", "name": "compute_rmsd_kabsch", "signature": "(coords_ref: np.ndarray, coords_mobile: np.ndarray) -> float", "symbol_type": "function"}], "compute_tsne": [{"docstring": "Compute t-SNE embedding.\n\nArgs:\n    data: SingleCellData object\n    n_components: Number of t-SNE dimensions\n    perplexity: t-SNE perplexity parameter\n    n_iter: Number of iterations\n    random_state: Random seed\n\nReturns:\n    SingleCellData with t-SNE coordinates in obsm", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/dimensionality.py", "line_number": 434, "module": "src.metainformant.singlecell.dimensionality", "name": "compute_tsne", "signature": "(data: SingleCellData, n_components: int = 2, perplexity: float = 30.0, n_iter: int = 1000, random_state: int = 42) -> SingleCellData", "symbol_type": "function"}], "compute_umap": [{"docstring": "Compute UMAP embedding.\n\nArgs:\n    data: SingleCellData with neighbor graph\n    n_components: Number of UMAP dimensions\n    min_dist: Minimum distance between points in embedding\n    spread: Scale of embedded points\n    n_epochs: Number of training epochs\n    random_state: Random seed\n\nReturns:\n    SingleCellData with UMAP coordinates in obsm", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/dimensionality.py", "line_number": 338, "module": "src.metainformant.singlecell.dimensionality", "name": "compute_umap", "signature": "(data: SingleCellData, n_components: int = 2, min_dist: float = 0.5, spread: float = 1.0, n_epochs: int = 200, random_state: int = 42) -> SingleCellData", "symbol_type": "function"}], "concat_fastq": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 75, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "concat_fastq", "signature": "(args, metadata, output_dir, g)", "symbol_type": "function"}], "concordance_plot": [{"docstring": "Replication concordance plot.\n\nCompares effect sizes/p-values between discovery and replication cohorts.\nAssesses consistency of associations.\n\nArgs:\n    discovery_results: Discovery cohort results\n    replication_results: Replication cohort results\n    output_path: Output path\n    significance_threshold: P-value threshold\n    title: Plot title\n\nReturns:\n    Plot metadata with concordance statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_comparison.py", "line_number": 339, "module": "src.metainformant.gwas.visualization_comparison", "name": "concordance_plot", "signature": "(discovery_results: list[dict[str, Any]] | Path, replication_results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "conditional_entropy": [{"docstring": "Calculate conditional entropy H(X|Y).\n\nMeasures the uncertainty in X given knowledge of Y.\n\nArgs:\n    x: Sequence of X values\n    y: Sequence of Y values (must match length of x)\n    base: Logarithm base\n    \nReturns:\n    Conditional entropy H(X|Y)\n    \nExamples:\n    >>> x = [0, 1, 0, 1]\n    >>> y = [0, 0, 1, 1]  # X = Y\n    >>> conditional_entropy(x, y)  # Should be 0 (no uncertainty given Y)\n    0.0", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 126, "module": "src.metainformant.information.syntactic", "name": "conditional_entropy", "signature": "(x: Sequence[Any], y: Sequence[Any], base: float = 2.0) -> float", "symbol_type": "function"}], "conditional_mutual_information": [{"docstring": "Calculate conditional mutual information I(X; Y|Z).\n\nMeasures the information shared between X and Y given Z.\nI(X; Y|Z) = H(X|Z) + H(Y|Z) - H(X, Y|Z)\n\nArgs:\n    x: Sequence of X values\n    y: Sequence of Y values\n    z: Sequence of Z values (all must have same length)\n    base: Logarithm base\n    \nReturns:\n    Conditional mutual information", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 244, "module": "src.metainformant.information.syntactic", "name": "conditional_mutual_information", "signature": "(x: Sequence[Any], y: Sequence[Any], z: Sequence[Any], base: float = 2.0) -> float", "symbol_type": "function"}], "conf2str": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 365, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "conf2str", "signature": "(conf)", "symbol_type": "function"}], "confidence": [{"docstring": "Create confidence object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 540, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "confidence", "signature": "(self, elem)", "symbol_type": "function"}], "config": [{"docstring": "Run `amalgkit config` (generate tool configs for downstream tools).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 556, "module": "src.metainformant.rna.amalgkit", "name": "config", "signature": "(params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}], "config_main": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/config.py", "line_number": 34, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.config", "name": "config_main", "signature": "(args)", "symbol_type": "function"}], "configure_logging_from_env": [{"docstring": "Configure root logger from environment variables.\n\nReads CORE_LOG_LEVEL environment variable and configures the root logger\naccordingly. This affects all loggers that inherit from root.\n\nArgs:\n    default_level: Default log level if CORE_LOG_LEVEL is not set\n\nExamples:\n    >>> configure_logging_from_env()\n    >>> # Now all loggers will use CORE_LOG_LEVEL if set", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/logging.py", "line_number": 113, "module": "src.metainformant.core.logging", "name": "configure_logging_from_env", "signature": "(default_level: str = 'INFO') -> None", "symbol_type": "function"}], "consensus": [{"docstring": "Compute a majority rule consensus tree of all clades with relative frequency>=threshold from a list of trees.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 917, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "consensus", "signature": "(trees, threshold = 0.5, outgroup = None)", "symbol_type": "function"}, {"docstring": "Return the consensus sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/__init__.py", "line_number": 414, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.__init__", "name": "consensus", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the consensus sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 137, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "consensus", "signature": "(self)", "symbol_type": "function"}], "consensus_from_alignment": [{"docstring": "Return a simple majority-rule consensus sequence.\n\nGaps ('-') are ignored when determining the majority at each position.\nIf no non-gap characters exist at a position, a '-' is emitted.\nAssumes all sequences are of equal length; if not, truncates to the\nminimum length.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/consensus.py", "line_number": 6, "module": "src.metainformant.dna.consensus", "name": "consensus_from_alignment", "signature": "(id_to_seq: dict[str, str]) -> str", "symbol_type": "function"}], "consrtm": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 636, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "consrtm", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1021, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "consrtm", "signature": "(self, content)", "symbol_type": "function"}], "constant": [{"docstring": "Return a list with all constant characters.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 1812, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "constant", "signature": "(self, matrix = None, delete = (), exclude = ())", "symbol_type": "function"}], "construct_document": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 54, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_document", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 54, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_document", "signature": "(self, node)", "symbol_type": "function"}], "construct_mapping": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 132, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_mapping", "signature": "(self, node, deep = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 215, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_mapping", "signature": "(self, node, deep = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 132, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_mapping", "signature": "(self, node, deep = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 215, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_mapping", "signature": "(self, node, deep = False)", "symbol_type": "function"}], "construct_object": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 67, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_object", "signature": "(self, node, deep = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 67, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_object", "signature": "(self, node, deep = False)", "symbol_type": "function"}], "construct_pairs": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 147, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_pairs", "signature": "(self, node, deep = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 147, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_pairs", "signature": "(self, node, deep = False)", "symbol_type": "function"}], "construct_python_bytes": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 500, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_python_bytes", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 500, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_python_bytes", "signature": "(self, node)", "symbol_type": "function"}], "construct_python_complex": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 519, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_python_complex", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 519, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_python_complex", "signature": "(self, node)", "symbol_type": "function"}], "construct_python_long": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 516, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_python_long", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 516, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_python_long", "signature": "(self, node)", "symbol_type": "function"}], "construct_python_module": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 572, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_python_module", "signature": "(self, suffix, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 572, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_python_module", "signature": "(self, suffix, node)", "symbol_type": "function"}], "construct_python_name": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 565, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_python_name", "signature": "(self, suffix, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 565, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_python_name", "signature": "(self, suffix, node)", "symbol_type": "function"}], "construct_python_object": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 614, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_python_object", "signature": "(self, suffix, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 614, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_python_object", "signature": "(self, suffix, node)", "symbol_type": "function"}], "construct_python_object_apply": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 623, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_python_object_apply", "signature": "(self, suffix, node, newobj = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 623, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_python_object_apply", "signature": "(self, suffix, node, newobj = False)", "symbol_type": "function"}], "construct_python_object_new": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 658, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_python_object_new", "signature": "(self, suffix, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 658, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_python_object_new", "signature": "(self, suffix, node)", "symbol_type": "function"}], "construct_python_str": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 494, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_python_str", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 494, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_python_str", "signature": "(self, node)", "symbol_type": "function"}], "construct_python_tuple": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 522, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_python_tuple", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 522, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_python_tuple", "signature": "(self, node)", "symbol_type": "function"}], "construct_python_unicode": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 497, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_python_unicode", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 497, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_python_unicode", "signature": "(self, node)", "symbol_type": "function"}], "construct_scalar": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 117, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_scalar", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 173, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_scalar", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 117, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_scalar", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 173, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_scalar", "signature": "(self, node)", "symbol_type": "function"}], "construct_sequence": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 124, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_sequence", "signature": "(self, node, deep = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 124, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_sequence", "signature": "(self, node, deep = False)", "symbol_type": "function"}], "construct_undefined": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 426, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_undefined", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 426, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_undefined", "signature": "(self, node)", "symbol_type": "function"}], "construct_yaml_binary": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 294, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_yaml_binary", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 294, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_yaml_binary", "signature": "(self, node)", "symbol_type": "function"}], "construct_yaml_bool": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 233, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_yaml_bool", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 233, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_yaml_bool", "signature": "(self, node)", "symbol_type": "function"}], "construct_yaml_float": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 270, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_yaml_float", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 270, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_yaml_float", "signature": "(self, node)", "symbol_type": "function"}], "construct_yaml_int": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 237, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_yaml_int", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 237, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_yaml_int", "signature": "(self, node)", "symbol_type": "function"}], "construct_yaml_map": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 410, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_yaml_map", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 410, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_yaml_map", "signature": "(self, node)", "symbol_type": "function"}], "construct_yaml_null": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 220, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_yaml_null", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 220, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_yaml_null", "signature": "(self, node)", "symbol_type": "function"}], "construct_yaml_object": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 416, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_yaml_object", "signature": "(self, node, cls)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 416, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_yaml_object", "signature": "(self, node, cls)", "symbol_type": "function"}], "construct_yaml_omap": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 353, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_yaml_omap", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 353, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_yaml_omap", "signature": "(self, node)", "symbol_type": "function"}], "construct_yaml_pairs": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 375, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_yaml_pairs", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 375, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_yaml_pairs", "signature": "(self, node)", "symbol_type": "function"}], "construct_yaml_seq": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 405, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_yaml_seq", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 405, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_yaml_seq", "signature": "(self, node)", "symbol_type": "function"}], "construct_yaml_set": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 396, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_yaml_set", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 396, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_yaml_set", "signature": "(self, node)", "symbol_type": "function"}], "construct_yaml_str": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 402, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_yaml_str", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 402, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_yaml_str", "signature": "(self, node)", "symbol_type": "function"}], "construct_yaml_timestamp": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 322, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "construct_yaml_timestamp", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 322, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "construct_yaml_timestamp", "signature": "(self, node)", "symbol_type": "function"}], "contains": [{"docstring": "Check if current bitstr1 contains another one bitstr2.\n\nThat is to say, the bitstr2.index_one() is a subset of\nbitstr1.index_one().\n\nExamples:\n    \"011011\" contains \"011000\", \"011001\", \"000011\"\n\nBe careful, \"011011\" also contains \"000000\". Actually, all _BitString\nobjects contain all-zero _BitString of the same length.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/Consensus.py", "line_number": 180, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.Consensus", "name": "contains", "signature": "(self, other)", "symbol_type": "function"}], "contig_location": [{"docstring": "Deal with CONTIG information.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 777, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "contig_location", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": "Signal that we have contig information to add to the record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1139, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "contig_location", "signature": "(self, content)", "symbol_type": "function"}], "convert": [{"docstring": "Convert between two alignment files, returns number of alignments.\n\nArguments:\n - in_file - an input handle or filename\n - in_format - input file format, lower case string\n - output - an output handle or filename\n - out_file - output file format, lower case string\n - molecule_type - optional molecule type to apply, string containing\n   \"DNA\", \"RNA\" or \"protein\".\n\n**NOTE** - If you provide an output filename, it will be opened which will\noverwrite any existing file without warning. This may happen if even the\nconversion is aborted (e.g. an invalid out_format name is given).\n\nSome output formats require the molecule type be specified where this\ncannot be determined by the parser. For example, converting to FASTA,\nClustal, or PHYLIP format to NEXUS:\n\n>>> from io import StringIO\n>>> from Bio import AlignIO\n>>> handle = StringIO()\n>>> AlignIO.convert(\"Phylip/horses.phy\", \"phylip\", handle, \"nexus\", \"DNA\")\n1\n>>> print(handle.getvalue())\n#NEXUS\nbegin data;\ndimensions ntax=10 nchar=40;\nformat datatype=dna missing=? gap=-;\nmatrix\nMesohippus   AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nHypohippus   AAACCCCCCCAAAAAAAAACAAAAAAAAAAAAAAAAAAAA\nArchaeohip   CAAAAAAAAAAAAAAAACACAAAAAAAAAAAAAAAAAAAA\nParahippus   CAAACAACAACAAAAAAAACAAAAAAAAAAAAAAAAAAAA\nMerychippu   CCAACCACCACCCCACACCCAAAAAAAAAAAAAAAAAAAA\n'M. secundu' CCAACCACCACCCACACCCCAAAAAAAAAAAAAAAAAAAA\nNannipus     CCAACCACAACCCCACACCCAAAAAAAAAAAAAAAAAAAA\nNeohippari   CCAACCCCCCCCCCACACCCAAAAAAAAAAAAAAAAAAAA\nCalippus     CCAACCACAACCCACACCCCAAAAAAAAAAAAAAAAAAAA\nPliohippus   CCCACCCCCCCCCACACCCCAAAAAAAAAAAAAAAAAAAA\n;\nend;\n<BLANKLINE>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/__init__.py", "line_number": 401, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.__init__", "name": "convert", "signature": "(in_file, in_format, out_file, out_format, molecule_type = None)", "symbol_type": "function"}, {"docstring": "Convert between two tree file formats.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_io.py", "line_number": 84, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._io", "name": "convert", "signature": "(in_file, in_format, out_file, out_format, parse_args = None, **kwargs)", "symbol_type": "function"}, {"docstring": "Convert between two search output formats, return number of records.\n\n - in_file    - Handle to the input file, or the filename as string.\n - in_format  - Lower case string denoting the format of the input file.\n - out_file   - Handle to the output file, or the filename as string.\n - out_format - Lower case string denoting the format of the output file.\n - in_kwargs  - Dictionary of keyword arguments for the input function.\n - out_kwargs - Dictionary of keyword arguments for the output function.\n\nThe convert function is a shortcut function for ``parse`` and ``write``. It has\nthe same return type as ``write``. Format-specific arguments may be passed to\nthe convert function, but only as dictionaries.\n\nHere is an example of using ``convert`` to convert from a BLAST+ XML file\ninto a tabular file with comments::\n\n    from Bio import SearchIO\n    in_file = 'Blast/mirna.xml'\n    in_fmt = 'blast-xml'\n    out_file = 'results.tab'\n    out_fmt = 'blast-tab'\n    out_kwarg = {'comments': True}\n    SearchIO.convert(in_file, in_fmt, out_file, out_fmt, out_kwargs=out_kwarg)\n    <stdout> (3, 239, 277, 277)\n\nGiven that different search output file provide different statistics and\ndifferent level of details, the convert function is limited only to\nconverting formats that have the same statistics and for conversion to\nformats with the same level of detail, or less.\n\nFor example, converting from a BLAST+ XML output to a HMMER table file\nis not possible, as these are two search programs with different kinds of\nstatistics. In theory, you may provide the necessary values required by the\nHMMER table file (e.g. conditional e-values, envelope coordinates, etc).\nHowever, these values are likely to hold little meaning as they are not true\nHMMER-computed values.\n\nAnother example is converting from BLAST+ XML to BLAST+ tabular file. This\nis possible, as BLAST+ XML provide all the values necessary to create a\nBLAST+ tabular file. However, the reverse conversion may not be possible.\nThere are more details covered in the XML file that are not found in a\ntabular file (e.g. the lambda and kappa values)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/__init__.py", "line_number": 626, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.__init__", "name": "convert", "signature": "(in_file, in_format, out_file, out_format, in_kwargs = None, out_kwargs = None)", "symbol_type": "function"}, {"docstring": "Convert between two sequence file formats, return number of records.\n\nArguments:\n - in_file - an input handle or filename\n - in_format - input file format, lower case string\n - out_file - an output handle or filename\n - out_format - output file format, lower case string\n - molecule_type - optional molecule type to apply, string containing\n   \"DNA\", \"RNA\" or \"protein\".\n\n**NOTE** - If you provide an output filename, it will be opened which will\noverwrite any existing file without warning.\n\nThe idea here is that while doing this will work::\n\n    from Bio import SeqIO\n    records = SeqIO.parse(in_handle, in_format)\n    count = SeqIO.write(records, out_handle, out_format)\n\nit is shorter to write::\n\n    from Bio import SeqIO\n    count = SeqIO.convert(in_handle, in_format, out_handle, out_format)\n\nAlso, Bio.SeqIO.convert is faster for some conversions as it can make some\noptimisations.\n\nFor example, going from a filename to a handle:\n\n>>> from Bio import SeqIO\n>>> from io import StringIO\n>>> handle = StringIO(\"\")\n>>> SeqIO.convert(\"Quality/example.fastq\", \"fastq\", handle, \"fasta\")\n3\n>>> print(handle.getvalue())\n>EAS54_6_R1_2_1_413_324\nCCCTTCTTGTCTTCAGCGTTTCTCC\n>EAS54_6_R1_2_1_540_792\nTTGGCAGGCCAAGGCCGATGGATCA\n>EAS54_6_R1_2_1_443_348\nGTTGCTTCTGGCGTGGGTGGGGGGG\n<BLANKLINE>\n\nNote some formats like SeqXML require you to specify the molecule type\nwhen it cannot be determined by the parser:\n\n>>> from Bio import SeqIO\n>>> from io import BytesIO\n>>> handle = BytesIO()\n>>> SeqIO.convert(\"Quality/example.fastq\", \"fastq\", handle, \"seqxml\", \"DNA\")\n3", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/__init__.py", "line_number": 1090, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.__init__", "name": "convert", "signature": "(in_file, in_format, out_file, out_format, molecule_type = None)", "symbol_type": "function"}, {"docstring": "Call TogoWS for file format conversion.\n\nArguments:\n - data - string or handle containing input record(s)\n - in_format - string describing the input file format (e.g. \"genbank\")\n - out_format - string describing the requested output format (e.g. \"fasta\")\n\nFor a list of supported conversions (e.g. \"genbank\" to \"fasta\"), see\nhttp://togows.dbcls.jp/convert/\n\nNote that Biopython has built in support for conversion of sequence and\nalignnent file formats (functions Bio.SeqIO.convert and Bio.AlignIO.convert)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/TogoWS/__init__.py", "line_number": 306, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.TogoWS.__init__", "name": "convert", "signature": "(data, in_format, out_format)", "symbol_type": "function"}], "convert_absolute_support": [{"docstring": "Convert absolute support (clade-count) to rel. frequencies.\n\nSome software (e.g. PHYLIP consense) just calculate how often clades appear, instead of\ncalculating relative frequencies.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 549, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "convert_absolute_support", "signature": "(self, nrep)", "symbol_type": "function"}], "convert_js_args_to_python_args": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 33, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "convert_js_args_to_python_args", "signature": "(fn)", "symbol_type": "function"}], "convert_matplotlib_to_plotly": [{"docstring": "Convert a matplotlib figure to Plotly format.\n\nArgs:\n    fig: Matplotlib figure\n\nReturns:\n    Plotly figure object\n\nExample:\n    >>> from metainformant.visualization.interactive import convert_matplotlib_to_plotly\n    >>> import matplotlib.pyplot as plt\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [4, 5, 6])\n    >>> plotly_fig = convert_matplotlib_to_plotly(fig)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/interactive.py", "line_number": 122, "module": "src.metainformant.visualization.interactive", "name": "convert_matplotlib_to_plotly", "signature": "(fig: Any) -> Any", "symbol_type": "function"}], "convert_sample": [{"docstring": "Convert a single sample and return results.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/convert_existing_sra.py", "line_number": 81, "module": "scripts.rna.convert_existing_sra", "name": "convert_sample", "signature": "(sample_id: str, sra_file: Path, idx: int, total: int) -> tuple[str, bool, str, int]", "symbol_type": "function"}], "convert_sequences_to_tokens": [{"docstring": "Convert event sequences to token format for embedding/ML.\n\nArgs:\n    sequences: List of EventSequence objects\n    \nReturns:\n    List of token sequences, where each sequence is a list of \"domain:event_type\" strings\n    \nExamples:\n    >>> sequences = [EventSequence(\"p1\", [Event(\"degree\", datetime(2010, 1, 1), \"education\")])]\n    >>> tokens = convert_sequences_to_tokens(sequences)\n    >>> tokens[0]\n    ['education:degree']", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/utils.py", "line_number": 114, "module": "src.metainformant.life_events.utils", "name": "convert_sequences_to_tokens", "signature": "(sequences: List[EventSequence]) -> List[List[str]]", "symbol_type": "function"}], "convert_sra_to_fastq": [{"docstring": "Convert a local SRA file to FASTQ format.\n\nPrefers parallel-fastq-dump (works better with local files) and falls back\nto fasterq-dump if needed. Automatically compresses output FASTQ files.\n\nArgs:\n    sample_id: SRA accession ID (e.g., \"SRR1234567\")\n    sra_file: Path to the SRA file\n    output_dir: Directory where FASTQ files should be written\n    threads: Number of threads for conversion\n    log_dir: Optional directory for log files\n    \nReturns:\n    Tuple of (success: bool, message: str, fastq_files: list[Path])\n    fastq_files contains paths to created FASTQ files (may be empty if failed)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/getfastq.py", "line_number": 495, "module": "src.metainformant.rna.steps.getfastq", "name": "convert_sra_to_fastq", "signature": "(sample_id: str, sra_file: Path, output_dir: Path) -> tuple[bool, str, list[Path]]", "symbol_type": "function"}], "converter": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 801, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "converter", "signature": "(data, item_converter = item_converter)", "symbol_type": "function"}], "coord_space": [{"docstring": "Generate transformation matrix to coordinate space defined by 3 points.\n\nNew coordinate space will have:\n    acs[0] on XZ plane\n    acs[1] origin\n    acs[2] on +Z axis\n\n:param NumPy column array x3 acs: X,Y,Z column input coordinates x3\n:param bool rev: if True, also return reverse transformation matrix\n    (to return from coord_space)\n:returns: 4x4 NumPy array, x2 if rev=True", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 526, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "coord_space", "signature": "(a0: np.ndarray, a1: np.ndarray, a2: np.ndarray, rev: bool = False) -> tuple[np.ndarray, np.ndarray | None]", "symbol_type": "function"}], "copy": [{"docstring": "Create a deep copy of the data.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/preprocessing.py", "line_number": 80, "module": "src.metainformant.singlecell.preprocessing", "name": "copy", "signature": "(self) -> 'SingleCellData'", "symbol_type": "function"}, {"docstring": "Create a copy of the Atom.\n\nParent information is lost.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 489, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "copy", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Copy entity recursively.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 385, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "copy", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Copy disorderd entity recursively.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 477, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "copy", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a deep copy of the Vector.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 378, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "copy", "signature": "(self)", "symbol_type": "function"}], "copy_initNCaCs": [{"docstring": "Copy atom coordinates for initNCaC atoms from other IC_Chain.\n\nCopies the coordinates and sets atomArrayValid flags True for initial\nNCaC and after any chain breaks.\n\nNeeded for :meth:`.distance_to_internal_coordinates` if target has\nchain breaks (otherwise each fragment will start at origin).\n\nAlso useful if copying internal coordinates from another chain.\n\nN.B. :meth:`IC_Residue.set_angle()` and :meth:`IC_Residue.set_length()`\ninvalidate their relevant atoms, so apply them before calling this\nfunction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 2187, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "copy_initNCaCs", "signature": "(self, other: 'IC_Chain') -> None", "symbol_type": "function"}], "correlation": [{"docstring": "Pearson correlation coefficient between two sequences.\n\nReturns 0.0 if inputs are empty, different lengths, or either variance is 0.\nUses population definitions (divide by n).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 72, "module": "src.metainformant.math.price", "name": "correlation", "signature": "(x: Sequence[float], y: Sequence[float]) -> float", "symbol_type": "function"}], "correlation_coefficient": [{"docstring": "Calculate Pearson correlation coefficient between two lists.\n\nComputes the linear correlation between two variables, measuring the\nstrength and direction of their linear relationship.\n\nArgs:\n    x: First list of numeric values\n    y: Second list of numeric values (must match length of x)\n    \nReturns:\n    Pearson correlation coefficient in [-1, 1]. Returns 0.0 if:\n    - Lists have different lengths\n    - Lists have fewer than 2 elements\n    - Either list has zero variance\n    \nRaises:\n    ValueError: If lists have different lengths (when len(x) != len(y))\n    \nExamples:\n    >>> correlation_coefficient([1, 2, 3], [2, 4, 6])\n    1.0\n    >>> correlation_coefficient([1, 2, 3], [3, 2, 1])\n    -1.0\n    \nNote:\n    This is a convenience function. For more advanced correlation\n    analysis, use the `correlation` function from `price.py`.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/__init__.py", "line_number": 267, "module": "src.metainformant.math.__init__", "name": "correlation_coefficient", "signature": "(x: list[float], y: list[float]) -> float", "symbol_type": "function"}], "correlation_heatmap": [{"docstring": "Create a correlation heatmap.\n\nArgs:\n    data: DataFrame with numeric columns\n    method: Correlation method ('pearson', 'spearman', 'kendall')\n    cmap: Colormap for the heatmap\n    annot: Whether to annotate cells with correlation values\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments for seaborn.heatmap\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import correlation_heatmap\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> df = pd.DataFrame(np.random.random((10, 5)))\n    >>> ax = correlation_heatmap(df)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/statistical.py", "line_number": 239, "module": "src.metainformant.visualization.statistical", "name": "correlation_heatmap", "signature": "(data: pd.DataFrame, **kwargs) -> plt.Axes", "symbol_type": "function"}], "count": [{"docstring": "Return the number of non-overlapping occurrences of sub in data[start:end].\n\nOptional arguments start and end are interpreted as in slice notation.\nThis method behaves as the count method of Python strings.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 160, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "count", "signature": "(self, sub, start = None, end = None)", "symbol_type": "function"}, {"docstring": "Return a non-overlapping count, like that of a python string.\n\nThe number of occurrences of substring argument sub in the\n(sub)sequence given by [start:end] is returned as an integer.\nOptional arguments start and end are interpreted as in slice\nnotation.\n\nArguments:\n - sub - a string or another Seq object to look for\n - start - optional integer, slice start\n - end - optional integer, slice end\n\ne.g.\n\n>>> from Bio.Seq import Seq\n>>> my_seq = Seq(\"AAAATGA\")\n>>> print(my_seq.count(\"A\"))\n5\n>>> print(my_seq.count(\"ATG\"))\n1\n>>> print(my_seq.count(Seq(\"AT\")))\n1\n>>> print(my_seq.count(\"AT\", 2, -1))\n1\n\nHOWEVER, please note because the ``count`` method of Seq and MutableSeq\nobjects, like that of Python strings, do a non-overlapping search, this\nmay not give the answer you expect:\n\n>>> \"AAAA\".count(\"AA\")\n2\n>>> print(Seq(\"AAAA\").count(\"AA\"))\n2\n\nFor an overlapping search, use the ``count_overlap`` method:\n\n>>> print(Seq(\"AAAA\").count_overlap(\"AA\"))\n3", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 631, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "count", "signature": "(self, sub, start = None, end = None)", "symbol_type": "function"}, {"docstring": "Return the number of non-overlapping occurrences of sub in seq[start:end].\n\nOptional arguments start and end are interpreted as in slice notation.\nThis method behaves as the count method of Python strings.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 1080, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "count", "signature": "(self, sub, start = None, end = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 995, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "count", "signature": "(model)", "symbol_type": "function"}], "count_TV": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/analysis.py", "line_number": 655, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.analysis", "name": "count_TV", "signature": "(codon1, codon2, diff, codon_table, weight = 1)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 965, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "count_TV", "signature": "(codon1, codon2, diff, codon_table, weight = 1)", "symbol_type": "function"}], "count_amino_acids": [{"docstring": "Count standard amino acids, return a dict.\n\nCounts the number times each amino acid is in the protein\nsequence. Returns a dictionary {AminoAcid:Number}.\n\nThe return value is cached in self.amino_acids_content.\nIt is not recalculated upon subsequent calls.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/ProtParam.py", "line_number": 86, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.ProtParam", "name": "count_amino_acids", "signature": "(self)", "symbol_type": "function"}], "count_go_scripts": [{"docstring": "Count Gene Ontology annotation script files in a directory.\n\nArgs:\n    go_dir: Directory path containing GO annotation files\n    \nReturns:\n    Integer count of annotation script files found", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/go.py", "line_number": 18, "module": "src.metainformant.ontology.go", "name": "count_go_scripts", "signature": "(go_dir: Path) -> int", "symbol_type": "function"}], "count_overlap": [{"docstring": "Return an overlapping count.\n\nReturns an integer, the number of occurrences of substring\nargument sub in the (sub)sequence given by [start:end].\nOptional arguments start and end are interpreted as in slice\nnotation.\n\nArguments:\n - sub - a string or another Seq object to look for\n - start - optional integer, slice start\n - end - optional integer, slice end\n\ne.g.\n\n>>> from Bio.Seq import Seq\n>>> print(Seq(\"AAAA\").count_overlap(\"AA\"))\n3\n>>> print(Seq(\"ATATATATA\").count_overlap(\"ATA\"))\n4\n>>> print(Seq(\"ATATATATA\").count_overlap(\"ATA\", 3, -1))\n1\n\nFor a non-overlapping search, use the ``count`` method:\n\n>>> print(Seq(\"AAAA\").count(\"AA\"))\n2\n\nWhere substrings do not overlap, ``count_overlap`` behaves the same as\nthe ``count`` method:\n\n>>> from Bio.Seq import Seq\n>>> my_seq = Seq(\"AAAATGA\")\n>>> print(my_seq.count_overlap(\"A\"))\n5\n>>> my_seq.count_overlap(\"A\") == my_seq.count(\"A\")\nTrue\n>>> print(my_seq.count_overlap(\"ATG\"))\n1\n>>> my_seq.count_overlap(\"ATG\") == my_seq.count(\"ATG\")\nTrue\n>>> print(my_seq.count_overlap(Seq(\"AT\")))\n1\n>>> my_seq.count_overlap(Seq(\"AT\")) == my_seq.count(Seq(\"AT\"))\nTrue\n>>> print(my_seq.count_overlap(\"AT\", 2, -1))\n1\n>>> my_seq.count_overlap(\"AT\", 2, -1) == my_seq.count(\"AT\", 2, -1)\nTrue\n\nHOWEVER, do not use this method for such cases because the\ncount() method is much for efficient.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 684, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "count_overlap", "signature": "(self, sub, start = None, end = None)", "symbol_type": "function"}], "count_quantified_samples": [{"docstring": "Count quantified and total samples for a species.\n\nArgs:\n    config_path: Path to species workflow config file\n    \nReturns:\n    Tuple of (quantified_count, total_count)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/monitoring.py", "line_number": 26, "module": "src.metainformant.rna.monitoring", "name": "count_quantified_samples", "signature": "(config_path: Path) -> tuple[int, int]", "symbol_type": "function"}], "count_terminals": [{"docstring": "Count the number of terminal nodes that are attached to a node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 345, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "count_terminals", "signature": "(self, node = None)", "symbol_type": "function"}, {"docstring": "Count the number of terminal (leaf) nodes within this tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 452, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "count_terminals", "signature": "(self)", "symbol_type": "function"}], "count_words": [{"docstring": "Count words in text after normalization.\n\nArgs:\n    text: Text to count words in\n\nReturns:\n    Number of words", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/text.py", "line_number": 147, "module": "src.metainformant.core.text", "name": "count_words", "signature": "(text: str) -> int", "symbol_type": "function"}], "counts": [{"docstring": "Count the number of identities, mismatches, and gaps of an alignment.\n\nThis method takes a single optional argument named scoring, which can be either None\n(default), a substitution matrix, a wildcard character, or a pairwise\naligner object:\n\n - If the argument is a substitution matrix, (typically from the\n   ``Bio.Align.substitution_matrices`` submodule), then use it to\n   calculate the total substitution score for the alignment, as well as\n   the number of positive matches.\n - If the argument is a single character, then it is interpreted as the\n   wildcard character. This character is ignored in the calculation of\n   the number of matches, mismatches, and positives.\n - If the argument is pairwise aligner object, then use it to set the\n   wildcard character (if set) and also calculate the alignment score,\n   the gap scores, and the total substitution score. If the aligner has\n   an associated substitution matrix, then use it to calculate these\n   scores, and also calculate the number of positive matches.\n\n>>> aligner = PairwiseAligner(mode='global', match_score=2, mismatch_score=-1)\n>>> for alignment in aligner.align(\"TACCG\", \"ACG\"):\n...     print(\"Score = %.1f:\" % alignment.score)\n...     c = alignment.counts()\n...     print(f\"{c.gaps} gaps, {c.identities} identities, {c.mismatches} mismatches\")\n...     print(alignment)\n...\nScore = 4.0:\n2 gaps, 3 identities, 0 mismatches\ntarget            0 TACCG 5\n                  0 -||-| 5\nquery             0 -AC-G 3\n<BLANKLINE>\nScore = 4.0:\n2 gaps, 3 identities, 0 mismatches\ntarget            0 TACCG 5\n                  0 -|-|| 5\nquery             0 -A-CG 3\n<BLANKLINE>\n\nThe counts are calculated by summing over all pairs of sequences in the\nalignment.\n\nAn `AlignmentCounts` object has the following properties:\n\n - score                      - the alignment score (calculated only if the\n                                argument is a pairwise aligner, and set to None\n                                otherwise);\n - aligned                    - the number of letters aligned to each other in\n                                the alignment;\n - substitution_score         - the total substitution score of letters aligned\n                                to each other (calculated only if the argument\n                                is a pairwise aligner or a substitution matrix,\n                                and set to None otherwise);\n - identities                 - the number of identical letters in the\n                                alignment;\n - mismatches                 - the number of mismatched letters in the\n                                alignment;\n - positives                  - the number of aligned letters with a positive\n                                score (set to None if no substitution matrix is\n                                defined);\n - gap_score                  - the total gap score (calculated only if the\n                                argument is a pairwise aligner, and set to None\n                                otherwise);\n - gaps                       - the total gap length;\n - open_gaps                  - the number of gaps opened in the alignment;\n - extend_gaps                - the number of gap extensions in the alignment;\n - open_left_gaps             - the number of gaps opened on the left side of\n                                the alignment;\n - open_right_gaps            - the number of gaps opened on the right side of\n                                the alignment;\n - open_internal_gaps         - the number of gaps opened in the interior of the\n                                alignment;\n - extend_left_gaps           - the number of gap extensions on the left side of\n                                the alignment;\n - extend_right_gaps          - the number of gap extensions on the right side\n                                of the alignment;\n - extend_internal_gaps       - the number of gap extensions in the interior of\n                                the alignment;\n - open_left_insertions       - the number of insertion gaps opened on the left\n                                side of the alignment;\n - open_left_deletions        - the number of deletion gaps opened on the left\n                                side of the alignment;\n - open_right_insertions      - the number of insertion gaps opened on the right\n                                side of the alignment;\n - open_right_deletions       - the number of deletion gaps opened on the right\n                                side of the alignment;\n - open_internal_insertions   - the number of insertion gaps opened in the\n                                interior of the alignment;\n - open_internal_deletions    - the number of deletion gaps opened in the\n                                interior of the alignment;\n - extend_left_insertions     - the number of insertion gap extensions on the\n                                left side of the alignment;\n - extend_left_deletions      - the number of deletion gap extensions on the\n                                left side of the alignment;\n - extend_right_insertions    - the number of insertion gap extensions on the\n                                right side of the alignment;\n - extend_right_deletions     - the number of deletion gap extensions on the\n                                right side of the alignment;\n - extend_internal_insertions - the number of insertion gap extensions in the\n                                interior of the alignment;\n - extend_internal_deletions  - the number of deletion gap extensions in the\n                                interior of the alignment;\n - left_insertions            - the number of letters inserted on the left side\n                                of the alignment;\n - left_deletions             - the number of letters deleted on the left side\n                                of the alignment;\n - right_insertions           - the number of letters inserted on the right side\n                                of the alignment;\n - right_deletions            - the number of letters deleted on the right side\n                                of the alignment;\n - internal_insertions        - the number of letters inserted in the interior\n                                of the alignment;\n - internal_deletions         - the number of letters deleted in the interior of\n                                the alignment;\n - insertions                 - the total number of letters inserted;\n - deletions                  - the total number of letters deleted;\n - left_gaps                  - the total gap length on the left side of the\n                                alignment;\n - right_gaps                 - the total gap length on the right side of the\n                                alignment;\n - internal_gaps              - the total gap length in the interior of the\n                                alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 3780, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "counts", "signature": "(self, scoring = None)", "symbol_type": "function"}], "covariance": [{"docstring": "Calculate population covariance between two sequences.\n\nUses population formula: Cov(X,Y) = E[(X - E[X])(Y - E[Y])] = E[XY] - E[X]E[Y]\n\nArgs:\n    x: First sequence of values\n    y: Second sequence of values (must match length of x)\n    \nReturns:\n    Population covariance. Returns 0.0 if inputs are empty, mismatched lengths, or invalid.\n    \nExamples:\n    >>> covariance([1, 2, 3], [2, 4, 6])\n    1.333...\n    >>> covariance([1, 1, 1], [2, 3, 4])\n    0.0", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 34, "module": "src.metainformant.math.price", "name": "covariance", "signature": "(x: Sequence[float], y: Sequence[float]) -> float", "symbol_type": "function"}], "coverage_plot": [{"docstring": "Create a coverage plot for sequencing data.\n\nArgs:\n    positions: Genomic positions\n    coverage: Coverage values\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import coverage_plot\n    >>> import numpy as np\n    >>> positions = np.arange(1000, 2000, 10)\n    >>> coverage = np.random.poisson(50, len(positions))\n    >>> ax = coverage_plot(positions, coverage)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/genomics.py", "line_number": 434, "module": "src.metainformant.visualization.genomics", "name": "coverage_plot", "signature": "(positions: Sequence[int], coverage: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "cpu_count": [{"docstring": "Get the number of CPU cores available.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/parallel.py", "line_number": 145, "module": "src.metainformant.core.parallel", "name": "cpu_count", "signature": "() -> int", "symbol_type": "function"}], "cr_class": [{"docstring": "Return covalent radii class for atom or None.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4770, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "cr_class", "signature": "(self) -> str | None", "symbol_type": "function"}], "crc32": [{"docstring": "Return the crc32 checksum for a sequence (string or Seq object).\n\nNote that the case is important:\n\n>>> crc32(\"ACGTACGTACGT\")\n20049947\n>>> crc32(\"acgtACGTacgt\")\n1688586483", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/CheckSum.py", "line_number": 16, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.CheckSum", "name": "crc32", "signature": "(seq)", "symbol_type": "function"}], "crc64": [{"docstring": "Return the crc64 checksum for a sequence (string or Seq object).\n\nNote that the case is important:\n\n>>> crc64(\"ACGTACGTACGT\")\n'CRC-C4FBB762C4A87EBD'\n>>> crc64(\"acgtACGTacgt\")\n'CRC-DA4509DC64A87EBD'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/CheckSum.py", "line_number": 57, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.CheckSum", "name": "crc64", "signature": "(s)", "symbol_type": "function"}], "create": [{"docstring": "Create a Motif object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/__init__.py", "line_number": 35, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.__init__", "name": "create", "signature": "(instances, alphabet = 'ACGT')", "symbol_type": "function"}], "createHit": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HmmerIO/hmmer2_text.py", "line_number": 25, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HmmerIO.hmmer2_text", "name": "createHit", "signature": "(self, hsp_list)", "symbol_type": "function"}], "create_alignment": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/hhr.py", "line_number": 81, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.hhr", "name": "create_alignment", "signature": "()", "symbol_type": "function"}], "create_binary_file": [{"docstring": "Create a binary file with specified content.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 162, "module": "tests.conftest", "name": "create_binary_file", "signature": "(self, path: str, content: bytes) -> Path", "symbol_type": "function"}], "create_composite_abstract": [{"docstring": "Create a composite graphical abstract combining all experiment results.\n\nArgs:\n    experiment_results: Dictionary with keys as experiment names and values as result objects\n    dest: Destination path for the composite figure\n\nReturns:\n    Path to saved composite figure or None if dest is None", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/plotting.py", "line_number": 327, "module": "src.metainformant.math.selection_experiments.plotting", "name": "create_composite_abstract", "signature": "(experiment_results: dict) -> Path | None", "symbol_type": "function"}], "create_config_from_package": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/config.py", "line_number": 24, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.config", "name": "create_config_from_package", "signature": "(args)", "symbol_type": "function"}], "create_example_sequences": [{"docstring": "Create example event sequences for demonstration.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/life_course_example.py", "line_number": 39, "module": "scripts.life_events.life_course_example", "name": "create_example_sequences", "signature": "()", "symbol_type": "function"}], "create_file": [{"docstring": "Create a file with specified content.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 154, "module": "tests.conftest", "name": "create_file", "signature": "(self, path: str, content: str) -> Path", "symbol_type": "function"}], "create_interactive_heatmap": [{"docstring": "Create an interactive heatmap.\n\nArgs:\n    data: 2D array of values\n    x_labels: Optional x-axis labels\n    y_labels: Optional y-axis labels\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Plotly figure object\n\nExample:\n    >>> from metainformant.visualization.interactive import create_interactive_heatmap\n    >>> import numpy as np\n    >>> data = np.random.random((10, 10)).tolist()\n    >>> fig = create_interactive_heatmap(data)\n    >>> fig.show()", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/interactive.py", "line_number": 77, "module": "src.metainformant.visualization.interactive", "name": "create_interactive_heatmap", "signature": "(data: list[list[float]], **kwargs) -> Any", "symbol_type": "function"}], "create_interactive_scatter": [{"docstring": "Create an interactive scatter plot.\n\nArgs:\n    x: X-axis values\n    y: Y-axis values\n    labels: Optional labels for hover tooltips\n    colors: Optional color values\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Plotly figure object\n\nExample:\n    >>> from metainformant.visualization.interactive import create_interactive_scatter\n    >>> import numpy as np\n    >>> x = np.random.random(100)\n    >>> y = np.random.random(100)\n    >>> fig = create_interactive_scatter(x, y)\n    >>> fig.show()", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/interactive.py", "line_number": 21, "module": "src.metainformant.visualization.interactive", "name": "create_interactive_scatter", "signature": "(x: list[float], y: list[float], **kwargs) -> Any", "symbol_type": "function"}], "create_multi_panel": [{"docstring": "Create a multi-panel figure layout.\n\nArgs:\n    n_panels: Number of panels\n    layout: Layout type ('grid', 'vertical', 'horizontal')\n    figsize: Figure size tuple\n    **kwargs: Additional arguments for subplots\n\nReturns:\n    Tuple of (figure, list of axes)\n\nExample:\n    >>> from metainformant.visualization.layout import create_multi_panel\n    >>> fig, axes = create_multi_panel(4, layout='grid')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/layout.py", "line_number": 55, "module": "src.metainformant.visualization.layout", "name": "create_multi_panel", "signature": "(n_panels: int, layout: str = 'grid', **kwargs) -> tuple[plt.Figure, list]", "symbol_type": "function"}], "create_network": [{"docstring": "Create a biological network with specified nodes.\n\nConvenience function to create a network and add nodes in one step.\n\nArgs:\n    nodes: List of node identifier strings\n    directed: If True, network is directed. If False (default), undirected.\n    \nReturns:\n    BiologicalNetwork object with specified nodes but no edges\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\"], directed=False)\n    >>> network.num_nodes()\n    3", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 219, "module": "src.metainformant.networks.graph", "name": "create_network", "signature": "(nodes: List[str], directed: bool = False) -> BiologicalNetwork", "symbol_type": "function"}, {"docstring": "Convert ProteinNetwork to BiologicalNetwork object.\n\nCreates a graph representation of the protein interactions with\nfiltering by confidence and evidence types. Edge weights represent\ninteraction confidence.\n\nArgs:\n    min_confidence: Minimum confidence score (0-1) for including\n        interactions. Default 0.4 (medium confidence). Higher values\n        create sparser, higher-quality networks.\n    evidence_filter: Optional list of evidence types to include.\n        If provided, only interactions with at least one matching\n        evidence type are included. Common values:\n        [\"experimental\"] - only experimentally validated\n        [\"database\", \"experimental\"] - exclude textmining\n        \nReturns:\n    BiologicalNetwork object with:\n    - Nodes: All proteins\n    - Edges: Filtered interactions with confidence as edge weight\n    - Node attributes: Protein metadata if available\n    \nExamples:\n    >>> ppi = ProteinNetwork()\n    >>> ppi.add_interaction(\"P1\", \"P2\", confidence=0.8, evidence_types=[\"experimental\"])\n    >>> ppi.add_interaction(\"P1\", \"P3\", confidence=0.3)\n    >>> network = ppi.create_network(min_confidence=0.5)\n    >>> network.num_edges()\n    1  # Only high-confidence interaction included", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 276, "module": "src.metainformant.networks.ppi", "name": "create_network", "signature": "(self, min_confidence: float = 0.4, evidence_filter: Optional[List[str]] = None) -> BiologicalNetwork", "symbol_type": "function"}, {"docstring": "Convert GeneRegulatoryNetwork to BiologicalNetwork object.\n\nCreates a directed graph representation of regulatory interactions\nwith filtering by confidence and regulation type. Edge weights\ncombine regulatory strength and confidence.\n\nArgs:\n    min_confidence: Minimum confidence score (0-1) for including\n        regulations. Default 0.0 includes all regulations.\n    regulation_filter: Optional list of regulation types to include.\n        If provided, only regulations matching these types are included.\n        Valid values: \"activation\", \"repression\", \"unknown\"\n        \nReturns:\n    BiologicalNetwork object (directed=True) with:\n    - Nodes: All genes (marked as TFs if applicable)\n    - Edges: Filtered regulatory interactions\n    - Edge weights: strength \u00d7 confidence\n    - Node attributes: Gene metadata if available\n    \nExamples:\n    >>> grn = GeneRegulatoryNetwork()\n    >>> grn.add_regulation(\"TF1\", \"GENE1\", regulation_type=\"activation\", confidence=0.8)\n    >>> grn.add_regulation(\"TF1\", \"GENE2\", regulation_type=\"repression\", confidence=0.3)\n    >>> network = grn.create_network(\n    ...     min_confidence=0.5,\n    ...     regulation_filter=[\"activation\"]\n    ... )\n    >>> network.num_edges()\n    1  # Only high-confidence activation included", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 363, "module": "src.metainformant.networks.regulatory", "name": "create_network", "signature": "(self, min_confidence: float = 0.0, regulation_filter: Optional[List[str]] = None) -> BiologicalNetwork", "symbol_type": "function"}], "create_pathway_network": [{"docstring": "Create network where pathways are nodes connected by gene overlap.\n\nConstructs a BiologicalNetwork where each pathway becomes a node,\nand edges connect pathways that share genes. Edge weights represent\nJaccard similarity. Useful for pathway clustering and hierarchical\nanalysis.\n\nArgs:\n    min_overlap: Minimum number of shared genes required for edge.\n        Higher values create sparser networks.\n    min_jaccard: Minimum Jaccard similarity (0-1) required for edge.\n        Higher values require more similar pathway composition.\n\nReturns:\n    BiologicalNetwork object with pathways as nodes. Nodes retain\n    pathway metadata as attributes. Edge weights are Jaccard indices.\n    \nExamples:\n    >>> pn = PathwayNetwork()\n    >>> pn.add_pathway(\"path1\", [\"GENE1\", \"GENE2\", \"GENE3\"])\n    >>> pn.add_pathway(\"path2\", [\"GENE2\", \"GENE3\", \"GENE4\"])\n    >>> network = pn.create_pathway_network(min_overlap=1, min_jaccard=0.3)\n    >>> network.num_edges()\n    1  # path1 and path2 connected", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 259, "module": "src.metainformant.networks.pathway", "name": "create_pathway_network", "signature": "(self, min_overlap: int = 2, min_jaccard: float = 0.1) -> BiologicalNetwork", "symbol_type": "function"}], "create_sample_config": [{"docstring": "Create a sample configuration file for testing.\n\nArgs:\n    output_path: Path to save sample config\n    sample_type: Type of sample config ('basic', 'advanced', 'scientific')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/workflow.py", "line_number": 157, "module": "src.metainformant.core.workflow", "name": "create_sample_config", "signature": "(output_path: str | Path, sample_type: str = 'basic') -> None", "symbol_type": "function"}], "create_subplot_grid": [{"docstring": "Create a subplot grid for multiple plots.\n\nArgs:\n    n_plots: Number of plots\n    ncols: Number of columns\n    figsize: Figure size tuple (if None, auto-calculates)\n    sharex: Whether to share x-axis\n    sharey: Whether to share y-axis\n\nReturns:\n    Tuple of (figure, axes array)\n\nExample:\n    >>> from metainformant.visualization.layout import create_subplot_grid\n    >>> fig, axes = create_subplot_grid(6, ncols=3)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/layout.py", "line_number": 13, "module": "src.metainformant.visualization.layout", "name": "create_subplot_grid", "signature": "(n_plots: int, ncols: int = 3) -> tuple[plt.Figure, np.ndarray]", "symbol_type": "function"}], "create_temp_file": [{"docstring": "Create a temporary file path that doesn't exist yet.\n\nArgs:\n    suffix: File extension\n    prefix: Filename prefix\n    directory: Directory for temp file (uses system temp if None)\n\nReturns:\n    Path to non-existent temporary file", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 180, "module": "src.metainformant.core.paths", "name": "create_temp_file", "signature": "(suffix: str = '', prefix: str = 'tmp', directory: str | Path | None = None) -> Path", "symbol_type": "function"}], "create_test_model": [{"docstring": "Create and save a test model.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 46, "module": "tests.test_life_events_cli", "name": "create_test_model", "signature": "(tmp_path: Path) -> Path", "symbol_type": "function"}], "create_test_sequences_file": [{"docstring": "Create a test event sequences JSON file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 24, "module": "tests.test_life_events_cli", "name": "create_test_sequences_file", "signature": "(tmp_path: Path) -> Path", "symbol_type": "function"}], "crop_matrix": [{"docstring": "Return a matrix without deleted taxa and excluded characters.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 1910, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "crop_matrix", "signature": "(self, matrix = None, delete = (), exclude = ())", "symbol_type": "function"}], "cross_cohort_forest": [{"docstring": "Forest plot for meta-analysis across cohorts.\n\nShows effect estimates from multiple studies for a specific variant.\n\nArgs:\n    cohort_results: Dictionary of {cohort_name: results}\n    output_path: Output path\n    variant_id: Variant identifier (e.g., \"chr1:12345\")\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_comparison.py", "line_number": 309, "module": "src.metainformant.gwas.visualization_comparison", "name": "cross_cohort_forest", "signature": "(cohort_results: dict[str, list[dict[str, Any]]], output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "cross_entropy": [{"docstring": "Calculate cross-entropy H(P, Q).\n\nMeasures the average number of bits needed to encode events from\ndistribution P using a code optimized for distribution Q.\n\nArgs:\n    p: True probability distribution P\n    q: Approximate probability distribution Q\n    base: Logarithm base\n    \nReturns:\n    Cross-entropy H(P, Q) = -\u03a3 p_i \u00d7 log(q_i)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 339, "module": "src.metainformant.information.syntactic", "name": "cross_entropy", "signature": "(p: Sequence[float], q: Sequence[float], base: float = 2.0) -> float", "symbol_type": "function"}], "cross_validate": [{"docstring": "Perform cross-validation.\n\nArgs:\n    model_func: Function that returns trained model (or use classifier_func)\n    X: Feature matrix\n    y: Target vector\n    cv: Number of cross-validation folds (or use cv_folds)\n    scoring: Scoring metric\n    random_state: Random seed\n    classifier_func: Alternative name for model_func (for compatibility)\n    cv_folds: Alternative name for cv (for compatibility)\n    **model_kwargs: Parameters for model_func\n\nReturns:\n    Dictionary with validation scores and statistics including mean_accuracy, std_accuracy, fold_results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/validation.py", "line_number": 121, "module": "src.metainformant.ml.validation", "name": "cross_validate", "signature": "(model_func: Callable = None, X: np.ndarray = None, y: np.ndarray = None, cv: int = 5, scoring: str = 'accuracy', random_state: Optional[int] = None, classifier_func: Callable = None, cv_folds: int = None, **model_kwargs) -> Dict[str, Any]", "symbol_type": "function"}], "cross_validate_biological": [{"docstring": "Cross-validation for biological classifier.\n\nArgs:\n    X: Feature matrix\n    y: Labels\n    algorithm: Classification algorithm\n    cv_folds: Number of CV folds\n    random_state: Random seed\n\nReturns:\n    Dictionary of metric_name -> list of fold scores", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/classification.py", "line_number": 479, "module": "src.metainformant.ml.classification", "name": "cross_validate_biological", "signature": "(X: np.ndarray, y: np.ndarray, algorithm: str = 'random_forest', cv_folds: int = 5, random_state: Optional[int] = None) -> Dict[str, List[float]]", "symbol_type": "function"}], "csca": [{"docstring": "Run `amalgkit csca` (cross-species correlation analysis and plots).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 591, "module": "src.metainformant.rna.amalgkit", "name": "csca", "signature": "(params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}], "csca_dir": [{"docstring": "Path to CSCA statistical test results directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/configs.py", "line_number": 59, "module": "src.metainformant.rna.configs", "name": "csca_dir", "signature": "(self) -> Path", "symbol_type": "function"}], "csca_main": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/csca.py", "line_number": 39, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.csca", "name": "csca_main", "signature": "(args)", "symbol_type": "function"}], "cslice": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 117, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "cslice", "signature": "(p)", "symbol_type": "function"}], "cstatus": [{"docstring": "Summarize character.\n\nnarrow=True:  paup-mode (a c ? --> ac; ? ? ? --> ?)\nnarrow=false:           (a c ? --> a c g t -; ? ? ? --> a c g t -)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 1872, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "cstatus", "signature": "(self, site, delete = (), narrow = True)", "symbol_type": "function"}], "cstmm": [{"docstring": "Run `amalgkit cstmm` (cross-species TMM normalization).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 581, "module": "src.metainformant.rna.amalgkit", "name": "cstmm", "signature": "(params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}], "cstmm_dir": [{"docstring": "Path to CSTMM statistical test results directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/configs.py", "line_number": 49, "module": "src.metainformant.rna.configs", "name": "cstmm_dir", "signature": "(self) -> Path", "symbol_type": "function"}], "cstmm_main": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/cstmm.py", "line_number": 45, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.cstmm", "name": "cstmm_main", "signature": "(args)", "symbol_type": "function"}], "cumulative_gc_skew": [{"docstring": "Cumulative GC skew walk: +1 for G, -1 for C, 0 otherwise; returns floats.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/composition.py", "line_number": 19, "module": "src.metainformant.dna.composition", "name": "cumulative_gc_skew", "signature": "(seq: str) -> List[float]", "symbol_type": "function"}], "curate": [{"docstring": "Run `amalgkit curate` (detect outliers and unwanted biases).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 586, "module": "src.metainformant.rna.amalgkit", "name": "curate", "signature": "(params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}], "curate_dir": [{"docstring": "Path to curation results directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/configs.py", "line_number": 54, "module": "src.metainformant.rna.configs", "name": "curate_dir", "signature": "(self) -> Path", "symbol_type": "function"}], "curate_main": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/curate.py", "line_number": 77, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.curate", "name": "curate_main", "signature": "(args)", "symbol_type": "function"}], "current_suppliers": [{"docstring": "List the current suppliers for the restriction batch.\n\nReturn a sorted list of the suppliers which have been used to\ncreate the batch.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2084, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "current_suppliers", "signature": "(self)", "symbol_type": "function"}], "cut": [{"docstring": "Create clusters by cutting the hierarchical clustering tree.\n\nDivide the elements in a hierarchical clustering result mytree\ninto clusters, and return an array with the number of the cluster\nto which each element was assigned.\n\nKeyword arguments:\n - nclusters: The desired number of clusters.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 86, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "cut", "signature": "(self, nclusters = None)", "symbol_type": "function"}], "cut_once": [{"docstring": "Return if the cutting pattern has one cut.\n\nTrue if the enzyme cut the sequence one time on each strand.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 694, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "cut_once", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the cutting pattern has one cut.\n\nTrue if the enzyme cut the sequence one time on each strand.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 773, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "cut_once", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the cutting pattern has one cut.\n\nTrue if the enzyme cut the sequence one time on each strand.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 852, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "cut_once", "signature": "(cls)", "symbol_type": "function"}], "cut_twice": [{"docstring": "Return if the cutting pattern has two cuts.\n\nTrue if the enzyme cut the sequence twice on each strand.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 702, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "cut_twice", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the cutting pattern has two cuts.\n\nTrue if the enzyme cut the sequence twice on each strand.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 781, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "cut_twice", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the cutting pattern has two cuts.\n\nTrue if the enzyme cut the sequence twice on each strand.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 860, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "cut_twice", "signature": "(cls)", "symbol_type": "function"}], "darken": [{"docstring": "Return darkened color as a ReportLab RGB color.\n\nTake a passed color and returns a Reportlab color that is darker by the\nfactor indicated in the parameter.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/KGML_vis.py", "line_number": 43, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.KGML_vis", "name": "darken", "signature": "(color, factor = 0.7)", "symbol_type": "function"}], "data": [{"docstring": "Overrides the data attribute of UserList.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/__init__.py", "line_number": 847, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.__init__", "name": "data", "signature": "(self)", "symbol_type": "function"}], "data_file_division": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 374, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "data_file_division", "signature": "(self, division)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 921, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "data_file_division", "signature": "(self, content)", "symbol_type": "function"}], "data_generator": [{"docstring": "Extract population data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/LargeFileParser.py", "line_number": 102, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.LargeFileParser", "name": "data_generator", "signature": "(self)", "symbol_type": "function"}], "data_quartiles": [{"docstring": "Return (minimum, lowerQ, medianQ, upperQ, maximum) values as a tuple.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_GraphSet.py", "line_number": 126, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._GraphSet", "name": "data_quartiles", "signature": "(self)", "symbol_type": "function"}], "data_table": [{"docstring": "Generate a data table from a list of input xpk files.\n\nParameters\n----------\nfn_list : list\n    List of .xpk file names.\ndatalabel : str\n    The data element reported.\nkeyatom : str\n    The name of the nucleus used as an index for the data table.\n\nReturns\n-------\noutlist : list\n   List of table rows indexed by ``keyatom``.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/NMR/xpktools.py", "line_number": 243, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.NMR.xpktools", "name": "data_table", "signature": "(fn_list, datalabel, keyatom)", "symbol_type": "function"}], "datasets_cli_available": [{"docstring": "Check if NCBI datasets CLI tool is available on PATH.\n\nReturns:\n    True if 'datasets' command is found, False otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/ncbi.py", "line_number": 106, "module": "src.metainformant.dna.ncbi", "name": "datasets_cli_available", "signature": "() -> bool", "symbol_type": "function"}], "date": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 377, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "date", "signature": "(self, submit_date)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 924, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "date", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": "Create date object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 544, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "date", "signature": "(self, elem)", "symbol_type": "function"}], "db_source": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 517, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "db_source", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 977, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "db_source", "signature": "(self, content)", "symbol_type": "function"}], "dblink": [{"docstring": "Store DBLINK cross references as dbxrefs in our record object.\n\nThis line type is expected to replace the PROJECT line in 2009. e.g.\n\nDuring transition::\n\n    PROJECT     GenomeProject:28471\n    DBLINK      Project:28471\n                Trace Assembly Archive:123456\n\nOnce the project line is dropped::\n\n    DBLINK      Project:28471\n                Trace Assembly Archive:123456\n\nNote GenomeProject -> Project.\n\nWe'll have to see some real examples to be sure, but based on the\nabove example we can expect one reference per line.\n\nNote that at some point the NCBI have included an extra space, e.g.::\n\n    DBLINK      Project: 28471", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 464, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "dblink", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 989, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "dblink", "signature": "(self, content)", "symbol_type": "function"}], "dbxrefs": [{"docstring": "Database cross references.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeq.py", "line_number": 545, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeq", "name": "dbxrefs", "signature": "(self) -> list[str]", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeq.py", "line_number": 552, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeq", "name": "dbxrefs", "signature": "(self, value: list[str]) -> None", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeq.py", "line_number": 556, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeq", "name": "dbxrefs", "signature": "(self) -> None", "symbol_type": "function"}], "ddm_analytic_accuracy": [{"docstring": "Calculate closed-form accuracy for symmetric drift-diffusion model (DDM).\n\nComputes the probability of correct choice in a two-alternative forced choice\ndecision-making task. The DDM models decision-making as a stochastic process\nwhere evidence accumulates until a threshold is reached.\n\nArgs:\n    drift_rate: Mean rate of evidence accumulation (v)\n    boundary: Decision threshold (a)\n    noise_sd: Standard deviation of noise (sigma), default 1.0\n    \nReturns:\n    Probability of correct choice in [0, 1]. Returns 0.5 for invalid inputs.\n    Formula: P(correct) = 1 / (1 + exp(-2*v*a/sigma^2)) when starting at 0.\n    \nExamples:\n    >>> ddm_analytic_accuracy(drift_rate=0.5, boundary=1.0, noise_sd=1.0)\n    0.731...\n    >>> ddm_analytic_accuracy(drift_rate=0.0, boundary=1.0, noise_sd=1.0)\n    0.5\n    \nReferences:\n    Ratcliff, R., & McKoon, G. (2008). The diffusion decision model: theory\n    and data for two-choice decision tasks. Neural computation, 20(4), 873-922.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/ddm.py", "line_number": 6, "module": "src.metainformant.math.ddm", "name": "ddm_analytic_accuracy", "signature": "(drift_rate: float, boundary: float, noise_sd: float = 1.0) -> float", "symbol_type": "function"}], "ddm_mean_decision_time": [{"docstring": "Calculate approximate mean decision time for symmetric drift-diffusion model.\n\nEstimates the expected time until a decision boundary is reached in a\ntwo-alternative forced choice task.\n\nArgs:\n    drift_rate: Mean rate of evidence accumulation (v)\n    boundary: Decision threshold (a)\n    noise_sd: Standard deviation of noise (sigma), default 1.0\n    \nReturns:\n    Expected decision time. Returns 0.0 for invalid inputs.\n    Formula: E[T] \u2248 (a/v) * tanh(a*v/sigma^2) for v != 0.\n    For small v (drift_rate < 1e-8), uses diffusion-limited approximation a^2/sigma^2.\n    \nExamples:\n    >>> ddm_mean_decision_time(drift_rate=0.5, boundary=1.0, noise_sd=1.0)\n    1.928...\n    >>> ddm_mean_decision_time(drift_rate=0.0, boundary=1.0, noise_sd=1.0)\n    1.0\n    \nReferences:\n    Ratcliff, R., & McKoon, G. (2008). The diffusion decision model: theory\n    and data for two-choice decision tasks. Neural computation, 20(4), 873-922.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/ddm.py", "line_number": 41, "module": "src.metainformant.math.ddm", "name": "ddm_mean_decision_time", "signature": "(drift_rate: float, boundary: float, noise_sd: float = 1.0) -> float", "symbol_type": "function"}], "debug": [{"docstring": "Debug status\n\n:param value: The debug status, True or False.\n:type: bool", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 298, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "debug", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Debug status\n\n:param value: The debug status, True or False.\n:type: bool", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 307, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "debug", "signature": "(self, value)", "symbol_type": "function"}], "decode": [{"docstring": "Decode the data as bytes using the codec registered for encoding.\n\nencoding\n  The encoding with which to decode the bytes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 152, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "decode", "signature": "(self, encoding = 'utf-8')", "symbol_type": "function"}, {"docstring": "Decode the arguments for the _align function.\n\nkeywds will get passed to it, so translate the arguments\nto this function into forms appropriate for _align.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/pairwise2.py", "line_number": 414, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.pairwise2", "name": "decode", "signature": "(self, *args, **keywds)", "symbol_type": "function"}], "decorator": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/errors.py", "line_number": 128, "module": "src.metainformant.core.errors", "name": "decorator", "signature": "(func: Callable[..., T]) -> Callable[..., T]", "symbol_type": "function"}], "deduplicate": [{"docstring": "Remove adjacent duplicate points.\n\nThis is important for use with the Polygon class since reportlab has a\nbug with duplicate points.\n\nArguments:\n - points - list of points [x1, y1, x2, y2,...]\n\nReturns a list in the same format with consecutive duplicates removed", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_AbstractDrawer.py", "line_number": 311, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._AbstractDrawer", "name": "deduplicate", "signature": "(points)", "symbol_type": "function"}], "default_dihedron": [{"docstring": "Create Dihedron based on same residue class dihedra in ref database.\n\nAdds Dihedron to current Chain.internal_coord, see ic_data for default\nvalues and reference database source.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 306, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "default_dihedron", "signature": "(ek: list, ric: IC_Residue) -> None", "symbol_type": "function"}], "default_hedron": [{"docstring": "Create Hedron based on same re_class hedra in ref database.\n\nAdds Hedron to current Chain.internal_coord, see ic_data for default\nvalues and reference database source.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 211, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "default_hedron", "signature": "(ek: tuple, ric: IC_Residue) -> None", "symbol_type": "function"}], "defined": [{"docstring": "Return True if the sequence is defined, False if undefined or partially defined.\n\nZero-length sequences are always considered to be defined.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 343, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "defined", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return True if the sequence is defined, False if undefined or partially defined.\n\nZero-length sequences are always considered to be defined.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2000, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "defined", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return False, as the sequence is not defined and has a non-zero length.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2449, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "defined", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return False, as the sequence is not fully defined and has a non-zero length.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2674, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "defined", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return only results from enzymes that produce defined overhangs.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2404, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "defined", "signature": "(self, dct = None)", "symbol_type": "function"}], "defined_ranges": [{"docstring": "Return a tuple of the ranges where the sequence contents is defined.\n\nThe return value has the format ((start1, end1), (start2, end2), ...).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 351, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "defined_ranges", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a tuple of the ranges where the sequence contents is defined.\n\nThe return value has the format ((start1, end1), (start2, end2), ...).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2011, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "defined_ranges", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a tuple of the ranges where the sequence contents is defined.\n\nAs the sequence contents of an _UndefinedSequenceData object is fully\nundefined, the return value is always an empty tuple.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2454, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "defined_ranges", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a tuple of the ranges where the sequence contents is defined.\n\nThe return value has the format ((start1, end1), (start2, end2), ...).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2679, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "defined_ranges", "signature": "(self)", "symbol_type": "function"}], "definition": [{"docstring": "Set the definition as the description of the sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 380, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "definition", "signature": "(self, definition)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 927, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "definition", "signature": "(self, content)", "symbol_type": "function"}], "degenerate_consensus": [{"docstring": "Return the degenerate consensus sequence.\n\nFollowing the rules adapted from\nD. R. Cavener: \"Comparison of the consensus sequence flanking\ntranslational start sites in Drosophila and vertebrates.\"\nNucleic Acids Research 15(4): 1353-1361. (1987).\n\nThe same rules are used by TRANSFAC.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/__init__.py", "line_number": 424, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.__init__", "name": "degenerate_consensus", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the degenerate consensus sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 165, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "degenerate_consensus", "signature": "(self)", "symbol_type": "function"}], "del_feature": [{"docstring": "Delete a feature.\n\nArguments:\n - feature_id: Unique id of the feature to delete\n\nRemove a feature from the set, indicated by its id.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_FeatureSet.py", "line_number": 76, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._FeatureSet", "name": "del_feature", "signature": "(self, feature_id)", "symbol_type": "function"}], "del_graph": [{"docstring": "Remove a graph from the set, indicated by its id.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_GraphSet.py", "line_number": 102, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._GraphSet", "name": "del_graph", "signature": "(self, graph_id)", "symbol_type": "function"}], "del_set": [{"docstring": "Remove the set with the passed id from the track.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Track.py", "line_number": 226, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Track", "name": "del_set", "signature": "(self, set_id)", "symbol_type": "function"}], "del_track": [{"docstring": "Remove the track to be drawn at a particular level on the diagram.\n\nArguments:\n    - track_level   - an integer. The level of the track on the diagram\n      to delete.\n\ndel_track(self, track_level)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Diagram.py", "line_number": 328, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Diagram", "name": "del_track", "signature": "(self, track_level)", "symbol_type": "function"}], "delete_sample_fastqs": [{"docstring": "Delete FASTQ files for a specific sample.\n\nSearches for FASTQ files in both getfastq subdirectory and direct structure,\nand removes them to free disk space.\n\nArgs:\n    sample_id: SRA accession ID (e.g., \"SRR1234567\")\n    fastq_dir: Base directory containing FASTQ files", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/getfastq.py", "line_number": 699, "module": "src.metainformant.rna.steps.getfastq", "name": "delete_sample_fastqs", "signature": "(sample_id: str, fastq_dir: Path) -> None", "symbol_type": "function"}], "delta": [{"docstring": "Create mutation/drift function.\n\nArgs:\n    mu: Mean mutation effect\n    sigma: Standard deviation of mutation effects\n    \nReturns:\n    Mutation function that adds random changes", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/model.py", "line_number": 157, "module": "src.metainformant.math.selection_experiments.model", "name": "delta", "signature": "(mu: float, sigma: float) -> Callable[[np.ndarray], np.ndarray]", "symbol_type": "function"}], "delta_mean_trait": [{"docstring": "Change in mean trait \u0394z\u0304 given fitness and trait values.\n\nEquivalent to the total term from ``price_equation``.\nIf ``trait_offspring`` is None, returns Cov(w_rel, z).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 311, "module": "src.metainformant.math.price", "name": "delta_mean_trait", "signature": "(fitness: Sequence[float], trait_parent: Sequence[float], trait_offspring: Sequence[float] | None = None) -> float", "symbol_type": "function"}], "density": [{"docstring": "Calculate network density (fraction of possible edges present).\n\nDensity measures how connected a network is, ranging from 0 (no edges)\nto 1 (fully connected). For directed networks, maximum edges is n(n-1).\nFor undirected networks, maximum edges is n(n-1)/2.\n\nReturns:\n    Density value in [0, 1]. Returns 0.0 if network has fewer than 2 nodes.\n    Formula: density = actual_edges / max_possible_edges\n    \nExamples:\n    >>> network = BiologicalNetwork(directed=False)\n    >>> network.add_node(\"A\"); network.add_node(\"B\"); network.add_node(\"C\")\n    >>> network.add_edge(\"A\", \"B\")\n    >>> network.density()  # 1 edge out of 3 possible\n    0.333...", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 194, "module": "src.metainformant.networks.graph", "name": "density", "signature": "(self) -> float", "symbol_type": "function"}], "density_plot": [{"docstring": "Create a density plot (kernel density estimation).\n\nArgs:\n    data: Data to plot\n    ax: Matplotlib axes (creates new if None)\n    fill: Whether to fill under the curve\n    alpha: Transparency\n    color: Line/fill color\n    xlabel: X-axis label\n    ylabel: Y-axis label\n    title: Plot title\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import density_plot\n    >>> import numpy as np\n    >>> data = np.random.normal(0, 1, 1000)\n    >>> ax = density_plot(data)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/statistical.py", "line_number": 287, "module": "src.metainformant.visualization.statistical", "name": "density_plot", "signature": "(data: Sequence[float]) -> plt.Axes", "symbol_type": "function"}], "depths": [{"docstring": "Create a mapping of tree clades to depths (by branch length).\n\n:Parameters:\n    unit_branch_lengths : bool\n        If True, count only the number of branches (levels in the tree).\n        By default the distance is the cumulative branch length leading\n        to the clade.\n\n:returns: dict of {clade: depth}, where keys are all of the Clade\n    instances in the tree, and values are the distance from the root to\n    each clade (including terminals).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 456, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "depths", "signature": "(self, unit_branch_lengths = False)", "symbol_type": "function"}], "descend_resolver": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/resolver.py", "line_number": 91, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.resolver", "name": "descend_resolver", "signature": "(self, current_node, current_index)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/resolver.py", "line_number": 91, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.resolver", "name": "descend_resolver", "signature": "(self, current_node, current_index)", "symbol_type": "function"}], "descendants": [{"docstring": "Get all descendant terms (transitive children) of a given term.\n\nReturns the complete set of child terms reachable via is_a relationships,\nexcluding the term itself. Useful for finding all more specific terms.\n\nArgs:\n    onto: Ontology object containing terms\n    term_id: Identifier of the term (e.g., \"GO:0008150\")\n    use_cache: If True, use cached result if available\n    \nReturns:\n    Set of descendant term IDs. Returns empty set if term not found or has no children.\n    \nRaises:\n    ValueError: If term_id is empty or not found in ontology\n    \nExamples:\n    >>> onto = load_go_obo(\"go.obo\")\n    >>> descs = descendants(onto, \"GO:0008150\")  # biological_process\n    >>> len(descs) > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/query.py", "line_number": 134, "module": "src.metainformant.ontology.query", "name": "descendants", "signature": "(onto: Ontology, term_id: str, use_cache: bool = True) -> Set[str]", "symbol_type": "function"}], "description_all": [{"docstring": "Alternative descriptions of the Hit.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/hit.py", "line_number": 337, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.hit", "name": "description_all", "signature": "(self)", "symbol_type": "function"}], "deserialize": [{"docstring": "Deserializes response into an object.\n\n:param response: RESTResponse object to be deserialized.\n:param response_type: For the response, a tuple containing:\n    valid classes\n    a list containing valid classes (for list schemas)\n    a dict containing a tuple of valid classes as the value\n    Example values:\n    (str,)\n    (Pet,)\n    (float, none_type)\n    ([int, none_type],)\n    ({str: (bool, str, int, float, date, datetime, str, none_type)},)\n:param _check_type: boolean, whether to check the types of the data\n    received from the server\n:type _check_type: bool\n\n:return: deserialized object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 289, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "deserialize", "signature": "(self, response, response_type, _check_type)", "symbol_type": "function"}], "deserialize_file": [{"docstring": "Deserializes body to file\n\nSaves response body into a file in a temporary folder,\nusing the filename from the `Content-Disposition` header if provided.\n\nArgs:\n    param response_data (str):  the file data to write\n    configuration (Configuration): the instance to use to convert files\n\nKeyword Args:\n    content_disposition (str):  the value of the Content-Disposition\n        header\n\nReturns:\n    (file_type): the deserialized file which is open\n        The user is responsible for closing and reading the file", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1378, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "deserialize_file", "signature": "(response_data, configuration, content_disposition = None)", "symbol_type": "function"}], "deserialize_model": [{"docstring": "Deserializes model_data to model instance.\n\nArgs:\n    model_data (int/str/float/bool/none_type/list/dict): data to instantiate the model\n    model_class (OpenApiModel): the model class\n    path_to_item (list): path to the model in the received data\n    check_type (bool): whether to check the data tupe for the values in\n        the model\n    configuration (Configuration): the instance to use to convert files\n    spec_property_naming (bool): True if the variable names in the input\n        data are serialized names as specified in the OpenAPI document.\n        False if the variables names in the input data are python\n        variable names in PEP-8 snake case.\n\nReturns:\n    model instance\n\nRaise:\n    ApiTypeError\n    ApiValueError\n    ApiKeyError", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1337, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "deserialize_model", "signature": "(model_data, model_class, path_to_item, check_type, configuration, spec_property_naming)", "symbol_type": "function"}], "deserialize_primitive": [{"docstring": "Deserializes string to primitive type.\n\n:param data: str/int/float\n:param klass: str/class the class to convert to\n\n:return: int, float, str, bool, date, datetime", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1233, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "deserialize_primitive", "signature": "(data, klass, path_to_item)", "symbol_type": "function"}], "detach_child": [{"docstring": "Remove a child.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 260, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "detach_child", "signature": "(self, id)", "symbol_type": "function"}], "detach_parent": [{"docstring": "Remove reference to parent.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 382, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "detach_parent", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Detach the parent.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 256, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "detach_parent", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Detach the parent.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 533, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "detach_parent", "signature": "(self)", "symbol_type": "function"}], "detect_adapter_contamination": [{"docstring": "Detect adapter sequence contamination.\n\nArgs:\n    sequences: List of sequences to check\n    adapter_sequences: List of known adapter sequences\n\nReturns:\n    Dict mapping sequence indices to list of detected adapters", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/contamination.py", "line_number": 123, "module": "src.metainformant.quality.contamination", "name": "detect_adapter_contamination", "signature": "(sequences: List[str], adapter_sequences: List[str] | None = None) -> Dict[str, List[str]]", "symbol_type": "function"}], "detect_communities": [{"docstring": "Detect communities (modules) in a biological network.\n\nIdentifies groups of nodes that are more densely connected internally\nthan externally. Community detection is useful for finding functional\nmodules in biological networks (protein complexes, gene modules, etc.).\n\nArgs:\n    network: Input biological network\n    method: Community detection algorithm:\n        - \"louvain\": Fast modularity optimization (default)\n        - \"greedy\": Greedy modularity maximization\n        - \"leiden\": Leiden algorithm (improved over Louvain)\n    resolution: Resolution parameter for modularity optimization.\n        Higher values find smaller, more numerous communities.\n        Lower values find larger, fewer communities. Default 1.0.\n    seed: Random seed for reproducible results\n    \nReturns:\n    Dictionary mapping node identifier to community ID (integer).\n    Nodes in the same community share the same ID.\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\", \"D\", \"E\"])\n    >>> network.add_edge(\"A\", \"B\"); network.add_edge(\"B\", \"C\")\n    >>> network.add_edge(\"D\", \"E\")\n    >>> communities = detect_communities(network, method=\"louvain\")\n    >>> len(set(communities.values()))  # Number of communities\n    2\n    \nReferences:\n    Blondel, V. D., et al. (2008). Fast unfolding of communities in\n    large networks. Journal of Statistical Mechanics, 2008(10), P10008.\n    \n    Traag, V. A., et al. (2019). From Louvain to Leiden: guaranteeing\n    well-connected communities. Scientific Reports, 9(1), 5233.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/community.py", "line_number": 14, "module": "src.metainformant.networks.community", "name": "detect_communities", "signature": "(network: BiologicalNetwork, method: str = 'louvain', resolution: float = 1.0, seed: Optional[int] = None) -> Dict[str, int]", "symbol_type": "function"}], "detect_communities_analysis": [{"docstring": "Detect network communities.\n\nArgs:\n    network: BiologicalNetwork object\n    output_dir: Output directory for results\n    \nReturns:\n    Dictionary with community detection results", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/networks/run_network_analysis.py", "line_number": 192, "module": "scripts.networks.run_network_analysis", "name": "detect_communities_analysis", "signature": "(network, output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "detect_complexes": [{"docstring": "Detect protein complexes in PPI network.\n\nIdentifies densely connected subgraphs that likely represent\nprotein complexes. Uses community detection to find complexes.\n\nArgs:\n    ppi_network: ProteinNetwork object\n    min_confidence: Minimum interaction confidence for network construction\n    min_size: Minimum complex size (default 3)\n    max_size: Maximum complex size (default 50)\n    \nReturns:\n    List of dictionaries, each containing:\n    - complex_id: Unique identifier for complex\n    - proteins: List of protein IDs in complex\n    - size: Number of proteins\n    - avg_confidence: Average interaction confidence within complex\n    - density: Edge density within complex\n    \nExamples:\n    >>> ppi = ProteinNetwork()\n    >>> # Add dense interactions\n    >>> complexes = detect_complexes(ppi, min_confidence=0.7)\n    >>> len(complexes) > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 847, "module": "src.metainformant.networks.ppi", "name": "detect_complexes", "signature": "(ppi_network: ProteinNetwork, min_confidence: float = 0.7, min_size: int = 3, max_size: int = 50) -> List[Dict[str, Any]]", "symbol_type": "function"}], "detect_cross_species_contamination": [{"docstring": "Detect potential cross-species contamination by comparing sequences\nagainst multiple reference genomes.\n\nArgs:\n    sequences: List of DNA sequences to check\n    reference_genomes: Dict mapping species names to reference sequences\n    threshold: Minimum similarity threshold for contamination detection\n\nReturns:\n    Dict mapping sequence indices to list of potential contaminant species", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/contamination.py", "line_number": 13, "module": "src.metainformant.quality.contamination", "name": "detect_cross_species_contamination", "signature": "(sequences: List[str], reference_genomes: Dict[str, str], threshold: float = 0.1) -> Dict[str, List[str]]", "symbol_type": "function"}], "detect_drive_size_category": [{"docstring": "Detect drive size category based on available free space.\n\nArgs:\n    path: Path to check (directory or file on the drive)\n    \nReturns:\n    \"large\" (> 1TB free), \"medium\" (500GB-1TB free), or \"small\" (< 500GB free)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/disk.py", "line_number": 136, "module": "src.metainformant.core.disk", "name": "detect_drive_size_category", "signature": "(path: Path) -> str", "symbol_type": "function"}], "detect_layout_from_file": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 478, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "detect_layout_from_file", "signature": "(sra_stat)", "symbol_type": "function"}], "detect_mycoplasma_contamination": [{"docstring": "Detect mycoplasma contamination in cell culture samples.\n\nArgs:\n    sequences: List of sequences to check\n    mycoplasma_genome: Mycoplasma reference genome sequence\n\nReturns:\n    Dict mapping sequence indices to contamination status", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/contamination.py", "line_number": 89, "module": "src.metainformant.quality.contamination", "name": "detect_mycoplasma_contamination", "signature": "(sequences: List[str], mycoplasma_genome: str | None = None) -> Dict[str, bool]", "symbol_type": "function"}], "detect_outliers": [{"docstring": "Detect outliers in a sequence of values.\n\nIdentifies values that are unusually high or low using z-score or\nother methods. Optionally applies FDR correction for multiple comparisons.\n\nArgs:\n    values: Sequence of values to test\n    method: Method for outlier detection (\"zscore\", \"iqr\")\n    threshold: Threshold for outlier detection (standard deviations for zscore)\n    fdr_correction: Whether to apply FDR correction\n\nReturns:\n    Dictionary with:\n    - outlier_indices: List of indices of outliers\n    - outlier_values: List of outlier values\n    - z_scores: Z-scores for all values (if method is zscore)\n    - p_values: P-values for all values (if calculable)\n    \nExamples:\n    >>> values = [1.0, 2.0, 3.0, 100.0, 4.0, 5.0]\n    >>> result = detect_outliers(values, threshold=2.0)\n    >>> len(result[\"outlier_indices\"]) > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen_stats.py", "line_number": 191, "module": "src.metainformant.math.popgen_stats", "name": "detect_outliers", "signature": "(values: Sequence[float], method: str = 'zscore', threshold: float = 3.0, fdr_correction: bool = False) -> dict[str, list[int] | list[float]]", "symbol_type": "function"}], "detect_regulatory_cascades": [{"docstring": "Detect regulatory cascades (multi-level regulation chains).\n\nIdentifies chains of regulation where one regulator controls another,\nwhich in turn controls downstream targets. Cascades reveal hierarchical\nregulatory structure.\n\nArgs:\n    grn: Gene regulatory network\n    max_length: Maximum cascade length to detect (default 5)\n    min_confidence: Minimum confidence for regulatory interactions\n    \nReturns:\n    List of cascade dictionaries, each containing:\n    - cascade_id: Unique identifier\n    - length: Number of regulatory steps\n    - regulators: List of regulator IDs in cascade order\n    - target: Final target gene\n    - avg_confidence: Average confidence across cascade\n    \nExamples:\n    >>> grn = GeneRegulatoryNetwork()\n    >>> grn.add_regulation(\"TF1\", \"TF2\", confidence=0.8)\n    >>> grn.add_regulation(\"TF2\", \"GENE1\", confidence=0.9)\n    >>> cascades = detect_regulatory_cascades(grn)\n    >>> len(cascades) > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 991, "module": "src.metainformant.networks.regulatory", "name": "detect_regulatory_cascades", "signature": "(grn: GeneRegulatoryNetwork, max_length: int = 5, min_confidence: float = 0.5) -> List[Dict[str, Any]]", "symbol_type": "function"}], "detect_rrna_contamination": [{"docstring": "Detect ribosomal RNA contamination in sequencing data.\n\nArgs:\n    sequences: List of sequences to check\n    rrna_patterns: List of rRNA sequence patterns (auto-generated if None)\n\nReturns:\n    Dict mapping sequence indices to contamination scores", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/contamination.py", "line_number": 47, "module": "src.metainformant.quality.contamination", "name": "detect_rrna_contamination", "signature": "(sequences: List[str], rrna_patterns: List[str] | None = None) -> Dict[str, float]", "symbol_type": "function"}], "detect_sequence_bias": [{"docstring": "Detect nucleotide composition bias in a sequence.\n\nArgs:\n    seq: DNA sequence to analyze\n\nReturns:\n    Dictionary with bias statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 248, "module": "src.metainformant.dna.sequences", "name": "detect_sequence_bias", "signature": "(seq: str) -> Dict[str, float]", "symbol_type": "function"}], "detect_vector_contamination": [{"docstring": "Detect plasmid or viral vector contamination.\n\nArgs:\n    sequences: List of sequences to check\n    vector_sequences: Dict mapping vector names to sequences\n\nReturns:\n    Dict mapping sequence indices to list of potential vector contaminants", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/contamination.py", "line_number": 160, "module": "src.metainformant.quality.contamination", "name": "detect_vector_contamination", "signature": "(sequences: List[str], vector_sequences: Dict[str, str] | None = None) -> Dict[str, List[str]]", "symbol_type": "function"}], "determine_block_hints": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 980, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "determine_block_hints", "signature": "(self, text)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 980, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "determine_block_hints", "signature": "(self, text)", "symbol_type": "function"}], "determine_encoding": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/reader.py", "line_number": 122, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.reader", "name": "determine_encoding", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/reader.py", "line_number": 122, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.reader", "name": "determine_encoding", "signature": "(self)", "symbol_type": "function"}], "deterministic_seed": [{"docstring": "Generate deterministic integer seed from string data.\n\nArgs:\n    data: String to hash for seed generation\n\nReturns:\n    Integer seed in valid range for random number generators", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/hash.py", "line_number": 24, "module": "src.metainformant.core.hash", "name": "deterministic_seed", "signature": "(data: str) -> int", "symbol_type": "function"}], "df_search": [{"docstring": "Depth first search of g.\n\nReturns a list of all nodes that can be reached from the root node\nin depth-first order.\n\nIf root is not given, the search will be rooted at an arbitrary node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/MultiGraph.py", "line_number": 145, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.MultiGraph", "name": "df_search", "signature": "(graph, root = None)", "symbol_type": "function"}], "dfs": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 35, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "dfs", "signature": "(elem)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 46, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "dfs", "signature": "(elem)", "symbol_type": "function"}], "difference": [{"docstring": "Get angle difference between this and other +/- 180 angles.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4476, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "difference", "signature": "(self, other: 'Dihedron') -> float", "symbol_type": "function"}], "differential_entropy": [{"docstring": "Calculate differential entropy for continuous data.\n\nDifferential entropy extends Shannon entropy to continuous distributions.\nEstimated from samples using histogram or kernel density estimation.\n\nArgs:\n    samples: Array of continuous samples\n    method: Estimation method (\"histogram\" or \"kde\")\n    bins: Number of bins for histogram method (auto if None)\n    \nReturns:\n    Differential entropy estimate in nats (natural log base)\n    \nExamples:\n    >>> import numpy as np\n    >>> samples = np.random.normal(0, 1, 1000)\n    >>> h = differential_entropy(samples)\n    >>> h > 0  # Should be positive\n    True\n    \nRaises:\n    ValueError: If samples array is empty or method is invalid\n    \nReferences:\n    Cover, T. M., & Thomas, J. A. (2006). Elements of Information Theory.\n    John Wiley & Sons.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/continuous.py", "line_number": 17, "module": "src.metainformant.information.continuous", "name": "differential_entropy", "signature": "(samples: np.ndarray, method: str = 'histogram', bins: int | None = None) -> float", "symbol_type": "function"}], "differential_expression_plot": [{"docstring": "Plot top differentially expressed genes.\n\nArgs:\n    data: DataFrame with differential expression results\n    gene_col: Column name for gene names\n    log2fc_col: Column name for log2 fold change\n    pvalue_col: Column name for p-values\n    top_n: Number of top genes to plot\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import differential_expression_plot\n    >>> import pandas as pd\n    >>> data = pd.DataFrame({\n    ...     'gene': ['gene1', 'gene2', 'gene3'],\n    ...     'log2fc': [2.0, -1.5, 1.0],\n    ...     'pvalue': [0.001, 0.01, 0.05]\n    ... })\n    >>> ax = differential_expression_plot(data, top_n=3)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/expression.py", "line_number": 193, "module": "src.metainformant.visualization.expression", "name": "differential_expression_plot", "signature": "(data: pd.DataFrame, gene_col: str = 'gene', log2fc_col: str = 'log2fc', pvalue_col: str = 'pvalue', **kwargs) -> plt.Axes", "symbol_type": "function"}], "differential_methylation": [{"docstring": "Identify differentially methylated regions between two conditions.\n\nCompares methylation levels between two conditions and identifies\nCpG sites with significant differences.\n\nArgs:\n    condition1_df: Methylation data for condition 1 (must have 'chrom', 'pos', 'beta' columns)\n    condition2_df: Methylation data for condition 2 (must have 'chrom', 'pos', 'beta' columns)\n    min_coverage: Minimum coverage required for both conditions\n    min_diff: Minimum absolute difference in beta values to consider significant\n    \nReturns:\n    DataFrame with differentially methylated sites:\n    - 'chrom', 'pos': Genomic coordinates\n    - 'beta1', 'beta2': Beta values for each condition\n    - 'delta_beta': Difference (beta1 - beta2)\n    - 'abs_delta_beta': Absolute difference", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/methylation.py", "line_number": 54, "module": "src.metainformant.epigenome.methylation", "name": "differential_methylation", "signature": "(condition1_df: pd.DataFrame, condition2_df: pd.DataFrame, min_coverage: int = 5, min_diff: float = 0.2) -> pd.DataFrame", "symbol_type": "function"}], "dihedra_check": [{"docstring": "Look for required dihedra in residue, generate defaults if set.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 445, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "dihedra_check", "signature": "(ric: IC_Residue) -> None", "symbol_type": "function"}], "dihedral_signs": [{"docstring": "Get sign array (+1/-1) for each element of chain dihedraAngle array.\n\nRequired for :meth:`.distance_to_internal_coordinates`", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 2040, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "dihedral_signs", "signature": "(self) -> np.ndarray", "symbol_type": "function"}], "directory": [{"docstring": "Directory for caching XSD and DTD files.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 327, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "directory", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Set a custom directory for the local DTD/XSD directories.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 332, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "directory", "signature": "(cls, value)", "symbol_type": "function"}], "discover_config_files": [{"docstring": "Discover all config files matching patterns.\n\nArgs:\n    repo_root: Root directory of repository\n    domain: Optional domain filter (e.g., 'rna', 'gwas', 'amalgkit')\n\nReturns:\n    List of dictionaries with config file information:\n    - path: Path to config file\n    - domain: Domain name (extracted from path)\n    - format: File format ('yaml', 'toml', 'json')\n    - size: File size in bytes\n    - modified_time: Modification timestamp", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 459, "module": "src.metainformant.core.config", "name": "discover_config_files", "signature": "(repo_root: str | Path, domain: str | None = None) -> list[dict[str, Any]]", "symbol_type": "function"}], "discover_configs": [{"docstring": "Discover all config files in the repository.\n\nArgs:\n    repo_root: Root directory of the repository\n    domain: Optional domain filter (e.g., 'rna', 'gwas')\n\nReturns:\n    List of ConfigInfo objects for each discovered config file", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/discovery.py", "line_number": 225, "module": "src.metainformant.core.discovery", "name": "discover_configs", "signature": "(repo_root: str | Path, domain: str | None = None) -> list[ConfigInfo]", "symbol_type": "function"}], "discover_functions": [{"docstring": "Discover all functions in a module with their signatures.\n\nArgs:\n    module_path: Path to Python module file\n    pattern: Optional regex pattern to filter function names\n\nReturns:\n    List of FunctionInfo objects for each discovered function\n\nRaises:\n    FileNotFoundError: If module_path does not exist\n    SyntaxError: If module cannot be parsed", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/discovery.py", "line_number": 136, "module": "src.metainformant.core.discovery", "name": "discover_functions", "signature": "(module_path: str | Path, pattern: str | None = None) -> list[FunctionInfo]", "symbol_type": "function"}], "discover_output_patterns": [{"docstring": "Get output directory patterns for a module.\n\nArgs:\n    module_name: Name of the module (e.g., 'rna', 'gwas', 'dna')\n\nReturns:\n    Dictionary with output pattern information:\n    - base_pattern: Base output pattern\n    - subdirs: List of common subdirectories\n    - examples: Example output paths", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 211, "module": "src.metainformant.core.paths", "name": "discover_output_patterns", "signature": "(module_name: str) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Discover output directory patterns for a module.\n\nArgs:\n    module_name: Name of the module (e.g., 'rna', 'gwas', 'dna')\n\nReturns:\n    OutputPattern with base pattern and subdirectories", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/discovery.py", "line_number": 277, "module": "src.metainformant.core.discovery", "name": "discover_output_patterns", "signature": "(module_name: str) -> OutputPattern", "symbol_type": "function"}], "discover_species_configs": [{"docstring": "Discover all species configuration files.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/validate_all_species_workflow.py", "line_number": 46, "module": "scripts.validate_all_species_workflow", "name": "discover_species_configs", "signature": "() -> list[Tuple[str, Path]]", "symbol_type": "function"}, {"docstring": "Discover all species configs and extract metadata.\n\nArgs:\n    config_dir: Directory containing amalgkit config files\n\nReturns:\n    Dictionary mapping species_id -> {'name': str, 'total': int}", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/orchestration.py", "line_number": 46, "module": "src.metainformant.rna.orchestration", "name": "discover_species_configs", "signature": "(config_dir: Path) -> dict[str, dict[str, Any]]", "symbol_type": "function"}], "discover_workflows": [{"docstring": "Discover all workflow entry points and their configs.\n\nArgs:\n    repo_root: Root directory of repository (defaults to current directory)\n\nReturns:\n    List of dictionaries with workflow information", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/discovery.py", "line_number": 510, "module": "src.metainformant.core.discovery", "name": "discover_workflows", "signature": "(repo_root: str | Path | None = None) -> list[dict[str, Any]]", "symbol_type": "function"}], "discriminator": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_assembly_completeness.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_assembly_completeness", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_peptide.py", "line_number": 109, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_peptide", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_bio_project_lineage.py", "line_number": 94, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_bio_project_lineage", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request_content_type.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request_content_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_prokaryote_gene_request.py", "line_number": 99, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_prokaryote_gene_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_gene.py", "line_number": 99, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_gene", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response_edges_entry.py", "line_number": 94, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response_edges_entry", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_dataset_request.py", "line_number": 100, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_dataset_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_error_virus_error_code.py", "line_number": 87, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_error_virus_error_code", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_filter.py", "line_number": 108, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_filter", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptor_chromosome.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptor_chromosome", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_genomic_region_genomic_region_type.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_genomic_region_genomic_region_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sci_name_and_ids.py", "line_number": 94, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sci_name_and_ids", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_metadata_response.py", "line_number": 97, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_metadata_response", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_message.py", "line_number": 97, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_message", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_filter_assembly_source.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_filter_assembly_source", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_project.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_project", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_feature_counts.py", "line_number": 94, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_feature_counts", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_query_request_tax_rank_filter.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_query_request_tax_rank_filter", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request_sort_field.py", "line_number": 90, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request_sort_field", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_match.py", "line_number": 101, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_match", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotated_assemblies.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotated_assemblies", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request.py", "line_number": 108, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_prokaryote_gene_request_gene_flank_config.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_prokaryote_gene_request_gene_flank_config", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_table_format.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_table_format", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_conserved_domain.py", "line_number": 96, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_conserved_domain", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_query_request.py", "line_number": 99, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_query_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_assembly_status.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_assembly_status", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_warning.py", "line_number": 100, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_warning", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request_sort.py", "line_number": 97, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request_sort", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_query_request_taxon_resource_filter.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_query_request_taxon_resource_filter", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_micro_bigge_dataset_request_file_type.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_micro_bigge_dataset_request_file_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_match.py", "line_number": 104, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_match", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_attribute.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_attribute", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_prokaryote_gene_location_completeness.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_prokaryote_gene_location_completeness", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata_request.py", "line_number": 108, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_mature_peptide.py", "line_number": 90, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_mature_peptide", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_availability_request.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_availability_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response_edge_child_status.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response_edge_child_status", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ortholog_request.py", "line_number": 96, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ortholog_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_filter_assembly_level.py", "line_number": 90, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_filter_assembly_level", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptor_rna_type.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptor_rna_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sleep_request.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sleep_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sort_direction.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sort_direction", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_id.py", "line_number": 90, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_id", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_request_resolution.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_request_resolution", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_transcript.py", "line_number": 109, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_transcript", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary_dehydrated.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary_dehydrated", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_counts.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_counts", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_gene_descriptor_gene_type.py", "line_number": 99, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_gene_descriptor_gene_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_count_by_type.py", "line_number": 97, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_count_by_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_group.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_group", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_fasta.py", "line_number": 94, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_fasta", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_peptide_uni_prot_id.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_peptide_uni_prot_id", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptor.py", "line_number": 119, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptor", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_range.py", "line_number": 98, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_range", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_range.py", "line_number": 97, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_range", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_error_assembly_error_code.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_error_assembly_error_code", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_transcript_transcript_type.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_transcript_transcript_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_element_flank_config.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_element_flank_config", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_availability.py", "line_number": 90, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_availability", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_error_gene_error_code.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_error_gene_error_code", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_genomic_region.py", "line_number": 97, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_genomic_region", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_assembly_type.py", "line_number": 96, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_assembly_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_dataset_request.py", "line_number": 114, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_dataset_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ref_gene_catalog_dataset_request.py", "line_number": 98, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ref_gene_catalog_dataset_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_tax_tree_request.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_tax_tree_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_micro_bigge_dataset_request.py", "line_number": 98, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_micro_bigge_dataset_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_busco_stat.py", "line_number": 95, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_busco_stat", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_availability.py", "line_number": 90, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_availability", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation.py", "line_number": 96, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_assembly.py", "line_number": 128, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_assembly", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_data_report_request_content_type.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_data_report_request_content_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_assembly_collection_location.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_assembly_collection_location", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_table_field.py", "line_number": 108, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_table_field", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_request.py", "line_number": 96, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_metadata_request.py", "line_number": 95, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_metadata_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_protein.py", "line_number": 99, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_protein", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary.py", "line_number": 109, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_match.py", "line_number": 97, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_match", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_virus_type.py", "line_number": 93, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_virus_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response.py", "line_number": 101, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_description.py", "line_number": 96, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_description", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_purpose_of_sampling.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_purpose_of_sampling", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_seq_range_set.py", "line_number": 95, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_seq_range_set", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_genomic_location.py", "line_number": 97, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_genomic_location", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_request_content_type.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_request_content_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_orientation.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_orientation", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata_request_bioprojects.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata_request_bioprojects", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_seq_range_set_fasta.py", "line_number": 98, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_seq_range_set_fasta", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_contact.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_contact", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_warning_replaced_id.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_warning_replaced_id", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_lineage_organism.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_lineage_organism", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sars2_protein_dataset_request.py", "line_number": 109, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sars2_protein_dataset_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_assembly_file.py", "line_number": 95, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_assembly_file", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_filter_assembly_version.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_filter_assembly_version", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_rank_type.py", "line_number": 131, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_rank_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_metadata_request_content_type.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_metadata_request_content_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_error.py", "line_number": 104, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_error", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_count_type.py", "line_number": 101, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_count_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary_file_summary.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary_file_summary", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_linked_assembly_linked_assembly_type.py", "line_number": 96, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_linked_assembly_linked_assembly_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ortholog_set.py", "line_number": 96, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ortholog_set", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_data_report_page.py", "line_number": 100, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_data_report_page", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_method_payload_request.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_method_payload_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_node_count_by_type.py", "line_number": 95, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_node_count_by_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/rpc_status.py", "line_number": 96, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.rpc_status", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_data_report_request.py", "line_number": 101, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_data_report_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptor.py", "line_number": 135, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptor", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sleep_reply.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sleep_reply", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_counts.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_counts", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_tabular_output.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_tabular_output", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism.py", "line_number": 122, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_bio_project.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_bio_project", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sci_name_and_ids_sci_name_and_id.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sci_name_and_ids_sci_name_and_id", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_nomenclature_authority.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_nomenclature_authority", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_descriptor.py", "line_number": 115, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_descriptor", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_metadata.py", "line_number": 98, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_metadata", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_genomic_region_genomic_region_type.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_genomic_region_genomic_region_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_annotation.py", "line_number": 94, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_annotation", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_organism.py", "line_number": 100, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_organism", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_transcript_transcript_type.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_transcript_transcript_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary_hydrated.py", "line_number": 90, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary_hydrated", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_status.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_status", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_assembly.py", "line_number": 105, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_assembly", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_warning_gene_warning_code.py", "line_number": 94, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_warning_gene_warning_code", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_orientation.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_orientation", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_gene_descriptor_rna_type.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_gene_descriptor_rna_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_request.py", "line_number": 103, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_request", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_version_reply.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_version_reply", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptor_gene_type.py", "line_number": 99, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptor_gene_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_owner.py", "line_number": 95, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_owner", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/protobuf_any.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.protobuf_any", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_dataset_filter.py", "line_number": 97, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_dataset_filter", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request_symbols_for_taxon.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request_symbols_for_taxon", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_accessions.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_accessions", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptors.py", "line_number": 97, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptors", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata_request_content_type.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata_request_content_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_assembly_isolate.py", "line_number": 90, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_assembly_isolate", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ref_gene_catalog_dataset_request_file_type.py", "line_number": 90, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ref_gene_catalog_dataset_request_file_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary_available_files.py", "line_number": 101, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary_available_files", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata.py", "line_number": 99, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response_edge.py", "line_number": 95, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response_edge", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_node.py", "line_number": 107, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_node", "name": "discriminator", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ortholog_request_content_type.py", "line_number": 88, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ortholog_request_content_type", "name": "discriminator", "signature": "()", "symbol_type": "function"}], "disordered_add": [{"docstring": "Add a disordered atom.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 560, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "disordered_add", "signature": "(self, atom)", "symbol_type": "function"}, {"docstring": "Add disordered entry.\n\nThis is implemented by DisorderedAtom and DisorderedResidue.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 556, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "disordered_add", "signature": "(self, child)", "symbol_type": "function"}, {"docstring": "Add a residue object and use its resname as key.\n\nArguments:\n - residue - Residue object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Residue.py", "line_number": 161, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Residue", "name": "disordered_add", "signature": "(self, residue)", "symbol_type": "function"}], "disordered_get": [{"docstring": "Get the child object associated with id.\n\nIf id is None, the currently selected child is returned.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 579, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "disordered_get", "signature": "(self, id = None)", "symbol_type": "function"}], "disordered_get_id_list": [{"docstring": "Return a list of id's.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 574, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "disordered_get_id_list", "signature": "(self)", "symbol_type": "function"}], "disordered_get_list": [{"docstring": "Return list of atom instances.\n\nSorts children by altloc (empty, then alphabetical).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 553, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "disordered_get_list", "signature": "(self) -> list[Atom]", "symbol_type": "function"}, {"docstring": "Return list of children.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 588, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "disordered_get_list", "signature": "(self)", "symbol_type": "function"}], "disordered_has_id": [{"docstring": "Check if there is an object present associated with this id.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 529, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "disordered_has_id", "signature": "(self, id)", "symbol_type": "function"}], "disordered_remove": [{"docstring": "Remove a child atom altloc from the DisorderedAtom.\n\nArguments:\n - altloc - name of the altloc to remove, as a string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 574, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "disordered_remove", "signature": "(self, altloc: str)", "symbol_type": "function"}, {"docstring": "Remove disordered entry.\n\nThis is implemented by DisorderedAtom and DisorderedResidue.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 563, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "disordered_remove", "signature": "(self, child)", "symbol_type": "function"}, {"docstring": "Remove a child residue from the DisorderedResidue.\n\nArguments:\n - resname - name of the child residue to remove, as a string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Residue.py", "line_number": 176, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Residue", "name": "disordered_remove", "signature": "(self, resname)", "symbol_type": "function"}], "disordered_select": [{"docstring": "Select the object with given id as the currently active object.\n\nUncaught method calls are forwarded to the selected child object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 549, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "disordered_select", "signature": "(self, id)", "symbol_type": "function"}], "display": [{"docstring": "Quick and dirty lists of all nodes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 609, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "display", "signature": "(self)", "symbol_type": "function"}], "display_generation": [{"docstring": "Display generation statistics and evolution plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/plotting.py", "line_number": 308, "module": "src.metainformant.math.selection_experiments.plotting", "name": "display_generation", "signature": "(gr: GenerationsResult) -> Path | None", "symbol_type": "function"}], "display_gr": [{"docstring": "Create accessible visualization of trait evolution over generations.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/plotting.py", "line_number": 196, "module": "src.metainformant.math.selection_experiments.plotting", "name": "display_gr", "signature": "(gr: GenerationsResult) -> Path | None", "symbol_type": "function"}], "display_s_vs_q": [{"docstring": "Create accessible visualization of structural trait vs quality relationship.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/plotting.py", "line_number": 33, "module": "src.metainformant.math.selection_experiments.plotting", "name": "display_s_vs_q", "signature": "(r: GenerationResult) -> Path | None", "symbol_type": "function"}], "display_sq_vs_w": [{"docstring": "Create accessible visualization of traits vs fitness relationships.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/plotting.py", "line_number": 106, "module": "src.metainformant.math.selection_experiments.plotting", "name": "display_sq_vs_w", "signature": "(r: GenerationResult) -> Path | None", "symbol_type": "function"}], "dispose": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 106, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "dispose", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 89, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "dispose", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 106, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "dispose", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 89, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "dispose", "signature": "(self)", "symbol_type": "function"}], "dist_pearson": [{"docstring": "Return the similarity score based on pearson correlation for the given motif against self.\n\nWe use the Pearson's correlation of the respective probabilities.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 567, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "dist_pearson", "signature": "(self, other)", "symbol_type": "function"}], "dist_pearson_at": [{"docstring": "Return the similarity score based on pearson correlation at the given offset.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 586, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "dist_pearson_at", "signature": "(self, other, offset)", "symbol_type": "function"}], "distance": [{"docstring": "Calculate shortest path distance between two terms.\n\nUses common ancestors to find shortest path. Distance is the number of\nedges in the shortest path, or None if no path exists.\n\nArgs:\n    onto: Ontology object containing terms\n    term1: First term identifier\n    term2: Second term identifier\n    \nReturns:\n    Integer distance (number of edges), or None if no path exists\n    \nRaises:\n    ValueError: If either term_id is empty or not found\n    \nExamples:\n    >>> onto = load_go_obo(\"go.obo\")\n    >>> dist = distance(onto, \"GO:0009987\", \"GO:0008150\")\n    >>> dist is not None\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/query.py", "line_number": 330, "module": "src.metainformant.ontology.query", "name": "distance", "signature": "(onto: Ontology, term1: str, term2: str) -> int | None", "symbol_type": "function"}, {"docstring": "Add and return the sum of the branchlengths between two nodes.\n\ndist = distance(self,node1,node2)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 489, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "distance", "signature": "(self, node1, node2)", "symbol_type": "function"}, {"docstring": "Calculate the sum of the branch lengths between two targets.\n\nIf only one target is specified, the other is the root of this tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 485, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "distance", "signature": "(self, target1, target2 = None)", "symbol_type": "function"}], "distance_plot": [{"docstring": "Generate 2D distance plot from atomArray.\n\nDefault is to calculate distances for all atoms.  To generate the\nclassic C-alpha distance plot, pass a boolean mask array like::\n\n    atmNameNdx = internal_coords.AtomKey.fields.atm\n    CaSelect = [\n        atomArrayIndex.get(k)\n        for k in atomArrayIndex.keys()\n        if k.akl[atmNameNdx] == \"CA\"\n    ]\n    plot = cic.distance_plot(CaSelect)\n\nAlternatively, this will select all backbone atoms::\n\n    backboneSelect = [\n        atomArrayIndex.get(k)\n        for k in atomArrayIndex.keys()\n        if k.is_backbone()\n    ]\n\n:param [bool] filter: restrict atoms for calculation\n\n.. seealso::\n    :meth:`.distance_to_internal_coordinates`, which requires the\n    default all atom distance plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 2002, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "distance_plot", "signature": "(self, filter: np.ndarray | None = None) -> np.ndarray", "symbol_type": "function"}], "distance_to_internal_coordinates": [{"docstring": "Compute chain di/hedra from from distance and chirality data.\n\nDistance properties on hedra L12, L23, L13 and dihedra L14 configured\nby :meth:`.distplot_to_dh_arrays` or alternative loader.\n\ndihedraAngles result is multiplied by dihedra_signs at final step\nrecover chirality information lost in distance plot (mirror image of\nstructure has same distances but opposite sign dihedral angles).\n\nNote that chain breaks will cause errors in rebuilt structure, use\n:meth:`.copy_initNCaCs` to avoid this\n\nBased on Blue, the Hedronometer's answer to `The dihedral angles of a tetrahedron\nin terms of its edge lengths <https://math.stackexchange.com/a/49340/972353>`_\non `math.stackexchange.com <https://math.stackexchange.com/>`_.  See also:\n`\"Heron-like Hedronometric Results for Tetrahedral Volume\"\n<http://daylateanddollarshort.com/mathdocs/Heron-like-Results-for-Tetrahedral-Volume.pdf>`_.\n\nOther values from that analysis included here as comments for\ncompleteness:\n\n* oa = hedron1 L12 if reverse else hedron1 L23\n* ob = hedron1 L23 if reverse else hedron1 L12\n* ac = hedron2 L12 if reverse else hedron2 L23\n* ab = hedron1 L13 = law of cosines on OA, OB (hedron1 L12, L23)\n* oc = hedron2 L13 = law of cosines on OA, AC (hedron2 L12, L23)\n* bc = dihedron L14\n\ntarget is OA, the dihedral angle along edge oa.\n\n:param bool resetAtoms: default True.\n    Mark all atoms in di/hedra and atomArray for updating by\n    :meth:`.internal_to_atom_coordinates`.  Alternatively set this to\n    False and manipulate `atomArrayValid`, `dAtoms_needs_update` and\n    `hAtoms_needs_update` directly to reduce computation.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 2073, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "distance_to_internal_coordinates", "signature": "(self, resetAtoms: bool | None = True) -> None", "symbol_type": "function"}], "distancematrix": [{"docstring": "Calculate and return a distance matrix from the data.\n\nThis function returns the distance matrix calculated from the data.\n\nKeyword arguments:\n - data: nrows x ncolumns array containing the data values.\n - mask: nrows x ncolumns array of integers, showing which data are\n   missing. If mask[i, j]==0, then data[i, j] is missing.\n - weight: the weights to be used when calculating distances.\n - transpose: if False: the distances between rows are calculated;\n              if True:  the distances between columns are calculated.\n - dist: specifies the distance function to be used:\n   - dist == 'e': Euclidean distance\n   - dist == 'b': City Block distance\n   - dist == 'c': Pearson correlation\n   - dist == 'a': absolute value of the correlation\n   - dist == 'u': uncentered correlation\n   - dist == 'x': absolute uncentered correlation\n   - dist == 's': Spearman's rank correlation\n   - dist == 'k': Kendall's tau\n\nReturn value:\nThe distance matrix is returned as a list of 1D arrays containing the\ndistance matrix calculated from the data. The number of columns in eac\nrow is equal to the row number. Hence, the first row has zero length.\nFor example:\n\n>>> from numpy import array\n>>> from Bio.Cluster import distancematrix\n>>> data = array([[0, 1,  2,  3],\n...               [4, 5,  6,  7],\n...               [8, 9, 10, 11],\n...               [1, 2,  3,  4]])\n>>> distances = distancematrix(data, dist='e')\n>>> distances\n[array([], dtype=float64), array([16.]), array([64., 16.]), array([ 1.,  9., 49.])]\n\nwhich can be rewritten as::\n\n    distances = [array([], dtype=float64),\n                 array([ 16.]),\n                 array([ 64.,  16.]),\n                 array([  1.,   9.,  49.])]\n\nThis corresponds to the distance matrix::\n\n    [ 0., 16., 64.,  1.]\n    [16.,  0., 16.,  9.]\n    [64., 16.,  0., 49.]\n    [ 1.,  9., 49.,  0.]", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 520, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "distancematrix", "signature": "(data, mask = None, weight = None, transpose = False, dist = 'e')", "symbol_type": "function"}, {"docstring": "Calculate the distance matrix and return it as a list of arrays.\n\nKeyword arguments:\n - transpose:\n     if False: calculate the distances between genes (rows);\n     if True: calculate the distances between samples (columns).\n - dist: specifies the distance function to be used:\n   - dist == 'e': Euclidean distance\n   - dist == 'b': City Block distance\n   - dist == 'c': Pearson correlation\n   - dist == 'a': absolute value of the correlation\n   - dist == 'u': uncentered correlation\n   - dist == 'x': absolute uncentered correlation\n   - dist == 's': Spearman's rank correlation\n   - dist == 'k': Kendall's tau\n\nReturn value:\n\nThe distance matrix is returned as a list of 1D arrays containing the\ndistance matrix between the gene expression data. The number of columns\nin each row is equal to the row number. Hence, the first row has zero\nlength. An example of the return value is:\n\n    matrix = [[],\n              array([1.]),\n              array([7., 3.]),\n              array([4., 2., 6.])]\n\nThis corresponds to the distance matrix:\n\n    [0., 1., 7., 4.]\n    [1., 0., 3., 2.]\n    [7., 3., 0., 6.]\n    [4., 2., 6., 0.]", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 963, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "distancematrix", "signature": "(self, transpose = False, dist = 'e')", "symbol_type": "function"}], "distplot_to_dh_arrays": [{"docstring": "Load di/hedra distance arrays from distplot.\n\nFill :class:`IC_Chain` arrays hedraL12, L23, L13 and dihedraL14\ndistance value arrays from input distplot, dihedra_signs array from\ninput dihedra_signs.  Distplot and di/hedra distance arrays must index\naccording to AtomKey mappings in :class:`IC_Chain` .hedraNdx and .dihedraNdx\n(created in :meth:`IC_Chain.init_edra`)\n\nCall :meth:`atom_to_internal_coordinates` (or at least :meth:`init_edra`)\nto generate a2ha_map and d2a_map before running this.\n\nExplicitly removed from :meth:`.distance_to_internal_coordinates` so\nuser may populate these chain di/hedra arrays by other\nmethods.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 2047, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "distplot_to_dh_arrays", "signature": "(self, distplot: np.ndarray, dihedra_signs: np.ndarray) -> None", "symbol_type": "function"}], "distribution": [{"docstring": "Create geographic distribution object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 554, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "distribution", "signature": "(self, elem)", "symbol_type": "function"}, {"docstring": "Calculate the distribution of the scores at the given precision.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 612, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "distribution", "signature": "(self, background = None, precision = 10 ** 3)", "symbol_type": "function"}], "dna_complementarity_score": [{"docstring": "Calculate complementarity score between two DNA sequences.\n\nArgs:\n    seq1: First DNA sequence\n    seq2: Second DNA sequence\n\nReturns:\n    Complementarity score (0-1, where 1 is perfectly complementary)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 98, "module": "src.metainformant.dna.sequences", "name": "dna_complementarity_score", "signature": "(seq1: str, seq2: str) -> float", "symbol_type": "function"}], "dna_integration": [{"docstring": "Information-theoretic analysis of DNA sequences.\n\nWrapper for analyzing DNA sequences from the DNA module.\n\nArgs:\n    sequences: Dictionary of sequence ID -> sequence, or list of sequences\n    k: K-mer size for analysis\n    analysis_type: Type of analysis (\"entropy\", \"profile\", \"comparison\")\n    \nReturns:\n    Analysis results dictionary\n    \nExamples:\n    >>> from metainformant.dna import sequences\n    >>> dna_seqs = sequences.read_fasta(\"data/sequences.fasta\")\n    >>> results = dna_integration(dna_seqs, k=2)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/integration.py", "line_number": 110, "module": "src.metainformant.information.integration", "name": "dna_integration", "signature": "(sequences: dict[str, str] | list[str], k: int = 1, analysis_type: str = 'entropy') -> dict[str, Any]", "symbol_type": "function"}], "do_not_cut": [{"docstring": "Return only results from enzymes that don't cut between borders.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2547, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "do_not_cut", "signature": "(self, start, end, dct = None)", "symbol_type": "function"}], "domain": [{"docstring": "Create protein domain object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 562, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "domain", "signature": "(self, elem)", "symbol_type": "function"}, {"docstring": "Serialize a domain node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 822, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "domain", "signature": "(self, obj)", "symbol_type": "function"}], "domain_architecture": [{"docstring": "Create domain architecture object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 572, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "domain_architecture", "signature": "(self, elem)", "symbol_type": "function"}], "domain_specific_embeddings": [{"docstring": "Learn separate embeddings per domain.\n\nCreates separate embedding spaces for each domain (health, education, etc.),\nallowing domain-specific semantic relationships to be captured.\n\nArgs:\n    sequences: List of event sequences\n    domain_labels: List of domain labels for each sequence (same structure as sequences)\n    embedding_dim: Dimension of embedding vectors\n    window_size: Size of context window\n    **kwargs: Additional arguments passed to learn_event_embeddings\n    \nReturns:\n    Dictionary mapping domain names to event embedding dictionaries\n    \nExamples:\n    >>> sequences = [\n    ...     [\"diagnosis\", \"job_change\", \"raise\"],\n    ...     [\"degree\", \"job_change\", \"move\"],\n    ... ]\n    >>> domains = [\n    ...     [\"health\", \"occupation\", \"income\"],\n    ...     [\"education\", \"occupation\", \"address\"],\n    ... ]\n    >>> embeddings = domain_specific_embeddings(sequences, domains, embedding_dim=50)\n    >>> \"health\" in embeddings\n    True\n    >>> \"diagnosis\" in embeddings[\"health\"]\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/embeddings.py", "line_number": 260, "module": "src.metainformant.life_events.embeddings", "name": "domain_specific_embeddings", "signature": "(sequences: List[List[str]], domain_labels: List[List[str]], embedding_dim: int = 100, window_size: int = 5, **kwargs: Any) -> Dict[str, Dict[str, NDArray[np.float64]]]", "symbol_type": "function"}], "domainsClusteredByEv": [{"docstring": "Get domains clustered by evalue.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 781, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "domainsClusteredByEv", "signature": "(self, id)", "symbol_type": "function"}], "domainsClusteredById": [{"docstring": "Get domains clustered by percentage identity.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 801, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "domainsClusteredById", "signature": "(self, id)", "symbol_type": "function"}], "download_all_assemblies": [{"docstring": "Retrieve all biological assemblies not in the local PDB copy.\n\n:param listfile: File name to which all assembly codes will be written\n\n:param file_format: Format in which to download the entries.\n    Available options are \"mmCif\" or \"pdb\". Defaults to \"mmCif\".\n\n:param max_num_threads: The maximum number of threads to use while downloading the assemblies", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 581, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "download_all_assemblies", "signature": "(self, listfile: str | None = None, file_format: str | None = None, max_num_threads: int | None = None)", "symbol_type": "function"}], "download_and_process_data": [{"docstring": "Download and process data based on configuration.\n\nThis is a comprehensive end-to-end processing function that can handle\nmultiple data sources and processing steps based on a configuration file.\n\nArgs:\n    config: Configuration dictionary with processing instructions\n    output_dir: Directory for outputs (uses 'output/processing' if None)\n    verbose: Whether to print progress information\n    \nReturns:\n    Dictionary with processing results and metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/workflow.py", "line_number": 16, "module": "src.metainformant.core.workflow", "name": "download_and_process_data", "signature": "(config: dict) -> dict[str, Any]", "symbol_type": "function"}], "download_assembly_package": [{"docstring": "Get a genome dataset by accession  # noqa: E501\n\nDownload a genome dataset including fasta sequence, annotation and a detailed data report by accession.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.download_assembly_package(accessions, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    accessions ([str]): NCBI genome assembly accessions\n\nKeyword Args:\n    chromosomes ([str]): The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence.. [optional]\n    exclude_sequence (bool): Set to true to omit the genomic sequence.. [optional] if omitted the server will use the default value of False\n    include_annotation_type ([V1AnnotationForAssemblyType]): Select additional types of annotation to include in the data package.  If unset, no annotation is provided.. [optional]\n    hydrated (V1AssemblyDatasetRequestResolution): Set to DATA_REPORT_ONLY, to only retrieve data-reports.. [optional]\n    filename (str): Output file name.. [optional] if omitted the server will use the default value of \"ncbi_dataset.zip\"\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    file_type\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/genome_api.py", "line_number": 1223, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.genome_api", "name": "download_assembly_package", "signature": "(self, accessions, **kwargs)", "symbol_type": "function"}], "download_assembly_package_post": [{"docstring": "Get a genome dataset by post  # noqa: E501\n\nThe 'GET' version of download is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.download_assembly_package_post(v1_assembly_dataset_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_assembly_dataset_request (V1AssemblyDatasetRequest):\n\nKeyword Args:\n    filename (str): Output file name.. [optional] if omitted the server will use the default value of \"ncbi_dataset.zip\"\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    file_type\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/genome_api.py", "line_number": 1303, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.genome_api", "name": "download_assembly_package_post", "signature": "(self, v1_assembly_dataset_request, **kwargs)", "symbol_type": "function"}], "download_cds_fasta_from_ftp": [{"docstring": "Download CDS FASTA file directly from NCBI FTP.\n\nArgs:\n    ftp_url: Base FTP URL for the genome\n    genome_dir: Directory to save the file\n    accession: NCBI assembly accession\n    assembly_name: Optional assembly name (for filename construction)\n    config: Optional config dict (may contain genome.files.cds_fasta)\n    \nReturns:\n    Path to downloaded file if successful, None otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/genome_prep.py", "line_number": 171, "module": "src.metainformant.rna.genome_prep", "name": "download_cds_fasta_from_ftp", "signature": "(ftp_url: str, genome_dir: Path, accession: str, assembly_name: str | None = None, config: dict[str, Any] | None = None) -> Path | None", "symbol_type": "function"}], "download_cif_for": [{"docstring": "Download the mmCIF file for an AlphaFold prediction.\n\nDownloads the file to the current working directory if no destination is specified.\n\n:param prediction: An AlphaFold prediction\n:type prediction: dict\n:param directory: The directory to write the mmCIF data to, defaults to the current working directory\n:type directory: Union[int, str, bytes, PathLike], optional\n:return: The path to the mmCIF file\n:rtype: str", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/alphafold_db.py", "line_number": 53, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.alphafold_db", "name": "download_cif_for", "signature": "(prediction: dict, directory: str | bytes | PathLike | None = None) -> str", "symbol_type": "function"}], "download_csv": [{"docstring": "Download and parse CSV from a URL.\n\nArgs:\n    url: URL to download CSV from\n    timeout: Request timeout in seconds\n    **kwargs: Additional arguments for pandas.read_csv\n    \nReturns:\n    DataFrame or None if failed", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 430, "module": "src.metainformant.core.io", "name": "download_csv", "signature": "(url: str, **kwargs) -> Any", "symbol_type": "function"}], "download_entire_pdb": [{"docstring": "Retrieve all PDB entries not present in the local PDB copy.\n\nNOTE: The default download format has changed from PDB to PDBx/mmCif.\n\n:param listfile: Filename to which all PDB codes will be written\n\n:param file_format: File format. Available options:\n\n    * \"mmCif\" (default, PDBx/mmCif file),\n    * \"pdb\" (format PDB),\n    * \"xml\" (PMDML/XML format),\n    * \"mmtf\" (highly compressed),\n    * \"bundle\" (PDB formatted archive for large structure)\n\n:param max_num_threads: The maximum number of threads to use while downloading PDB entries", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 613, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "download_entire_pdb", "signature": "(self, listfile: str | None = None, file_format: str | None = None, max_num_threads: int | None = None)", "symbol_type": "function"}], "download_file": [{"docstring": "Download a file from a URL to a local path.\n\nArgs:\n    url: URL to download from\n    dest_path: Local path to save the file\n    chunk_size: Size of download chunks\n    timeout: Request timeout in seconds\n    \nReturns:\n    True if download successful, False otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 347, "module": "src.metainformant.core.io", "name": "download_file", "signature": "(url: str, dest_path: str | Path) -> bool", "symbol_type": "function"}], "download_gene_package": [{"docstring": "Get a gene dataset by gene ID  # noqa: E501\n\nGet a gene dataset including gene, transcript and protein fasta sequence, annotation and metadata by gene ID.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.download_gene_package(gene_ids, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    gene_ids ([int]): NCBI gene ids\n\nKeyword Args:\n    include_annotation_type ([V1Fasta]): Select additional types of annotation to include in the data package.  If unset, no annotation is provided.. [optional]\n    fasta_filter ([str]): Limit the FASTA sequences in the datasets package to these transcript and protein accessions. [optional]\n    filename (str): Output file name.. [optional] if omitted the server will use the default value of \"ncbi_dataset.zip\"\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    file_type\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 925, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "download_gene_package", "signature": "(self, gene_ids, **kwargs)", "symbol_type": "function"}], "download_gene_package_post": [{"docstring": "Get a gene dataset by POST  # noqa: E501\n\nGet a gene dataset including gene, transcript and protein fasta sequence, annotation and metadata by POST.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.download_gene_package_post(v1_gene_dataset_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_gene_dataset_request (V1GeneDatasetRequest):\n\nKeyword Args:\n    filename (str): Output file name.. [optional] if omitted the server will use the default value of \"ncbi_dataset.zip\"\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    file_type\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 1003, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "download_gene_package_post", "signature": "(self, v1_gene_dataset_request, **kwargs)", "symbol_type": "function"}], "download_genome_data_package": [{"docstring": "Download genome assembly package from NCBI Datasets API.\n\nArgs:\n    accessions: Iterable of assembly accessions (e.g., GCF_000001405.40)\n    filename: Output filename for downloaded package\n    \nReturns:\n    API response object\n    \nRaises:\n    RuntimeError: If ncbi-datasets-pylib not installed or unavailable", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/ncbi.py", "line_number": 20, "module": "src.metainformant.dna.ncbi", "name": "download_genome_data_package", "signature": "(accessions: Iterable[str], filename: str) -> Any", "symbol_type": "function"}], "download_genome_package_best_effort": [{"docstring": "Try to download an accession package via CLI, then API, then FTP.\n\nWrites a small JSON report to dest_dir and returns the record.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/ncbi.py", "line_number": 407, "module": "src.metainformant.dna.ncbi", "name": "download_genome_package_best_effort", "signature": "(accession: str, dest_dir: str | Path) -> dict", "symbol_type": "function"}], "download_genome_via_api": [{"docstring": "Download a genome package via NCBI Datasets API URL (zip), then extract.\n\nWrites progress files under dest_dir: download.progress.json and download.progress.txt", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/ncbi.py", "line_number": 218, "module": "src.metainformant.dna.ncbi", "name": "download_genome_via_api", "signature": "(accession: str, dest_dir: str | Path) -> dict", "symbol_type": "function"}], "download_genome_via_datasets_cli": [{"docstring": "Use `datasets` CLI to download a genome package into dest_dir.\n\ninclude: e.g., [\"gff3\",\"rna\",\"cds\",\"protein\",\"genome\",\"seq-report\"].\nStreams stdout/stderr to log files under dest_dir to show progress.\nReturns a record with paths and command metadata.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/ncbi.py", "line_number": 139, "module": "src.metainformant.dna.ncbi", "name": "download_genome_via_datasets_cli", "signature": "(accession: str, dest_dir: str | Path) -> dict", "symbol_type": "function"}], "download_genome_via_ftp": [{"docstring": "Attempt to download common files from an NCBI FTP directory URL.\n\nThis expects ftp_url to be a directory containing standard files. We try to fetch\nmd5checksums and common FASTA/GFF files by conventional names if present.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/ncbi.py", "line_number": 384, "module": "src.metainformant.dna.ncbi", "name": "download_genome_via_ftp", "signature": "(ftp_url: str, dest_dir: str | Path) -> dict", "symbol_type": "function"}], "download_json": [{"docstring": "Download and parse JSON from a URL.\n\nArgs:\n    url: URL to download JSON from\n    timeout: Request timeout in seconds\n    \nReturns:\n    Parsed JSON data or None if failed", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 390, "module": "src.metainformant.core.io", "name": "download_json", "signature": "(url: str) -> Any", "symbol_type": "function"}], "download_obsolete_entries": [{"docstring": "Retrieve all obsolete PDB entries not present in local obsolete PDB copy.\n\nNOTE: The default download format has changed from PDB to PDBx/mmCif.\n\n:param listfile: Filename to which all PDB codes will be written\n\n:param file_format: File format. Available options:\n\n    * \"mmCif\" (default, PDBx/mmCif file),\n    * \"pdb\" (PDB format),\n    * \"xml\" (PMDML/XML format).\n\n:param max_num_threads: The maximum number of threads to use while downloading PDB entries", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 648, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "download_obsolete_entries", "signature": "(self, listfile: str | None = None, file_format: str | None = None, max_num_threads: int | None = None)", "symbol_type": "function"}], "download_pdb_files": [{"docstring": "Fetch set of PDB structure files from the PDB server and store them locally.\n\n:param pdb_codes: A list of 4-symbol PDB structure IDs\n\n:param obsolete:\n    Has a meaning only for obsolete structures.\n    If True, download the obsolete structure to 'obsolete' folder.\n    Otherwise, the download won't be performed.\n    This option doesn't work for mmtf format as obsolete structures are not available as mmtf.\n    (default: ``False``)\n\n:param pdir: Put the file in this directory. By default, create a PDB-style directory tree.\n\n:param file_format: File format. Available options:\n\n    * \"mmCif\" (default, PDBx/mmCif file),\n    * \"pdb\" (format PDB),\n    * \"xml\" (PMDML/XML format),\n    * \"mmtf\" (highly compressed),\n    * \"bundle\" (PDB formatted archive for large structure).\n\n:param overwrite: If set to true, existing structure files will be overwritten. (default: ``False``)\n\n:param max_num_threads: The maximum number of threads to use when downloading files", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 415, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "download_pdb_files", "signature": "(self, pdb_codes: list[str], obsolete: bool = False, pdir: str | None = None, file_format: str | None = None, overwrite: bool = False, max_num_threads: int | None = None)", "symbol_type": "function"}], "download_prokaryote_gene_package": [{"docstring": "Get a prokaryote gene dataset by RefSeq protein accession  # noqa: E501\n\nGet a prokaryote gene dataset including gene and protein fasta sequence, annotation and metadata by prokaryote protein accession.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.download_prokaryote_gene_package(accessions, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    accessions ([str]): WP prokaryote protein accession\n\nKeyword Args:\n    include_annotation_type ([V1Fasta]): Select additional types of annotation to include in the data package.  If unset, no annotation is provided.. [optional]\n    gene_flank_config_length (int): [optional]\n    taxon (str): NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank When specified, return data from this taxon and its subtree. [optional]\n    filename (str): Output file name.. [optional] if omitted the server will use the default value of \"ncbi_dataset.zip\"\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    file_type\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/prokaryote_api.py", "line_number": 173, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.prokaryote_api", "name": "download_prokaryote_gene_package", "signature": "(self, accessions, **kwargs)", "symbol_type": "function"}], "download_prokaryote_gene_package_post": [{"docstring": "Get a prokaryote gene dataset by RefSeq protein accession by POST  # noqa: E501\n\nGet a prokaryote gene dataset including gene and protein fasta sequence, annotation and metadata by prokaryote protein accession by POST.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.download_prokaryote_gene_package_post(v1_prokaryote_gene_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_prokaryote_gene_request (V1ProkaryoteGeneRequest):\n\nKeyword Args:\n    filename (str): Output file name.. [optional] if omitted the server will use the default value of \"ncbi_dataset.zip\"\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    file_type\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/prokaryote_api.py", "line_number": 252, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.prokaryote_api", "name": "download_prokaryote_gene_package_post", "signature": "(self, v1_prokaryote_gene_request, **kwargs)", "symbol_type": "function"}], "download_reference_genome": [{"docstring": "Download reference genome using NCBI infrastructure.\n\nArgs:\n    accession: NCBI assembly accession (e.g., GCF_000001405.40)\n    dest_dir: Destination directory for genome files\n    include: List of file types to download (genome, gff3, etc.)\n    ftp_url: Optional FTP URL for direct download\n\nReturns:\n    Dictionary with download metadata and paths", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/download.py", "line_number": 15, "module": "src.metainformant.gwas.download", "name": "download_reference_genome", "signature": "(accession: str, dest_dir: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "download_rna_fasta_from_ftp": [{"docstring": "Download RNA FASTA file directly from NCBI FTP.\n\nArgs:\n    ftp_url: Base FTP URL for the genome\n    genome_dir: Directory to save the file\n    accession: NCBI assembly accession\n    assembly_name: Optional assembly name (for filename construction)\n    config: Optional config dict (may contain genome.files.transcriptome_fasta)\n    \nReturns:\n    Path to downloaded file if successful, None otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/genome_prep.py", "line_number": 86, "module": "src.metainformant.rna.genome_prep", "name": "download_rna_fasta_from_ftp", "signature": "(ftp_url: str, genome_dir: Path, accession: str, assembly_name: str | None = None, config: dict[str, Any] | None = None) -> Path | None", "symbol_type": "function"}], "download_sra": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 184, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "download_sra", "signature": "(metadata, sra_stat, args, work_dir, overwrite = False)", "symbol_type": "function"}], "download_sra_data": [{"docstring": "Download SRA data for specified accessions.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/run_genome_scale_gwas.py", "line_number": 58, "module": "scripts.gwas.run_genome_scale_gwas", "name": "download_sra_data", "signature": "(accessions: list[str], output_dir: Path, threads: int = 8)", "symbol_type": "function"}], "download_sra_project": [{"docstring": "Download all SRA runs from a BioProject.\n\nArgs:\n    bioproject: NCBI BioProject accession (e.g., PRJNA292680)\n    dest_dir: Destination directory\n    max_runs: Maximum number of runs to download\n    threads: Threads per download\n\nReturns:\n    Dictionary with download status for all runs", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/sra_download.py", "line_number": 211, "module": "src.metainformant.gwas.sra_download", "name": "download_sra_project", "signature": "(bioproject: str, dest_dir: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "download_sra_run": [{"docstring": "Download SRA run and convert to FASTQ.\n\nArgs:\n    sra_accession: SRA run accession (e.g., SRR1234567)\n    dest_dir: Destination directory for FASTQ files\n    use_fasterq: Use fasterq-dump (faster) instead of fastq-dump\n    threads: Number of threads for fasterq-dump\n\nReturns:\n    Dictionary with download status and file paths", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/sra_download.py", "line_number": 38, "module": "src.metainformant.gwas.sra_download", "name": "download_sra_run", "signature": "(sra_accession: str, dest_dir: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "download_text": [{"docstring": "Download text content from a URL.\n\nArgs:\n    url: URL to download text from\n    timeout: Request timeout in seconds\n    \nReturns:\n    Text content or None if failed", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 410, "module": "src.metainformant.core.io", "name": "download_text", "signature": "(url: str) -> str | None", "symbol_type": "function"}], "download_variant_data": [{"docstring": "Download variant data from public databases.\n\nSupported sources:\n- dbSNP: NCBI dbSNP database (via FTP)\n- custom: Custom VCF URL\n- sra: Download SRA data and call variants\n\nArgs:\n    source: Data source (dbSNP, custom, sra)\n    accession: Genome/assembly accession for dbSNP, or SRA run accession\n    region: Optional genomic region filter (chr:start-end)\n    dest_dir: Destination directory for variant files\n    url: Direct URL for custom downloads\n\nReturns:\n    Dictionary with download metadata and file paths", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/download.py", "line_number": 65, "module": "src.metainformant.gwas.download", "name": "download_variant_data", "signature": "(source: str, accession: str | None = None, region: str | None = None, dest_dir: str | Path | None = None, url: str | None = None) -> dict[str, Any]", "symbol_type": "function"}], "draw": [{"docstring": "Draw the specified component.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/BasicChromosome.py", "line_number": 92, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.BasicChromosome", "name": "draw", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Draw out the information for the Organism.\n\nArguments:\n - output_file -- The name of a file specifying where the\n   document should be saved, or a handle to be written to.\n   The output format is set when creating the Organism object.\n   Alternatively, output_file=None will return the drawing using\n   the low-level ReportLab objects (for further processing, such\n   as adding additional graphics, before writing).\n - title -- The output title of the produced document.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/BasicChromosome.py", "line_number": 122, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.BasicChromosome", "name": "draw", "signature": "(self, output_file, title)", "symbol_type": "function"}, {"docstring": "Draw a chromosome on the specified template.\n\nIdeally, the x_position and y_*_position attributes should be\nset prior to drawing -- otherwise we're going to have some problems.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/BasicChromosome.py", "line_number": 240, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.BasicChromosome", "name": "draw", "signature": "(self, cur_drawing)", "symbol_type": "function"}, {"docstring": "Draw a chromosome segment.\n\nBefore drawing, the range we are drawing in needs to be set.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/BasicChromosome.py", "line_number": 425, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.BasicChromosome", "name": "draw", "signature": "(self, cur_drawing)", "symbol_type": "function"}, {"docstring": "Draw nothing to the current diagram (dummy method).\n\nThe segment spacer has no actual image in the diagram,\nso this method therefore does nothing, but is defined\nto match the expected API of the other segment objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/BasicChromosome.py", "line_number": 813, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.BasicChromosome", "name": "draw", "signature": "(self, cur_diagram)", "symbol_type": "function"}, {"docstring": "Draw out the distribution information.\n\nArguments:\n - output_file - The name of the file to output the information to,\n   or a handle to write to.\n - title - A title to display on the graphic.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/Distribution.py", "line_number": 49, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.Distribution", "name": "draw", "signature": "(self, output_file, title)", "symbol_type": "function"}, {"docstring": "Draw a bar chart with the info in the specified range.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/Distribution.py", "line_number": 161, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.Distribution", "name": "draw", "signature": "(self, cur_drawing, start_x, start_y, end_x, end_y)", "symbol_type": "function"}, {"docstring": "Draw a line distribution into the current drawing.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/Distribution.py", "line_number": 251, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.Distribution", "name": "draw", "signature": "(self, cur_drawing, start_x, start_y, end_x, end_y)", "symbol_type": "function"}, {"docstring": "Add the map elements to the drawing.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/KGML_vis.py", "line_number": 142, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.KGML_vis", "name": "draw", "signature": "(self, filename)", "symbol_type": "function"}, {"docstring": "Draw a circular diagram of the stored data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 187, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "draw", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Draw the diagram, with passed parameters overriding existing attributes.\n\ngdd.draw(format='circular')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Diagram.py", "line_number": 156, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Diagram", "name": "draw", "signature": "(self, format = None, pagesize = None, orientation = None, x = None, y = None, xl = None, xr = None, yt = None, yb = None, start = None, end = None, tracklines = None, fragments = None, fragment_size = None, track_size = None, circular = None, circle_core = None, cross_track_links = None)", "symbol_type": "function"}, {"docstring": "Draw a linear diagram of the data in the parent Diagram object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 172, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Plot the given tree using matplotlib (or pylab).\n\nThe graphic is a rooted tree, drawn with roughly the same algorithm as\ndraw_ascii.\n\nAdditional keyword arguments passed into this function are used as pyplot\noptions. The input format should be in the form of:\npyplot_option_name=(tuple), pyplot_option_name=(tuple, dict), or\npyplot_option_name=(dict).\n\nExample using the pyplot options 'axhspan' and 'axvline'::\n\n    from Bio import Phylo, AlignIO\n    from Bio.Phylo.TreeConstruction import DistanceCalculator, DistanceTreeConstructor\n    constructor = DistanceTreeConstructor()\n    aln = AlignIO.read(open('TreeConstruction/msa.phy'), 'phylip')\n    calculator = DistanceCalculator('identity')\n    dm = calculator.get_distance(aln)\n    tree = constructor.upgma(dm)\n    Phylo.draw(tree, axhspan=((0.25, 7.75), {'facecolor':'0.5'}),\n    ... axvline={'x':0, 'ymin':0, 'ymax':1})\n\nVisual aspects of the plot can also be modified using pyplot's own functions\nand objects (via pylab or matplotlib). In particular, the pyplot.rcParams\nobject can be used to scale the font size (rcParams[\"font.size\"]) and line\nwidth (rcParams[\"lines.linewidth\"]).\n\n:Parameters:\n    label_func : callable\n        A function to extract a label from a node. By default this is str(),\n        but you can use a different function to select another string\n        associated with each node. If this function returns None for a node,\n        no label will be shown for that node.\n    do_show : bool\n        Whether to show() the plot automatically.\n    show_confidence : bool\n        Whether to display confidence values, if present on the tree.\n    axes : matplotlib/pylab axes\n        If a valid matplotlib.axes.Axes instance, the phylogram is plotted\n        in that Axes. By default (None), a new figure is created.\n    branch_labels : dict or callable\n        A mapping of each clade to the label that will be shown along the\n        branch leading to it. By default this is the confidence value(s) of\n        the clade, taken from the ``confidence`` attribute, and can be\n        easily toggled off with this function's ``show_confidence`` option.\n        But if you would like to alter the formatting of confidence values,\n        or label the branches with something other than confidence, then use\n        this option.\n    label_colors : dict or callable\n        A function or a dictionary specifying the color of the tip label.\n        If the tip label can't be found in the dict or label_colors is\n        None, the label will be shown in black.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 282, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "draw", "signature": "(tree, label_func = str, do_show = True, show_confidence = True, axes = None, branch_labels = None, label_colors = None, *args, **kwargs)", "symbol_type": "function"}], "draw_arrow": [{"docstring": "Draw an arrow.\n\nReturns a closed path object representing an arrow enclosed by the\nbox with corners at {point1=(x1,y1), point2=(x2,y2)}, a shaft height\ngiven by shaft_height_ratio (relative to box height), a head length\ngiven by head_length_ratio (also relative to box height), and\nan orientation that may be 'left' or 'right'.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_AbstractDrawer.py", "line_number": 219, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._AbstractDrawer", "name": "draw_arrow", "signature": "(point1, point2, color = colors.lightgreen, border = None, shaft_height_ratio = 0.4, head_length_ratio = 0.5, orientation = 'right', colour = None, **kwargs)", "symbol_type": "function"}], "draw_ascii": [{"docstring": "Draw an ascii-art phylogram of the given tree.\n\nThe printed result looks like::\n\n                                    _________ Orange\n                     ______________|\n                    |              |______________ Tangerine\n      ______________|\n     |              |          _________________________ Grapefruit\n    _|              |_________|\n     |                        |______________ Pummelo\n     |\n     |__________________________________ Apple\n\n\n:Parameters:\n    file : file-like object\n        File handle opened for writing the output drawing. (Default:\n        standard output)\n    column_width : int\n        Total number of text columns used by the drawing.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 187, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "draw_ascii", "signature": "(tree, file = None, column_width = 80)", "symbol_type": "function"}], "draw_bar_graph": [{"docstring": "Return list of drawable elements for a bar graph.\n\nArguments:\n - graph     Graph object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 606, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "draw_bar_graph", "signature": "(self, graph)", "symbol_type": "function"}, {"docstring": "Return list of drawable elements for a bar graph.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 1364, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw_bar_graph", "signature": "(self, graph)", "symbol_type": "function"}], "draw_box": [{"docstring": "Draw a box.\n\nArguments:\n - point1, point2 - coordinates for opposite corners of the box\n   (x,y tuples)\n - color /colour - The color for the box (colour takes priority\n   over color)\n - border - Border color for the box\n\nReturns a closed path object, beginning at (x1,y1) going round\nthe four points in order, and filling with the passed color.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_AbstractDrawer.py", "line_number": 103, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._AbstractDrawer", "name": "draw_box", "signature": "(point1, point2, color = colors.lightgreen, border = None, colour = None, **kwargs)", "symbol_type": "function"}], "draw_clade": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 252, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "draw_clade", "signature": "(clade, startcol)", "symbol_type": "function"}, {"docstring": "Recursively draw a tree, down from the given clade.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 518, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "draw_clade", "signature": "(clade, x_start, color, lw)", "symbol_type": "function"}], "draw_clade_lines": [{"docstring": "Create a line with or without a line collection object.\n\nGraphical formatting of the lines representing clades in the plot can be\ncustomized by altering this function.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 468, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "draw_clade_lines", "signature": "(use_linecollection = False, orientation = 'horizontal', y_here = 0, x_start = 0, x_here = 0, y_bot = 0, y_top = 0, color = 'black', lw = '.1', capstyle = 'round', joinstyle = 'round')", "symbol_type": "function"}], "draw_cross_link": [{"docstring": "Draw a cross-link between features.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 433, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "draw_cross_link", "signature": "(self, cross_link)", "symbol_type": "function"}, {"docstring": "Draw cross-link between two features.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 775, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw_cross_link", "signature": "(self, cross_link)", "symbol_type": "function"}], "draw_cut_corner_box": [{"docstring": "Draw a box with the corners cut off.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_AbstractDrawer.py", "line_number": 138, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._AbstractDrawer", "name": "draw_cut_corner_box", "signature": "(point1, point2, corner = 0.5, color = colors.lightgreen, border = None, **kwargs)", "symbol_type": "function"}], "draw_feature": [{"docstring": "Return list of feature elements and list of labels for them.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 279, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "draw_feature", "signature": "(self, feature)", "symbol_type": "function"}, {"docstring": "Draw feature.\n\nArguments:\n - feature           Feature containing location info\n\nReturns tuple of (list of elements describing single feature, list\nof labels for those elements).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 690, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw_feature", "signature": "(self, feature)", "symbol_type": "function"}], "draw_feature_location": [{"docstring": "Draw feature location.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 722, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw_feature_location", "signature": "(self, feature, locstart, locend)", "symbol_type": "function"}], "draw_feature_set": [{"docstring": "Return list of feature elements and list of labels for them.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 264, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "draw_feature_set", "signature": "(self, set)", "symbol_type": "function"}, {"docstring": "Draw feature set.\n\nArguments:\n - set       FeatureSet object\n\nReturns a tuple (list of elements describing features, list of\nlabels for elements).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 668, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw_feature_set", "signature": "(self, set)", "symbol_type": "function"}], "draw_graph_set": [{"docstring": "Return list of graph elements and list of their labels.\n\nArguments:\n - set       GraphSet object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 524, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "draw_graph_set", "signature": "(self, set)", "symbol_type": "function"}, {"docstring": "Draw graph set.\n\nArguments:\n - set       GraphSet object\n\nReturns tuple (list of graph elements, list of graph labels).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 1168, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw_graph_set", "signature": "(self, set)", "symbol_type": "function"}], "draw_greytrack": [{"docstring": "Drawing element for grey background to passed Track object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 990, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "draw_greytrack", "signature": "(self, track)", "symbol_type": "function"}, {"docstring": "Draw greytrack.\n\nArguments:\n - track     Track object\n\nPut in a grey background to the current track in all fragments,\nif track specifies that we should.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 590, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw_greytrack", "signature": "(self, track)", "symbol_type": "function"}], "draw_heat_graph": [{"docstring": "Return list of drawable elements for the heat graph.\n\nArguments:\n - graph     Graph object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 668, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "draw_heat_graph", "signature": "(self, graph)", "symbol_type": "function"}, {"docstring": "Return a list of drawable elements for the heat graph.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 1289, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw_heat_graph", "signature": "(self, graph)", "symbol_type": "function"}], "draw_line_graph": [{"docstring": "Return line graph as list of drawable elements.\n\nArguments:\n - graph     GraphData object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 546, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "draw_line_graph", "signature": "(self, graph)", "symbol_type": "function"}, {"docstring": "Return a line graph as a list of drawable elements.\n\nArguments:\n - graph     Graph object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 1191, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw_line_graph", "signature": "(self, graph)", "symbol_type": "function"}], "draw_polygon": [{"docstring": "Draw polygon.\n\nArguments:\n - list_of_point - list of (x,y) tuples for the corner coordinates\n - color / colour - The color for the box\n\nReturns a closed path object, beginning at (x1,y1) going round\nthe four points in order, and filling with the passed colour.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_AbstractDrawer.py", "line_number": 185, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._AbstractDrawer", "name": "draw_polygon", "signature": "(list_of_points, color = colors.lightgreen, border = None, colour = None, **kwargs)", "symbol_type": "function"}], "draw_scale": [{"docstring": "Return list of elements in the scale and list of their labels.\n\nArguments:\n - track     Track object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 710, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "draw_scale", "signature": "(self, track)", "symbol_type": "function"}, {"docstring": "Draw scale.\n\nArgument:\n - track     Track object\n\nReturns a tuple of (list of elements in the scale, list of labels\nin the scale).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 424, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw_scale", "signature": "(self, track)", "symbol_type": "function"}], "draw_test_tracks": [{"docstring": "Draw blue test tracks with grene line down their center.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 957, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "draw_test_tracks", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Draw test tracks.\n\nDraw red lines indicating the top and bottom of each fragment,\nand blue ones indicating tracks to be drawn.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 305, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw_test_tracks", "signature": "(self)", "symbol_type": "function"}], "draw_tick": [{"docstring": "Return drawing element for a tick on the scale.\n\nArguments:\n - tickpos   Int, position of the tick on the sequence\n - ctr       Float, Y co-ord of the center of the track\n - ticklen   How long to draw the tick\n - track     Track, the track the tick is drawn on\n - draw_label    Boolean, write the tick label?", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 902, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "draw_tick", "signature": "(self, tickpos, ctr, ticklen, track, draw_label)", "symbol_type": "function"}, {"docstring": "Draw tick.\n\nArguments:\n - tickpos   Int, position of the tick on the sequence\n - ctr       Float, Y co-ord of the center of the track\n - ticklen   How long to draw the tick\n - track     Track, the track the tick is drawn on\n - draw_label    Boolean, write the tick label?\n\nReturns a drawing element that is the tick on the scale", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 362, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw_tick", "signature": "(self, tickpos, ctr, ticklen, track, draw_label)", "symbol_type": "function"}], "draw_to_file": [{"docstring": "Write the comparative plot to a file.\n\nArguments:\n - output_file - The name of the file to output the information to,\n   or a handle to write to.\n - title - A title to display on the graphic.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/Comparative.py", "line_number": 79, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.Comparative", "name": "draw_to_file", "signature": "(self, output_file, title)", "symbol_type": "function"}], "draw_track": [{"docstring": "Return list of track elements and list of track labels.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 250, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "draw_track", "signature": "(self, track)", "symbol_type": "function"}, {"docstring": "Draw track.\n\nArguments:\n - track     Track object\n\nReturns a tuple (list of elements in the track, list of labels in\nthe track).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 341, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "draw_track", "signature": "(self, track)", "symbol_type": "function"}], "dssp_dict_from_pdb_file": [{"docstring": "Create a DSSP dictionary from a PDB file.\n\nParameters\n----------\nin_file : string\n    pdb file\n\nDSSP : string\n    DSSP executable (argument to subprocess)\n\ndssp_version : string\n    Version of DSSP executable\n\nReturns\n-------\n(out_dict, keys) : tuple\n    a dictionary that maps (chainid, resid) to\n    amino acid type, secondary structure code and\n    accessibility.\n\nExamples\n--------\nHow dssp_dict_from_pdb_file could be used::\n\n    from Bio.PDB.DSSP import dssp_dict_from_pdb_file\n    dssp_tuple = dssp_dict_from_pdb_file(\"/local-pdb/1fat.pdb\")\n    dssp_dict = dssp_tuple[0]\n    print(dssp_dict['A',(' ', 1, ' ')])", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/DSSP.py", "line_number": 135, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.DSSP", "name": "dssp_dict_from_pdb_file", "signature": "(in_file, DSSP = 'dssp', dssp_version = '3.9.9')", "symbol_type": "function"}], "dump": [{"docstring": "Serialize a Python object into a YAML stream.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 248, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "dump", "signature": "(data, stream = None, Dumper = Dumper, **kwds)", "symbol_type": "function"}, {"docstring": "Serialize a Python object into a YAML stream.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 248, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "dump", "signature": "(data, stream = None, Dumper = Dumper, **kwds)", "symbol_type": "function"}], "dump_all": [{"docstring": "Serialize a sequence of Python objects into a YAML stream.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 215, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "dump_all", "signature": "(documents, stream = None, Dumper = Dumper, default_style = None, default_flow_style = False, canonical = None, indent = None, width = None, allow_unicode = None, line_break = None, encoding = None, explicit_start = None, explicit_end = None, version = None, tags = None, sort_keys = True)", "symbol_type": "function"}, {"docstring": "Serialize a sequence of Python objects into a YAML stream.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 215, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "dump_all", "signature": "(documents, stream = None, Dumper = Dumper, default_style = None, default_flow_style = False, canonical = None, indent = None, width = None, allow_unicode = None, line_break = None, encoding = None, explicit_start = None, explicit_end = None, version = None, tags = None, sort_keys = True)", "symbol_type": "function"}], "dump_json": [{"docstring": "Write object to JSON file with optional atomic write.\n\nArgs:\n    obj: Object to serialize (must be JSON-serializable)\n    path: Output file path\n    indent: Number of spaces for indentation (None for compact)\n    atomic: If True, write to temp file then rename (prevents corruption)\n\nRaises:\n    IOError: If file write fails", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 60, "module": "src.metainformant.core.io", "name": "dump_json", "signature": "(obj: Any, path: str | Path) -> None", "symbol_type": "function"}], "dump_json_gz": [{"docstring": "Dump object as gzipped JSON file.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 91, "module": "src.metainformant.core.io", "name": "dump_json_gz", "signature": "(obj: Any, path: str | Path) -> None", "symbol_type": "function"}], "duplication_levels": [{"docstring": "Analyze sequence duplication levels.\n\nArgs:\n    reads: List of FASTQ records\n\nReturns:\n    Dictionary with duplication analysis", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/fastq.py", "line_number": 378, "module": "src.metainformant.quality.fastq", "name": "duplication_levels", "signature": "(reads: List[FastqRecord]) -> Dict[str, Any]", "symbol_type": "function"}], "ecitmatch": [{"docstring": "Retrieve PMIDs for input citation strings, returned as a handle.\n\nECitMatch retrieves PubMed IDs (PMIDs) that correspond to a set of input\ncitation strings.\n\nSee the online documentation for an explanation of the parameters:\nhttp://www.ncbi.nlm.nih.gov/books/NBK25499/#chapter4.ECitMatch\n\nShort example:\n\n>>> from Bio import Entrez\n>>> Entrez.email = \"Your.Name.Here@example.org\"\n>>> citation_1 = {\"journal_title\": \"proc natl acad sci u s a\",\n...               \"year\": \"1991\", \"volume\": \"88\", \"first_page\": \"3248\",\n...               \"author_name\": \"mann bj\", \"key\": \"citation_1\"}\n>>> handle = Entrez.ecitmatch(db=\"pubmed\", bdata=[citation_1])\n>>> print(handle.read().strip().split(\"|\"))\n['proc natl acad sci u s a', '1991', '88', '3248', 'mann bj', 'citation_1', '2014248']\n>>> handle.close()\n\n:returns: Handle to the results, by default in plain text.\n:raises urllib.error.URLError: If there's a network error.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/__init__.py", "line_number": 444, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.__init__", "name": "ecitmatch", "signature": "(**keywds)", "symbol_type": "function"}], "edges": [{"docstring": "Return a list of all the edges with this label.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/Graph.py", "line_number": 93, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.Graph", "name": "edges", "signature": "(self, label)", "symbol_type": "function"}, {"docstring": "Return a list of all the edges with this label.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/MultiGraph.py", "line_number": 85, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.MultiGraph", "name": "edges", "signature": "(self, label)", "symbol_type": "function"}], "efetch": [{"docstring": "Fetch Entrez results which are returned as a handle.\n\nEFetch retrieves records in the requested format from a list or set of one or\nmore UIs or from user's environment.\n\nSee the online documentation for an explanation of the parameters:\nhttp://www.ncbi.nlm.nih.gov/books/NBK25499/#chapter4.EFetch\n\nShort example:\n\n>>> from Bio import Entrez\n>>> Entrez.email = \"Your.Name.Here@example.org\"\n>>> handle = Entrez.efetch(db=\"nucleotide\", id=\"AY851612\", rettype=\"gb\", retmode=\"text\")\n>>> print(handle.readline().strip())\nLOCUS       AY851612                 892 bp    DNA     linear   PLN 10-APR-2007\n>>> handle.close()\n\nThis will automatically use an HTTP POST rather than HTTP GET if there\nare over 200 identifiers as recommended by the NCBI.\n\n**Warning:** The NCBI changed the default retmode in Feb 2012, so many\ndatabases which previously returned text output now give XML.\n\n:returns: Handle to the results.\n:raises urllib.error.URLError: If there's a network error.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/__init__.py", "line_number": 170, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.__init__", "name": "efetch", "signature": "(db, **keywords)", "symbol_type": "function"}], "effect_direction_plot": [{"docstring": "Effect direction plot showing consistent directionality.\n\nVisualizes whether effect directions are consistent across genome,\nuseful for detecting systematic biases.\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    significance_threshold: P-value threshold\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_effects.py", "line_number": 151, "module": "src.metainformant.gwas.visualization_effects", "name": "effect_direction_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "effect_size_forest_plot": [{"docstring": "Forest plot of top variants with effect sizes and confidence intervals.\n\nShows effect estimates (beta or OR) with 95% CI for significant variants.\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    top_n: Number of top variants to show\n    significance_threshold: P-value threshold\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_effects.py", "line_number": 32, "module": "src.metainformant.gwas.visualization_effects", "name": "effect_size_forest_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "effect_size_plot": [{"docstring": "Forest plot showing effect sizes for top variants.\n\nArgs:\n    results: Results or path\n    output_path: Save path\n    top_n: Number of top variants to show\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_enhanced.py", "line_number": 494, "module": "src.metainformant.gwas.visualization_enhanced", "name": "effect_size_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "effective_population_size_from_heterozygosity": [{"docstring": "Estimate effective population size from observed heterozygosity and mutation rate.\n\nUses the relationship between heterozygosity and the population mutation\nparameter \u03b8 under the infinite-alleles model. At equilibrium, heterozygosity\nH = \u03b8 / (\u03b8 + 1), where \u03b8 = 2Ne\u03bc for haploid or \u03b8 = 4Ne\u03bc for diploid.\n\nSolving for Ne: Ne = \u03b8 / (ploidy \u00d7 \u03bc), where \u03b8 = H / (1 - H).\n\nArgs:\n    observed_heterozygosity: Observed heterozygosity in the population (H) in [0, 1]\n    mutation_rate: Mutation rate per site per generation (\u03bc)\n    ploidy: Ploidy level. Default 2 for diploid (\u03b8 = 4Ne\u03bc). Use 1 for haploid (\u03b8 = 2Ne\u03bc).\n        \nReturns:\n    Estimated effective population size. Returns 0.0 if mutation_rate <= 0 or\n    heterozygosity is invalid.\n    \nExamples:\n    >>> # Diploid with H=0.5 and \u03bc=1e-8\n    >>> effective_population_size_from_heterozygosity(0.5, mutation_rate=1e-8, ploidy=2)\n    12500000.0  # Ne = (0.5/(1-0.5)) / (4 * 1e-8) = 1.0 / (4e-8) = 25e6\n    >>> # Haploid example\n    >>> effective_population_size_from_heterozygosity(0.3, mutation_rate=1e-7, ploidy=1)\n    2142857.14...\n    \nReferences:\n    Nei, M., & Tajima, F. (1981). DNA polymorphism detectable by restriction\n    endonucleases. Genetics, 97(1), 145-163.\n    Kimura, M., & Crow, J. F. (1964). The number of alleles that can be\n    maintained in a finite population. Genetics, 49(4), 725-738.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 369, "module": "src.metainformant.math.popgen", "name": "effective_population_size_from_heterozygosity", "signature": "(observed_heterozygosity: float, mutation_rate: float) -> float", "symbol_type": "function"}], "effective_reproduction_number": [{"docstring": "Effective reproduction number R_e = R0 * S.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/epidemiology.py", "line_number": 127, "module": "src.metainformant.math.epidemiology", "name": "effective_reproduction_number", "signature": "(R0: float, susceptible_fraction: float) -> float", "symbol_type": "function"}], "effective_size_from_family_size_variance": [{"docstring": "Crow and Denniston approximation: Ne \u2248 (4N - 2) / (Vk + 2).\n\nN is census size (diploid), Vk is variance in family size. Guards for non-negative values.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/effective_size.py", "line_number": 69, "module": "src.metainformant.math.effective_size", "name": "effective_size_from_family_size_variance", "signature": "(census_size: float, variance_offspring_number: float) -> float", "symbol_type": "function"}], "effective_size_sex_ratio": [{"docstring": "Calculate effective population size with unequal sex ratio.\n\nWhen the number of breeding males and females differ, effective size\nis reduced compared to census size. This accounts for variance in\nreproductive success due to sex ratio imbalance.\n\nArgs:\n    num_males: Number of breeding males (Nm)\n    num_females: Number of breeding females (Nf)\n    \nReturns:\n    Effective population size. Returns 0.0 if both are zero.\n    Formula: Ne = 4 \u00d7 Nm \u00d7 Nf / (Nm + Nf)\n    \nExamples:\n    >>> effective_size_sex_ratio(num_males=100, num_females=100)\n    200.0\n    >>> effective_size_sex_ratio(num_males=10, num_females=90)\n    36.0\n    \nReferences:\n    Wright, S. (1931). Evolution in Mendelian populations. Genetics,\n    16(2), 97-159.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/effective_size.py", "line_number": 37, "module": "src.metainformant.math.effective_size", "name": "effective_size_sex_ratio", "signature": "(num_males: float, num_females: float) -> float", "symbol_type": "function"}], "egquery": [{"docstring": "Provide Entrez database counts for a global search (DEPRECATED).\n\nEGQuery provided Entrez database counts in XML for a single search\nusing Global Query. However, the NCBI are no longer maintaining this\nfunction and suggest using esearch on each database of interest.\n\nSee the online documentation for an explanation of the parameters:\nhttp://www.ncbi.nlm.nih.gov/books/NBK25499/#chapter4.EGQuery\n\nThis quick example based on a longer version from the Biopython\nTutorial just checks there are over 60 matches for 'Biopython'\nin PubMedCentral:\n\n>>> from Bio import Entrez\n>>> Entrez.email = \"Your.Name.Here@example.org\"\n>>> handle = Entrez.egquery(term=\"biopython\")  # doctest: +SKIP\n>>> record = Entrez.read(handle)  # doctest: +SKIP\n>>> handle.close()  # doctest: +SKIP\n>>> for row in record[\"eGQueryResult\"]:  # doctest: +SKIP\n...     if \"pmc\" in row[\"DbName\"]:  # doctest: +SKIP\n...         print(int(row[\"Count\"]) > 60)  # doctest: +SKIP\nTrue\n\n:returns: Handle to the results, by default in XML format.\n:raises urllib.error.URLError: If there's a network error.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/__init__.py", "line_number": 348, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.__init__", "name": "egquery", "signature": "(**keywds)", "symbol_type": "function"}], "einfo": [{"docstring": "Return a summary of the Entrez databases as a results handle.\n\nEInfo provides field names, index term counts, last update, and\navailable links for each Entrez database.\n\nSee the online documentation for an explanation of the parameters:\nhttp://www.ncbi.nlm.nih.gov/books/NBK25499/#chapter4.EInfo\n\nShort example:\n\n>>> from Bio import Entrez\n>>> Entrez.email = \"Your.Name.Here@example.org\"\n>>> record = Entrez.read(Entrez.einfo())\n>>> 'pubmed' in record['DbList']\nTrue\n\n:returns: Handle to the results, by default in XML format.\n:raises urllib.error.URLError: If there's a network error.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/__init__.py", "line_number": 288, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.__init__", "name": "einfo", "signature": "(**keywds)", "symbol_type": "function"}], "element": [{"docstring": "Return the Pathway as a valid KGML element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 222, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "element", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the Entry as a valid KGML element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 376, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "element", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the Component as a valid KGML element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 448, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "element", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the Graphics as a valid KGML element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 592, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "element", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return KGML element describing the Reaction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 758, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "element", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return KGML element describing the Relation.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 844, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "element", "signature": "(self)", "symbol_type": "function"}], "elementDecl": [{"docstring": "Call a call-back function for each element declaration in a DTD.\n\nThis is used for each element declaration in a DTD like::\n\n    <!ELEMENT       name          (...)>\n\nThe purpose of this function is to determine whether this element\nshould be regarded as a string, integer, list, dictionary, structure,\nor error.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 916, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "elementDecl", "signature": "(self, name, model)", "symbol_type": "function"}], "elements": [{"docstring": "List the enzymes of the RestrictionBatch as list of strings.\n\nGive all the names of the enzymes in B sorted alphabetically.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2184, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "elements", "signature": "(self)", "symbol_type": "function"}], "elink": [{"docstring": "Check for linked external articles and return a handle.\n\nELink checks for the existence of an external or Related Articles link\nfrom a list of one or more primary IDs;  retrieves IDs and relevancy\nscores for links to Entrez databases or Related Articles; creates a\nhyperlink to the primary LinkOut provider for a specific ID and\ndatabase, or lists LinkOut URLs and attributes for multiple IDs.\n\nSee the online documentation for an explanation of the parameters:\nhttp://www.ncbi.nlm.nih.gov/books/NBK25499/#chapter4.ELink\n\nNote that ELink treats the \"id\" parameter differently than the other\ntools when multiple values are given. You should generally pass multiple\nUIDs as a list of strings or integers. This will provide a \"one-to-one\"\nmapping from source database UIDs to destination database UIDs in the\nresult. If multiple source UIDs are passed as a single comma-delimited\nstring all destination UIDs will be mixed together in the result.\n\nThis example finds articles related to the Biopython application\nnote's entry in the PubMed database:\n\n>>> from Bio import Entrez\n>>> Entrez.email = \"Your.Name.Here@example.org\"\n>>> pmid = \"19304878\"\n>>> handle = Entrez.elink(dbfrom=\"pubmed\", id=pmid, linkname=\"pubmed_pubmed\")\n>>> record = Entrez.read(handle)\n>>> handle.close()\n>>> print(record[0][\"LinkSetDb\"][0][\"LinkName\"])\npubmed_pubmed\n>>> linked = [link[\"Id\"] for link in record[0][\"LinkSetDb\"][0][\"Link\"]]\n>>> \"14630660\" in linked\nTrue\n\nThis is explained in much more detail in the Biopython Tutorial.\n\n:returns: Handle to the results, by default in XML format.\n:raises urllib.error.URLError: If there's a network error.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/__init__.py", "line_number": 242, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.__init__", "name": "elink", "signature": "(**keywds)", "symbol_type": "function"}], "elucidate": [{"docstring": "Return a string representing the recognition site and cuttings.\n\nReturn a representation of the site with the cut on the (+) strand\nrepresented as '^' and the cut on the (-) strand as '_'.\nie:\n\n>>> from Bio.Restriction import EcoRI, KpnI, EcoRV, SnaI\n>>> EcoRI.elucidate()   # 5' overhang\n'G^AATT_C'\n>>> KpnI.elucidate()    # 3' overhang\n'G_GTAC^C'\n>>> EcoRV.elucidate()   # blunt\n'GAT^_ATC'\n>>> SnaI.elucidate()    # NotDefined, cut profile unknown.\n'? GTATAC ?'\n>>>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1581, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "elucidate", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return a string representing the recognition site and cuttings.\n\nReturn a representation of the site with the cut on the (+) strand\nrepresented as '^' and the cut on the (-) strand as '_'.\nie:\n\n>>> from Bio.Restriction import EcoRI, KpnI, EcoRV, SnaI\n>>> EcoRI.elucidate()   # 5' overhang\n'G^AATT_C'\n>>> KpnI.elucidate()    # 3' overhang\n'G_GTAC^C'\n>>> EcoRV.elucidate()   # blunt\n'GAT^_ATC'\n>>> SnaI.elucidate()     # NotDefined, cut profile unknown.\n'? GTATAC ?'\n>>>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1730, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "elucidate", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return a string representing the recognition site and cuttings.\n\nReturn a representation of the site with the cut on the (+) strand\nrepresented as '^' and the cut on the (-) strand as '_'.\nie:\n\n>>> from Bio.Restriction import EcoRI, KpnI, EcoRV, SnaI\n>>> EcoRI.elucidate()   # 5' overhang\n'G^AATT_C'\n>>> KpnI.elucidate()    # 3' overhang\n'G_GTAC^C'\n>>> EcoRV.elucidate()   # blunt\n'GAT^_ATC'\n>>> SnaI.elucidate()     # NotDefined, cut profile unknown.\n'? GTATAC ?'\n>>>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1888, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "elucidate", "signature": "(cls)", "symbol_type": "function"}], "emit": [{"docstring": "Emit YAML parsing events into a stream.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 157, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "emit", "signature": "(events, stream = None, Dumper = Dumper, canonical = None, indent = None, width = None, allow_unicode = None, line_break = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 111, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "emit", "signature": "(self, event)", "symbol_type": "function"}, {"docstring": "Emit YAML parsing events into a stream.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 157, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "emit", "signature": "(events, stream = None, Dumper = Dumper, canonical = None, indent = None, width = None, allow_unicode = None, line_break = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 111, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "emit", "signature": "(self, event)", "symbol_type": "function"}], "end": [{"docstring": "End location - right most (maximum) value, regardless of strand.\n\nRead only, returns an integer like position object, possibly a fuzzy\nposition.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 1264, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "end", "signature": "(self)", "symbol_type": "function"}, {"docstring": "End location - right most (maximum) value, regardless of strand.\n\nRead only, returns an integer like position object, possibly a fuzzy\nposition.\n\nFor the special case of a CompoundLocation wrapping the origin of\na circular genome this will match the genome length.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 1665, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "end", "signature": "(self)", "symbol_type": "function"}], "endA": [{"docstring": "End position of Feature A.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CrossLink.py", "line_number": 50, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CrossLink", "name": "endA", "signature": "(self)", "symbol_type": "function"}], "endB": [{"docstring": "End position of Feature B.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CrossLink.py", "line_number": 81, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CrossLink", "name": "endB", "signature": "(self)", "symbol_type": "function"}], "endDBRefElement": [{"docstring": "Handle the end of a DBRef element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 356, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "endDBRefElement", "signature": "(self, name, qname)", "symbol_type": "function"}], "endDescriptionElement": [{"docstring": "Handle the end of a description element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 260, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "endDescriptionElement", "signature": "(self, name, qname)", "symbol_type": "function"}], "endElement": [{"docstring": "Found XML end tag.\n\nArguments:\n - name -- tag name", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIXML.py", "line_number": 545, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIXML", "name": "endElement", "signature": "(self, name)", "symbol_type": "function"}, {"docstring": "Define the end of the search record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/ScanProsite.py", "line_number": 132, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.ScanProsite", "name": "endElement", "signature": "(self, name)", "symbol_type": "function"}, {"docstring": "End and XML element of the given name.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlastIO/blast_xml.py", "line_number": 693, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlastIO.blast_xml", "name": "endElement", "signature": "(self, name)", "symbol_type": "function"}], "endElementHandler": [{"docstring": "Handle end of an XML element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 826, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "endElementHandler", "signature": "(self, name)", "symbol_type": "function"}], "endEntryElement": [{"docstring": "Handle end of an entry element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 154, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "endEntryElement", "signature": "(self, name, qname)", "symbol_type": "function"}], "endErrorElementHandler": [{"docstring": "Handle end of an XML error element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 807, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "endErrorElementHandler", "signature": "(self, tag)", "symbol_type": "function"}], "endIntegerElementHandler": [{"docstring": "Handle end of an XML integer element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 832, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "endIntegerElementHandler", "signature": "(self, tag)", "symbol_type": "function"}], "endNamespaceDeclHandler": [{"docstring": "Handle end of an XML namespace declaration.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 565, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "endNamespaceDeclHandler", "signature": "(self, prefix)", "symbol_type": "function"}], "endParent": [{"docstring": "End an XML element with children.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlastIO/blast_xml.py", "line_number": 715, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlastIO.blast_xml", "name": "endParent", "signature": "(self)", "symbol_type": "function"}], "endParents": [{"docstring": "End XML elements, according to the given number.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlastIO/blast_xml.py", "line_number": 728, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlastIO.blast_xml", "name": "endParents", "signature": "(self, num)", "symbol_type": "function"}], "endPropertyElement": [{"docstring": "Handle the end of a property element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 409, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "endPropertyElement", "signature": "(self, name, qname)", "symbol_type": "function"}], "endRawElementHandler": [{"docstring": "Handle end of an XML raw element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 787, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "endRawElementHandler", "signature": "(self, name)", "symbol_type": "function"}], "endSeqXMLElement": [{"docstring": "Handle end of the seqXML element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 104, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "endSeqXMLElement", "signature": "(self, name, qname)", "symbol_type": "function"}], "endSequenceElement": [{"docstring": "Handle the end of a sequence element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 287, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "endSequenceElement", "signature": "(self, name, qname)", "symbol_type": "function"}], "endSkipElementHandler": [{"docstring": "Handle end of an XML skip element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 800, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "endSkipElementHandler", "signature": "(self, name)", "symbol_type": "function"}], "endSpeciesElement": [{"docstring": "Handle end of a species element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 240, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "endSpeciesElement", "signature": "(self, name, qname)", "symbol_type": "function"}], "endStringElementHandler": [{"docstring": "Handle end of an XML string element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 755, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "endStringElementHandler", "signature": "(self, tag)", "symbol_type": "function"}], "endswith": [{"docstring": "Return True if data ends with the specified suffix, False otherwise.\n\nWith optional start, test data beginning at that position.\nWith optional end, stop comparing data at that position.\nsuffix can also be a tuple of bytes to try.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 221, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "endswith", "signature": "(self, suffix, start = None, end = None)", "symbol_type": "function"}, {"docstring": "Return True if the sequence ends with the given suffix, False otherwise.\n\nReturn True if the sequence ends with the specified suffix\n(a string or another Seq object), False otherwise.\nWith optional start, test sequence beginning at that position.\nWith optional end, stop comparing sequence at that position.\nsuffix can also be a tuple of strings to try.  e.g.\n\n>>> from Bio.Seq import Seq\n>>> my_rna = Seq(\"GUCAUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAGUUG\")\n>>> my_rna.endswith(\"UUG\")\nTrue\n>>> my_rna.endswith(\"AUG\")\nFalse\n>>> my_rna.endswith(\"AUG\", 0, 18)\nTrue\n>>> my_rna.endswith((\"UCC\", \"UCA\", \"UUG\"))\nTrue", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1039, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "endswith", "signature": "(self, suffix, start = None, end = None)", "symbol_type": "function"}], "enrich_genes": [{"docstring": "Gene enrichment analysis using Gene Ontology.\n\n**Note**: This function requires the `scipy` package for statistical tests.\nInstall with: `pip install scipy`\n\nPerforms Fisher's exact test for GO term enrichment. Annotations are\nautomatically propagated to ancestor terms (if a gene is annotated with a term,\nit's also considered annotated with all parent terms).\n\nArgs:\n    genes: List of gene identifiers to test for enrichment\n    background: Optional background gene set. If None, uses all genes in\n        gene_to_terms as background\n    onto: Ontology object containing GO terms\n    gene_to_terms: Dictionary mapping gene_id -> set of GO term IDs\n    method: Statistical test method (\"fisher_exact\" only currently supported)\n    correction: Multiple testing correction (\"fdr\", \"bonferroni\", or \"none\")\n    alpha: Significance level (default: 0.05)\n    propagate_annotations: If True, propagate annotations to ancestor terms\n    \nReturns:\n    Dictionary with enrichment results:\n    - 'terms': List of enriched GO terms with statistics, sorted by p-value\n    - 'method': Statistical test used\n    - 'correction': Multiple testing correction method\n    - 'n_genes': Number of genes in query set\n    - 'n_background': Number of genes in background\n    - 'n_tests': Number of GO terms tested\n    - 'n_significant': Number of significantly enriched terms\n    \nRaises:\n    ImportError: If scipy is not installed\n    ValueError: If gene_to_terms is empty or invalid\n    \nExamples:\n    >>> # Requires scipy and gene-to-term mappings\n    >>> gene_to_terms = {\"GENE1\": {\"GO:0008150\"}, \"GENE2\": {\"GO:0008150\"}}\n    >>> genes = [\"GENE1\", \"GENE2\"]\n    >>> onto = load_go_obo(\"go.obo\")\n    >>> result = enrich_genes(genes, None, onto, gene_to_terms)\n    >>> len(result[\"terms\"]) > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/go.py", "line_number": 173, "module": "src.metainformant.ontology.go", "name": "enrich_genes", "signature": "(genes: List[str], background: List[str] | None, onto: Ontology, gene_to_terms: dict[str, Set[str]], method: str = 'fisher_exact', correction: str = 'fdr', alpha: float = 0.05, propagate_annotations: bool = True) -> dict[str, Any]", "symbol_type": "function"}], "enrichment_plot": [{"docstring": "Create an enrichment plot for pathway/gene set analysis.\n\nArgs:\n    data: DataFrame with enrichment results\n    x_col: Column name for x-axis (usually enrichment ratio or odds ratio)\n    y_col: Column name for y-axis (usually -log10(p-value))\n    p_threshold: P-value threshold for significance\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments for scatter\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import enrichment_plot\n    >>> import pandas as pd\n    >>> data = pd.DataFrame({\n    ...     'enrichment_ratio': [1.5, 2.0, 0.8, 1.2],\n    ...     'pvalue': [0.001, 0.01, 0.5, 0.1]\n    ... })\n    >>> data['neg_log10_p'] = -np.log10(data['pvalue'])\n    >>> ax = enrichment_plot(data, 'enrichment_ratio', 'neg_log10_p')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/expression.py", "line_number": 72, "module": "src.metainformant.visualization.expression", "name": "enrichment_plot", "signature": "(data: pd.DataFrame, x_col: str, y_col: str, **kwargs) -> plt.Axes", "symbol_type": "function"}], "ensure_amalgkit_available": [{"docstring": "Ensure amalgkit CLI is available before running RNA tests.\n\nThis fixture runs automatically for all tests and ensures amalgkit\nis available. If not available, it attempts auto-install.\nIf installation fails, the test session will fail.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 113, "module": "tests.conftest", "name": "ensure_amalgkit_available", "signature": "()", "symbol_type": "function"}], "ensure_cli_available": [{"docstring": "Ensure `amalgkit` CLI is available; optionally attempt auto-install.\n\nReturns (ok, message, install_record_dict_or_none).\ninstall_record contains keys: {\"attempted\": bool, \"return_code\": int, \"stdout\": str, \"stderr\": str}", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 167, "module": "src.metainformant.rna.amalgkit", "name": "ensure_cli_available", "signature": "() -> tuple[bool, str, dict | None]", "symbol_type": "function"}], "ensure_directory": [{"docstring": "Create a directory (and parents) if missing and return it as Path.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 11, "module": "src.metainformant.core.io", "name": "ensure_directory", "signature": "(path: str | Path) -> Path", "symbol_type": "function"}, {"docstring": "Create directory and any missing parent directories.\n\nArgs:\n    path: Directory path to create", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 22, "module": "src.metainformant.core.paths", "name": "ensure_directory", "signature": "(path: Path) -> None", "symbol_type": "function"}], "ensure_venv_activated": [{"docstring": "Automatically activate virtual environment if needed.\n\nUses uv-based venv discovery to handle filesystem limitations.\n\nArgs:\n    auto_setup: If True, automatically setup venv if missing\n    \nReturns:\n    True if venv is activated, False if setup needed", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/_setup_utils.py", "line_number": 226, "module": "scripts.rna._setup_utils", "name": "ensure_venv_activated", "signature": "(auto_setup: bool = True) -> bool", "symbol_type": "function"}], "entropy_estimation": [{"docstring": "Estimate entropy from continuous samples using various methods.\n\nArgs:\n    samples: Array of continuous samples\n    method: Estimation method (\"plugin\", \"miller_madow\", \"chao_shen\")\n    bins: Number of bins for discretization (if applicable)\n    \nReturns:\n    Entropy estimate in bits\n    \nExamples:\n    >>> import numpy as np\n    >>> samples = np.random.normal(0, 1, 1000)\n    >>> h = entropy_estimation(samples, method=\"plugin\")\n    >>> h > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/continuous.py", "line_number": 248, "module": "src.metainformant.information.continuous", "name": "entropy_estimation", "signature": "(samples: np.ndarray, method: str = 'plugin', bins: int | None = None) -> float", "symbol_type": "function"}], "entropy_estimator": [{"docstring": "Estimate entropy from counts using various methods.\n\nArgs:\n    counts: Dictionary of counts or list of counts\n    method: Estimation method (\"plugin\", \"miller_madow\", \"chao_shen\", \"jackknife\")\n    bias_correction: Whether to apply bias correction\n    \nReturns:\n    Entropy estimate in bits\n    \nExamples:\n    >>> counts = {\"A\": 50, \"T\": 30, \"G\": 20}\n    >>> h = entropy_estimator(counts, method=\"miller_madow\")\n    >>> h > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/estimation.py", "line_number": 23, "module": "src.metainformant.information.estimation", "name": "entropy_estimator", "signature": "(counts: dict[Any, int] | list[int], method: str = 'plugin', bias_correction: bool = True) -> float", "symbol_type": "function"}], "entropy_plot": [{"docstring": "Plot entropy values across positions or sequences.\n\nArgs:\n    entropies: Entropy values\n    positions: Optional positions (if None, uses indices)\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import entropy_plot\n    >>> import numpy as np\n    >>> entropies = np.random.uniform(0, 2, 100)\n    >>> ax = entropy_plot(entropies)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/information.py", "line_number": 20, "module": "src.metainformant.visualization.information", "name": "entropy_plot", "signature": "(entropies: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "entry": [{"docstring": "Return the Entry corresponding to this reaction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 748, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "entry", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Call TogoWS 'entry' to fetch a record.\n\nArguments:\n - db - database (string), see list below.\n - id - identifier (string) or a list of identifiers (either as a list of\n   strings or a single string with comma separators).\n - format - return data file format (string), options depend on the database\n   e.g. \"xml\", \"json\", \"gff\", \"fasta\", \"ttl\" (RDF Turtle)\n - field - specific field from within the database record (string)\n   e.g. \"au\" or \"authors\" for pubmed.\n\nAt the time of writing, this includes the following::\n\n    KEGG: compound, drug, enzyme, genes, glycan, orthology, reaction,\n          module, pathway\n    DDBj: ddbj, dad, pdb\n    NCBI: nuccore, nucest, nucgss, nucleotide, protein, gene, onim,\n          homologue, snp, mesh, pubmed\n    EBI:  embl, uniprot, uniparc, uniref100, uniref90, uniref50\n\nFor the current list, please see http://togows.dbcls.jp/entry/\n\nThis function is essentially equivalent to the NCBI Entrez service\nEFetch, available in Biopython as Bio.Entrez.efetch(...), but that\ndoes not offer field extraction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/TogoWS/__init__.py", "line_number": 76, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.TogoWS.__init__", "name": "entry", "signature": "(db, id, format = None, field = None)", "symbol_type": "function"}], "enumerate_atoms": [{"docstring": "Ensure all atoms in entity have serial_number set.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 909, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "enumerate_atoms", "signature": "(entity)", "symbol_type": "function"}], "epost": [{"docstring": "Post a file of identifiers for future use.\n\nPosts a file containing a list of UIs for future use in the user's\nenvironment to use with subsequent search strategies.\n\nSee the online documentation for an explanation of the parameters:\nhttp://www.ncbi.nlm.nih.gov/books/NBK25499/#chapter4.EPost\n\n:returns: Handle to the results.\n:raises urllib.error.URLError: If there's a network error.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/__init__.py", "line_number": 151, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.__init__", "name": "epost", "signature": "(db, **keywds)", "symbol_type": "function"}], "eqtl_analysis": [{"docstring": "Perform expression quantitative trait locus (eQTL) analysis.\n\nIdentifies genetic variants associated with gene expression levels.\n\nArgs:\n    genotypes: DataFrame with samples as rows and variants as columns (0, 1, 2 encoding)\n    expression: DataFrame with samples as rows and genes as columns\n    variant_positions: DataFrame with 'variant_id', 'chrom', 'pos' columns\n    gene_positions: DataFrame with 'gene_id', 'chrom', 'start', 'end' columns\n    window_size: Window size around genes to search for variants (default: 1Mb)\n    min_samples: Minimum number of samples required for association test\n    \nReturns:\n    DataFrame with eQTL associations:\n    - 'gene_id': Gene identifier\n    - 'variant_id': Variant identifier\n    - 'distance': Distance from variant to gene\n    - 'correlation': Correlation between genotype and expression\n    - 'p_value': Statistical significance (if scipy available)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/rna_integration.py", "line_number": 129, "module": "src.metainformant.dna.rna_integration", "name": "eqtl_analysis", "signature": "(genotypes: pd.DataFrame, expression: pd.DataFrame, variant_positions: pd.DataFrame, gene_positions: pd.DataFrame, window_size: int = 1000000, min_samples: int = 10) -> pd.DataFrame", "symbol_type": "function"}], "equilibrium_heterozygosity_infinite_alleles": [{"docstring": "Calculate equilibrium heterozygosity under infinite-alleles mutation model.\n\nUnder the infinite-alleles model, each mutation creates a new unique allele.\nAt equilibrium, mutation (increasing diversity) balances genetic drift\n(decreasing diversity).\n\nArgs:\n    effective_population_size: Effective population size (Ne)\n    mutation_rate: Mutation rate per generation per locus (\u03bc)\n    \nReturns:\n    Equilibrium heterozygosity in [0, 1]. Returns 0.0 if either parameter <= 0.\n    Formula: H_eq = 4Ne\u03bc / (1 + 4Ne\u03bc)\n    \nExamples:\n    >>> equilibrium_heterozygosity_infinite_alleles(effective_population_size=1000, mutation_rate=0.0001)\n    0.285...\n    >>> equilibrium_heterozygosity_infinite_alleles(effective_population_size=10000, mutation_rate=0.0001)\n    0.8...\n    \nReferences:\n    Kimura, M., & Crow, J. F. (1964). The number of alleles that can be\n    maintained in a finite population. Genetics, 49(4), 725-738.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 240, "module": "src.metainformant.math.popgen", "name": "equilibrium_heterozygosity_infinite_alleles", "signature": "(effective_population_size: float, mutation_rate: float) -> float", "symbol_type": "function"}], "equischizomers": [{"docstring": "List equischizomers of the enzyme.\n\nReturn a tuple of all the isoschizomers of RE.\nIf batch is supplied it is used instead of the default AllEnzymes.\n\nEquischizomer: same site, same position of restriction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 621, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "equischizomers", "signature": "(cls, batch = None)", "symbol_type": "function"}], "error_context": [{"docstring": "Context manager for adding error context.\n\nArgs:\n    context_msg: Message to add to exception\n    reraise: Whether to reraise the exception with context\n\nExample:\n    with error_context(\"Failed to process file\"):\n        # Operations that might fail\n        process_file(path)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/errors.py", "line_number": 156, "module": "src.metainformant.core.errors", "name": "error_context", "signature": "(context_msg: str, reraise: bool = True) -> Iterator[None]", "symbol_type": "function"}], "esearch": [{"docstring": "Run an Entrez search and return a handle to the results.\n\nESearch searches and retrieves primary IDs (for use in EFetch, ELink\nand ESummary) and term translations, and optionally retains results\nfor future use in the user's environment.\n\nSee the online documentation for an explanation of the parameters:\nhttp://www.ncbi.nlm.nih.gov/books/NBK25499/#chapter4.ESearch\n\nShort example:\n\n>>> from Bio import Entrez\n>>> Entrez.email = \"Your.Name.Here@example.org\"\n>>> handle = Entrez.esearch(\n...     db=\"nucleotide\", retmax=10, idtype=\"acc\",\n...     term=\"opuntia[ORGN] accD 2007[Publication Date]\"\n... )\n...\n>>> record = Entrez.read(handle)\n>>> handle.close()\n>>> int(record[\"Count\"]) >= 2\nTrue\n>>> \"EF590893.1\" in record[\"IdList\"]\nTrue\n>>> \"EF590892.1\" in record[\"IdList\"]\nTrue\n\n:returns: Handle to the results, which are always in XML format.\n:raises urllib.error.URLError: If there's a network error.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/__init__.py", "line_number": 204, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.__init__", "name": "esearch", "signature": "(db, term, **keywds)", "symbol_type": "function"}], "espell": [{"docstring": "Retrieve spelling suggestions as a results handle.\n\nESpell retrieves spelling suggestions, if available.\n\nSee the online documentation for an explanation of the parameters:\nhttp://www.ncbi.nlm.nih.gov/books/NBK25499/#chapter4.ESpell\n\nShort example:\n\n>>> from Bio import Entrez\n>>> Entrez.email = \"Your.Name.Here@example.org\"\n>>> record = Entrez.read(Entrez.espell(term=\"biopythooon\"))\n>>> print(record[\"Query\"])\nbiopythooon\n>>> print(record[\"CorrectedQuery\"])\nbiopython\n\n:returns: Handle to the results, by default in XML format.\n:raises urllib.error.URLError: If there's a network error.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/__init__.py", "line_number": 388, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.__init__", "name": "espell", "signature": "(**keywds)", "symbol_type": "function"}], "estimate_population_structure": [{"docstring": "Estimate population structure from VCF file.\n\nArgs:\n    vcf_path: Path to VCF file\n    config: Structure configuration with compute_pca, n_components, etc.\n    output_dir: Optional directory to write PCA and kinship results\n\nReturns:\n    Dictionary with PCA and kinship results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/structure.py", "line_number": 360, "module": "src.metainformant.gwas.structure", "name": "estimate_population_structure", "signature": "(vcf_path: str | Path, config: dict[str, Any], output_dir: str | Path | None = None) -> dict[str, Any]", "symbol_type": "function"}], "esummary": [{"docstring": "Retrieve document summaries as a results handle.\n\nESummary retrieves document summaries from a list of primary IDs or\nfrom the user's environment.\n\nSee the online documentation for an explanation of the parameters:\nhttp://www.ncbi.nlm.nih.gov/books/NBK25499/#chapter4.ESummary\n\nThis example discovers more about entry 19923 in the structure\ndatabase:\n\n>>> from Bio import Entrez\n>>> Entrez.email = \"Your.Name.Here@example.org\"\n>>> handle = Entrez.esummary(db=\"structure\", id=\"19923\")\n>>> record = Entrez.read(handle)\n>>> handle.close()\n>>> print(record[0][\"Id\"])\n19923\n>>> print(record[0][\"PdbDescr\"])\nCRYSTAL STRUCTURE OF E. COLI ACONITASE B\n\n\n:returns: Handle to the results, by default in XML format.\n:raises urllib.error.URLError: If there's a network error.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/__init__.py", "line_number": 315, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.__init__", "name": "esummary", "signature": "(**keywds)", "symbol_type": "function"}], "evaluate_classifier": [{"docstring": "Evaluate classifier performance.\n\nArgs:\n    classifier: Fitted classifier\n    X_test: Test features (can also use X as keyword)\n    y_test: True test labels (can also use y as keyword)\n\nReturns:\n    Dictionary of evaluation metrics including 'accuracy' and 'predictions'", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/classification.py", "line_number": 414, "module": "src.metainformant.ml.classification", "name": "evaluate_classifier", "signature": "(classifier: BiologicalClassifier, X_test: np.ndarray = None, y_test: np.ndarray = None, X: np.ndarray = None, y: np.ndarray = None) -> Dict[str, Any]", "symbol_type": "function"}], "evaluate_regressor": [{"docstring": "Evaluate regressor performance.\n\nArgs:\n    regressor: Fitted regressor\n    X_test: Test features (can also use X as keyword)\n    y_test: True test labels (can also use y as keyword)\n\nReturns:\n    Dictionary of evaluation metrics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/regression.py", "line_number": 127, "module": "src.metainformant.ml.regression", "name": "evaluate_regressor", "signature": "(regressor: BiologicalRegressor, X_test: np.ndarray = None, y_test: np.ndarray = None, X: np.ndarray = None, y: np.ndarray = None) -> Dict[str, float]", "symbol_type": "function"}], "event_importance": [{"docstring": "Rank events by their contribution to predictions.\n\nArgs:\n    predictor: Trained EventSequencePredictor (must be fitted)\n    sequences: List of event sequences (must not be empty)\n    event_embeddings: Event embeddings dictionary\n    method: Importance method (\"permutation\", \"gradient\")\n    \nReturns:\n    Dictionary mapping event tokens to importance scores (normalized to [0, 1])\n    \nRaises:\n    ValueError: If predictor not fitted, sequences empty, or invalid method\n    \nExamples:\n    >>> from metainformant.life_events import EventSequencePredictor, learn_event_embeddings\n    >>> import numpy as np\n    >>> sequences = [[\"health:diagnosis\", \"occupation:job_change\"]]\n    >>> y = np.array([0])\n    >>> predictor = EventSequencePredictor(random_state=42)\n    >>> predictor.fit(sequences, y)\n    >>> embeddings = learn_event_embeddings(sequences, random_state=42)\n    >>> importance = event_importance(predictor, sequences, embeddings)\n    >>> len(importance) > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/interpretability.py", "line_number": 51, "module": "src.metainformant.life_events.interpretability", "name": "event_importance", "signature": "(predictor: 'EventSequencePredictor', sequences: List[List[str]], event_embeddings: Dict[str, NDArray], method: str = 'permutation') -> Dict[str, float]", "symbol_type": "function"}], "events": [{"docstring": "Create events object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 579, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "events", "signature": "(self, elem)", "symbol_type": "function"}], "ewens_watterson_test": [{"docstring": "Ewens-Watterson test for selective neutrality.\n\nTests whether observed allele frequency distribution matches the expected\ndistribution under the neutral infinite-alleles model.\n\nArgs:\n    allele_frequencies: List of allele frequencies per site\n    sample_size: Number of sampled sequences (n)\n    \nReturns:\n    Dictionary with:\n    - f_statistic: Ewens-Watterson F statistic\n    - expected_f: Expected F under neutrality\n    - variance_f: Variance of F under neutrality\n    - p_value: Approximate p-value (if calculable)\n    \nExamples:\n    >>> freqs = [0.5, 0.3, 0.2]\n    >>> result = ewens_watterson_test(freqs, sample_size=10)\n    >>> \"f_statistic\" in result\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 521, "module": "src.metainformant.math.coalescent", "name": "ewens_watterson_test", "signature": "(allele_frequencies: Iterable[float], sample_size: int) -> dict[str, float]", "symbol_type": "function"}], "execute": [{"docstring": "Execute a sql statement.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 303, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "execute", "signature": "(self, operation, params = None, multi = False)", "symbol_type": "function"}, {"docstring": "Just execute an sql command.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 543, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "execute", "signature": "(self, sql, args = None)", "symbol_type": "function"}, {"docstring": "Just execute an sql command.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/DBUtils.py", "line_number": 42, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.DBUtils", "name": "execute", "signature": "(self, cursor, sql, args = None)", "symbol_type": "function"}, {"docstring": "Execute SQL command.\n\nReplaces %s with ? for variable substitution in sqlite3.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/DBUtils.py", "line_number": 62, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.DBUtils", "name": "execute", "signature": "(self, cursor, sql, args = None)", "symbol_type": "function"}], "execute_and_fetch_col0": [{"docstring": "Return a list of values from the first column in the row.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 576, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "execute_and_fetch_col0", "signature": "(self, sql, args = None)", "symbol_type": "function"}, {"docstring": "Return a list of values from the first column in the row.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 610, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "execute_and_fetch_col0", "signature": "(self, sql, args = None)", "symbol_type": "function"}], "execute_and_fetchall": [{"docstring": "Return a list of tuples of all rows.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 581, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "execute_and_fetchall", "signature": "(self, sql, args = None)", "symbol_type": "function"}, {"docstring": "Return a list of tuples of all rows.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 615, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "execute_and_fetchall", "signature": "(self, sql, args = None)", "symbol_type": "function"}], "execute_gwas_workflow": [{"docstring": "Execute the full GWAS workflow in order.\n\nWorkflow steps:\n1. Configuration loading\n2. Genome preparation (if needed)\n3. Variant acquisition (download, call, or use existing)\n4. Quality control\n5. Population structure analysis\n6. Phenotype loading\n7. Association testing\n8. Multiple testing correction\n9. Visualization\n10. Results export\n\nArgs:\n    config: GWAS workflow configuration\n    check: If True, only validate configuration without execution\n\nReturns:\n    Dictionary with workflow results and metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/workflow.py", "line_number": 24, "module": "src.metainformant.gwas.workflow", "name": "execute_gwas_workflow", "signature": "(config: GWASWorkflowConfig) -> dict[str, Any]", "symbol_type": "function"}], "execute_one": [{"docstring": "Execute sql that returns 1 record, and return the record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 535, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "execute_one", "signature": "(self, sql, args = None)", "symbol_type": "function"}, {"docstring": "Execute sql that returns 1 record, and return the record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 605, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "execute_one", "signature": "(self, sql, args = None)", "symbol_type": "function"}], "execute_workflow": [{"docstring": "Execute the full amalgkit workflow in order.\n\nThis workflow provides end-to-end functionality:\n1. Automatic genome download \u2192 transcriptome preparation \u2192 kallisto indexing (if genome config exists)\n2. Metadata retrieval for available samples\n3. Immediate per-sample processing: download \u2192 quantify \u2192 delete FASTQ (default behavior)\n\nGenome setup is automatic: if genome config exists but genome/index is missing,\nthe workflow will automatically download and prepare everything before proceeding.\n\nReturns a list of return codes per step in order.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/workflow.py", "line_number": 373, "module": "src.metainformant.rna.workflow", "name": "execute_workflow", "signature": "(config: AmalgkitWorkflowConfig) -> list[int]", "symbol_type": "function"}], "executemany": [{"docstring": "Execute many sql statements.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 307, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "executemany", "signature": "(self, operation, params)", "symbol_type": "function"}, {"docstring": "Execute many sql commands.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 549, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "executemany", "signature": "(self, sql, args)", "symbol_type": "function"}, {"docstring": "Execute many sql commands.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/DBUtils.py", "line_number": 46, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.DBUtils", "name": "executemany", "signature": "(self, cursor, sql, seq)", "symbol_type": "function"}, {"docstring": "Execute many sql statements.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/DBUtils.py", "line_number": 70, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.DBUtils", "name": "executemany", "signature": "(self, cursor, sql, seq)", "symbol_type": "function"}], "expand_and_resolve": [{"docstring": "Expand user (~) and resolve to absolute path without requiring existence.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 6, "module": "src.metainformant.core.paths", "name": "expand_and_resolve", "signature": "(path: str | Path) -> Path", "symbol_type": "function"}], "expect_alias": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 260, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_alias", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 260, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_alias", "signature": "(self)", "symbol_type": "function"}], "expect_block_mapping": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 388, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_block_mapping", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 388, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_block_mapping", "signature": "(self)", "symbol_type": "function"}], "expect_block_mapping_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 395, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_block_mapping_key", "signature": "(self, first = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 395, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_block_mapping_key", "signature": "(self, first = False)", "symbol_type": "function"}], "expect_block_mapping_simple_value": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 409, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_block_mapping_simple_value", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 409, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_block_mapping_simple_value", "signature": "(self)", "symbol_type": "function"}], "expect_block_mapping_value": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 414, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_block_mapping_value", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 414, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_block_mapping_value", "signature": "(self)", "symbol_type": "function"}], "expect_block_sequence": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 368, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_block_sequence", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 368, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_block_sequence", "signature": "(self)", "symbol_type": "function"}], "expect_block_sequence_item": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 376, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_block_sequence_item", "signature": "(self, first = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 376, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_block_sequence_item", "signature": "(self, first = False)", "symbol_type": "function"}], "expect_document_end": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 214, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_document_end", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 214, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_document_end", "signature": "(self)", "symbol_type": "function"}], "expect_document_root": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 226, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_document_root", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 226, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_document_root", "signature": "(self)", "symbol_type": "function"}], "expect_document_start": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 178, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_document_start", "signature": "(self, first = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 178, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_document_start", "signature": "(self, first = False)", "symbol_type": "function"}], "expect_first_block_mapping_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 392, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_first_block_mapping_key", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 392, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_first_block_mapping_key", "signature": "(self)", "symbol_type": "function"}], "expect_first_block_sequence_item": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 373, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_first_block_sequence_item", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 373, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_first_block_sequence_item", "signature": "(self)", "symbol_type": "function"}], "expect_first_document_start": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 175, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_first_document_start", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 175, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_first_document_start", "signature": "(self)", "symbol_type": "function"}], "expect_first_flow_mapping_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 316, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_first_flow_mapping_key", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 316, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_first_flow_mapping_key", "signature": "(self)", "symbol_type": "function"}], "expect_first_flow_sequence_item": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 280, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_first_flow_sequence_item", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 280, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_first_flow_sequence_item", "signature": "(self)", "symbol_type": "function"}], "expect_flow_mapping": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 310, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_flow_mapping", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 310, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_flow_mapping", "signature": "(self)", "symbol_type": "function"}], "expect_flow_mapping_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 333, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_flow_mapping_key", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 333, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_flow_mapping_key", "signature": "(self)", "symbol_type": "function"}], "expect_flow_mapping_simple_value": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 354, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_flow_mapping_simple_value", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 354, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_flow_mapping_simple_value", "signature": "(self)", "symbol_type": "function"}], "expect_flow_mapping_value": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 359, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_flow_mapping_value", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 359, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_flow_mapping_value", "signature": "(self)", "symbol_type": "function"}], "expect_flow_sequence": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 274, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_flow_sequence", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 274, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_flow_sequence", "signature": "(self)", "symbol_type": "function"}], "expect_flow_sequence_item": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 292, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_flow_sequence_item", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 292, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_flow_sequence_item", "signature": "(self)", "symbol_type": "function"}], "expect_node": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 232, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_node", "signature": "(self, root = False, sequence = False, mapping = False, simple_key = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 232, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_node", "signature": "(self, root = False, sequence = False, mapping = False, simple_key = False)", "symbol_type": "function"}], "expect_nothing": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 170, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_nothing", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 170, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_nothing", "signature": "(self)", "symbol_type": "function"}], "expect_scalar": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 266, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_scalar", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 266, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_scalar", "signature": "(self)", "symbol_type": "function"}], "expect_stream_start": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 160, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "expect_stream_start", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 160, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "expect_stream_start", "signature": "(self)", "symbol_type": "function"}], "expectation": [{"docstring": "Calculate weighted or unweighted expectation (mean) of values.\n\nArgs:\n    values: Iterable of numeric values\n    weights: Optional weights for each value. If None, computes simple mean.\n    \nReturns:\n    Weighted mean if weights provided, else arithmetic mean. Returns 0.0 for empty input.\n    \nExamples:\n    >>> expectation([1.0, 2.0, 3.0])\n    2.0\n    >>> expectation([1.0, 2.0, 3.0], weights=[1.0, 2.0, 1.0])\n    2.0", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 6, "module": "src.metainformant.math.price", "name": "expectation", "signature": "(values: Iterable[float], weights: Iterable[float] | None = None) -> float", "symbol_type": "function"}], "expected_coalescent_waiting_times": [{"docstring": "Calculate expected waiting times for each coalescent event.\n\nUnder Kingman's coalescent, the expected time until k lineages coalesce\nto (k-1) lineages is 4Ne / (k(k-1)) for diploids.\n\nArgs:\n    sample_size: Number of sampled sequences (n)\n    effective_population_size: Effective population size (Ne, diploid)\n    \nReturns:\n    List of expected waiting times in generations, one for each coalescent\n    event from n lineages down to 2 lineages. The k-th element (0-indexed)\n    is the expected time for (n-k) lineages to coalesce to (n-k-1) lineages.\n    Formula: E[T\u2096] = 4Ne / (k(k-1)). Returns empty list if inputs invalid.\n    \nExamples:\n    >>> times = expected_coalescent_waiting_times(sample_size=5, effective_population_size=1000)\n    >>> len(times)\n    3  # 5->4, 4->3, 3->2 coalescent events\n    >>> times[0] < times[-1]  # More recent coalescence faster\n    True\n    \nReferences:\n    Kingman, J. F. C. (1982). On the genealogy of large populations.\n    Journal of Applied Probability, 19(A), 27-43.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 733, "module": "src.metainformant.math.coalescent", "name": "expected_coalescent_waiting_times", "signature": "(sample_size: int, effective_population_size: float) -> list[float]", "symbol_type": "function"}], "expected_pairwise_diversity": [{"docstring": "Calculate expected pairwise nucleotide diversity \u03c0 under neutral equilibrium.\n\nUnder the infinite sites model with neutral mutations, the expected pairwise\ndiversity equals the population mutation parameter \u03b8 = 4Ne\u03bc for diploids.\n\nArgs:\n    effective_population_size: Effective population size (Ne, diploid)\n    mutation_rate: Mutation rate per site per generation (\u03bc)\n    \nReturns:\n    Expected pairwise diversity \u03c0. Formula: E[\u03c0] = 4Ne \u00d7 \u03bc (diploid).\n    Returns 0.0 if Ne <= 0 or \u03bc <= 0.\n    \nExamples:\n    >>> expected_pairwise_diversity(effective_population_size=10000, mutation_rate=0.0001)\n    4.0\n    >>> expected_pairwise_diversity(effective_population_size=1000, mutation_rate=0.00001)\n    0.04\n    \nReferences:\n    Tajima, F. (1983). Evolutionary relationship of DNA sequences in finite\n    populations. Genetics, 105(2), 437-460.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 73, "module": "src.metainformant.math.coalescent", "name": "expected_pairwise_diversity", "signature": "(effective_population_size: float, mutation_rate: float) -> float", "symbol_type": "function"}], "expected_pairwise_diversity_from_theta": [{"docstring": "Calculate expected pairwise diversity from population mutation parameter \u03b8.\n\nUnder the infinite sites model, the expected pairwise diversity equals\nthe population mutation parameter \u03b8 (for per-site calculations).\n\nArgs:\n    theta: Population mutation parameter \u03b8. For diploids: \u03b8 = 4Ne\u03bc.\n        For haploid: \u03b8 = 2Ne\u03bc.\n        \nReturns:\n    Expected pairwise diversity \u03c0. For infinite sites model, E[\u03c0] = \u03b8.\n    Returns 0.0 if theta <= 0.\n    \nExamples:\n    >>> expected_pairwise_diversity_from_theta(theta=0.01)\n    0.01\n    >>> expected_pairwise_diversity_from_theta(theta=1.5)\n    1.5\n    \nNote:\n    This is for per-site diversity. For genome-wide estimates, multiply\n    by the number of sites or use expected_pairwise_diversity() with\n    effective size and mutation rate.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 102, "module": "src.metainformant.math.coalescent", "name": "expected_pairwise_diversity_from_theta", "signature": "(theta: float) -> float", "symbol_type": "function"}], "expected_r2_from_Ne_c": [{"docstring": "Calculate expected r\u00b2 under mutation-drift-recombination balance.\n\nUnder neutral evolution, the expected LD between unlinked loci depends\non effective population size and recombination rate. Higher Ne or higher\nrecombination leads to lower expected LD.\n\nArgs:\n    effective_population_size: Effective population size (Ne)\n    recombination_fraction: Recombination fraction (c) in [0, 0.5]\n    \nReturns:\n    Expected r\u00b2 value in [0, 1]. Returns 0.0 if Ne <= 0.\n    Formula: E[r\u00b2] \u2248 1 / (1 + 4Ne \u00d7 c)\n    \nExamples:\n    >>> expected_r2_from_Ne_c(effective_population_size=1000, recombination_fraction=0.01)\n    0.961...\n    >>> expected_r2_from_Ne_c(effective_population_size=10000, recombination_fraction=0.1)\n    0.024...  # Much lower LD with larger Ne and higher recombination\n    \nReferences:\n    Hill, W. G., & Robertson, A. (1968). Linkage disequilibrium in finite\n    populations. Theoretical and Applied Genetics, 38(6), 226-231.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/ld.py", "line_number": 252, "module": "src.metainformant.math.ld", "name": "expected_r2_from_Ne_c", "signature": "(effective_population_size: float, recombination_fraction: float) -> float", "symbol_type": "function"}], "expected_segregating_sites": [{"docstring": "Calculate expected number of segregating sites under infinite sites model.\n\nUnder the infinite sites model (each mutation creates a new unique site),\nthe expected number of segregating sites depends on \u03b8, sample size, and\nsequence length.\n\nArgs:\n    sample_size: Number of sampled sequences (n)\n    theta: Population mutation parameter \u03b8. For diploids: \u03b8 = 4Ne\u03bc.\n        For haploid: \u03b8 = 2Ne\u03bc.\n    sequence_length: Optional sequence length L. If provided, assumes\n        per-site \u03b8 and multiplies result by L.\n        \nReturns:\n    Expected number of segregating sites. Formula: E[S] = a\u2081 \u00d7 \u03b8 where\n    a\u2081 = \u03a3\u1d62\u208c\u2081\u207f\u207b\u00b9 1/i. If sequence_length is provided, returns E[S] = a\u2081 \u00d7 \u03b8 \u00d7 L.\n    Returns 0.0 if inputs invalid.\n    \nExamples:\n    >>> expected_segregating_sites(sample_size=10, theta=0.01)\n    2.82...\n    >>> expected_segregating_sites(sample_size=10, theta=0.001, sequence_length=1000)\n    2.82...\n    \nReferences:\n    Watterson, G. A. (1975). On the number of segregating sites in genetical\n    models without recombination. Theoretical Population Biology, 7(2), 256-276.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 642, "module": "src.metainformant.math.coalescent", "name": "expected_segregating_sites", "signature": "(sample_size: int, theta: float) -> float", "symbol_type": "function"}], "expected_sfs_counts": [{"docstring": "Calculate expected site frequency spectrum (SFS) counts under neutral equilibrium.\n\nThe site frequency spectrum describes the distribution of allele frequencies\nacross polymorphic sites. Under neutral equilibrium, rare variants are more\ncommon than common variants due to the recent origin of most mutations.\n\nArgs:\n    sample_size: Number of sampled sequences (n)\n    theta: Population mutation parameter \u03b8. For diploids: \u03b8 = 4Ne\u03bc.\n        For haploid: \u03b8 = 2Ne\u03bc.\n    sequence_length: Optional sequence length L. If provided, multiplies\n        each count by L.\n        \nReturns:\n    List of length (n-1) containing expected counts of sites with\n    i derived alleles, for i = 1, 2, ..., n-1. Formula: E[\u03be\u1d62] = \u03b8 / i\n    (per-site). If sequence_length provided, E[\u03be\u1d62] = \u03b8 \u00d7 L / i.\n    Returns zeros if inputs invalid.\n    \nExamples:\n    >>> sfs = expected_sfs_counts(sample_size=5, theta=0.01)\n    >>> len(sfs)\n    4\n    >>> sfs[0] > sfs[-1]  # Rare variants more common\n    True\n    \nReferences:\n    Fu, Y. X. (1995). Statistical properties of segregating sites.\n    Theoretical Population Biology, 48(2), 172-197.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 687, "module": "src.metainformant.math.coalescent", "name": "expected_sfs_counts", "signature": "(sample_size: int, theta: float) -> list[float]", "symbol_type": "function"}], "expected_time_to_mrca": [{"docstring": "Calculate expected time to most recent common ancestor (MRCA).\n\nUnder Kingman's coalescent model, this is the expected total time (in generations)\nuntil all sampled lineages have coalesced to a single common ancestor.\n\nArgs:\n    sample_size: Number of sampled individuals (n)\n    effective_population_size: Effective population size (Ne, diploid)\n    \nReturns:\n    Expected time to MRCA. Formula: T_MRCA = 4N \\sum_{k=2}^n 1/(k(k-1))\n    Uses diploid scaling (4N). Returns 0.0 for invalid inputs.\n    \nExamples:\n    >>> expected_time_to_mrca(sample_size=10, effective_population_size=1000)\n    7366.6...\n    >>> expected_time_to_mrca(sample_size=2, effective_population_size=1000)\n    4000.0\n    \nReferences:\n    Kingman, J. F. C. (1982). On the genealogy of large populations.\n    Journal of Applied Probability, 19(A), 27-43.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 8, "module": "src.metainformant.math.coalescent", "name": "expected_time_to_mrca", "signature": "(sample_size: int, effective_population_size: float) -> float", "symbol_type": "function"}], "expected_total_branch_length": [{"docstring": "Calculate expected total branch length of coalescent tree.\n\nComputes the expected sum of all branch lengths in the coalescent tree\nuntil all lineages have coalesced. This is proportional to the expected\nnumber of mutations in the sample.\n\nArgs:\n    sample_size: Number of sampled individuals (n)\n    effective_population_size: Effective population size (Ne, diploid)\n    \nReturns:\n    Expected total branch length in generations. Formula: E[L] = 4Ne \u00d7 H_{n-1}\n    where H_{n-1} is the (n-1)th harmonic number. Returns 0.0 for invalid inputs.\n    \nExamples:\n    >>> expected_total_branch_length(sample_size=10, effective_population_size=1000)\n    9677.4...\n    >>> expected_total_branch_length(sample_size=2, effective_population_size=1000)\n    4000.0\n    \nReferences:\n    Kingman, J. F. C. (1982). On the genealogy of large populations.\n    Journal of Applied Probability, 19(A), 27-43.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 40, "module": "src.metainformant.math.coalescent", "name": "expected_total_branch_length", "signature": "(sample_size: int, effective_population_size: float) -> float", "symbol_type": "function"}], "exponential_growth_effective_size": [{"docstring": "Calculate effective population size under exponential growth.\n\nUnder exponential growth, the effective population size is the harmonic\nmean of population sizes over time. This approximates the expected\ncoalescence time for a sample.\n\nArgs:\n    current_size: Current population size (N_t)\n    growth_rate: Per-generation growth rate (r). Positive for growth,\n        negative for decline. For exponential growth: N_t = N_0 * e^(r*t)\n    generations: Number of generations over which to calculate harmonic mean\n\nReturns:\n    Effective population size (harmonic mean). Returns current_size if\n    generations <= 0 or growth_rate is zero.\n    \nExamples:\n    >>> # Growing population: 1000 \u2192 10000 over 10 generations\n    >>> exponential_growth_effective_size(10000, growth_rate=0.23, generations=10)\n    4342...\n    \n    >>> # Declining population\n    >>> exponential_growth_effective_size(1000, growth_rate=-0.1, generations=10)\n    371...\n    \nReferences:\n    Maruyama, T., & Fuerst, P. A. (1984). Population bottlenecks and\n    nonequilibrium models in population genetics. I. Allele numbers when\n    populations evolve from zero variability. Genetics, 108(3), 745-763.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/demography.py", "line_number": 8, "module": "src.metainformant.math.demography", "name": "exponential_growth_effective_size", "signature": "(current_size: int, growth_rate: float, generations: int) -> float", "symbol_type": "function"}], "export_csv": [{"docstring": "Export embeddings to CSV format.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/export_embeddings.py", "line_number": 53, "module": "scripts.life_events.export_embeddings", "name": "export_csv", "signature": "(embeddings: dict, output_path: Path)", "symbol_type": "function"}], "export_fasta": [{"docstring": "Write matrix into a fasta file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 1771, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "export_fasta", "signature": "(self, filename = None, width = 70)", "symbol_type": "function"}], "export_network": [{"docstring": "Export network to file in various formats.\n\nSupports multiple export formats for network persistence and sharing:\n- JSON: Human-readable format with all attributes\n- CSV: Simple edge list format\n- GraphML: XML-based format for graph tools\n\nArgs:\n    network: Biological network to export\n    filepath: Path to output file\n    format: Export format (\"json\", \"csv\", \"graphml\"). Default \"json\"\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\"])\n    >>> network.add_edge(\"A\", \"B\", weight=0.8)\n    >>> export_network(network, \"network.json\", format=\"json\")\n    \nRaises:\n    ValueError: If format is not supported", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 603, "module": "src.metainformant.networks.graph", "name": "export_network", "signature": "(network: BiologicalNetwork, filepath: str, format: str = 'json') -> None", "symbol_type": "function"}], "export_numpy": [{"docstring": "Export embeddings to NumPy format.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/export_embeddings.py", "line_number": 83, "module": "scripts.life_events.export_embeddings", "name": "export_numpy", "signature": "(embeddings: dict, output_path: Path)", "symbol_type": "function"}], "export_phylip": [{"docstring": "Write matrix into a PHYLIP file.\n\nNote that this writes a relaxed PHYLIP format file, where the names\nare not truncated, nor checked for invalid characters.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 1790, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "export_phylip", "signature": "(self, filename = None)", "symbol_type": "function"}], "export_to_string_format": [{"docstring": "Export PPI network to STRING database format.\n\nExports interactions in STRING TSV format compatible with STRING database\ntools and visualization.\n\nArgs:\n    ppi_network: ProteinNetwork to export\n    filepath: Output file path\n    score_threshold: Minimum combined score (0-1000) to include.\n        Interactions below threshold are excluded.\n        \nExamples:\n    >>> ppi = ProteinNetwork()\n    >>> ppi.add_interaction(\"P1\", \"P2\", confidence=0.8)\n    >>> export_to_string_format(ppi, \"output.tsv\", score_threshold=400)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 928, "module": "src.metainformant.networks.ppi", "name": "export_to_string_format", "signature": "(ppi_network: ProteinNetwork, filepath: str, score_threshold: int = 400) -> None", "symbol_type": "function"}], "export_word2vec": [{"docstring": "Export embeddings to Word2Vec text format.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/export_embeddings.py", "line_number": 71, "module": "scripts.life_events.export_embeddings", "name": "export_word2vec", "signature": "(embeddings: dict, output_path: Path)", "symbol_type": "function"}], "expression_heatmap": [{"docstring": "Create an expression heatmap with clustering.\n\nArgs:\n    data: Expression data (genes x samples)\n    row_cluster: Whether to cluster rows (genes)\n    col_cluster: Whether to cluster columns (samples)\n    cmap: Colormap for expression values\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments for seaborn.clustermap\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import expression_heatmap\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> data = pd.DataFrame(np.random.random((10, 5)))\n    >>> ax = expression_heatmap(data)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/expression.py", "line_number": 31, "module": "src.metainformant.visualization.expression", "name": "expression_heatmap", "signature": "(data: pd.DataFrame, **kwargs) -> plt.Axes", "symbol_type": "function"}], "extend": [{"docstring": "Add a sequence to the original mutable sequence object.\n\n>>> my_seq = MutableSeq('ACTCGACGTCG')\n>>> my_seq.extend('A')\n>>> my_seq\nMutableSeq('ACTCGACGTCGA')\n>>> my_seq.extend('TTT')\n>>> my_seq\nMutableSeq('ACTCGACGTCGATTT')\n\nNo return value.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2328, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "extend", "signature": "(self, other)", "symbol_type": "function"}, {"docstring": "Add more SeqRecord objects to the alignment as rows.\n\nThey must all have the same length as the original alignment. For\nexample,\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqRecord import SeqRecord\n>>> from Bio.Align import MultipleSeqAlignment\n>>> a = SeqRecord(Seq(\"AAAACGT\"), id=\"Alpha\")\n>>> b = SeqRecord(Seq(\"AAA-CGT\"), id=\"Beta\")\n>>> c = SeqRecord(Seq(\"AAAAGGT\"), id=\"Gamma\")\n>>> d = SeqRecord(Seq(\"AAAACGT\"), id=\"Delta\")\n>>> e = SeqRecord(Seq(\"AAA-GGT\"), id=\"Epsilon\")\n\nFirst we create a small alignment (three rows):\n\n>>> align = MultipleSeqAlignment([a, b, c])\n>>> print(align)\nAlignment with 3 rows and 7 columns\nAAAACGT Alpha\nAAA-CGT Beta\nAAAAGGT Gamma\n\nNow we can extend this alignment with another two rows:\n\n>>> align.extend([d, e])\n>>> print(align)\nAlignment with 5 rows and 7 columns\nAAAACGT Alpha\nAAA-CGT Beta\nAAAAGGT Gamma\nAAAACGT Delta\nAAA-GGT Epsilon\n\nBecause the alignment object allows iteration over the rows as\nSeqRecords, you can use the extend method with a second alignment\n(provided its sequences have the same length as the original alignment).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 439, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "extend", "signature": "(self, records)", "symbol_type": "function"}, {"docstring": "Append another SeqMap onto the end of self.\n\nBoth SeqMaps must have the same PDB ID, PDB datestamp and\nRAF version.  The RAF flags are erased if they are inconsistent. This\nmay happen when fragments are taken from different chains.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/Raf.py", "line_number": 207, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.Raf", "name": "extend", "signature": "(self, other)", "symbol_type": "function"}], "externalEntityRefHandler": [{"docstring": "Handle external entity reference in order to cache DTD locally.\n\nThe purpose of this function is to load the DTD locally, instead\nof downloading it from the URL specified in the XML. Using the local\nDTD results in much faster parsing. If the DTD is not found locally,\nwe try to download it. If new DTDs become available from NCBI,\nputting them in Bio/Entrez/DTDs will allow the parser to see them.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 1095, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "externalEntityRefHandler", "signature": "(self, context, base, systemId, publicId)", "symbol_type": "function"}], "extract": [{"docstring": "Extract the feature's sequence from supplied parent sequence.\n\nThe parent_sequence can be a Seq like object or a string, and will\ngenerally return an object of the same type. The exception to this is\na MutableSeq as the parent sequence will return a Seq object.\n\nThis should cope with complex locations including complements, joins\nand fuzzy positions. Even mixed strand features should work! This\nalso covers features on protein sequences (e.g. domains), although\nhere reverse strand features are not permitted. If the\nlocation refers to other records, they must be supplied in the\noptional dictionary references.\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqFeature import SeqFeature, SimpleLocation\n>>> seq = Seq(\"MKQHKAMIVALIVICITAVVAAL\")\n>>> f = SeqFeature(SimpleLocation(8, 15), type=\"domain\")\n>>> f.extract(seq)\nSeq('VALIVIC')\n\nIf the SimpleLocation is None, e.g. when parsing invalid locus\nlocations in the GenBank parser, extract() will raise a ValueError.\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqFeature import SeqFeature\n>>> seq = Seq(\"MKQHKAMIVALIVICITAVVAAL\")\n>>> f = SeqFeature(None, type=\"domain\")\n>>> f.extract(seq)\nTraceback (most recent call last):\n   ...\nValueError: The feature's .location is None. Check the sequence file for a valid location.\n\nNote - currently only compound features of type \"join\" are supported.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 289, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "extract", "signature": "(self, parent_sequence, references = None)", "symbol_type": "function"}, {"docstring": "Extract the sequence from supplied parent sequence using the SimpleLocation object.\n\nThe parent_sequence can be a Seq like object or a string, and will\ngenerally return an object of the same type. The exception to this is\na MutableSeq as the parent sequence will return a Seq object.\nIf the location refers to other records, they must be supplied\nin the optional dictionary references.\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqFeature import SimpleLocation\n>>> seq = Seq(\"MKQHKAMIVALIVICITAVVAAL\")\n>>> feature_loc = SimpleLocation(8, 15)\n>>> feature_loc.extract(seq)\nSeq('VALIVIC')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 1272, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "extract", "signature": "(self, parent_sequence, references = None)", "symbol_type": "function"}, {"docstring": "Extract the sequence from supplied parent sequence using the CompoundLocation object.\n\nThe parent_sequence can be a Seq like object or a string, and will\ngenerally return an object of the same type. The exception to this is\na MutableSeq as the parent sequence will return a Seq object.\nIf the location refers to other records, they must be supplied\nin the optional dictionary references.\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqFeature import SimpleLocation, CompoundLocation\n>>> seq = Seq(\"MKQHKAMIVALIVICITAVVAAL\")\n>>> fl1 = SimpleLocation(2, 8)\n>>> fl2 = SimpleLocation(10, 15)\n>>> fl3 = CompoundLocation([fl1,fl2])\n>>> fl3.extract(seq)\nSeq('QHKAMILIVIC')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 1686, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "extract", "signature": "(self, parent_sequence, references = None)", "symbol_type": "function"}, {"docstring": "Write out selected portion to filename.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Dice.py", "line_number": 73, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Dice", "name": "extract", "signature": "(structure, chain_id, start, end, filename)", "symbol_type": "function"}], "extract_email_addresses": [{"docstring": "Extract email addresses from text.\n\nArgs:\n    text: Text to extract emails from\n\nReturns:\n    List of email addresses found", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/text.py", "line_number": 160, "module": "src.metainformant.core.text", "name": "extract_email_addresses", "signature": "(text: str) -> list[str]", "symbol_type": "function"}], "extract_numbers": [{"docstring": "Extract all numeric values from text.\n\nArgs:\n    text: Text to extract numbers from\n\nReturns:\n    List of extracted numeric values", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/text.py", "line_number": 117, "module": "src.metainformant.core.text", "name": "extract_numbers", "signature": "(text: str) -> list[float]", "symbol_type": "function"}], "extract_phenotypes_from_events": [{"docstring": "Extract phenotype traits from event sequence.\n\nMaps events to phenotypic categories and aggregates temporal information.\n\nArgs:\n    sequence: EventSequence to extract phenotypes from (single sequence, not list)\n    phenotype_categories: Optional mapping of phenotype categories to event types\n    \nReturns:\n    Dictionary with extracted phenotypes including:\n    - person_id: Person identifier\n    - total_events: Total number of events\n    - domains: List of domains present\n    - event_types: List of event types\n    - domain_counts: Count of events per domain\n    - health_events, education_events, occupation_events: Domain-specific counts\n    - health_conditions, education_achievements, occupation_changes: Domain-specific event lists\n    - first_event_time, last_event_time: Temporal boundaries\n    - event_span_years: Time span in years\n    \nRaises:\n    ImportError: If life_events module is not available\n    ValidationError: If sequence is invalid or empty\n    \nExamples:\n    >>> from metainformant.life_events import EventSequence, Event\n    >>> from datetime import datetime\n    >>> from metainformant.phenotype import extract_phenotypes_from_events\n    >>> events = [\n    ...     Event(\"diabetes\", datetime(2020, 1, 1), \"health\"),\n    ...     Event(\"bachelors\", datetime(2010, 6, 1), \"education\"),\n    ... ]\n    >>> seq = EventSequence(person_id=\"p1\", events=events)\n    >>> phenotypes = extract_phenotypes_from_events(seq)\n    >>> \"health_events\" in phenotypes\n    True\n    >>> phenotypes[\"total_events\"]\n    2", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/phenotype/life_course.py", "line_number": 29, "module": "src.metainformant.phenotype.life_course", "name": "extract_phenotypes_from_events", "signature": "(sequence: EventSequence, phenotype_categories: Optional[Dict[str, List[str]]] = None) -> Dict[str, Any]", "symbol_type": "function"}], "extract_signature_from_docstring": [{"docstring": "Extract parameter and return type info from docstring.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/triple_check_rna.py", "line_number": 33, "module": "scripts.triple_check_rna", "name": "extract_signature_from_docstring", "signature": "(docstring: str) -> dict[str, Any]", "symbol_type": "function"}], "extract_structure": [{"docstring": "Recursively extract structure.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 561, "module": "src.metainformant.core.config", "name": "extract_structure", "signature": "(data: dict[str, Any], prefix: str = '') -> dict[str, Any]", "symbol_type": "function"}], "extract_subgraph": [{"docstring": "Extract subgraph containing only specified nodes and their edges.\n\nCreates a new network containing only the specified nodes and all\nedges between them from the original network.\n\nArgs:\n    network: Input biological network\n    nodes: List of node identifiers to include in subgraph\n    \nReturns:\n    New BiologicalNetwork object containing subgraph\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\", \"D\"])\n    >>> network.add_edge(\"A\", \"B\")\n    >>> network.add_edge(\"B\", \"C\")\n    >>> subgraph = extract_subgraph(network, [\"A\", \"B\"])\n    >>> subgraph.num_nodes()\n    2\n    >>> subgraph.num_edges()\n    1", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 859, "module": "src.metainformant.networks.graph", "name": "extract_subgraph", "signature": "(network: BiologicalNetwork, nodes: List[str]) -> BiologicalNetwork", "symbol_type": "function"}], "extract_transcripts_from_gff": [{"docstring": "Extract transcript sequences from GFF file using gffread.\n\nArgs:\n    gff_path: Path to GFF/GFF3 annotation file\n    genome_fasta_path: Path to genomic FASTA file\n    output_fasta_path: Path to output transcript FASTA file\n    \nReturns:\n    True if extraction successful, False otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/genome_prep.py", "line_number": 254, "module": "src.metainformant.rna.genome_prep", "name": "extract_transcripts_from_gff", "signature": "(gff_path: Path, genome_fasta_path: Path, output_fasta_path: Path) -> bool", "symbol_type": "function"}], "extract_variant_regions": [{"docstring": "Extract specific genomic regions from VCF file.\n\nArgs:\n    vcf_path: Path to input VCF file\n    regions: List of genomic regions (format: \"chr:start-end\")\n    output_vcf: Path to output VCF file\n\nReturns:\n    Dictionary with extraction metadata\n\nNote:\n    This requires bcftools to be available on PATH.\n    Returns status indicating if extraction succeeded.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/download.py", "line_number": 255, "module": "src.metainformant.gwas.download", "name": "extract_variant_regions", "signature": "(vcf_path: str | Path, regions: list[str], output_vcf: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "fastq_dir": [{"docstring": "Path to FASTQ files directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/configs.py", "line_number": 34, "module": "src.metainformant.rna.configs", "name": "fastq_dir", "signature": "(self) -> Path", "symbol_type": "function"}], "fay_wu_h": [{"docstring": "Calculate Fay & Wu's H statistic.\n\nFay & Wu's H tests for selection by comparing high-frequency derived alleles\nto expected under neutrality. H < 0 suggests positive selection (selective sweep).\n\nArgs:\n    num_segregating_sites: Number of segregating sites (S)\n    pairwise_diversity: Average pairwise nucleotide diversity (\u03c0)\n    sample_size: Number of sampled sequences (n)\n    ancestral_state: Optional ancestral sequence (for derived allele identification)\n    sequences: Optional sequences (for derived allele counting if ancestral_state provided)\n    \nReturns:\n    Fay & Wu's H statistic. H < 0 suggests positive selection.\n    Returns 0.0 if inputs invalid or calculation not possible.\n    \nExamples:\n    >>> fay_wu_h(num_segregating_sites=10, pairwise_diversity=5.0, sample_size=10)\n    -2.5...\n    \nNote:\n    This implementation uses a simplified calculation: H = \u03c0 - \u03b8_S.\n    The full Fay & Wu's H statistic requires counting high-frequency\n    derived alleles, which needs ancestral state information. When\n    ancestral_state and sequences are provided, they are currently\n    not used. For accurate H calculations with derived allele frequencies,\n    use specialized population genetics software that implements the\n    full algorithm with ancestral state reconstruction.\n    \nReferences:\n    Fay, J. C., & Wu, C. I. (2000). Hitchhiking under positive Darwinian selection.\n    Genetics, 155(3), 1405-1413.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 347, "module": "src.metainformant.math.coalescent", "name": "fay_wu_h", "signature": "(num_segregating_sites: int, pairwise_diversity: float, sample_size: int) -> float", "symbol_type": "function"}], "fay_wu_h_from_sequences": [{"docstring": "Calculate Fay & Wu's H from sequences.\n\nWrapper function that computes H from DNA sequences.\nNote: Full H requires ancestral state; this is an approximation.\n\nArgs:\n    seqs: Sequence of DNA sequences (strings)\n\nReturns:\n    Fay & Wu's H statistic. Returns 0.0 if insufficient data.\n\nExamples:\n    >>> seqs = [\"AAAA\", \"AAAT\", \"AATT\"]\n    >>> h = fay_wu_h_from_sequences(seqs)\n    >>> isinstance(h, float)\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population.py", "line_number": 414, "module": "src.metainformant.dna.population", "name": "fay_wu_h_from_sequences", "signature": "(seqs: Sequence[str]) -> float", "symbol_type": "function"}], "fdr_correction": [{"docstring": "Apply Benjamini-Hochberg FDR correction.\n\nArgs:\n    pvalues: List of p-values\n    alpha: FDR level\n\nReturns:\n    Dictionary with:\n    - corrected_pvalues: FDR-adjusted p-values\n    - significant_count: Number of significant results\n    - significant_indices: Indices of significant results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/correction.py", "line_number": 63, "module": "src.metainformant.gwas.correction", "name": "fdr_correction", "signature": "(pvalues: list[float], alpha: float = 0.05) -> dict[str, Any]", "symbol_type": "function"}], "feature_attribution": [{"docstring": "Compute SHAP-style feature attribution for events.\n\nArgs:\n    predictor: Trained EventSequencePredictor (must be fitted)\n    sequences: Event sequences (must not be empty)\n    event_embeddings: Event embeddings dictionary\n    use_shap: Whether to use SHAP library (if available, falls back to permutation otherwise)\n    \nReturns:\n    Dictionary mapping events to attribution scores\n    \nRaises:\n    ValueError: If predictor not fitted or sequences empty\n    \nExamples:\n    >>> from metainformant.life_events import EventSequencePredictor, learn_event_embeddings\n    >>> import numpy as np\n    >>> sequences = [[\"health:diagnosis\", \"occupation:job_change\"]]\n    >>> y = np.array([0])\n    >>> predictor = EventSequencePredictor(random_state=42)\n    >>> predictor.fit(sequences, y)\n    >>> embeddings = learn_event_embeddings(sequences, random_state=42)\n    >>> attribution = feature_attribution(predictor, sequences, embeddings)\n    >>> len(attribution) > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/interpretability.py", "line_number": 208, "module": "src.metainformant.life_events.interpretability", "name": "feature_attribution", "signature": "(predictor: 'EventSequencePredictor', sequences: List[List[str]], event_embeddings: Dict[str, NDArray], use_shap: bool = False) -> Dict[str, float]", "symbol_type": "function"}], "feature_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 691, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "feature_key", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": "Grab the key of the feature and signal the start of a new feature.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1067, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "feature_key", "signature": "(self, content)", "symbol_type": "function"}], "feature_qualifier": [{"docstring": "When we get a qualifier key and its value.\n\nCan receive None, since you can have valueless keys such as /pseudo", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 730, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "feature_qualifier", "signature": "(self, key, value)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1096, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "feature_qualifier", "signature": "(self, key, value)", "symbol_type": "function"}], "feature_qualifier_description": [{"docstring": "Use feature_qualifier instead (OBSOLETE).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 773, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "feature_qualifier_description", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1121, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "feature_qualifier_description", "signature": "(self, content)", "symbol_type": "function"}], "feature_qualifier_name": [{"docstring": "Use feature_qualifier instead (OBSOLETE).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 769, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "feature_qualifier_name", "signature": "(self, content_list)", "symbol_type": "function"}, {"docstring": "Deal with qualifier names.\n\nWe receive a list of keys, since you can have valueless keys such as\n/pseudo which would be passed in with the next key (since no other\ntags separate them in the file)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1101, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "feature_qualifier_name", "signature": "(self, content_list)", "symbol_type": "function"}], "features_line": [{"docstring": "Get ready for the feature table when we reach the FEATURE line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 680, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "features_line", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": "Get ready for the feature table when we reach the FEATURE line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1057, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "features_line", "signature": "(self, content)", "symbol_type": "function"}], "feed": [{"docstring": "Raise an Error if plain text is received in the data.\n\nThis is to show the Error messages returned by ScanProsite.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/ScanProsite.py", "line_number": 86, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.ScanProsite", "name": "feed", "signature": "(self, data, isFinal = 0)", "symbol_type": "function"}, {"docstring": "Feed a set of data into the consumer.\n\nThis method is intended for use with the \"old\" code in Bio.GenBank\n\nArguments:\n - handle - A handle with the information to parse.\n - consumer - The consumer that should be informed of events.\n - do_features - Boolean, should the features be parsed?\n   Skipping the features can be much faster.\n\nReturn values:\n - true  - Passed a record\n - false - Did not find a record", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/Scanner.py", "line_number": 432, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.Scanner", "name": "feed", "signature": "(self, handle, consumer, do_features = True)", "symbol_type": "function"}], "fetch_alias": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 601, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_alias", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 601, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_alias", "signature": "(self)", "symbol_type": "function"}], "fetch_alphafold_model": [{"docstring": "Download AlphaFold model from EBI database.\n\nArgs:\n    uniprot_acc: UniProt accession identifier\n    out_dir: Output directory for downloaded file\n    version: AlphaFold model version (default: 4)\n    fmt: Format, either \"pdb\" or \"cif\" (default: \"pdb\")\n    \nReturns:\n    Path to downloaded model file\n    \nRaises:\n    requests.HTTPError: If download fails\n    ValueError: If fmt is not \"pdb\" or \"cif\"", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/alphafold.py", "line_number": 31, "module": "src.metainformant.protein.alphafold", "name": "fetch_alphafold_model", "signature": "(uniprot_acc: str, out_dir: Path) -> Path", "symbol_type": "function"}], "fetch_anchor": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 612, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_anchor", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 612, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_anchor", "signature": "(self)", "symbol_type": "function"}], "fetch_block_entry": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 484, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_block_entry", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 484, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_block_entry", "signature": "(self)", "symbol_type": "function"}], "fetch_block_scalar": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 640, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_block_scalar", "signature": "(self, style)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 640, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_block_scalar", "signature": "(self, style)", "symbol_type": "function"}], "fetch_dbid_by_dbname": [{"docstring": "Return the internal id for the sub-database using its name.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 379, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "fetch_dbid_by_dbname", "signature": "(self, dbname)", "symbol_type": "function"}], "fetch_directive": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 390, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_directive", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 390, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_directive", "signature": "(self)", "symbol_type": "function"}], "fetch_document_end": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 405, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_document_end", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 405, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_document_end", "signature": "(self)", "symbol_type": "function"}], "fetch_document_indicator": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 408, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_document_indicator", "signature": "(self, TokenClass)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 408, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_document_indicator", "signature": "(self, TokenClass)", "symbol_type": "function"}], "fetch_document_start": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 402, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_document_start", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 402, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_document_start", "signature": "(self)", "symbol_type": "function"}], "fetch_double": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 654, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_double", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 654, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_double", "signature": "(self)", "symbol_type": "function"}], "fetch_flow_collection_end": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 453, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_flow_collection_end", "signature": "(self, TokenClass)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 453, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_flow_collection_end", "signature": "(self, TokenClass)", "symbol_type": "function"}], "fetch_flow_collection_start": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 430, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_flow_collection_start", "signature": "(self, TokenClass)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 430, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_flow_collection_start", "signature": "(self, TokenClass)", "symbol_type": "function"}], "fetch_flow_entry": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 470, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_flow_entry", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 470, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_flow_entry", "signature": "(self)", "symbol_type": "function"}], "fetch_flow_mapping_end": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 450, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_flow_mapping_end", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 450, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_flow_mapping_end", "signature": "(self)", "symbol_type": "function"}], "fetch_flow_mapping_start": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 427, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_flow_mapping_start", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 427, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_flow_mapping_start", "signature": "(self)", "symbol_type": "function"}], "fetch_flow_scalar": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 657, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_flow_scalar", "signature": "(self, style)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 657, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_flow_scalar", "signature": "(self, style)", "symbol_type": "function"}], "fetch_flow_sequence_end": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 447, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_flow_sequence_end", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 447, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_flow_sequence_end", "signature": "(self)", "symbol_type": "function"}], "fetch_flow_sequence_start": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 424, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_flow_sequence_start", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 424, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_flow_sequence_start", "signature": "(self)", "symbol_type": "function"}], "fetch_folded": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 637, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_folded", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 637, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_folded", "signature": "(self)", "symbol_type": "function"}], "fetch_interpro_domains": [{"docstring": "Fetch InterPro entries for a UniProt accession via REST API.\n\nReturns a list of result dictionaries (shape depends on API version).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/interpro.py", "line_number": 8, "module": "src.metainformant.protein.interpro", "name": "fetch_interpro_domains", "signature": "(uniprot_acc: str) -> List[Dict]", "symbol_type": "function"}], "fetch_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 517, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_key", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 517, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_key", "signature": "(self)", "symbol_type": "function"}], "fetch_literal": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 634, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_literal", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 634, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_literal", "signature": "(self)", "symbol_type": "function"}], "fetch_more_tokens": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 156, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_more_tokens", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 156, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_more_tokens", "signature": "(self)", "symbol_type": "function"}], "fetch_motif_by_id": [{"docstring": "Fetch a single JASPAR motif from the DB by its JASPAR matrix ID.\n\nExample id 'MA0001.1'.\n\nArguments:\n - id - JASPAR matrix ID. This may be a fully specified ID including\n        the version number (e.g. MA0049.2) or just the base ID (e.g.\n        MA0049). If only a base ID is provided, the latest version is\n        returned.\n\nReturns:\n - A Bio.motifs.jaspar.Motif object\n\n**NOTE:** The perl TFBS module allows you to specify the type of matrix\nto return (PFM, PWM, ICM) but matrices are always stored in JASPAR as\nPFMs so this does not really belong here. Once a PFM is fetched the\npwm() and pssm() methods can be called to return the normalized and\nlog-odds matrices.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/jaspar/db.py", "line_number": 108, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.jaspar.db", "name": "fetch_motif_by_id", "signature": "(self, id)", "symbol_type": "function"}], "fetch_motifs": [{"docstring": "Fetch jaspar.Record (list) of motifs using selection criteria.\n\nArguments::\n\n    Except where obvious, all selection criteria arguments may be\n    specified as a single value or a list of values. Motifs must\n    meet ALL the specified selection criteria to be returned with\n    the precedent exceptions noted below.\n\n    all         - Takes precedent of all other selection criteria.\n                  Every motif is returned. If 'all_versions' is also\n                  specified, all versions of every motif are returned,\n                  otherwise just the latest version of every motif is\n                  returned.\n    matrix_id   - Takes precedence over all other selection criteria\n                  except 'all'.  Only motifs with the given JASPAR\n                  matrix ID(s) are returned. A matrix ID may be\n                  specified as just a base ID or full JASPAR IDs\n                  including version number. If only a base ID is\n                  provided for specific motif(s), then just the latest\n                  version of those motif(s) are returned unless\n                  'all_versions' is also specified.\n    collection  - Only motifs from the specified JASPAR collection(s)\n                  are returned. NOTE - if not specified, the collection\n                  defaults to CORE for all other selection criteria\n                  except 'all' and 'matrix_id'. To apply the other\n                  selection criteria across all JASPAR collections,\n                  explicitly set collection=None.\n    tf_name     - Only motifs with the given name(s) are returned.\n    tf_class    - Only motifs of the given TF class(es) are returned.\n    tf_family   - Only motifs from the given TF families are returned.\n    tax_group   - Only motifs belonging to the given taxonomic\n                  supergroups are returned (e.g. 'vertebrates',\n                  'insects', 'nematodes' etc.)\n    species     - Only motifs derived from the given species are\n                  returned.  Species are specified as taxonomy IDs.\n    data_type   - Only motifs generated with the given data type (e.g.\n                  ('ChIP-seq', 'PBM', 'SELEX' etc.) are returned.\n                  NOTE - must match exactly as stored in the database.\n    pazar_id    - Only motifs with the given PAZAR TF ID are returned.\n    medline     - Only motifs with the given medline (PubmMed IDs) are\n                  returned.\n    min_ic      - Only motifs whose profile matrices have at least this\n                  information content (specificty) are returned.\n    min_length  - Only motifs whose profiles are of at least this\n                  length are returned.\n    min_sites   - Only motifs compiled from at least these many binding\n                  sites are returned.\n    all_versions- Unless specified, just the latest version of motifs\n                  determined by the other selection criteria are\n                  returned. Otherwise all versions of the selected\n                  motifs are returned.\n\nReturns:\n    - A Bio.motifs.jaspar.Record (list) of motifs.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/jaspar/db.py", "line_number": 169, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.jaspar.db", "name": "fetch_motifs", "signature": "(self, collection = JASPAR_DFLT_COLLECTION, tf_name = None, tf_class = None, tf_family = None, matrix_id = None, tax_group = None, species = None, pazar_id = None, data_type = None, medline = None, min_ic = 0, min_length = 0, min_sites = 0, all = False, all_versions = False)", "symbol_type": "function"}], "fetch_motifs_by_name": [{"docstring": "Fetch a list of JASPAR motifs from a JASPAR DB by the given TF name(s).\n\nArguments:\nname - a single name or list of names\nReturns:\nA list of Bio.motifs.jaspar.Motif objects\n\nNotes:\nNames are not guaranteed to be unique. There may be more than one\nmotif with the same name. Therefore even if name specifies a single\nname, a list of motifs is returned. This just calls\nself.fetch_motifs(collection = None, tf_name = name).\n\nThis behaviour is different from the TFBS perl module's\nget_Matrix_by_name() method which always returns a single matrix,\nissuing a warning message and returning the first matrix retrieved\nin the case where multiple matrices have the same name.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/jaspar/db.py", "line_number": 147, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.jaspar.db", "name": "fetch_motifs_by_name", "signature": "(self, name)", "symbol_type": "function"}], "fetch_pdb_structure": [{"docstring": "Download a PDB structure by ID in the chosen format (pdb|cif).\n\nReturns the path to the downloaded file.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/pdb.py", "line_number": 8, "module": "src.metainformant.protein.pdb", "name": "fetch_pdb_structure", "signature": "(pdb_id: str, out_dir: Path) -> Path", "symbol_type": "function"}], "fetch_plain": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 668, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_plain", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 668, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_plain", "signature": "(self)", "symbol_type": "function"}], "fetch_seqid_by_accession": [{"docstring": "Return the internal id for a sequence using its accession.\n\nArguments:\n - dbid - the internal id for the sub-database\n - name - the accession of the sequence. Corresponds to the\n   accession column of the bioentry table of the SQL schema", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 411, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "fetch_seqid_by_accession", "signature": "(self, dbid, name)", "symbol_type": "function"}], "fetch_seqid_by_display_id": [{"docstring": "Return the internal id for a sequence using its display id.\n\nArguments:\n - dbid - the internal id for the sub-database\n - name - the name of the sequence. Corresponds to the\n   name column of the bioentry table of the SQL schema", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 389, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "fetch_seqid_by_display_id", "signature": "(self, dbid, name)", "symbol_type": "function"}], "fetch_seqid_by_identifier": [{"docstring": "Return the internal id for a sequence using its identifier.\n\nArguments:\n - dbid - the internal id for the sub-database\n - identifier - the identifier of the sequence. Corresponds to\n   the identifier column of the bioentry table in the SQL schema.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 479, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "fetch_seqid_by_identifier", "signature": "(self, dbid, identifier)", "symbol_type": "function"}], "fetch_seqid_by_version": [{"docstring": "Return the internal id for a sequence using its accession and version.\n\nArguments:\n - dbid - the internal id for the sub-database\n - name - the accession of the sequence containing a version number.\n   Must correspond to <accession>.<version>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 449, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "fetch_seqid_by_version", "signature": "(self, dbid, name)", "symbol_type": "function"}], "fetch_seqids_by_accession": [{"docstring": "Return a list internal ids using an accession.\n\nArguments:\n - dbid - the internal id for the sub-database\n - name - the accession of the sequence. Corresponds to the\n   accession column of the bioentry table of the SQL schema", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 433, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "fetch_seqids_by_accession", "signature": "(self, dbid, name)", "symbol_type": "function"}], "fetch_single": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 651, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_single", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 651, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_single", "signature": "(self)", "symbol_type": "function"}], "fetch_sra_xml": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/metadata.py", "line_number": 17, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.metadata", "name": "fetch_sra_xml", "signature": "(search_term, retmax = 1000)", "symbol_type": "function"}], "fetch_stream_end": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 371, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_stream_end", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 371, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_stream_end", "signature": "(self)", "symbol_type": "function"}], "fetch_stream_start": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 359, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_stream_start", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 359, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_stream_start", "signature": "(self)", "symbol_type": "function"}], "fetch_tag": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 623, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_tag", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 623, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_tag", "signature": "(self)", "symbol_type": "function"}], "fetch_uniprot_fasta": [{"docstring": "Fetch UniProt FASTA sequence for a single accession and return as string.\n\nReturns the raw FASTA text. Caller can write to file if desired.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/uniprot.py", "line_number": 60, "module": "src.metainformant.protein.uniprot", "name": "fetch_uniprot_fasta", "signature": "(accession: str) -> str", "symbol_type": "function"}], "fetch_value": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 545, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "fetch_value", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 545, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "fetch_value", "signature": "(self)", "symbol_type": "function"}], "fetchall": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 326, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "fetchall", "signature": "(self)", "symbol_type": "function"}], "fetchone": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 330, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "fetchone", "signature": "(self)", "symbol_type": "function"}], "file_hash_comparison": [{"docstring": "Compare two files by their SHA256 hashes.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/hash.py", "line_number": 44, "module": "src.metainformant.core.hash", "name": "file_hash_comparison", "signature": "(file1: str | Path, file2: str | Path) -> bool", "symbol_type": "function"}], "fileno": [{"docstring": "Return integer file descriptor.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 781, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "fileno", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return integer file descriptor.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 916, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "fileno", "signature": "(self)", "symbol_type": "function"}], "filepath2spp": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/cstmm.py", "line_number": 38, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.cstmm", "name": "filepath2spp", "signature": "(file_paths)", "symbol_type": "function"}], "files_parameters": [{"docstring": "Builds form parameters.\n\n:param files: None or a dict with key=param_name and\n    value is a list of open file objects\n:return: List of tuples of form parameters with file data", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 526, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "files_parameters", "signature": "(self, files: typing.Optional[typing.Dict[str, typing.List[io.IOBase]]] = None)", "symbol_type": "function"}], "fill_chromosome": [{"docstring": "Add the collected segment information to a chromosome for drawing.\n\nArguments:\n - chromosome - A Chromosome graphics object that we can add\n   chromosome segments to.\n\nThis creates ChromosomeSegment (and TelomereSegment) objects to\nfill in the chromosome. The information is derived from the\nlabel and count information, with counts transformed to the\nspecified color map.\n\nReturns the chromosome with all of the segments added.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/DisplayRepresentation.py", "line_number": 131, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.DisplayRepresentation", "name": "fill_chromosome", "signature": "(self, chromosome)", "symbol_type": "function"}], "filter": [{"docstring": "Create new Hit object whose HSP objects pass the filter function.\n\n:param func: function for filtering\n:type func: callable, accepts HSP, returns bool\n\n``filter`` is analogous to Python's built-in ``filter`` function, except\nthat instead of returning a list it returns a ``Hit`` object. Here is an\nexample of using ``filter`` to select for HSPs having bitscores bigger\nthan 60::\n\n    >>> from Bio import SearchIO\n    >>> qresult = next(SearchIO.parse('Blast/mirna.xml', 'blast-xml'))\n    >>> hit = qresult[3]\n    >>> evalue_filter = lambda hsp: hsp.bitscore > 60\n    >>> filtered_hit = hit.filter(evalue_filter)\n    >>> len(hit)\n    2\n    >>> len(filtered_hit)\n    1\n    >>> print(filtered_hit)\n    Query: 33211\n           mir_1\n      Hit: gi|301171322|ref|NR_035857.1| (86)\n           Pan troglodytes microRNA mir-520c (MIR520C), microRNA\n     HSPs: ----  --------  ---------  ------  ---------------  ---------------------\n              #   E-value  Bit score    Span      Query range              Hit range\n           ----  --------  ---------  ------  ---------------  ---------------------\n              0   8.9e-20     100.47      60           [1:61]                [13:73]", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/hit.py", "line_number": 361, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.hit", "name": "filter", "signature": "(self, func = None)", "symbol_type": "function"}], "filter_by_confidence": [{"docstring": "Create filtered network with only high-confidence interactions.\n\nArgs:\n    threshold: Minimum confidence score (0-1)\n\nReturns:\n    New ProteinNetwork with filtered interactions", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 193, "module": "src.metainformant.networks.ppi", "name": "filter_by_confidence", "signature": "(self, threshold: float = 0.0) -> 'ProteinNetwork'", "symbol_type": "function"}, {"docstring": "Create filtered network with only high-confidence regulations.\n\nArgs:\n    threshold: Minimum confidence score (0-1)\n\nReturns:\n    New GeneRegulatoryNetwork with filtered regulations", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 253, "module": "src.metainformant.networks.regulatory", "name": "filter_by_confidence", "signature": "(self, threshold: float = 0.0) -> 'GeneRegulatoryNetwork'", "symbol_type": "function"}], "filter_by_domain": [{"docstring": "Create new sequence with only events from specified domain.\n\nArgs:\n    domain: Domain to filter by\n    \nReturns:\n    New EventSequence with filtered events", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 111, "module": "src.metainformant.life_events.events", "name": "filter_by_domain", "signature": "(self, domain: str) -> 'EventSequence'", "symbol_type": "function"}, {"docstring": "Create new database with sequences filtered by domain.\n\nArgs:\n    domain: Domain to filter by\n    \nReturns:\n    New EventDatabase with filtered sequences", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 263, "module": "src.metainformant.life_events.events", "name": "filter_by_domain", "signature": "(self, domain: str) -> 'EventDatabase'", "symbol_type": "function"}], "filter_by_evidence": [{"docstring": "Create filtered network with only specific evidence type.\n\nArgs:\n    evidence_type: Evidence type to filter by (e.g., \"experimental\")\n\nReturns:\n    New ProteinNetwork with filtered interactions", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 215, "module": "src.metainformant.networks.ppi", "name": "filter_by_evidence", "signature": "(self, evidence_type: str) -> 'ProteinNetwork'", "symbol_type": "function"}], "filter_by_maf": [{"docstring": "Filter variants by minor allele frequency.\n\nArgs:\n    genotypes: Genotype matrix (samples x variants), encoded as 0/1/2/-1\n    maf_threshold: Minimum minor allele frequency\n\nReturns:\n    Tuple of (variant_indices_to_keep, maf_value)\n    variant_indices_to_keep: List of variant indices passing MAF filter\n    maf_value: The calculated MAF (for logging)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/quality.py", "line_number": 155, "module": "src.metainformant.gwas.quality", "name": "filter_by_maf", "signature": "(genotypes: list[list[int]], maf_threshold: float = 0.01) -> tuple[list[int], float]", "symbol_type": "function"}], "filter_by_missing": [{"docstring": "Filter variants by missing data rate.\n\nArgs:\n    genotypes: Genotype matrix (samples x variants), encoded as 0/1/2/-1\n    max_missing: Maximum allowed missing genotype rate\n\nReturns:\n    List of variant indices passing missing data filter", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/quality.py", "line_number": 206, "module": "src.metainformant.gwas.quality", "name": "filter_by_missing", "signature": "(genotypes: list[list[int]], max_missing: float = 0.05) -> list[int]", "symbol_type": "function"}], "filter_by_namespace": [{"docstring": "Filter ontology to include only terms in specified namespace.\n\nCreates a new ontology containing only terms from the given namespace,\npreserving relationships within that namespace.\n\nArgs:\n    onto: Source ontology object\n    namespace: Namespace to filter by (e.g., \"biological_process\")\n    \nReturns:\n    New Ontology object containing only terms from the namespace\n    \nExamples:\n    >>> onto = load_go_obo(\"go.obo\")\n    >>> bp_onto = filter_by_namespace(onto, \"biological_process\")\n    >>> bp_onto.num_terms() < onto.num_terms()\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/query.py", "line_number": 431, "module": "src.metainformant.ontology.query", "name": "filter_by_namespace", "signature": "(onto: Ontology, namespace: str) -> Ontology", "symbol_type": "function"}], "filter_by_regulation_type": [{"docstring": "Create filtered network with only specific regulation type.\n\nArgs:\n    regulation_type: Type to filter by (\"activation\", \"repression\", \"unknown\")\n\nReturns:\n    New GeneRegulatoryNetwork with filtered regulations", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 276, "module": "src.metainformant.networks.regulatory", "name": "filter_by_regulation_type", "signature": "(self, regulation_type: str) -> 'GeneRegulatoryNetwork'", "symbol_type": "function"}], "filter_by_time": [{"docstring": "Create new sequence with events in time range.\n\nArgs:\n    start_time: Start of time range (inclusive)\n    end_time: End of time range (inclusive)\n    \nReturns:\n    New EventSequence with filtered events", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 127, "module": "src.metainformant.life_events.events", "name": "filter_by_time", "signature": "(self, start_time: Optional[datetime | float] = None, end_time: Optional[datetime | float] = None) -> 'EventSequence'", "symbol_type": "function"}], "filter_cells": [{"docstring": "Filter cells based on quality control metrics.\n\nArgs:\n    data: SingleCellData object with QC metrics\n    min_genes: Minimum number of genes per cell\n    max_genes: Maximum number of genes per cell (None for no limit)\n    min_counts: Minimum total counts per cell\n    max_counts: Maximum total counts per cell (None for no limit)\n    max_pct_mt: Maximum percentage of mitochondrial expression\n\nReturns:\n    Filtered SingleCellData object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/preprocessing.py", "line_number": 275, "module": "src.metainformant.singlecell.preprocessing", "name": "filter_cells", "signature": "(data: SingleCellData, min_genes: int = 200, max_genes: Optional[int] = None, min_counts: int = 1000, max_counts: Optional[int] = None, max_pct_mt: float = 20.0) -> SingleCellData", "symbol_type": "function"}], "filter_genes": [{"docstring": "Filter genes based on expression criteria.\n\nArgs:\n    data: SingleCellData object\n    min_cells: Minimum number of cells expressing the gene\n    min_counts: Minimum total counts for the gene\n\nReturns:\n    Filtered SingleCellData object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/preprocessing.py", "line_number": 328, "module": "src.metainformant.singlecell.preprocessing", "name": "filter_genes", "signature": "(data: SingleCellData, min_cells: int = 3, min_counts: int = 1) -> SingleCellData", "symbol_type": "function"}], "filter_network": [{"docstring": "Filter network by various criteria.\n\nCreates a new network containing only nodes/edges that meet the\nspecified criteria. Useful for removing low-degree nodes, weak edges,\nor isolated components.\n\nArgs:\n    network: Input biological network\n    min_degree: Minimum node degree to include (None = no limit)\n    max_degree: Maximum node degree to include (None = no limit)\n    min_edge_weight: Minimum edge weight to include (None = no limit)\n    max_edge_weight: Maximum edge weight to include (None = no limit)\n    component_size: Minimum component size to keep (None = keep all)\n    \nReturns:\n    New filtered BiologicalNetwork object\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\", \"D\"])\n    >>> network.add_edge(\"A\", \"B\", weight=0.9)\n    >>> network.add_edge(\"C\", \"D\", weight=0.3)\n    >>> filtered = filter_network(network, min_edge_weight=0.5)\n    >>> filtered.num_edges()\n    1", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 900, "module": "src.metainformant.networks.graph", "name": "filter_network", "signature": "(network: BiologicalNetwork, min_degree: Optional[int] = None, max_degree: Optional[int] = None, min_edge_weight: Optional[float] = None, max_edge_weight: Optional[float] = None, component_size: Optional[int] = None) -> BiologicalNetwork", "symbol_type": "function"}], "filtering_function": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 553, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "filtering_function", "signature": "(cut_on_watson)", "symbol_type": "function"}], "finalize_structure": [{"docstring": "Any functions needed to cleanup the structure.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/DefaultParser.py", "line_number": 212, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.DefaultParser", "name": "finalize_structure", "signature": "(self)", "symbol_type": "function"}], "find": [{"docstring": "Return the lowest index in data where subsection sub is found.\n\nReturn the lowest index in data where subsection sub is found,\nsuch that sub is contained within data[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 168, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "find", "signature": "(self, sub, start = None, end = None)", "symbol_type": "function"}, {"docstring": "Return the lowest index in the sequence where subsequence sub is found.\n\nWith optional arguments start and end, return the lowest index in the\nsequence such that the subsequence sub is contained within the sequence\nregion [start:end].\n\nArguments:\n - sub - a string or another Seq or MutableSeq object to search for\n - start - optional integer, slice start\n - end - optional integer, slice end\n\nReturns -1 if the subsequence is NOT found.\n\ne.g. Locating the first typical start codon, AUG, in an RNA sequence:\n\n>>> from Bio.Seq import Seq\n>>> my_rna = Seq(\"GUCAUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAGUUG\")\n>>> my_rna.find(\"AUG\")\n3\n\nThe next typical start codon can then be found by starting the search\nat position 4:\n\n>>> my_rna.find(\"AUG\", 4)\n15\n\nSee the ``search`` method to find the locations of multiple subsequences\nat the same time.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 777, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "find", "signature": "(self, sub, start = None, end = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1586, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "find", "signature": "(self, start, end)", "symbol_type": "function"}], "find_all_links": [{"docstring": "Find all markdown links in a file.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/triple_check_rna.py", "line_number": 127, "module": "scripts.triple_check_rna", "name": "find_all_links", "signature": "(doc_file: Path) -> list[tuple[str, str]]", "symbol_type": "function"}], "find_any": [{"docstring": "Return the first element found by find_elements(), or None.\n\nThis is also useful for checking whether any matching element exists in\nthe tree, and can be used in a conditional expression.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 295, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "find_any", "signature": "(self, *args, **kwargs)", "symbol_type": "function"}], "find_clades": [{"docstring": "Find each clade containing a matching element.\n\nThat is, find each element as with find_elements(), but return the\ncorresponding clade object. (This is usually what you want.)\n\n:returns: an iterable through all matching objects, searching\n    depth-first (preorder) by default.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 353, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "find_clades", "signature": "(self, target = None, terminal = None, order = 'preorder', **kwargs)", "symbol_type": "function"}], "find_configs_for_module": [{"docstring": "Find configs used by a module.\n\nArgs:\n    module_name: Name of module (e.g., 'rna', 'gwas', 'life_events')\n    repo_root: Root directory of repository\n\nReturns:\n    List of config file information dictionaries", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 583, "module": "src.metainformant.core.config", "name": "find_configs_for_module", "signature": "(module_name: str, repo_root: str | Path | None = None) -> list[dict[str, Any]]", "symbol_type": "function"}], "find_conserved_regions": [{"docstring": "Find conserved regions in an alignment.\n\nArgs:\n    alignment: AlignmentResult from global_align or local_align\n    min_length: Minimum length of conserved region\n\nReturns:\n    List of (sequence, start, end) tuples for conserved regions", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/alignment.py", "line_number": 116, "module": "src.metainformant.dna.alignment", "name": "find_conserved_regions", "signature": "(alignment: AlignmentResult, min_length: int = 5) -> list[tuple[str, int, int]]", "symbol_type": "function"}], "find_elements": [{"docstring": "Find all tree elements matching the given attributes.\n\nThe arbitrary keyword arguments indicate the attribute name of the\nsub-element and the value to match: string, integer or boolean. Strings\nare evaluated as regular expression matches; integers are compared\ndirectly for equality, and booleans evaluate the attribute's truth value\n(True or False) before comparing. To handle nonzero floats, search with\na boolean argument, then filter the result manually.\n\nIf no keyword arguments are given, then just the class type is used for\nmatching.\n\nThe result is an iterable through all matching objects, by depth-first\nsearch. (Not necessarily the same order as the elements appear in the\nsource file!)\n\n:Parameters:\n    target : TreeElement instance, type, dict, or callable\n        Specifies the characteristics to search for. (The default,\n        TreeElement, matches any standard Bio.Phylo type.)\n    terminal : bool\n        A boolean value to select for or against terminal nodes (a.k.a.\n        leaf nodes). True searches for only terminal nodes, False\n        excludes terminal nodes, and the default, None, searches both\n        terminal and non-terminal nodes, as well as any tree elements\n        lacking the ``is_terminal`` method.\n    order : {'preorder', 'postorder', 'level'}\n        Tree traversal order: 'preorder' (default) is depth-first\n        search, 'postorder' is DFS with child nodes preceding parents,\n        and 'level' is breadth-first search.\n\nExamples\n--------\n>>> from Bio import Phylo\n>>> phx = Phylo.PhyloXMLIO.read('PhyloXML/phyloxml_examples.xml')\n>>> matches = phx.phylogenies[5].find_elements(code='OCTVU')\n>>> next(matches)\nTaxonomy(code='OCTVU', scientific_name='Octopus vulgaris')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 307, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "find_elements", "signature": "(self, target = None, terminal = None, order = 'preorder', **kwargs)", "symbol_type": "function"}], "find_files_by_extension": [{"docstring": "Find all files with a specific extension in a directory.\n\nArgs:\n    directory: Directory to search\n    extension: File extension (with or without dot)\n\nReturns:\n    List of matching file paths", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 92, "module": "src.metainformant.core.paths", "name": "find_files_by_extension", "signature": "(directory: str | Path, extension: str) -> list[Path]", "symbol_type": "function"}], "find_fold_class": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 597, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "find_fold_class", "signature": "(codon, forward_table)", "symbol_type": "function"}], "find_marker_genes": [{"docstring": "Find marker genes for each cluster/group.\n\nArgs:\n    data: SingleCellData object\n    groupby: Column name in obs for grouping (e.g., 'leiden', 'louvain')\n    method: Statistical test ('wilcoxon', 'ttest', 'logreg')\n    n_genes: Maximum number of genes per group\n    logfc_min: Minimum log fold change\n    pval_cutoff: P-value cutoff\n    only_pos: Only return positive markers (upregulated)\n\nReturns:\n    DataFrame with marker genes and statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/clustering.py", "line_number": 312, "module": "src.metainformant.singlecell.clustering", "name": "find_marker_genes", "signature": "(data: SingleCellData, groupby: str, method: str = 'wilcoxon', n_genes: int = 100, logfc_min: float = 0.25, pval_cutoff: float = 0.05, only_pos: bool = True) -> pd.DataFrame", "symbol_type": "function"}], "find_motif_positions": [{"docstring": "Return 0-based start positions where motif (IUPAC) matches.\n\nSupports standard IUPAC ambiguity codes; case-insensitive.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/motifs.py", "line_number": 31, "module": "src.metainformant.dna.motifs", "name": "find_motif_positions", "signature": "(seq: str, motif: str) -> List[int]", "symbol_type": "function"}], "find_motifs": [{"docstring": "Find multiple motif patterns in a DNA sequence.\n\nArgs:\n    seq: DNA sequence to search\n    motif_patterns: List of motif patterns (supports IUPAC codes)\n\nReturns:\n    Dictionary mapping motif patterns to their positions", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 151, "module": "src.metainformant.dna.sequences", "name": "find_motifs", "signature": "(seq: str, motif_patterns: list[str]) -> Dict[str, list[int]]", "symbol_type": "function"}], "find_next_int": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/__init__.py", "line_number": 735, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.__init__", "name": "find_next_int", "signature": "(k, lst)", "symbol_type": "function"}], "find_orfs": [{"docstring": "Find open reading frames in a DNA sequence.\n\nArgs:\n    seq: DNA sequence to analyze\n    min_length: Minimum ORF length in nucleotides\n\nReturns:\n    List of (start, end, frame) tuples for ORFs", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 205, "module": "src.metainformant.dna.sequences", "name": "find_orfs", "signature": "(seq: str, min_length: int = 30) -> list[tuple[int, int, str]]", "symbol_type": "function"}, {"docstring": "Find Open Reading Frames (ORFs) in DNA sequence.\n\nArgs:\n    seq: DNA sequence string\n    min_aa: Minimum protein length in amino acids (default: 50)\n    include_reverse: Search reverse complement strand (default: True)\n    \nReturns:\n    List of ORF objects found in sequence", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/translation.py", "line_number": 45, "module": "src.metainformant.dna.translation", "name": "find_orfs", "signature": "(seq: str) -> List[ORF]", "symbol_type": "function"}], "find_output_locations": [{"docstring": "Find existing output directories.\n\nArgs:\n    repo_root: Root directory of repository\n    pattern: Optional pattern to match (e.g., 'rna', 'gwas')\n\nReturns:\n    List of Path objects for existing output directories", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 299, "module": "src.metainformant.core.paths", "name": "find_output_locations", "signature": "(repo_root: str | Path, pattern: str | None = None) -> list[Path]", "symbol_type": "function"}], "find_overlapping_pathways": [{"docstring": "Find pathways that overlap with a given pathway.\n\nArgs:\n    pathway_id: Pathway identifier to find overlaps for\n    min_overlap: Minimum number of shared genes required\n    return_dict: If True (default), returns dict with detailed overlap info. If False, returns set of pathway IDs.\n\nReturns:\n    If return_dict=True: Dictionary mapping pathway_id -> {\"shared_genes\": set, \"overlap_size\": int}\n    If return_dict=False: Set of pathway IDs that overlap with the given pathway", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 150, "module": "src.metainformant.networks.pathway", "name": "find_overlapping_pathways", "signature": "(self, pathway_id: str, min_overlap: int = 1, return_dict: bool = True) -> Union[Set[str], Dict[str, Dict[str, Any]]]", "symbol_type": "function"}], "find_palindromes": [{"docstring": "Find palindromic sequences in DNA.\n\nArgs:\n    seq: DNA sequence to search\n    min_length: Minimum length of palindromes to find\n    \nReturns:\n    List of (palindrome, start, end) tuples", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 321, "module": "src.metainformant.dna.sequences", "name": "find_palindromes", "signature": "(seq: str, min_length: int = 4) -> list[tuple[str, int, int]]", "symbol_type": "function"}], "find_partial_downloads": [{"docstring": "Find samples with partial downloads that aren't quantified.\n\nArgs:\n    fastq_dir: Directory containing FASTQ files\n    quant_dir: Directory containing quantification results\n\nReturns:\n    List of (sample_id, sample_dir, size_mb) tuples", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/cleanup.py", "line_number": 19, "module": "src.metainformant.rna.cleanup", "name": "find_partial_downloads", "signature": "(fastq_dir: Path, quant_dir: Path) -> list[tuple[str, Path, int]]", "symbol_type": "function"}], "find_python_module": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 525, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "find_python_module", "signature": "(self, name, mark, unsafe = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 715, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "find_python_module", "signature": "(self, name, mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 525, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "find_python_module", "signature": "(self, name, mark, unsafe = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 715, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "find_python_module", "signature": "(self, name, mark)", "symbol_type": "function"}], "find_python_name": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 540, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "find_python_name", "signature": "(self, name, mark, unsafe = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 718, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "find_python_name", "signature": "(self, name, mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 540, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "find_python_name", "signature": "(self, name, mark, unsafe = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 718, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "find_python_name", "signature": "(self, name, mark)", "symbol_type": "function"}], "find_repeats": [{"docstring": "Find repeated substrings in a DNA sequence.\n\nArgs:\n    seq: DNA sequence to analyze\n    min_length: Minimum length of repeats to find\n\nReturns:\n    Dictionary mapping repeat sequences to their positions", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 124, "module": "src.metainformant.dna.sequences", "name": "find_repeats", "signature": "(seq: str, min_length: int = 3) -> Dict[str, list[int]]", "symbol_type": "function"}], "find_restriction_sites": [{"docstring": "Find 0-based start positions of enzyme motifs in a sequence.\n\nMotifs may include IUPAC ambiguity codes. Only the forward strand is\nsearched.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/restriction.py", "line_number": 9, "module": "src.metainformant.dna.restriction", "name": "find_restriction_sites", "signature": "(seq: str, enzyme_to_motif: Dict[str, str]) -> Dict[str, List[int]]", "symbol_type": "function"}], "find_rna_fasta_in_genome_dir": [{"docstring": "Find RNA FASTA file in extracted genome directory.\n\nNCBI datasets extracts to various patterns:\n- ncbi_dataset_api_extracted/ncbi_dataset/data/{accession}/rna.fna\n- ncbi_dataset_api_extracted/ncbi_dataset/data/{accession}/rna.fna.gz\n- ncbi_dataset_extracted/ncbi_dataset/data/{accession}/rna.fna\n\nAlso searches recursively for RNA FASTA files and checks for direct FTP downloads.\n\nArgs:\n    genome_dir: Base genome directory\n    accession: NCBI assembly accession\n    \nReturns:\n    Path to RNA FASTA file if found, None otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/genome_prep.py", "line_number": 26, "module": "src.metainformant.rna.genome_prep", "name": "find_rna_fasta_in_genome_dir", "signature": "(genome_dir: Path, accession: str) -> Path | None", "symbol_type": "function"}], "find_start": [{"docstring": "Read in lines until find the ID/LOCUS line, which is returned.\n\nAny preamble (such as the header used by the NCBI on ``*.seq.gz`` archives)\nwill we ignored.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/Scanner.py", "line_number": 76, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.Scanner", "name": "find_start", "signature": "(self)", "symbol_type": "function"}], "find_start_codons": [{"docstring": "Find positions of ATG start codons.\n\nArgs:\n    seq: DNA sequence to search\n    \nReturns:\n    List of 0-based positions of ATG codons", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 400, "module": "src.metainformant.dna.sequences", "name": "find_start_codons", "signature": "(seq: str) -> list[int]", "symbol_type": "function"}], "find_stop_codons": [{"docstring": "Find positions of stop codons (TAA, TAG, TGA).\n\nArgs:\n    seq: DNA sequence to search\n    \nReturns:\n    List of 0-based positions of stop codons", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 416, "module": "src.metainformant.dna.sequences", "name": "find_stop_codons", "signature": "(seq: str) -> list[int]", "symbol_type": "function"}], "find_symbol": [{"docstring": "Find symbol definition(s) by name.\n\nArgs:\n    symbol_name: Name of symbol to find\n    symbol_type: Type of symbol ('function', 'class', or 'all')\n    repo_root: Root directory of repository\n\nReturns:\n    List of SymbolDefinition objects matching the symbol name", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/symbols.py", "line_number": 308, "module": "src.metainformant.core.symbols", "name": "find_symbol", "signature": "(symbol_name: str, symbol_type: str = 'function', repo_root: str | Path | None = None) -> list[SymbolDefinition]", "symbol_type": "function"}], "find_symbol_references": [{"docstring": "Find all references to a symbol across the repository.\n\nArgs:\n    symbol_name: Name of symbol to find references for\n    repo_root: Root directory of repository\n\nReturns:\n    List of SymbolReference objects for each occurrence", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/symbols.py", "line_number": 369, "module": "src.metainformant.core.symbols", "name": "find_symbol_references", "signature": "(symbol_name: str, repo_root: str | Path) -> list[SymbolReference]", "symbol_type": "function"}], "find_symbol_usage": [{"docstring": "Find all usages of a symbol across the repository.\n\nArgs:\n    symbol_name: Name of symbol to find\n    repo_root: Root directory of repository\n\nReturns:\n    List of SymbolUsage objects for each occurrence", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/discovery.py", "line_number": 423, "module": "src.metainformant.core.discovery", "name": "find_symbol_usage", "signature": "(symbol_name: str, repo_root: str | Path) -> list[SymbolUsage]", "symbol_type": "function"}], "find_term_by_name": [{"docstring": "Find term IDs by name (case-insensitive partial match).\n\nSearches for terms matching the given name. Returns all matching term IDs.\n\nArgs:\n    onto: Ontology object containing terms\n    name: Term name to search for (case-insensitive substring match)\n    namespace: Optional namespace filter\n    \nReturns:\n    List of matching term IDs\n    \nExamples:\n    >>> onto = load_go_obo(\"go.obo\")\n    >>> matches = find_term_by_name(onto, \"biological process\")\n    >>> len(matches) > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/query.py", "line_number": 397, "module": "src.metainformant.ontology.query", "name": "find_term_by_name", "signature": "(onto: Ontology, name: str, namespace: str | None = None) -> List[str]", "symbol_type": "function"}], "find_test_dir": [{"docstring": "Find the absolute path of Biopython's Tests directory.\n\nArguments:\nstart_dir -- Initial directory to begin lookup (default to current dir)\n\nIf the directory is not found up the filesystem's root directory, an\nexception will be raised.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/_utils.py", "line_number": 36, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio._utils", "name": "find_test_dir", "signature": "(start_dir: str | None = None) -> str", "symbol_type": "function"}], "find_unquantified_samples": [{"docstring": "Find all unquantified samples.\n\nArgs:\n    config_path: Path to species workflow config file\n    \nReturns:\n    List of sample IDs that are not quantified", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/monitoring.py", "line_number": 255, "module": "src.metainformant.rna.monitoring", "name": "find_unquantified_samples", "signature": "(config_path: Path) -> list[str]", "symbol_type": "function"}], "finditer": [{"docstring": "Return a list of a given pattern which occurs in the sequence.\n\nThe list is made of tuple (location, pattern.group).\nThe latter is used with non palindromic sites.\nPattern is the regular expression pattern corresponding to the\nenzyme restriction site.\nSize is the size of the restriction enzyme recognition-site size.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 215, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "finditer", "signature": "(self, pattern, size)", "symbol_type": "function"}], "finish_chain": [{"docstring": "Do last rnext, rprev links and process chain edra data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 571, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "finish_chain", "signature": "() -> None", "symbol_type": "function"}], "fisher_exact_test": [{"docstring": "Calculate Fisher's exact test for 2x2 contingency table.\n\nComputes odds ratio and p-value for a 2x2 contingency table using\nthe hypergeometric distribution. Useful for testing independence\nbetween two categorical variables.\n\nArgs:\n    a: Top-left cell count\n    b: Top-right cell count\n    c: Bottom-left cell count\n    d: Bottom-right cell count\n    \nReturns:\n    Tuple of (odds_ratio, p_value):\n    - odds_ratio: (a \u00d7 d) / (b \u00d7 c). Returns inf if b or c is zero.\n    - p_value: Two-tailed p-value from Fisher's exact test.\n      Returns 1.0 if scipy is unavailable (fallback).\n      \nRaises:\n    ImportError: If scipy is not available. Install with:\n        pip install metainformant[scientific]\n        or\n        pip install scipy\n        \nExamples:\n    >>> odds, p = fisher_exact_test(10, 2, 3, 15)\n    >>> odds\n    25.0\n    >>> 0.0 <= p <= 1.0\n    True\n    \nNote:\n    This function uses scipy.stats.fisher_exact when available for\n    accurate p-value calculation. If scipy is not installed, the\n    function will raise ImportError. For manual calculation without\n    scipy, consider using scipy.stats.fisher_exact directly.\n    \nReferences:\n    Fisher, R. A. (1922). On the interpretation of \u03c7\u00b2 from contingency\n    tables, and the calculation of P. Journal of the Royal Statistical\n    Society, 85(1), 87-94.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/__init__.py", "line_number": 388, "module": "src.metainformant.math.__init__", "name": "fisher_exact_test", "signature": "(a: int, b: int, c: int, d: int) -> tuple[float, float]", "symbol_type": "function"}], "fit": [{"docstring": "Fit model to event sequences.\n\nArgs:\n    sequences: List of event sequences (each sequence is list of event tokens)\n    y: Target values (labels for classification, continuous for regression)\n    event_embeddings: Optional pre-trained event embeddings\n    \nReturns:\n    Fitted predictor", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 71, "module": "src.metainformant.life_events.models", "name": "fit", "signature": "(self, sequences: Sequence[Sequence[str]], y: NDArray, event_embeddings: Optional[Dict[str, NDArray]] = None) -> 'EventSequencePredictor'", "symbol_type": "function"}, {"docstring": "Fit LSTM model.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 646, "module": "src.metainformant.life_events.models", "name": "fit", "signature": "(self, sequences: Sequence[Sequence[str]], y: NDArray, event_embeddings: Optional[Dict[str, NDArray]] = None) -> 'LSTMSequenceModel'", "symbol_type": "function"}, {"docstring": "Fit GRU model.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 829, "module": "src.metainformant.life_events.models", "name": "fit", "signature": "(self, sequences: Sequence[Sequence[str]], y: NDArray, event_embeddings: Optional[Dict[str, NDArray]] = None) -> 'GRUSequenceModel'", "symbol_type": "function"}, {"docstring": "Fit survival model.\n\nArgs:\n    sequences: List of event sequences\n    event_times: Time until event (or censoring time)\n    event_occurred: Binary array indicating if event occurred (1) or was censored (0)\n    event_embeddings: Optional pre-trained embeddings", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 1011, "module": "src.metainformant.life_events.models", "name": "fit", "signature": "(self, sequences: Sequence[Sequence[str]], event_times: NDArray, event_occurred: NDArray, event_embeddings: Optional[Dict[str, NDArray]] = None) -> 'SurvivalPredictor'", "symbol_type": "function"}, {"docstring": "Fit multi-task model.\n\nArgs:\n    sequences: List of event sequences\n    outcomes: Dictionary mapping task names to outcome arrays\n    event_embeddings: Optional pre-trained embeddings", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 1118, "module": "src.metainformant.life_events.models", "name": "fit", "signature": "(self, sequences: Sequence[Sequence[str]], outcomes: Dict[str, NDArray], event_embeddings: Optional[Dict[str, NDArray]] = None) -> 'MultiTaskPredictor'", "symbol_type": "function"}, {"docstring": "Fit classifier to training data.\n\nArgs:\n    X: Training feature matrix (samples x features)\n    y: Training labels\n\nReturns:\n    Fitted classifier", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/classification.py", "line_number": 35, "module": "src.metainformant.ml.classification", "name": "fit", "signature": "(self, X: np.ndarray, y: np.ndarray) -> 'BiologicalClassifier'", "symbol_type": "function"}, {"docstring": "Fit regressor to training data.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/regression.py", "line_number": 33, "module": "src.metainformant.ml.regression", "name": "fit", "signature": "(self, X: np.ndarray, y: np.ndarray) -> 'BiologicalRegressor'", "symbol_type": "function"}, {"docstring": "Fit a sigmoid function to this well and extract curve parameters.\n\nIf function is None or an empty tuple/list, then no fitting is done.\nOnly the object's ``.min``, ``.max`` and ``.average_height`` are\ncalculated.\n\nBy default the following fitting functions will be used in order:\n - gompertz\n - logistic\n - richards\n\nThe first function that is successfully fitted to the signals will\nbe used to extract the curve parameters and update ``.area`` and\n``.model``. If no function can be fitted an exception is raised.\n\nThe function argument should be a tuple or list of any of these three\nfunction names as strings.\n\nThere is no return value.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/phen_micro.py", "line_number": 845, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.phen_micro", "name": "fit", "signature": "(self, function = ('gompertz', 'logistic', 'richards'))", "symbol_type": "function"}, {"docstring": "Fit the provided function to the x and y values.\n\nThe function parameters and the parameters covariance.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/pm_fitting.py", "line_number": 136, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.pm_fitting", "name": "fit", "signature": "(function, x, y)", "symbol_type": "function"}], "fitness": [{"docstring": "Create fitness function with linear selection and noise.\n\nArgs:\n    k: Selection strength\n    mu: Optimal trait value\n    sigma: Fitness variance\n    \nReturns:\n    Fitness function that takes trait values and returns fitness", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/model.py", "line_number": 130, "module": "src.metainformant.math.selection_experiments.model", "name": "fitness", "signature": "(k: float, mu: float, sigma: float) -> Callable[[np.ndarray], np.ndarray]", "symbol_type": "function"}], "fix_abundance_naming": [{"docstring": "Create symlink from abundance.tsv to {SRR}_abundance.tsv for amalgkit merge.\n\nArgs:\n    quant_dir: Directory containing quantification results\n    sample_id: Sample ID (e.g., 'SRR1234567')\n\nReturns:\n    True if symlink was created or already exists", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/cleanup.py", "line_number": 136, "module": "src.metainformant.rna.cleanup", "name": "fix_abundance_naming", "signature": "(quant_dir: Path, sample_id: str) -> bool", "symbol_type": "function"}], "fix_abundance_naming_for_species": [{"docstring": "Fix abundance naming for all samples in a species.\n\nArgs:\n    config_path: Path to species workflow config file\n\nReturns:\n    Tuple of (created_count, already_exists_count)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/cleanup.py", "line_number": 164, "module": "src.metainformant.rna.cleanup", "name": "fix_abundance_naming_for_species", "signature": "(config_path: Path) -> tuple[int, int]", "symbol_type": "function"}], "fix_single": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 89, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "fix_single", "signature": "(tree)", "symbol_type": "function"}], "fixation_probability": [{"docstring": "Calculate probability that an allele will fix in a population.\n\nUses Kimura's diffusion approximation for fixation probability under\nselection and genetic drift in a finite population.\n\nArgs:\n    initial_frequency: Starting frequency of the allele (p)\n    effective_population_size: Effective population size (Ne)\n    selection_coefficient: Selection coefficient (s). s > 0 for advantage,\n        s < 0 for disadvantage, s = 0 for neutral\n        \nReturns:\n    Fixation probability in [0, 1]. For neutral alleles (s=0), returns\n    the initial frequency. Values clamped to [0, 1].\n    \nExamples:\n    >>> # Neutral allele with 10% initial frequency\n    >>> fixation_probability(0.1, effective_population_size=1000, selection_coefficient=0.0)\n    0.1\n    \n    >>> # Advantageous allele\n    >>> fixation_probability(0.01, effective_population_size=1000, selection_coefficient=0.01)\n    0.182...\n    \nReferences:\n    Kimura, M. (1962). On the probability of fixation of mutant genes\n    in a population. Genetics, 47(6), 713-719.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 120, "module": "src.metainformant.math.popgen", "name": "fixation_probability", "signature": "(initial_frequency: float, effective_population_size: int, selection_coefficient: float = 0.0) -> float", "symbol_type": "function"}], "flag_disorder": [{"docstring": "Set the disordered flag to 1.\n\nThe disordered flag indicates whether the atom is disordered or not.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 361, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "flag_disorder", "signature": "(self)", "symbol_type": "function"}], "flag_disordered": [{"docstring": "Set the disordered flag.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Residue.py", "line_number": 87, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Residue", "name": "flag_disordered", "signature": "(self)", "symbol_type": "function"}], "flatten_mapping": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 180, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "flatten_mapping", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 180, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "flatten_mapping", "signature": "(self, node)", "symbol_type": "function"}], "flexibility": [{"docstring": "Calculate the flexibility according to Vihinen, 1994.\n\nNo argument to change window size because parameters are specific for\na window=9. The parameters used are optimized for determining the\nflexibility.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/ProtParam.py", "line_number": 171, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.ProtParam", "name": "flexibility", "signature": "(self)", "symbol_type": "function"}], "float1_color": [{"docstring": "Map float (red, green, blue) tuple to a ReportLab Color object.\n\n- values: A tuple of (red, green, blue) intensities as floats\n  in the range 0 -> 1\n\nTakes a tuple of (red, green, blue) intensity values in the range\n0 -> 1 and returns an appropriate colors.Color object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Colors.py", "line_number": 218, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Colors", "name": "float1_color", "signature": "(self, values)", "symbol_type": "function"}], "flush": [{"docstring": "Flush data explicitally.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 880, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "flush", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1110, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "flush", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1126, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "flush", "signature": "(self)", "symbol_type": "function"}], "flush_stream": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 788, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "flush_stream", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 788, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "flush_stream", "signature": "(self)", "symbol_type": "function"}], "fmt": [{"docstring": "Alignment file format name.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/__init__.py", "line_number": 489, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.__init__", "name": "fmt", "signature": "(self)", "symbol_type": "function"}], "fmt_": [{"docstring": "Ensure the given value formats to a string correctly.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIXML.py", "line_number": 40, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIXML", "name": "fmt_", "signature": "(value, format_spec = '%s', default_str = '<unknown>')", "symbol_type": "function"}], "force_directed_plot": [{"docstring": "Create a force-directed network plot.\n\nArgs:\n    nodes: List of node names\n    edges: List of (source, target) edge tuples\n    node_sizes: Optional list of node sizes\n    node_colors: Optional list of node colors\n    iterations: Number of iterations for force-directed layout\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import force_directed_plot\n    >>> nodes = ['A', 'B', 'C', 'D', 'E']\n    >>> edges = [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'A')]\n    >>> ax = force_directed_plot(nodes, edges)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/networks.py", "line_number": 206, "module": "src.metainformant.visualization.networks", "name": "force_directed_plot", "signature": "(nodes: list[str], edges: list[tuple[str, str]], **kwargs) -> plt.Axes", "symbol_type": "function"}], "forecast_plot": [{"docstring": "Create a forecast plot with observed and predicted values.\n\nArgs:\n    time_points: Time points\n    observed: Observed values\n    forecast: Forecasted values\n    confidence_intervals: Optional (lower, upper) confidence intervals\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import forecast_plot\n    >>> import numpy as np\n    >>> time = np.arange(0, 20)\n    >>> observed = np.sin(time[:10])\n    >>> forecast = np.sin(time[10:])\n    >>> ax = forecast_plot(time, observed, forecast)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/timeseries.py", "line_number": 208, "module": "src.metainformant.visualization.timeseries", "name": "forecast_plot", "signature": "(time_points: Sequence[float], observed: Sequence[float], forecast: Sequence[float], confidence_intervals: tuple[Sequence[float], Sequence[float]] | None = None, **kwargs) -> plt.Axes", "symbol_type": "function"}], "format": [{"docstring": "Return the record as a string in the specified file format.\n\nThe format should be a lower case string supported as an output\nformat by Bio.SeqIO, which is used to turn the SeqRecord into a\nstring.  e.g.\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqRecord import SeqRecord\n>>> record = SeqRecord(Seq(\"MKQHKAMIVALIVICITAVVAALVTRKDLCEVHIRTGQTEVAVF\"),\n...                    id=\"YP_025292.1\", name=\"HokC\",\n...                    description=\"toxic membrane protein\")\n>>> record.format(\"fasta\")\n'>YP_025292.1 toxic membrane protein\\nMKQHKAMIVALIVICITAVVAALVTRKDLCEVHIRTGQTEVAVF\\n'\n>>> print(record.format(\"fasta\"))\n>YP_025292.1 toxic membrane protein\nMKQHKAMIVALIVICITAVVAALVTRKDLCEVHIRTGQTEVAVF\n<BLANKLINE>\n\nThe Python print function automatically appends a new line, meaning\nin this example a blank line is shown.  If you look at the string\nrepresentation you can see there is a trailing new line (shown as\nslash n) which is important when writing to a file or if\nconcatenating multiple sequence strings together.\n\nNote that this method will NOT work on every possible file format\nsupported by Bio.SeqIO (e.g. some are for multiple sequences only,\nand binary formats are not supported).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 789, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "format", "signature": "(self, format: str) -> str", "symbol_type": "function"}, {"docstring": "Return the alignment as a string in the specified file format.\n\nArguments:\n - fmt       - File format. Acceptable values are an empty string to\n               create a human-readable representation of the alignment,\n               or any of the alignment file formats supported by\n               `Bio.Align` (some have not yet been implemented).\n - scoring  - Optional keyword-only parameter; default=None.\n               If provided, can be:\n\n             - A substitution matrix (typically from the\n                `Bio.Align.substitution_matrices` submodule)\n                 used to mark positive matches (:) in the alignment string\n                 when two different residues have a positive score.\n\n             - A PairwiseAligner object, in which case its substitution\n                 matrix and settings are used for determining positive matches.\n\nAll other arguments are passed to the format-specific writer functions:\n - mask      - PSL format only. Specify if repeat regions in the target\n               sequence are masked and should be reported in the\n               `repMatches` field of the PSL file instead of in the\n               `matches` field. Acceptable values are\n               None   : no masking (default);\n               \"lower\": masking by lower-case characters;\n               \"upper\": masking by upper-case characters.\n - wildcard  - PSL format only. Report alignments to the wildcard\n               character in the target or query sequence in the\n               `nCount` field of the PSL file instead of in the\n               `matches`, `misMatches`, or `repMatches` fields.\n               Default value is 'N'.\n - md        - SAM format only. If True, calculate the MD tag from\n               the alignment and include it in the output. If False\n               (default), do not include the MD tag in the output.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 2330, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "format", "signature": "(self, fmt = '', *args, **kwargs)", "symbol_type": "function"}, {"docstring": "Return a string representation of the array.\n\nThe argument ``fmt`` specifies the number format to be used.\nBy default, the number format is \"%i\" if the array contains integer\nnumbers, and \"%.1f\" otherwise.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/substitution_matrices/__init__.py", "line_number": 416, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.substitution_matrices.__init__", "name": "format", "signature": "(self, fmt = '')", "symbol_type": "function"}, {"docstring": "Serialize the tree as a string in the specified file format.\n\n:param fmt: a lower-case string supported by ``Bio.Phylo.write``\n    as an output file format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 967, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "format", "signature": "(self, fmt = None)", "symbol_type": "function"}, {"docstring": "Evaluate enzyme (name) and return it (as RestrictionType).\n\nIf y is a RestrictionType return y.\nIf y can be evaluated to a RestrictionType return eval(y).\nRaise a ValueError in all other case.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2133, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "format", "signature": "(self, y)", "symbol_type": "function"}, {"docstring": "Return a string representation of the Motif in the given format.\n\nCurrently supported formats:\n - clusterbuster: Cluster Buster position frequency matrix format\n - pfm : JASPAR single Position Frequency Matrix\n - jaspar : JASPAR multiple Position Frequency Matrix\n - transfac : TRANSFAC like files", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/__init__.py", "line_number": 603, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.__init__", "name": "format", "signature": "(self, format_spec)", "symbol_type": "function"}], "format_alignment": [{"docstring": "Format the alignment prettily into a string.\n\nIMPORTANT: Gap symbol must be \"-\" (or ['-'] for lists)!\n\nSince Biopython 1.71 identical matches are shown with a pipe\ncharacter, mismatches as a dot, and gaps as a space.\n\nPrior releases just used the pipe character to indicate the\naligned region (matches, mismatches and gaps).\n\nAlso, in local alignments, if the alignment does not include\nthe whole sequences, now only the aligned part is shown,\ntogether with the start positions of the aligned subsequences.\nThe start positions are 1-based; so start position n is the\nn-th base/amino acid in the *un-aligned* sequence.\n\nNOTE: This is different to the alignment's begin/end values,\nwhich give the Python indices (0-based) of the bases/amino acids\nin the *aligned* sequences.\n\nIf you want to restore the 'historic' behaviour, that means\ndisplaying the whole sequences (including the non-aligned parts),\nuse ``full_sequences=True``. In this case, the non-aligned leading\nand trailing parts are also indicated by spaces in the match-line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/pairwise2.py", "line_number": 1348, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.pairwise2", "name": "format_alignment", "signature": "(align1, align2, score, begin, end, full_sequences = False)", "symbol_type": "function"}, {"docstring": "Return a string with the alignment in the A2M file format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/a2m.py", "line_number": 24, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.a2m", "name": "format_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Return a string with one alignment formatted as a BED line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bed.py", "line_number": 56, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bed", "name": "format_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Return a string with one alignment formatted as a chain block.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/chain.py", "line_number": 35, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.chain", "name": "format_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Return a string with a single alignment in the Clustal format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/clustal.py", "line_number": 40, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.clustal", "name": "format_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Return a string with the alignment in aligned FASTA format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/fasta.py", "line_number": 25, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.fasta", "name": "format_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Format a single alignment as a string.\n\nalignment - an Alignment object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/interfaces.py", "line_number": 277, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.interfaces", "name": "format_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Return a string with a single alignment formatted as a MAF block.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/maf.py", "line_number": 124, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.maf", "name": "format_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Return a string with a single alignment in the Mauve format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/mauve.py", "line_number": 97, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.mauve", "name": "format_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Return a string with a single alignment in the Nexus format.\n\nCreates an empty Nexus object, adds the sequences\nand then gets Nexus to prepare the output.\n\n - alignment  - An Alignment object\n - interleave - if None (default): interleave if columns > 1000\n                if True: use interleaved format\n                if False: do not use interleaved format", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/nexus.py", "line_number": 62, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.nexus", "name": "format_alignment", "signature": "(self, alignment, interleave = None)", "symbol_type": "function"}, {"docstring": "Return a string with a single alignment in the Phylip format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/phylip.py", "line_number": 25, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.phylip", "name": "format_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Return a string with a single alignment formatted as one PSL line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/psl.py", "line_number": 106, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.psl", "name": "format_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Return a string with a single alignment formatted as one SAM line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/sam.py", "line_number": 117, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.sam", "name": "format_alignment", "signature": "(self, alignment, md = None)", "symbol_type": "function"}, {"docstring": "Return a string with a single alignment in the Stockholm format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/stockholm.py", "line_number": 468, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.stockholm", "name": "format_alignment", "signature": "(self, alignment)", "symbol_type": "function"}], "format_branch_label": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 373, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "format_branch_label", "signature": "(clade)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 387, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "format_branch_label", "signature": "(clade)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 392, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "format_branch_label", "signature": "(clade)", "symbol_type": "function"}], "format_label": [{"docstring": "Format label for librdf.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 64, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "format_label", "signature": "(x)", "symbol_type": "function"}], "format_output": [{"docstring": "Summarise results as a nicely formatted string.\n\nArguments:\n - dct is a dictionary as returned by a RestrictionBatch.search()\n - title is the title of the map.\n   It must be a formatted string, i.e. you must include the line break.\n - s1 is the title separating the list of enzymes that have sites from\n   those without sites.\n - s1 must be a formatted string as well.\n\nThe format of print_that is a list.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/PrintFormat.py", "line_number": 113, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.PrintFormat", "name": "format_output", "signature": "(self, dct, title = '', s1 = '')", "symbol_type": "function"}, {"docstring": "Collect data and pass to PrintFormat.\n\nIf dct is not given the full dictionary is used.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2326, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "format_output", "signature": "(self, dct = None, title = '', s1 = '')", "symbol_type": "function"}], "format_phylip": [{"docstring": "Write data in Phylip format to a given file-like object or handle.\n\nThe output stream is the input distance matrix format used with Phylip\nprograms (e.g. 'neighbor'). See:\nhttp://evolution.genetics.washington.edu/phylip/doc/neighbor.html\n\n:Parameters:\n    handle : file or file-like object\n        A writeable text mode file handle or other object supporting\n        the 'write' method, such as StringIO or sys.stdout.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/TreeConstruction.py", "line_number": 335, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.TreeConstruction", "name": "format_phylip", "signature": "(self, handle)", "symbol_type": "function"}], "format_species_name": [{"docstring": "Format species name in proper binomial format.\n\nArgs:\n    species_name: Raw species name\n\nReturns:\n    Properly formatted species name", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/text.py", "line_number": 73, "module": "src.metainformant.core.text", "name": "format_species_name", "signature": "(species_name: str) -> str", "symbol_type": "function"}], "forward": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 634, "module": "src.metainformant.life_events.models", "name": "forward", "signature": "(self, x)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 818, "module": "src.metainformant.life_events.models", "name": "forward", "signature": "(self, x)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/reader.py", "line_number": 99, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.reader", "name": "forward", "signature": "(self, length = 1)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/reader.py", "line_number": 99, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.reader", "name": "forward", "signature": "(self, length = 1)", "symbol_type": "function"}], "fragcascade": [{"docstring": "Return a getter property with cascading setter, for HSPFragment objects.\n\nSimilar to ``partialcascade``, but for HSPFragment objects and acts on ``query``\nor ``hit`` properties of the object if they are not None.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 150, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "fragcascade", "signature": "(attr, seq_type, doc = '')", "symbol_type": "function"}], "fragments": [{"docstring": "Access the HSPFragment objects contained in the Hit.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/hit.py", "line_number": 342, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.hit", "name": "fragments", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Access the HSPFragment objects contained in the QueryResult.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 419, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "fragments", "signature": "(self)", "symbol_type": "function"}], "frequencies": [{"docstring": "Return the frequency of each letter in each column of the alignment.\n\nGaps are represented by a dash (\"-\") character.\nFor example,\n\n>>> from Bio import Align\n>>> aligner = Align.PairwiseAligner()\n>>> aligner.mode = \"global\"\n>>> alignments = aligner.align(\"GACCTG\", \"CGATCG\")\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            0 -GACCTG 6\n                  0 -||.|-| 7\nquery             0 CGATC-G 6\n<BLANKLINE>\n>>> alignment.frequencies\n{'-': array([1., 0., 0., 0., 0., 1., 0.]), 'G': array([0., 2., 0., 0., 0., 0., 2.]), 'A': array([0., 0., 2., 0., 0., 0., 0.]), 'C': array([1., 0., 0., 1., 2., 0., 0.]), 'T': array([0., 0., 0., 1., 0., 1., 0.])}\n>>> aligner.mode = \"local\"\n>>> alignments = aligner.align(\"GACCTG\", \"CGATCG\")\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            0 GACC 4\n                  0 ||.| 4\nquery             1 GATC 5\n<BLANKLINE>\n>>> alignment.frequencies\n{'G': array([2., 0., 0., 0.]), 'A': array([0., 2., 0., 0.]), 'C': array([0., 0., 1., 2.]), 'T': array([0., 0., 1., 0.])}", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 1468, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "frequencies", "signature": "(self)", "symbol_type": "function"}], "frequency": [{"docstring": "Return the theoretically cutting frequency of the enzyme.\n\nFrequency of the site, given as 'one cut per x bases' (int).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 667, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "frequency", "signature": "(cls)", "symbol_type": "function"}], "from_DataFrame": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 60, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "from_DataFrame", "signature": "(df)", "symbol_type": "function"}], "from_alignments_with_same_reference": [{"docstring": "Create an Alignment from a list of alignments in which the first sequence is the same (reference sequence).\n\nThis method combines multiple alignments into a single multiple sequence alignment.\nAll alignments must share the same reference sequence (ignoring gaps).\n\nArgs:\n    alignments: A list or tuple of Alignment objects.\n\nReturns:\n    An Alignment object representing a multiple sequence alignment.\n\nRaises:\n    ValueError: If no alignments are provided or if the reference\n    sequences do not match across all alignments.\n\nExample 1: Basic Usage with Strings\n    >>> from Bio.Seq import Seq\n    >>> from Bio.SeqRecord import SeqRecord\n    >>> from Bio.Align import PairwiseAligner, Alignment\n    >>> import numpy as np\n\n    Consider the following reference and sequences:\n    >>> reference_str = \"ACGT\"\n    >>> seq1_str = \"ACT\"\n    >>> seq2_str = \"ACGGT\"\n    >>> seq3_str = \"AT\"\n\n    To produce a pairwise alignment:\n    >>> aligner = PairwiseAligner()\n    >>> pwa = next(aligner.align(reference_str, seq1_str))\n\n    To produce a three sequence alignment:\n    >>> coords = np.array([\n    ...     [0, 1, 2, 3, 3, 4],\n    ...     [0, 1, 2, 3, 4, 5],\n    ...     [0, 1, 1, 1, 1, 2]\n    ... ])\n\n    >>> not_pwa = Alignment([reference_str, seq2_str, seq3_str], coords)\n\n    The pairwise alignment would look like\n    >>> print(f\"Reference: {pwa[0]}\")\n    Reference: ACGT\n    >>> print(f\"Seq1:      {pwa[1]}\")\n    Seq1:      AC-T\n\n    The three sequence alignment would look like\n    >>> str(not_pwa[0])\n    'ACG-T'\n    >>> str(not_pwa[1])\n    'ACGGT'\n    >>> str(not_pwa[2])\n    'A---T'\n\n    Now, we can combine these alignments into a multiple sequence alignment:\n    >>> msa = Alignment.from_alignments_with_same_reference([pwa, not_pwa])\n    >>> str(msa[0])\n    'ACG-T'\n    >>> str(msa[1])\n    'AC--T'\n    >>> str(msa[2])\n    'ACGGT'\n    >>> str(msa[3])\n    'A---T'\n\nExample 2: Using SeqRecord Objects with Metadata\n    Consider the following reference and sequences with metadata:\n    >>> reference_seqr = SeqRecord(Seq(\"ACGT\"), id=\"reference\", description=\"desc 1\")\n    >>> seq1 = SeqRecord(Seq(\"ACGGT\"), id=\"seq1\", description=\"desc 2\")\n    >>> seq2 = SeqRecord(Seq(\"AT\"), id=\"seq2\", description=\"desc 3\")\n\n    To produce pairwise alignments:\n    >>> aligner = PairwiseAligner()\n    >>> pwa1 = next(aligner.align(reference_seqr, seq1))\n    >>> pwa2 = next(aligner.align(reference_seqr, seq2))\n\n    The msa retains the metadata from the original SeqRecord objects:\n    >>> msa = Alignment.from_alignments_with_same_reference([pwa1, pwa2])\n    >>> print(msa.format(\"fasta\"))\n    >reference desc 1\n    ACG-T\n    >seq1 desc 2\n    ACGGT\n    >seq2 desc 3\n    A---T\n    <BLANKLINE>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 1069, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "from_alignments_with_same_reference", "signature": "(cls, alignments: list['Alignment'] | tuple['Alignment']) -> 'Alignment'", "symbol_type": "function"}], "from_bool": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/Consensus.py", "line_number": 219, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.Consensus", "name": "from_bool", "signature": "(cls, bools)", "symbol_type": "function"}], "from_bytes": [{"docstring": "Return an AutoSQLTable initialized using the bytes object data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 84, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "from_bytes", "signature": "(cls, data)", "symbol_type": "function"}], "from_clade": [{"docstring": "Create a new Tree object given a clade.\n\nKeyword arguments are the usual ``Tree`` constructor parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 747, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "from_clade", "signature": "(cls, clade, **kwargs)", "symbol_type": "function"}, {"docstring": "Create a new Phylogeny given a Newick or BaseTree Clade object.\n\nKeyword arguments are the usual ``PhyloXML.Clade`` constructor parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 229, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "from_clade", "signature": "(cls, clade, **kwargs)", "symbol_type": "function"}, {"docstring": "Create a new PhyloXML Clade from a Newick or BaseTree Clade object.\n\nKeyword arguments are the usual PhyloXML Clade constructor parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 415, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "from_clade", "signature": "(cls, clade, **kwargs)", "symbol_type": "function"}], "from_dict": [{"docstring": "Create Event from dictionary.\n\nArgs:\n    data: Dictionary with event data\n    \nReturns:\n    Event object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 59, "module": "src.metainformant.life_events.events", "name": "from_dict", "signature": "(cls, data: Dict[str, Any]) -> 'Event'", "symbol_type": "function"}, {"docstring": "Create EventSequence from dictionary.\n\nArgs:\n    data: Dictionary with sequence data\n    \nReturns:\n    EventSequence object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 213, "module": "src.metainformant.life_events.events", "name": "from_dict", "signature": "(cls, data: Dict[str, Any]) -> 'EventSequence'", "symbol_type": "function"}, {"docstring": "Create EventDatabase from dictionary.\n\nArgs:\n    data: Dictionary with database data\n    \nReturns:\n    EventDatabase object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 329, "module": "src.metainformant.life_events.events", "name": "from_dict", "signature": "(cls, data: Dict[str, Any]) -> 'EventDatabase'", "symbol_type": "function"}], "from_dna_variants": [{"docstring": "Load genomic variant data from VCF file for multi-omics integration.\n\nConverts VCF format variant data into a sample x variant matrix suitable\nfor multi-omics integration. Handles genotype encoding and missing data.\n\nArgs:\n    vcf_path: Path to VCF file\n    sample_column_prefix: Prefix for sample column names in output\n    \nReturns:\n    DataFrame with samples as rows and variants as columns. Genotypes\n    are encoded as 0 (homozygous reference), 1 (heterozygous), 2 (homozygous alternate)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 635, "module": "src.metainformant.multiomics.integration", "name": "from_dna_variants", "signature": "(vcf_path: Union[str, Path], sample_column_prefix: str = 'sample_') -> pd.DataFrame", "symbol_type": "function"}], "from_hex": [{"docstring": "Construct a BranchColor object from a hexadecimal string.\n\nThe string format is the same style used in HTML and CSS, such as\n'#FF8000' for an RGB value of (255, 128, 0).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 1176, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "from_hex", "signature": "(cls, hexstr)", "symbol_type": "function"}], "from_metabolomics": [{"docstring": "Load metabolomics data for multi-omics integration.\n\nLoads metabolite abundance data from CSV/TSV file with metabolites as columns\nand samples as rows. Optionally normalizes data (log2 transform and scaling).\n\nArgs:\n    metabolite_path: Path to metabolomics data file\n    delimiter: Delimiter for file (default: comma for CSV)\n    normalize: If True, apply log2 transformation and quantile normalization\n    \nReturns:\n    DataFrame with samples as rows and metabolites as columns", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 720, "module": "src.metainformant.multiomics.integration", "name": "from_metabolomics", "signature": "(metabolite_path: Union[str, Path], delimiter: str = ',', normalize: bool = True) -> pd.DataFrame", "symbol_type": "function"}], "from_msa": [{"docstring": "Convert a MultipleSeqAlignment to CodonAlignment.\n\nFunction to convert a MultipleSeqAlignment to CodonAlignment.\nIt is the user's responsibility to ensure all the requirement\nneeded by CodonAlignment is met.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonalignment.py", "line_number": 220, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonalignment", "name": "from_msa", "signature": "(cls, align)", "symbol_type": "function"}], "from_name": [{"docstring": "Construct a BranchColor object by the color's name.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 1190, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "from_name", "signature": "(cls, colorname)", "symbol_type": "function"}], "from_protein_abundance": [{"docstring": "Load protein abundance data for multi-omics integration.\n\nLoads protein abundance data from CSV/TSV file with proteins as columns\nand samples as rows.\n\nArgs:\n    protein_path: Path to protein abundance file\n    delimiter: Delimiter for file (default: comma for CSV)\n    \nReturns:\n    DataFrame with samples as rows and proteins as columns", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 694, "module": "src.metainformant.multiomics.integration", "name": "from_protein_abundance", "signature": "(protein_path: Union[str, Path], delimiter: str = ',') -> pd.DataFrame", "symbol_type": "function"}], "from_rna_expression": [{"docstring": "Load RNA expression data for multi-omics integration.\n\nLoads gene expression data from TSV/CSV file with genes as columns\nand samples as rows.\n\nArgs:\n    expression_path: Path to expression file (TSV or CSV)\n    delimiter: Delimiter for file (default: tab for TSV)\n    \nReturns:\n    DataFrame with samples as rows and genes as columns", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 668, "module": "src.metainformant.multiomics.integration", "name": "from_rna_expression", "signature": "(expression_path: Union[str, Path], delimiter: str = '\\t') -> pd.DataFrame", "symbol_type": "function"}], "from_seq": [{"docstring": "Get codon sequence from sequence data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 245, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "from_seq", "signature": "(cls, seq, rf_table = None)", "symbol_type": "function"}], "from_seqfeature": [{"docstring": "Create ProteinDomain object from SeqFeature.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 1026, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "from_seqfeature", "signature": "(cls, feat)", "symbol_type": "function"}], "from_seqrecord": [{"docstring": "Create a new PhyloXML Sequence from a SeqRecord object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 1136, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "from_seqrecord", "signature": "(cls, record, is_aligned = None)", "symbol_type": "function"}], "from_string": [{"docstring": "Return an AutoSQLTable initialized using the string object data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 129, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "from_string", "signature": "(cls, data)", "symbol_type": "function"}, {"docstring": "Instantiate the class from the given string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 107, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "from_string", "signature": "(cls, treetext)", "symbol_type": "function"}, {"docstring": "Convert file handle to StringIO object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NeXMLIO.py", "line_number": 102, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NeXMLIO", "name": "from_string", "signature": "(cls, treetext)", "symbol_type": "function"}, {"docstring": "Instantiate the Newick Tree class from the given string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NewickIO.py", "line_number": 107, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NewickIO", "name": "from_string", "signature": "(cls, treetext)", "symbol_type": "function"}], "from_tree": [{"docstring": "Create a new Phylogeny given a Tree (from Newick/Nexus or BaseTree).\n\nKeyword arguments are the usual ``Phylogeny`` constructor parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 214, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "from_tree", "signature": "(cls, tree, **kwargs)", "symbol_type": "function"}], "from_xml": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 66, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "from_xml", "signature": "(xml_root)", "symbol_type": "function"}], "from_yaml": [{"docstring": "Convert a representation node to a Python object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 377, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "from_yaml", "signature": "(cls, loader, node)", "symbol_type": "function"}, {"docstring": "Convert a representation node to a Python object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 377, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "from_yaml", "signature": "(cls, loader, node)", "symbol_type": "function"}], "fromfile": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1167, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "fromfile", "signature": "(cls, stream)", "symbol_type": "function"}], "fromstring": [{"docstring": "Create a Location object from a string.\n\nThis should accept any valid location string in the INSDC Feature Table\nformat (https://www.insdc.org/submitting-standards/feature-table/) as\nused in GenBank, DDBJ and EMBL files.\n\nSimple examples:\n\n>>> Location.fromstring(\"123..456\", 1000)\nSimpleLocation(ExactPosition(122), ExactPosition(456), strand=1)\n>>> Location.fromstring(\"complement(<123..>456)\", 1000)\nSimpleLocation(BeforePosition(122), AfterPosition(456), strand=-1)\n\nA more complex location using within positions,\n\n>>> Location.fromstring(\"(9.10)..(20.25)\", 1000)\nSimpleLocation(WithinPosition(8, left=8, right=9), WithinPosition(25, left=20, right=25), strand=1)\n\nNotice how that will act as though it has overall start 8 and end 25.\n\nZero length between feature,\n\n>>> Location.fromstring(\"123^124\", 1000)\nSimpleLocation(ExactPosition(123), ExactPosition(123), strand=1)\n\nThe expected sequence length is needed for a special case, a between\nposition at the start/end of a circular genome:\n\n>>> Location.fromstring(\"1000^1\", 1000)\nSimpleLocation(ExactPosition(1000), ExactPosition(1000), strand=1)\n\nApart from this special case, between positions P^Q must have P+1==Q,\n\n>>> Location.fromstring(\"123^456\", 1000)\nTraceback (most recent call last):\n   ...\nBio.SeqFeature.LocationParserError: invalid feature location '123^456'\n\nYou can optionally provide a reference name:\n\n>>> Location.fromstring(\"AL391218.9:105173..108462\", 2000000)\nSimpleLocation(ExactPosition(105172), ExactPosition(108462), strand=1, ref='AL391218.9')\n\n>>> Location.fromstring(\"<2644..159\", 2868, \"circular\")\nCompoundLocation([SimpleLocation(BeforePosition(2643), ExactPosition(2868), strand=1), SimpleLocation(ExactPosition(0), ExactPosition(159), strand=1)], 'join')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 629, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "fromstring", "signature": "(text, length = None, circular = False, stranded = True)", "symbol_type": "function"}, {"docstring": "Create a SimpleLocation object from a string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 898, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "fromstring", "signature": "(text, length = None, circular = False)", "symbol_type": "function"}, {"docstring": "Build a Position object from the text string.\n\nFor an end position, leave offset as zero (default):\n\n>>> Position.fromstring(\"5\")\nExactPosition(5)\n\nFor a start position, set offset to minus one (for Python counting):\n\n>>> Position.fromstring(\"5\", -1)\nExactPosition(4)\n\nThis also covers fuzzy positions:\n\n>>> p = Position.fromstring(\"<5\")\n>>> p\nBeforePosition(5)\n>>> print(p)\n<5\n>>> int(p)\n5\n\n>>> Position.fromstring(\">5\")\nAfterPosition(5)\n\nBy default assumes an end position, so note the integer behavior:\n\n>>> p = Position.fromstring(\"one-of(5,8,11)\")\n>>> p\nOneOfPosition(11, choices=[ExactPosition(5), ExactPosition(8), ExactPosition(11)])\n>>> print(p)\none-of(5,8,11)\n>>> int(p)\n11\n\n>>> Position.fromstring(\"(8.10)\")\nWithinPosition(10, left=8, right=10)\n\nFuzzy start positions:\n\n>>> p = Position.fromstring(\"<5\", -1)\n>>> p\nBeforePosition(4)\n>>> print(p)\n<4\n>>> int(p)\n4\n\nNotice how the integer behavior changes too!\n\n>>> p = Position.fromstring(\"one-of(5,8,11)\", -1)\n>>> p\nOneOfPosition(4, choices=[ExactPosition(4), ExactPosition(7), ExactPosition(10)])\n>>> print(p)\none-of(4,7,10)\n>>> int(p)\n4", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 1722, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "fromstring", "signature": "(text, offset = 0)", "symbol_type": "function"}], "fst_from_allele_freqs": [{"docstring": "Compute Fst for a bi-allelic locus from subpopulation allele-A frequencies.\n\nUses Hs = mean(2 p (1-p)) and Ht = 2 p_bar (1-p_bar).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/fst.py", "line_number": 40, "module": "src.metainformant.math.fst", "name": "fst_from_allele_freqs", "signature": "(subpop_allele_freqs: Iterable[float]) -> float", "symbol_type": "function"}], "fst_from_heterozygosity": [{"docstring": "Calculate Wright's Fst from heterozygosity values.\n\nFst measures population differentiation: the proportion of genetic\ndiversity that is between subpopulations rather than within them.\n\nArgs:\n    Hs: Average heterozygosity within subpopulations\n    Ht: Total heterozygosity in the entire population\n    \nReturns:\n    Fst value in [0, 1]. Returns 0.0 if Ht <= 0.\n    Formula: Fst = (Ht - Hs) / Ht\n    \nExamples:\n    >>> fst_from_heterozygosity(Hs=0.3, Ht=0.4)\n    0.25\n    >>> fst_from_heterozygosity(Hs=0.4, Ht=0.4)\n    0.0  # No differentiation\n    \nReferences:\n    Wright, S. (1949). The genetical structure of populations.\n    Annals of Eugenics, 15(1), 323-354.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/fst.py", "line_number": 6, "module": "src.metainformant.math.fst", "name": "fst_from_heterozygosity", "signature": "(Hs: float, Ht: float) -> float", "symbol_type": "function"}], "fu_and_li_d_star": [{"docstring": "Calculate Fu & Li's D* statistic.\n\nFu & Li's D* tests for departure from neutrality by comparing external\n(singleton) mutations to internal mutations. External mutations are those\nthat appear only once in the sample (singletons).\n\nD* > 0 suggests balancing selection or population contraction.\nD* < 0 suggests directional selection or population expansion.\nD* \u2248 0 is consistent with neutral equilibrium.\n\nArgs:\n    num_segregating_sites: Total number of segregating sites (S)\n    num_external_mutations: Number of external (singleton) mutations (\u03b7_e)\n    sample_size: Number of sampled sequences (n)\n    \nReturns:\n    Fu & Li's D* statistic. Returns 0.0 if variance is zero or inputs invalid.\n    \nExamples:\n    >>> fu_and_li_d_star(num_segregating_sites=10, num_external_mutations=5, sample_size=10)\n    -0.5...\n    \nReferences:\n    Fu, Y. X., & Li, W. H. (1993). Statistical tests of neutrality of mutations.\n    Genetics, 133(3), 693-709.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 211, "module": "src.metainformant.math.coalescent", "name": "fu_and_li_d_star", "signature": "(num_segregating_sites: int, num_external_mutations: int, sample_size: int) -> float", "symbol_type": "function"}], "fu_and_li_d_star_from_sequences": [{"docstring": "Calculate Fu & Li's D* from sequences.\n\nWrapper function that computes D* from DNA sequences by identifying\nexternal (singleton) mutations.\n\nArgs:\n    seqs: Sequence of DNA sequences (strings)\n\nReturns:\n    Fu & Li's D* statistic. Returns 0.0 if insufficient data.\n\nExamples:\n    >>> seqs = [\"AAAA\", \"AAAT\", \"AATT\"]\n    >>> d_star = fu_and_li_d_star_from_sequences(seqs)\n    >>> isinstance(d_star, float)\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population.py", "line_number": 309, "module": "src.metainformant.dna.population", "name": "fu_and_li_d_star_from_sequences", "signature": "(seqs: Sequence[str]) -> float", "symbol_type": "function"}], "fu_and_li_f_star": [{"docstring": "Calculate Fu & Li's F* statistic.\n\nFu & Li's F* combines information from both external mutations and\npairwise diversity, providing a more powerful test than D*.\n\nF* > 0 suggests balancing selection or population contraction.\nF* < 0 suggests directional selection or population expansion.\nF* \u2248 0 is consistent with neutral equilibrium.\n\nArgs:\n    num_segregating_sites: Total number of segregating sites (S)\n    num_external_mutations: Number of external (singleton) mutations (\u03b7_e)\n    pairwise_diversity: Average pairwise nucleotide diversity (\u03c0)\n    sample_size: Number of sampled sequences (n)\n    \nReturns:\n    Fu & Li's F* statistic. Returns 0.0 if variance is zero or inputs invalid.\n    \nExamples:\n    >>> fu_and_li_f_star(num_segregating_sites=10, num_external_mutations=5, pairwise_diversity=5.0, sample_size=10)\n    -1.2...\n    \nReferences:\n    Fu, Y. X., & Li, W. H. (1993). Statistical tests of neutrality of mutations.\n    Genetics, 133(3), 693-709.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 278, "module": "src.metainformant.math.coalescent", "name": "fu_and_li_f_star", "signature": "(num_segregating_sites: int, num_external_mutations: int, pairwise_diversity: float, sample_size: int) -> float", "symbol_type": "function"}], "fu_and_li_f_star_from_sequences": [{"docstring": "Calculate Fu & Li's F* from sequences.\n\nWrapper function that computes F* from DNA sequences.\n\nArgs:\n    seqs: Sequence of DNA sequences (strings)\n\nReturns:\n    Fu & Li's F* statistic. Returns 0.0 if insufficient data.\n\nExamples:\n    >>> seqs = [\"AAAA\", \"AAAT\", \"AATT\"]\n    >>> f_star = fu_and_li_f_star_from_sequences(seqs)\n    >>> isinstance(f_star, float)\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population.py", "line_number": 361, "module": "src.metainformant.dna.population", "name": "fu_and_li_f_star_from_sequences", "signature": "(seqs: Sequence[str]) -> float", "symbol_type": "function"}], "full": [{"docstring": "Perform analysis with all enzymes of batch and return all results.\n\nFull Restriction Map of the sequence, as a dictionary.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2379, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "full", "signature": "(self, linear = True)", "symbol_type": "function"}], "full_load": [{"docstring": "Parse the first YAML document in a stream\nand produce the corresponding Python object.\n\nResolve all tags except those known to be\nunsafe on untrusted input.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 97, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "full_load", "signature": "(stream)", "symbol_type": "function"}, {"docstring": "Parse the first YAML document in a stream\nand produce the corresponding Python object.\n\nResolve all tags except those known to be\nunsafe on untrusted input.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 97, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "full_load", "signature": "(stream)", "symbol_type": "function"}], "full_load_all": [{"docstring": "Parse all YAML documents in a stream\nand produce corresponding Python objects.\n\nResolve all tags except those known to be\nunsafe on untrusted input.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 107, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "full_load_all", "signature": "(stream)", "symbol_type": "function"}, {"docstring": "Parse all YAML documents in a stream\nand produce corresponding Python objects.\n\nResolve all tags except those known to be\nunsafe on untrusted input.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 107, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "full_load_all", "signature": "(stream)", "symbol_type": "function"}], "full_translate": [{"docstring": "Apply full translation with gaps considered.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 226, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "full_translate", "signature": "(self, codon_table = None, stop_symbol = '*')", "symbol_type": "function"}], "fullcascade": [{"docstring": "Return a getter property with a cascading setter.\n\nThis is similar to ``optionalcascade``, but for SearchIO containers that have\nat least one item (HSP). The getter always retrieves the attribute\nvalue from the first item. If the items have more than one attribute values,\nan error will be raised. The setter behaves like ``partialcascade``, except\nthat it only sets attributes to items in the object, not the object itself.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 99, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "fullcascade", "signature": "(attr, doc = '')", "symbol_type": "function"}], "func": [{"docstring": "Temporary function, params = [t, k, w].", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/analysis.py", "line_number": 773, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.analysis", "name": "func", "signature": "(params, pi = pi, codon_cnt = codon_cnt, codons = codons, codon_table = codon_table)", "symbol_type": "function"}, {"docstring": "Temporary function, params = [t, k, w].", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 1088, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "func", "signature": "(params, pi = pi, codon_cnt = codon_cnt, codon_lst = codon_lst, codon_table = codon_table)", "symbol_type": "function"}], "func_w1": [{"docstring": "Temporary function, params = [t, k]. w is fixed to 1.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/analysis.py", "line_number": 818, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.analysis", "name": "func_w1", "signature": "(params, pi = pi, codon_cnt = codon_cnt, codons = codons, codon_table = codon_table)", "symbol_type": "function"}, {"docstring": "Temporary function, params = [t, k]. w is fixed to 1.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 1130, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "func_w1", "signature": "(params, pi = pi, codon_cnt = codon_cnt, codon_lst = codon_lst, codon_table = codon_table)", "symbol_type": "function"}], "function_with_previous": [{"docstring": "Decorate a function as having an attribute named 'previous'.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/_utils.py", "line_number": 28, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio._utils", "name": "function_with_previous", "signature": "(func: F) -> _FunctionWithPrevious[F]", "symbol_type": "function"}], "functional_diversity_metrics": [{"docstring": "Calculate functional diversity metrics.\n\nArgs:\n    abundances: Species abundance values\n    trait_matrix: Matrix of trait values (species x traits)\n\nReturns:\n    Dictionary with functional diversity metrics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/community.py", "line_number": 329, "module": "src.metainformant.ecology.community", "name": "functional_diversity_metrics", "signature": "(abundances: Sequence[float], trait_matrix: Sequence[Sequence[float]]) -> Dict[str, float]", "symbol_type": "function"}], "functional_enrichment_plot": [{"docstring": "Functional enrichment of significant variants.\n\nShows distribution of variants across functional categories\n(e.g., coding, UTR, intergenic, regulatory).\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    annotation_file: Path to variant annotations\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_effects.py", "line_number": 281, "module": "src.metainformant.gwas.visualization_effects", "name": "functional_enrichment_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "functional_enrichment_ppi": [{"docstring": "Analyze functional enrichment in protein-protein interaction network.\n\nExamines which functional categories (e.g., GO terms, pathways) are\noverrepresented in the PPI network compared to random expectation.\nIdentifies functional modules and enriched biological processes.\n\nArgs:\n    ppi_network: ProteinNetwork object containing protein interactions\n    functional_annotations: Dictionary mapping protein_id to list of\n        functional annotation strings (e.g., GO terms, pathway names).\n        Example: {\"P12345\": [\"GO:0008150\", \"GO:0003674\"], ...}\n    min_confidence: Minimum interaction confidence (0-1) for including\n        interactions in the network. Higher values focus on high-quality\n        interactions. Default 0.5.\n        \nReturns:\n    Dictionary containing functional enrichment results:\n    - network_size: Number of proteins in filtered network\n    - total_functions: Number of unique functional annotations\n    - enriched_functions: List of overrepresented functions with statistics\n    - function_counts: Dictionary mapping function -> count in network\n    - expected_counts: Dictionary mapping function -> expected count\n    - enrichment_ratios: Dictionary mapping function -> enrichment ratio\n    \nExamples:\n    >>> annotations = {\n    ...     \"P1\": [\"GO:0008150\", \"GO:0003674\"],\n    ...     \"P2\": [\"GO:0008150\"],\n    ...     \"P3\": [\"GO:0003674\"]\n    ... }\n    >>> results = functional_enrichment_ppi(ppi_network, annotations, min_confidence=0.7)\n    >>> results[\"enriched_functions\"][0][\"function\"]\n    'GO:0008150'\n    >>> results[\"enriched_functions\"][0][\"fold_enrichment\"] > 1.0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 643, "module": "src.metainformant.networks.ppi", "name": "functional_enrichment_ppi", "signature": "(ppi_network: ProteinNetwork = None, functional_annotations: Dict[str, List[str]] = None, min_confidence: float = 0.5, protein_list: List[str] = None, function_key: str = None) -> Dict[str, Any]", "symbol_type": "function"}], "fuzzy_find_symbol": [{"docstring": "Find symbols with fuzzy matching.\n\nArgs:\n    symbol_name: Name of symbol to find (fuzzy match)\n    symbol_type: Type of symbol ('function', 'class', or 'all')\n    repo_root: Root directory of repository\n    threshold: Similarity threshold (0.0 to 1.0)\n\nReturns:\n    List of tuples (symbol_name, similarity_score) sorted by similarity", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/symbols.py", "line_number": 483, "module": "src.metainformant.core.symbols", "name": "fuzzy_find_symbol", "signature": "(symbol_name: str, symbol_type: str = 'function', repo_root: str | Path | None = None, threshold: float = 0.6) -> list[tuple[str, float]]", "symbol_type": "function"}], "gafbyproteiniterator": [{"docstring": "Iterate over records in a gene association file.\n\nReturns a list of all consecutive records with the same DB_Object_ID\nThis function should be called to read a\ngene_association.goa_uniprot file. Reads the first record and\nreturns a gaf 2.0 or a gaf 1.0 iterator as needed\n2016-04-09: added GAF 2.1 iterator & fixed bug in iterator assignment\nIn the meantime GAF 2.1 uses the GAF 2.0 iterator", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/UniProt/GOA.py", "line_number": 367, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.UniProt.GOA", "name": "gafbyproteiniterator", "signature": "(handle)", "symbol_type": "function"}], "gafiterator": [{"docstring": "Iterate over a GAF 1.0 or 2.x file.\n\nThis function should be called to read a\ngene_association.goa_uniprot file. Reads the first record and\nreturns a gaf 2.x or a gaf 1.0 iterator as needed\n\nExample: open, read, interat and filter results.\n\nOriginal data file has been trimmed to ~600 rows.\n\nOriginal source ftp://ftp.ebi.ac.uk/pub/databases/GO/goa/YEAST/goa_yeast.gaf.gz\n\n>>> from Bio.UniProt.GOA import gafiterator, record_has\n>>> Evidence = {'Evidence': set(['ND'])}\n>>> Synonym = {'Synonym': set(['YA19A_YEAST', 'YAL019W-A'])}\n>>> Taxon_ID = {'Taxon_ID': set(['taxon:559292'])}\n>>> with open('UniProt/goa_yeast.gaf', 'r') as handle:\n...     for rec in gafiterator(handle):\n...         if record_has(rec, Taxon_ID) and record_has(rec, Evidence) and record_has(rec, Synonym):\n...             for key in ('DB_Object_Name', 'Evidence', 'Synonym', 'Taxon_ID'):\n...                 print(rec[key])\n...\nPutative uncharacterized protein YAL019W-A\nND\n['YA19A_YEAST', 'YAL019W-A']\n['taxon:559292']\nPutative uncharacterized protein YAL019W-A\nND\n['YA19A_YEAST', 'YAL019W-A']\n['taxon:559292']\nPutative uncharacterized protein YAL019W-A\nND\n['YA19A_YEAST', 'YAL019W-A']\n['taxon:559292']", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/UniProt/GOA.py", "line_number": 398, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.UniProt.GOA", "name": "gafiterator", "signature": "(handle)", "symbol_type": "function"}], "gaponly": [{"docstring": "Return gap-only sites.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 2068, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "gaponly", "signature": "(self, include_missing = False)", "symbol_type": "function"}], "gc_content": [{"docstring": "Compute GC fraction of a nucleotide sequence (A/C/G/T/N-insensitive).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/fastq.py", "line_number": 106, "module": "src.metainformant.dna.fastq", "name": "gc_content", "signature": "(seq: str) -> float", "symbol_type": "function"}, {"docstring": "Calculate GC content of a DNA sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 31, "module": "src.metainformant.dna.sequences", "name": "gc_content", "signature": "(seq: str) -> float", "symbol_type": "function"}, {"docstring": "Compute the fraction GC content.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 289, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "gc_content", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Compute the GC-ratio.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 513, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "gc_content", "signature": "(self)", "symbol_type": "function"}], "gc_content_distribution": [{"docstring": "Analyze GC content distribution.\n\nArgs:\n    reads: List of FASTQ records\n\nReturns:\n    Dictionary with GC content analysis", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/fastq.py", "line_number": 243, "module": "src.metainformant.quality.fastq", "name": "gc_content_distribution", "signature": "(reads: List[FastqRecord]) -> Dict[str, Any]", "symbol_type": "function"}], "gc_fraction": [{"docstring": "Calculate G+C percentage in seq (float between 0 and 1).\n\nCopes with mixed case sequences. Ambiguous Nucleotides in this context are\nthose different from ATCGSWU (S is G or C, and W is A or T).\n\nIf ambiguous equals \"remove\" (default), will only count GCS and will only\ninclude ACTGSWU when calculating the sequence length. Equivalent to removing\nall characters in the set BDHKMNRVXY before calculating the GC content, as\neach of these ambiguous nucleotides can either be in (A,T) or in (C,G).\n\nIf ambiguous equals \"ignore\", it will treat only unambiguous nucleotides (GCS)\nas counting towards the GC percentage, but will include all ambiguous and\nunambiguous nucleotides when calculating the sequence length.\n\nIf ambiguous equals \"weighted\", will use a \"mean\" value when counting the\nambiguous characters, for example, G and C will be counted as 1, N and X will\nbe counted as 0.5, D will be counted as 0.33 etc. See Bio.SeqUtils._gc_values\nfor a full list.\n\nWill raise a ValueError for any other value of the ambiguous parameter.\n\n\n>>> from Bio.SeqUtils import gc_fraction\n>>> seq = \"ACTG\"\n>>> print(f\"GC content of {seq} : {gc_fraction(seq):.2f}\")\nGC content of ACTG : 0.50\n\nExample with an RNA sequence:\n\n>>> seq = \"GGAUCUUCGGAUCU\"\n>>> print(f\"GC content of {seq} : {gc_fraction(seq):.2f}\")\nGC content of GGAUCUUCGGAUCU : 0.50\n\nS and W are ambiguous for the purposes of calculating the GC content.\n\n>>> seq = \"ACTGSSSS\"\n>>> gc = gc_fraction(seq, \"remove\")\n>>> print(f\"GC content of {seq} : {gc:.2f}\")\nGC content of ACTGSSSS : 0.75\n>>> gc = gc_fraction(seq, \"ignore\")\n>>> print(f\"GC content of {seq} : {gc:.2f}\")\nGC content of ACTGSSSS : 0.75\n>>> gc = gc_fraction(seq, \"weighted\")\n>>> print(f\"GC content with ambiguous counting: {gc:.2f}\")\nGC content with ambiguous counting: 0.75\n\nSome examples with ambiguous nucleotides.\n\n>>> seq = \"ACTGN\"\n>>> gc = gc_fraction(seq, \"ignore\")\n>>> print(f\"GC content of {seq} : {gc:.2f}\")\nGC content of ACTGN : 0.40\n>>> gc = gc_fraction(seq, \"weighted\")\n>>> print(f\"GC content with ambiguous counting: {gc:.2f}\")\nGC content with ambiguous counting: 0.50\n>>> gc = gc_fraction(seq, \"remove\")\n>>> print(f\"GC content with ambiguous removing: {gc:.2f}\")\nGC content with ambiguous removing: 0.50\n\nAmbiguous nucleotides are also removed from the length of the sequence.\n\n>>> seq = \"GDVV\"\n>>> gc = gc_fraction(seq, \"ignore\")\n>>> print(f\"GC content of {seq} : {gc:.2f}\")\nGC content of GDVV : 0.25\n>>> gc = gc_fraction(seq, \"weighted\")\n>>> print(f\"GC content with ambiguous counting: {gc:.4f}\")\nGC content with ambiguous counting: 0.6667\n>>> gc = gc_fraction(seq, \"remove\")\n>>> print(f\"GC content with ambiguous removing: {gc:.2f}\")\nGC content with ambiguous removing: 1.00\n\n\nNote that this will return zero for an empty sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/__init__.py", "line_number": 53, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.__init__", "name": "gc_fraction", "signature": "(seq, ambiguous = 'remove')", "symbol_type": "function"}], "gc_skew": [{"docstring": "(G - C) / (G + C); returns 0.0 when there is no G/C content or empty input.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/composition.py", "line_number": 6, "module": "src.metainformant.dna.composition", "name": "gc_skew", "signature": "(seq: str) -> float", "symbol_type": "function"}], "gcg": [{"docstring": "Return the GCG checksum (int) for a sequence (string or Seq object).\n\nGiven a nucleotide or amino-acid sequence (or any string),\nreturns the GCG checksum (int). Checksum used by GCG program.\nseq type = str.\n\nBased on BioPerl GCG_checksum. Adapted by Sebastian Bassi\nwith the help of John Lenton, Pablo Ziliani, and Gabriel Genellina.\n\nAll sequences are converted to uppercase.\n\n>>> gcg(\"ACGTACGTACGT\")\n5688\n>>> gcg(\"acgtACGTacgt\")\n5688", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/CheckSum.py", "line_number": 81, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.CheckSum", "name": "gcg", "signature": "(seq)", "symbol_type": "function"}], "gen_key": [{"docstring": "Generate string of ':'-joined AtomKey strings from input.\n\nGenerate '2_A_C:3_P_N:3_P_CA' from (2_A_C, 3_P_N, 3_P_CA)\n:param list lst: list of AtomKey objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 3936, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "gen_key", "signature": "(lst: list['AtomKey']) -> str", "symbol_type": "function"}], "gen_tuple": [{"docstring": "Generate AtomKey tuple for ':'-joined AtomKey string.\n\nGenerate (2_A_C, 3_P_N, 3_P_CA) from '2_A_C:3_P_N:3_P_CA'\n:param str akstr: string of ':'-separated AtomKey strings", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 3948, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "gen_tuple", "signature": "(akstr: str) -> tuple", "symbol_type": "function"}], "gene_annotation_plot": [{"docstring": "Variants overlaid with gene annotations.\n\nShows association signal with gene structures (exons, introns).\nHelps identify variants in regulatory or coding regions.\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    gff_path: Path to GFF3 annotation file\n    chrom: Chromosome\n    start: Region start\n    end: Region end\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_regional.py", "line_number": 181, "module": "src.metainformant.gwas.visualization_regional", "name": "gene_annotation_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "gene_download_summary_by_accession": [{"docstring": "Get gene download summary by RefSeq Accession  # noqa: E501\n\nGet gene download summary by RefSeq Accession in a JSON output format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.gene_download_summary_by_accession(accessions, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    accessions ([str]): RNA or Protein accessions.\n\nKeyword Args:\n    fasta_filter ([str]): Limit the FASTA sequences in the datasets package to these transcript and protein accessions. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1DownloadSummary\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 1079, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "gene_download_summary_by_accession", "signature": "(self, accessions, **kwargs)", "symbol_type": "function"}], "gene_download_summary_by_id": [{"docstring": "Get gene download summary by GeneID  # noqa: E501\n\nGet a download summary by GeneID in a JSON output format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.gene_download_summary_by_id(gene_ids, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    gene_ids ([int]): NCBI gene ids\n\nKeyword Args:\n    fasta_filter ([str]): Limit the FASTA sequences in the datasets package to these transcript and protein accessions. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1DownloadSummary\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 1155, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "gene_download_summary_by_id", "signature": "(self, gene_ids, **kwargs)", "symbol_type": "function"}], "gene_download_summary_by_post": [{"docstring": "Get gene download summary  # noqa: E501\n\nGet gene download summary in a JSON output format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.gene_download_summary_by_post(v1_gene_dataset_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_gene_dataset_request (V1GeneDatasetRequest):\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1DownloadSummary\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 1231, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "gene_download_summary_by_post", "signature": "(self, v1_gene_dataset_request, **kwargs)", "symbol_type": "function"}], "gene_download_summary_by_tax_and_symbol": [{"docstring": "Get gene download summary by gene symbol  # noqa: E501\n\nGet gene download summary by gene symbol in a JSON output format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.gene_download_summary_by_tax_and_symbol(symbols, taxon, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    symbols ([str]): Gene symbol\n    taxon (str): Taxon for provided gene symbol\n\nKeyword Args:\n    fasta_filter ([str]): Limit the FASTA sequences in the datasets package to these transcript and protein accessions. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1DownloadSummary\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 1306, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "gene_download_summary_by_tax_and_symbol", "signature": "(self, symbols, taxon, **kwargs)", "symbol_type": "function"}], "gene_expression_plot": [{"docstring": "Plot expression levels for a single gene across samples.\n\nArgs:\n    gene_name: Name of the gene to plot\n    expression_data: DataFrame with genes as rows and samples as columns\n    sample_groups: Optional group labels for samples\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments for plotting\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import gene_expression_plot\n    >>> import pandas as pd\n    >>> data = pd.DataFrame({\n    ...     'sample1': [10, 20, 30],\n    ...     'sample2': [15, 25, 35]\n    ... }, index=['gene1', 'gene2', 'gene3'])\n    >>> ax = gene_expression_plot('gene1', data)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/expression.py", "line_number": 131, "module": "src.metainformant.visualization.expression", "name": "gene_expression_plot", "signature": "(gene_name: str, expression_data: pd.DataFrame, sample_groups: Sequence[str] | None = None, **kwargs) -> plt.Axes", "symbol_type": "function"}], "gene_metadata_by_accession": [{"docstring": "Get gene metadata by RefSeq Accession  # noqa: E501\n\nGet detailed gene metadata by RefSeq Accession in a JSON output format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.gene_metadata_by_accession(accessions, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    accessions ([str]): RNA or Protein accessions.\n\nKeyword Args:\n    returned_content (V1GeneDatasetRequestContentType): Return either gene-ids, or entire gene metadata. [optional]\n    sort_schema_field (V1GeneDatasetRequestSortField): Select a field to sort on.. [optional]\n    sort_schema_direction (V1SortDirection): Select a direction for the sort.. [optional]\n    limit (str): Limit the number of returned results (\"all\", \"none\", otherwise an integer value). [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1GeneMetadata\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 1386, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "gene_metadata_by_accession", "signature": "(self, accessions, **kwargs)", "symbol_type": "function"}], "gene_metadata_by_id": [{"docstring": "Get gene metadata by GeneID  # noqa: E501\n\nGet detailed gene metadata by GeneID in a JSON output format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.gene_metadata_by_id(gene_ids, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    gene_ids ([int]): NCBI gene ids\n\nKeyword Args:\n    returned_content (V1GeneDatasetRequestContentType): Return either gene-ids, or entire gene metadata. [optional]\n    sort_schema_field (V1GeneDatasetRequestSortField): Select a field to sort on.. [optional]\n    sort_schema_direction (V1SortDirection): Select a direction for the sort.. [optional]\n    limit (str): Limit the number of returned results (\"all\", \"none\", otherwise an integer value). [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1GeneMetadata\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 1465, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "gene_metadata_by_id", "signature": "(self, gene_ids, **kwargs)", "symbol_type": "function"}], "gene_metadata_by_post": [{"docstring": "Get gene metadata as JSON  # noqa: E501\n\nGet detailed gene metadata in a JSON output format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.gene_metadata_by_post(v1_gene_dataset_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_gene_dataset_request (V1GeneDatasetRequest):\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1GeneMetadata\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 1544, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "gene_metadata_by_post", "signature": "(self, v1_gene_dataset_request, **kwargs)", "symbol_type": "function"}], "gene_metadata_by_tax_and_symbol": [{"docstring": "Get gene metadata by gene symbol  # noqa: E501\n\nGet detailed gene metadata by gene symbol in a JSON output format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.gene_metadata_by_tax_and_symbol(symbols, taxon, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    symbols ([str]): Gene symbol\n    taxon (str): Taxon for provided gene symbol\n\nKeyword Args:\n    accessions ([str]): RNA or Protein accessions.. [optional]\n    returned_content (V1GeneDatasetRequestContentType): Return either gene-ids, or entire gene metadata. [optional]\n    sort_schema_field (V1GeneDatasetRequestSortField): Select a field to sort on.. [optional]\n    sort_schema_direction (V1SortDirection): Select a direction for the sort.. [optional]\n    limit (str): Limit the number of returned results (\"all\", \"none\", otherwise an integer value). [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1GeneMetadata\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 1619, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "gene_metadata_by_tax_and_symbol", "signature": "(self, symbols, taxon, **kwargs)", "symbol_type": "function"}], "gene_metadata_stream_by_post": [{"docstring": "Get gene metadata  # noqa: E501\n\nGet detailed gene metadata in a streaming, JSON-lines output format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.gene_metadata_stream_by_post(v1_gene_dataset_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_gene_dataset_request (V1GeneDatasetRequest):\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1GeneMatch\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 1703, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "gene_metadata_stream_by_post", "signature": "(self, v1_gene_dataset_request, **kwargs)", "symbol_type": "function"}], "gene_orthologs_by_id": [{"docstring": "Get gene orthologs by gene ID  # noqa: E501\n\nGet detailed gene metadata for an ortholog set by gene ID in a JSON output format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.gene_orthologs_by_id(gene_id, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    gene_id (int):\n\nKeyword Args:\n    returned_content (V1OrthologRequestContentType): Return either gene-ids, or entire gene metadata. [optional]\n    taxon_filter ([str]): Filter genes by taxa. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1OrthologSet\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 1778, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "gene_orthologs_by_id", "signature": "(self, gene_id, **kwargs)", "symbol_type": "function"}], "gene_tax_name_query": [{"docstring": "Get a list of taxonomy names and IDs found in the gene dataset given a partial taxonomic name  # noqa: E501\n\nThis endpoint retrieves a list of taxonomy names and IDs found in the gene dataset given a partial taxonomic name of any rank.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.gene_tax_name_query(taxon_query, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    taxon_query (str): NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank\n\nKeyword Args:\n    tax_rank_filter (V1OrganismQueryRequestTaxRankFilter): Set the scope of searched tax ranks. [optional]\n    tax_resource_filter (V1OrganismQueryRequestTaxonResourceFilter): [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1SciNameAndIds\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 1855, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "gene_tax_name_query", "signature": "(self, taxon_query, **kwargs)", "symbol_type": "function"}], "gene_tax_tree": [{"docstring": "Get a taxonomic subtree by taxonomic identifier  # noqa: E501\n\nUsing an NCBI Taxonomy ID or name (common or scientific) at any rank, get a subtree filtered for species with assembled genomes.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.gene_tax_tree(taxon, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    taxon (str): NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank\n\nKeyword Args:\n    children_only (bool): Only report the children of the requested taxon and not their descendants. [optional] if omitted the server will use the default value of False\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1Organism\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/gene_api.py", "line_number": 1932, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.gene_api", "name": "gene_tax_tree", "signature": "(self, taxon, **kwargs)", "symbol_type": "function"}], "gene_values_by_fields": [{"docstring": "Filters gene descriptor for provided `fields`\n\nArgs:\n    gene_descriptor: A single gene metadata record returned by the API\n    fields: List of fields to allow into returned dict\n\nReturns:\n    dict of supplied fields to their values\n\nSide Effects:\n    Prints report to stdout.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/metadata/gene.py", "line_number": 27, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.metadata.gene", "name": "gene_values_by_fields", "signature": "(gene_descriptor: V1GeneDescriptor, fields = List[str])", "symbol_type": "function"}], "generate": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1525, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "generate", "signature": "(cls, chromUsageList, alignments)", "symbol_type": "function"}], "generate_all_plots": [{"docstring": "Generate all available GWAS visualization plots.\n\nCreates a set of plots from GWAS results including:\n- Genome-wide views (Manhattan, circular, ideogram)\n- Statistical diagnostics (QQ, lambda GC, volcano)\n- Population structure (PCA, kinship)\n- Variant properties (MAF, density, Ts/Tv)\n- Effect sizes (forest plot, direction)\n\nArgs:\n    association_results: Path to association results TSV\n    output_dir: Directory for output plots\n    pca_file: Path to PCA components file\n    kinship_file: Path to kinship matrix file\n    vcf_file: Path to VCF file (for variant-level plots)\n    significance_threshold: P-value threshold for significance\n\nReturns:\n    Dictionary with plot generation results and paths", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_suite.py", "line_number": 18, "module": "src.metainformant.gwas.visualization_suite", "name": "generate_all_plots", "signature": "(association_results: Path, output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "generate_anchor": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/serializer.py", "line_number": 74, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.serializer", "name": "generate_anchor", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/serializer.py", "line_number": 74, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.serializer", "name": "generate_anchor", "signature": "(self, node)", "symbol_type": "function"}], "generate_cohort_sequences": [{"docstring": "Generate population-level event sequences with cohort-specific patterns.\n\nCreates multiple cohorts (e.g., different age groups, socioeconomic groups)\nwith distinct event patterns, allowing for population-level analysis.\n\nArgs:\n    n_cohorts: Number of distinct cohorts\n    n_sequences_per_cohort: Number of sequences per cohort\n    cohort_differences: Dictionary specifying cohort-specific patterns\n        Format: {\"cohort_name\": {\"domain\": probability, \"event_type\": probability}}\n    min_events_per_sequence: Minimum events per sequence\n    max_events_per_sequence: Maximum events per sequence\n    start_date: Start date (defaults to 10 years ago)\n    end_date: End date (defaults to today)\n    random_state: Random seed for reproducibility\n    \nReturns:\n    Dictionary mapping cohort names to lists of EventSequence objects\n    \nExamples:\n    >>> cohorts = generate_cohort_sequences(\n    ...     n_cohorts=2,\n    ...     n_sequences_per_cohort=20,\n    ...     cohort_differences={\n    ...         \"young\": {\"education\": 0.4, \"occupation\": 0.3},\n    ...         \"old\": {\"health\": 0.4, \"retirement\": 0.3}\n    ...     },\n    ...     random_state=42\n    ... )\n    >>> len(cohorts)\n    2", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/utils.py", "line_number": 821, "module": "src.metainformant.life_events.utils", "name": "generate_cohort_sequences", "signature": "(n_cohorts: int = 3, n_sequences_per_cohort: int = 50, cohort_differences: Optional[Dict[str, Dict[str, float]]] = None, min_events_per_sequence: int = 5, max_events_per_sequence: int = 30, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None, random_state: Optional[int] = None) -> Dict[str, List[EventSequence]]", "symbol_type": "function"}], "generate_comprehensive_dataset": [{"docstring": "Generate comprehensive synthetic population genetics dataset.\n\nArgs:\n    output_dir: Output directory for generated data\n    seed: Random seed for reproducibility\n    n_sequences_per_scenario: Number of sequences per scenario\n    sequence_length: Length of sequences\n\nReturns:\n    Dictionary with dataset metadata and file paths", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/popgen/analysis.py", "line_number": 91, "module": "scripts.popgen.analysis", "name": "generate_comprehensive_dataset", "signature": "(output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "generate_config_yaml": [{"docstring": "Generate amalgkit YAML configuration for a species.\n\nArgs:\n    species_name: Scientific name\n    species_data: RNA-seq metadata\n    genome_info: Genome assembly metadata (optional)\n    repo_root: Repository root directory for paths (optional)\n\nReturns:\n    YAML configuration string", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/discovery.py", "line_number": 284, "module": "src.metainformant.rna.discovery", "name": "generate_config_yaml", "signature": "(species_name: str, species_data: dict[str, Any], genome_info: dict[str, Any] | None = None) -> str", "symbol_type": "function"}], "generate_contamination_report": [{"docstring": "Generate a comprehensive contamination analysis report.\n\nArgs:\n    contamination_results: Results from various contamination detection methods\n    sample_metadata: Optional metadata about samples\n\nReturns:\n    Formatted contamination report", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/contamination.py", "line_number": 232, "module": "src.metainformant.quality.contamination", "name": "generate_contamination_report", "signature": "(contamination_results: Dict[str, Dict[str, List[str]]], sample_metadata: Dict[str, str] | None = None) -> str", "symbol_type": "function"}], "generate_csca_input_symlinks": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/csca.py", "line_number": 24, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.csca", "name": "generate_csca_input_symlinks", "signature": "(dir_csca_input_table, dir_curate, spp)", "symbol_type": "function"}], "generate_dashboard": [{"docstring": "Generate ASCII dashboard visualization with enhanced statistics.\n\nReturns:\n    Dashboard text as string", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/progress_tracker.py", "line_number": 279, "module": "src.metainformant.rna.progress_tracker", "name": "generate_dashboard", "signature": "(self) -> str", "symbol_type": "function"}], "generate_event_chain": [{"docstring": "Generate causally linked event sequence based on transition probabilities.\n\nCreates a chain of events where each event's probability depends on the previous\nevent, implementing a Markov chain model for event sequences.\n\nArgs:\n    chain_rules: Dictionary mapping \"domain:event_type\" to next event probabilities\n        Format: {\"domain:event_type\": {\"next_domain:next_event\": probability}}\n    start_event: Starting event type\n    start_domain: Starting domain\n    n_events: Number of events to generate\n    start_timestamp: Starting timestamp\n    time_span: Time span for events (in seconds)\n    event_types_by_domain: Dictionary mapping domains to available event types\n    random_state: Random seed for reproducibility\n    \nReturns:\n    List of causally linked Event objects\n    \nExamples:\n    >>> chain_rules = {\n    ...     \"education:degree\": {\"occupation:job_change\": 0.8, \"income:raise\": 0.2},\n    ...     \"occupation:job_change\": {\"address:move\": 0.5, \"income:raise\": 0.5}\n    ... }\n    >>> events = generate_event_chain(\n    ...     chain_rules, \"degree\", \"education\", 5,\n    ...     datetime(2010, 1, 1).timestamp(), 365*5*86400,\n    ...     {\"education\": [\"degree\"], \"occupation\": [\"job_change\"]},\n    ...     random_state=42\n    ... )\n    >>> len(events)\n    5", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/utils.py", "line_number": 368, "module": "src.metainformant.life_events.utils", "name": "generate_event_chain", "signature": "(chain_rules: Dict[str, Dict[str, float]], start_event: str, start_domain: str, n_events: int, start_timestamp: float, time_span: float, event_types_by_domain: Dict[str, List[str]], random_state: Optional[int] = None) -> List[Event]", "symbol_type": "function"}], "generate_genotype_matrix": [{"docstring": "Generate a genotype matrix with specified allele frequencies.\n\nCreates a genotype matrix where each individual is represented by a row\nand each site by a column. Genotypes can be generated under Hardy-Weinberg\nequilibrium or with specified allele frequencies.\n\nArgs:\n    n_individuals: Number of individuals (rows)\n    n_sites: Number of sites (columns)\n    allele_frequencies: Optional list of allele frequencies per site.\n        If provided, length must equal n_sites. If None, frequencies are\n        randomly sampled between min_maf and max_maf.\n    min_maf: Minimum minor allele frequency (if generating frequencies)\n    max_maf: Maximum minor allele frequency (if generating frequencies)\n    hwe: If True, genotypes follow Hardy-Weinberg equilibrium\n    ploidy: Ploidy level (2 for diploid, 1 for haploid)\n    rng: Random number generator\n\nReturns:\n    Genotype matrix as list of lists. For diploid: 0=AA, 1=AB, 2=BB.\n    For haploid: 0=reference, 1=alternate.\n\nExamples:\n    >>> genotypes = generate_genotype_matrix(\n    ...     n_individuals=10,\n    ...     n_sites=5,\n    ...     allele_frequencies=[0.2, 0.3, 0.4, 0.1, 0.5]\n    ... )\n    >>> len(genotypes)\n    10\n    >>> len(genotypes[0])\n    5", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/popgen.py", "line_number": 250, "module": "src.metainformant.simulation.popgen", "name": "generate_genotype_matrix", "signature": "(n_individuals: int, n_sites: int) -> list[list[int]]", "symbol_type": "function"}], "generate_linkage_disequilibrium_data": [{"docstring": "Generate genotype data with specified linkage disequilibrium.\n\nCreates genotypes with linkage disequilibrium (LD) between nearby sites.\nLD is controlled by recombination rate: lower recombination = higher LD.\n\nArgs:\n    n_individuals: Number of individuals\n    n_sites: Number of sites\n    r_squared_target: Target r\u00b2 value (LD measure)\n    recombination_rate: Recombination rate between sites (c)\n    allele_frequencies: Optional allele frequencies per site\n    rng: Random number generator\n\nReturns:\n    Genotype matrix with specified LD patterns\n\nExamples:\n    >>> genotypes = generate_linkage_disequilibrium_data(\n    ...     n_individuals=100,\n    ...     n_sites=10,\n    ...     r_squared_target=0.5,\n    ...     recombination_rate=0.01\n    ... )\n    >>> len(genotypes)\n    100", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/popgen.py", "line_number": 561, "module": "src.metainformant.simulation.popgen", "name": "generate_linkage_disequilibrium_data", "signature": "(n_individuals: int, n_sites: int) -> list[list[int]]", "symbol_type": "function"}], "generate_multisp_busco_table": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 569, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "generate_multisp_busco_table", "signature": "(dir_busco, outfile)", "symbol_type": "function"}], "generate_phenotypes": [{"docstring": "Generate realistic phenotype data.\n\nArgs:\n    n_samples: Number of samples\n    output_file: Output TSV file path\n    seed: Random seed", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/generate_phenotypes.py", "line_number": 14, "module": "scripts.gwas.generate_phenotypes", "name": "generate_phenotypes", "signature": "(n_samples: int = 150, output_file: Path = None, seed: int = 42)", "symbol_type": "function"}], "generate_population_sequences": [{"docstring": "Generate a population of sequences with specified diversity.\n\nGenerates sequences that approximate target nucleotide diversity (\u03c0) or\nWatterson's theta (\u03b8_W). Uses a coalescent-inspired approach to introduce\nmutations that create realistic polymorphism patterns.\n\nArgs:\n    n_sequences: Number of sequences to generate\n    sequence_length: Length of each sequence\n    nucleotide_diversity: Target \u03c0 (average pairwise differences per site).\n        If provided, mutations are introduced to approximate this value.\n    wattersons_theta: Target \u03b8_W (Watterson's estimator). Alternative to\n        nucleotide_diversity. If both provided, nucleotide_diversity takes precedence.\n    reference_sequence: Starting sequence. If None, generates random sequence.\n    mutation_rate: Per-site mutation rate (used if diversity targets not specified)\n    gc_content: GC content for reference sequence (if generating new one)\n    rng: Random number generator\n\nReturns:\n    List of sequences with specified diversity properties\n\nExamples:\n    >>> seqs = generate_population_sequences(\n    ...     n_sequences=10,\n    ...     sequence_length=1000,\n    ...     nucleotide_diversity=0.01\n    ... )\n    >>> len(seqs)\n    10\n    >>> len(seqs[0])\n    1000", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/popgen.py", "line_number": 22, "module": "src.metainformant.simulation.popgen", "name": "generate_population_sequences", "signature": "(n_sequences: int, sequence_length: int) -> list[str]", "symbol_type": "function"}], "generate_quality_report": [{"docstring": "Generate a comprehensive quality report from quality metrics.\n\nArgs:\n    quality_data: Dict containing quality metrics from various analyses\n    sample_name: Name of the sample being analyzed\n\nReturns:\n    Formatted quality report", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/metrics.py", "line_number": 247, "module": "src.metainformant.quality.metrics", "name": "generate_quality_report", "signature": "(quality_data: Dict[str, Dict[str, float]], sample_name: str = 'Unknown') -> str", "symbol_type": "function"}], "generate_random_dna": [{"docstring": "Generate random DNA sequence with specified GC content.\n\nArgs:\n    length: Length of sequence to generate\n    gc_content: Target GC content (0.0-1.0)\n    rng: Random number generator\n\nReturns:\n    Random DNA sequence string\n\nRaises:\n    ValidationError: If gc_content is not in [0, 1] or length is negative", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/sequences.py", "line_number": 15, "module": "src.metainformant.simulation.sequences", "name": "generate_random_dna", "signature": "(length: int) -> str", "symbol_type": "function"}], "generate_random_protein": [{"docstring": "Generate random protein sequence of specified length.\n\nArgs:\n    length: Desired sequence length\n    rng: Random number generator (default: random module)\n    \nReturns:\n    Random protein sequence using standard 20 amino acids\n    \nRaises:\n    ValidationError: If length is negative", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/sequences.py", "line_number": 105, "module": "src.metainformant.simulation.sequences", "name": "generate_random_protein", "signature": "(length: int) -> str", "symbol_type": "function"}], "generate_realistic_life_events": [{"docstring": "Generate highly realistic synthetic life event sequences with advanced patterns.\n\nCreates event sequences with:\n- Temporal dependencies (Markov chains)\n- Event co-occurrence patterns\n- Domain transition probabilities\n- Seasonal/cyclical patterns\n- Rare events\n- Configurable noise and missing data\n\nArgs:\n    n_sequences: Number of sequences to generate\n    min_events_per_sequence: Minimum events per sequence\n    max_events_per_sequence: Maximum events per sequence\n    start_date: Start date (defaults to 10 years ago)\n    end_date: End date (defaults to today)\n    domains: List of domains (defaults to standard domains)\n    event_types_by_domain: Event types per domain\n    transition_probabilities: Domain transition probabilities\n        Format: {\"domain1\": {\"domain2\": probability}}\n    cooccurrence_patterns: Events that tend to co-occur\n        Format: {\"event_type\": [\"co_occurring_event1\", \"co_occurring_event2\"]}\n    seasonal_patterns: Whether to apply seasonal variations\n    rare_event_probability: Probability of injecting rare events\n    generate_outcomes: Whether to generate outcome labels\n    outcome_relationship: Outcome generation pattern\n    temporal_noise: Level of temporal noise (0.0 to 1.0)\n    missing_data_probability: Probability of missing events\n    random_state: Random seed for reproducibility\n    \nReturns:\n    Tuple of (list of EventSequence objects, optional outcome array)\n    \nExamples:\n    >>> sequences, outcomes = generate_realistic_life_events(\n    ...     n_sequences=50,\n    ...     transition_probabilities={\"education\": {\"occupation\": 0.8}},\n    ...     seasonal_patterns=True,\n    ...     random_state=42\n    ... )\n    >>> len(sequences)\n    50", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/utils.py", "line_number": 543, "module": "src.metainformant.life_events.utils", "name": "generate_realistic_life_events", "signature": "(n_sequences: int = 100, min_events_per_sequence: int = 5, max_events_per_sequence: int = 30, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None, domains: Optional[List[str]] = None, event_types_by_domain: Optional[Dict[str, List[str]]] = None, transition_probabilities: Optional[Dict[str, Dict[str, float]]] = None, cooccurrence_patterns: Optional[Dict[str, List[str]]] = None, seasonal_patterns: bool = False, rare_event_probability: float = 0.05, generate_outcomes: bool = False, outcome_relationship: str = 'random', temporal_noise: float = 0.0, missing_data_probability: float = 0.0, random_state: Optional[int] = None) -> Tuple[List[EventSequence], Optional[np.ndarray]]", "symbol_type": "function"}], "generate_site_frequency_spectrum": [{"docstring": "Generate a site frequency spectrum with specified properties.\n\nCreates a site frequency spectrum (SFS) under the standard neutral model\nor with specified theta. The SFS describes the distribution of allele\nfrequencies across polymorphic sites.\n\nArgs:\n    sample_size: Number of sampled sequences (n)\n    n_sites: Number of polymorphic sites to generate\n    theta: Population mutation parameter \u03b8 = 4Ne\u03bc (for diploid)\n    folded: If True, return folded SFS (minor allele frequencies only)\n    rng: Random number generator\n\nReturns:\n    List of counts per frequency bin. For folded SFS, length is n//2.\n    For unfolded SFS, length is n-1.\n\nExamples:\n    >>> sfs = generate_site_frequency_spectrum(\n    ...     sample_size=10,\n    ...     n_sites=100,\n    ...     theta=0.01\n    ... )\n    >>> len(sfs)\n    5  # Folded SFS for n=10\n    >>> sum(sfs)\n    100  # Total polymorphic sites", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/popgen.py", "line_number": 487, "module": "src.metainformant.simulation.popgen", "name": "generate_site_frequency_spectrum", "signature": "(sample_size: int, n_sites: int) -> list[int]", "symbol_type": "function"}], "generate_summaries": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1543, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "generate_summaries", "signature": "(self, scale, totalSum)", "symbol_type": "function"}], "generate_summary_report": [{"docstring": "Generate human-readable summary report.\n\nArgs:\n    dataset_info: Dataset metadata\n    analysis_results: Analysis results\n    output_dir: Output directory", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/popgen/analysis.py", "line_number": 838, "module": "scripts.popgen.analysis", "name": "generate_summary_report", "signature": "(dataset_info: dict[str, Any], analysis_results: dict[str, Any], output_dir: Path) -> None", "symbol_type": "function"}], "generate_synthetic_data": [{"docstring": "Generate synthetic life event sequences.\n\nArgs:\n    n_sequences: Number of sequences to generate\n    min_events: Minimum events per sequence\n    max_events: Maximum events per sequence\n    generate_outcomes: Whether to generate outcomes\n    outcome_relationship: Outcome relationship pattern\n    random_state: Random seed\n    \nReturns:\n    Tuple of (sequences, outcomes)", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/run_life_events_analysis.py", "line_number": 145, "module": "scripts.life_events.run_life_events_analysis", "name": "generate_synthetic_data", "signature": "(n_sequences: int, min_events: int, max_events: int, generate_outcomes: bool, outcome_relationship: str, random_state: int = 42) -> tuple[list, Optional[Any]]", "symbol_type": "function"}], "generate_synthetic_life_events": [{"docstring": "Generate synthetic life event sequences for testing and demos.\n\nCreates realistic event sequences with temporal patterns, multiple domains,\nand optionally outcome labels that relate to event patterns.\n\nArgs:\n    n_sequences: Number of event sequences to generate\n    min_events_per_sequence: Minimum events per sequence\n    max_events_per_sequence: Maximum events per sequence\n    start_date: Start date for events (defaults to 10 years ago)\n    end_date: End date for events (defaults to today)\n    domains: List of domains to use (defaults to all standard domains)\n    event_types_by_domain: Dictionary mapping domains to event types\n        (defaults to realistic event types)\n    generate_outcomes: Whether to generate outcome labels\n    outcome_relationship: How outcomes relate to events:\n        - \"random\": Random binary outcomes\n        - \"health_focused\": Higher outcome for more health events\n        - \"education_focused\": Higher outcome for education events\n        - \"complex\": Complex pattern based on multiple domains\n    random_state: Random seed for reproducibility\n    \nReturns:\n    Tuple of (list of EventSequence objects, optional outcome array)\n    \nExamples:\n    >>> from datetime import datetime\n    >>> sequences, outcomes = generate_synthetic_life_events(\n    ...     n_sequences=10,\n    ...     random_state=42\n    ... )\n    >>> len(sequences)\n    10\n    >>> len(outcomes)\n    10", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/utils.py", "line_number": 195, "module": "src.metainformant.life_events.utils", "name": "generate_synthetic_life_events", "signature": "(n_sequences: int = 100, min_events_per_sequence: int = 5, max_events_per_sequence: int = 30, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None, domains: Optional[List[str]] = None, event_types_by_domain: Optional[dict[str, List[str]]] = None, generate_outcomes: bool = False, outcome_relationship: str = 'random', random_state: Optional[int] = None) -> tuple[List[EventSequence], Optional[np.ndarray]]", "symbol_type": "function"}], "generate_synthetic_variants": [{"docstring": "Generate synthetic variant data.\n\nArgs:\n    genome_fasta: Path to reference genome FASTA\n    output_vcf: Output VCF file path\n    n_samples: Number of samples to generate\n    n_variants: Number of variants to generate\n    seed: Random seed for reproducibility", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/generate_synthetic_variants.py", "line_number": 22, "module": "scripts.gwas.generate_synthetic_variants", "name": "generate_synthetic_variants", "signature": "(genome_fasta: Path, output_vcf: Path, n_samples: int = 100, n_variants: int = 10000, seed: int = 42)", "symbol_type": "function"}], "generate_two_populations": [{"docstring": "Generate two populations with specified Fst.\n\nCreates two populations that are differentiated by the specified Fst value.\nHigher Fst means more differentiation between populations.\n\nArgs:\n    n_pop1: Number of sequences in population 1\n    n_pop2: Number of sequences in population 2\n    sequence_length: Length of each sequence\n    fst: Target Fst value (0-1). Higher values = more differentiation\n    within_pop_diversity: Target nucleotide diversity within each population\n    reference_sequence: Starting sequence (ancestral)\n    gc_content: GC content for reference sequence\n    rng: Random number generator\n\nReturns:\n    Tuple of (pop1_sequences, pop2_sequences)\n    \nRaises:\n    ValidationError: If parameters are invalid\n\nExamples:\n    >>> pop1, pop2 = generate_two_populations(\n    ...     n_pop1=10,\n    ...     n_pop2=10,\n    ...     sequence_length=1000,\n    ...     fst=0.2\n    ... )\n    >>> len(pop1), len(pop2)\n    (10, 10)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/popgen.py", "line_number": 146, "module": "src.metainformant.simulation.popgen", "name": "generate_two_populations", "signature": "(n_pop1: int, n_pop2: int, sequence_length: int) -> tuple[list[str], list[str]]", "symbol_type": "function"}], "generate_visualization": [{"docstring": "Generate PNG visualization of workflow progress using the new visualization module.\n\nCreates a multi-panel bar chart visualization showing sample counts in each category\n(need_download, ongoing_download, failed_download, needs_quant, needs_delete, completed)\nfor each species, plus an overall summary panel.\n\nReturns:\n    Path to generated PNG file, or None if generation failed", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/progress_tracker.py", "line_number": 390, "module": "src.metainformant.rna.progress_tracker", "name": "generate_visualization", "signature": "(self) -> Path | None", "symbol_type": "function"}], "generate_visualizations": [{"docstring": "Generate all visualizations.\n\nArgs:\n    sequences: List of event sequences\n    results: Analysis results dictionary\n    output_dir: Output directory\n    all_viz: Whether to generate all visualization types", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/run_life_events_analysis.py", "line_number": 298, "module": "scripts.life_events.run_life_events_analysis", "name": "generate_visualizations", "signature": "(sequences: list, results: dict[str, Any], output_dir: Path, all_viz: bool = False) -> None", "symbol_type": "function"}, {"docstring": "Generate comprehensive visualizations for analysis results.\n\nArgs:\n    analysis_results: Analysis results dictionary\n    output_dir: Output directory for plots", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/popgen/analysis.py", "line_number": 620, "module": "scripts.popgen.analysis", "name": "generate_visualizations", "signature": "(analysis_results: dict[str, Any], output_dir: Path) -> None", "symbol_type": "function"}], "genes": [{"docstring": "Get all unique genes across all pathways.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 143, "module": "src.metainformant.networks.pathway", "name": "genes", "signature": "(self) -> Set[str]", "symbol_type": "function"}, {"docstring": "Get a list of entries of type gene.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 202, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "genes", "signature": "(self)", "symbol_type": "function"}], "genome_download_summary": [{"docstring": "Preview genome dataset download  # noqa: E501\n\nGet a download summary by accession in a JSON output format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.genome_download_summary(accessions, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    accessions ([str]): NCBI genome assembly accessions\n\nKeyword Args:\n    chromosomes ([str]): The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence.. [optional]\n    exclude_sequence (bool): Set to true to omit the genomic sequence.. [optional] if omitted the server will use the default value of False\n    include_annotation_type ([V1AnnotationForAssemblyType]): Select additional types of annotation to include in the data package.  If unset, no annotation is provided.. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1DownloadSummary\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/genome_api.py", "line_number": 1379, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.genome_api", "name": "genome_download_summary", "signature": "(self, accessions, **kwargs)", "symbol_type": "function"}], "genome_download_summary_by_post": [{"docstring": "Preview genome dataset download by POST  # noqa: E501\n\nThe 'GET' version of download summary is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.genome_download_summary_by_post(v1_assembly_dataset_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_assembly_dataset_request (V1AssemblyDatasetRequest):\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1DownloadSummary\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/genome_api.py", "line_number": 1457, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.genome_api", "name": "genome_download_summary_by_post", "signature": "(self, v1_assembly_dataset_request, **kwargs)", "symbol_type": "function"}], "genome_metadata_by_post": [{"docstring": "Get genome metadata by variety of identifiers  # noqa: E501\n\nGet detailed metadata for assembled genomes.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.genome_metadata_by_post(v1_assembly_metadata_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_assembly_metadata_request (V1AssemblyMetadataRequest):\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1AssemblyMetadata\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/genome_api.py", "line_number": 1532, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.genome_api", "name": "genome_metadata_by_post", "signature": "(self, v1_assembly_metadata_request, **kwargs)", "symbol_type": "function"}], "genome_wide_ld_heatmap": [{"docstring": "Genome-wide linkage disequilibrium heatmap (downsampled).\n\nShows LD patterns across genome by sampling variants.\nFull genome-wide LD computation is prohibitive for millions of SNPs.\n\nArgs:\n    vcf_path: Path to VCF file\n    output_path: Output path\n    sample_size: Number of variants to sample\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_genome.py", "line_number": 468, "module": "src.metainformant.gwas.visualization_genome", "name": "genome_wide_ld_heatmap", "signature": "(vcf_path: Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "genomic_control": [{"docstring": "Calculate genomic inflation factor (lambda_GC).\n\nArgs:\n    chi2_stats: Optional list of chi-square statistics\n    pvalues: Optional list of p-values (converted to chi-square if chi2_stats not provided)\n\nReturns:\n    Dictionary with:\n    - lambda_gc: Genomic inflation factor\n    - median_chi2: Median chi-square statistic\n    - median_chi2_expected: Expected median chi-square under null (\u2248 0.456)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/correction.py", "line_number": 126, "module": "src.metainformant.gwas.correction", "name": "genomic_control", "signature": "(chi2_stats: list[float] | None = None, pvalues: list[float] | None = None) -> dict[str, Any]", "symbol_type": "function"}], "get": [{"docstring": "Get item from cache.\n\nArgs:\n    key: Cache key\n    \nReturns:\n    Cached value or None if not found or expired", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/cache.py", "line_number": 185, "module": "src.metainformant.core.cache", "name": "get", "signature": "(self, key: str) -> Any | None", "symbol_type": "function"}, {"docstring": "returns the value of an attribute or some default value if the attribute was not set", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 456, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get", "signature": "(self, name, default = None)", "symbol_type": "function"}, {"docstring": "returns the value of an attribute or some default value if the attribute was not set", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 511, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get", "signature": "(self, name, default = None)", "symbol_type": "function"}, {"docstring": "returns the value of an attribute or some default value if the attribute was not set", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 634, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get", "signature": "(self, name, default = None)", "symbol_type": "function"}, {"docstring": "Return parsed object for this entry.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/File.py", "line_number": 133, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.File", "name": "get", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the value of the key if found; return value otherwise.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/substitution_matrices/__init__.py", "line_number": 261, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.substitution_matrices.__init__", "name": "get", "signature": "(self, key, value = None)", "symbol_type": "function"}, {"docstring": "Implement get for dictionary-like behaviour.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Data/CodonTable.py", "line_number": 406, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Data.CodonTable", "name": "get", "signature": "(self, codon, failobj = None)", "symbol_type": "function"}, {"docstring": "Check if enzyme is in batch and return it.\n\nIf add is True and enzyme is not in batch add enzyme to batch.\nIf add is False (which is the default) only return enzyme.\nIf enzyme is not a RestrictionType or can not be evaluated to\na RestrictionType, raise a ValueError.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2043, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "get", "signature": "(self, enzyme, add = False)", "symbol_type": "function"}, {"docstring": "Get offset and convert it from bytes to string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_index.py", "line_number": 33, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._index", "name": "get", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return SeqRecord.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/_index.py", "line_number": 50, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO._index", "name": "get", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the SeqRecord starting at the given offset.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/_index.py", "line_number": 148, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO._index", "name": "get", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the SeqRecord starting at the given offset.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/_index.py", "line_number": 167, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO._index", "name": "get", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the SeqRecord starting at the given offset.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/_index.py", "line_number": 481, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO._index", "name": "get", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 200, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "get", "signature": "(nucleotide)", "symbol_type": "function"}], "getAscendent": [{"docstring": "Return the ancenstor node of the given type, or None.\n\nNode type can be a two letter code or longer description,\ne.g. 'fa' or 'family'.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 642, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getAscendent", "signature": "(self, node_type)", "symbol_type": "function"}], "getAscendentFromSQL": [{"docstring": "Get ascendents using SQL backend.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 393, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getAscendentFromSQL", "signature": "(self, node, type)", "symbol_type": "function"}], "getAstralDomainsFromFile": [{"docstring": "Get the scop domains from a file containing a list of sids.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 816, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getAstralDomainsFromFile", "signature": "(self, filename = None, file_handle = None)", "symbol_type": "function"}], "getAstralDomainsFromSQL": [{"docstring": "Load ASTRAL domains from the MySQL database.\n\nLoad a set of astral domains from a column in the astral table of a MYSQL\ndatabase (which can be created with writeToSQL(...).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 836, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getAstralDomainsFromSQL", "signature": "(self, column)", "symbol_type": "function"}], "getAtoms": [{"docstring": "Extract all relevant ATOM and HETATOM records from a PDB file.\n\nThe PDB file is scanned for ATOM and HETATOM records. If the\nchain ID, residue ID (seqNum and iCode), and residue type match\na residue in this sequence map, then the record is echoed to the\noutput handle.\n\nThis is typically used to find the coordinates of a domain, or other\nresidue subset.\n\nArguments:\n - pdb_handle -- A handle to the relevant PDB file.\n - out_handle -- All output is written to this file like object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/Raf.py", "line_number": 237, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.Raf", "name": "getAtoms", "signature": "(self, pdb_handle, out_handle)", "symbol_type": "function"}], "getChildren": [{"docstring": "Return a list of children of this Node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 605, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getChildren", "signature": "(self)", "symbol_type": "function"}], "getDescendents": [{"docstring": "Return a list of all descendant nodes of the given type.\n\nNode type can be a two letter code or longer description,\ne.g. 'fa' or 'family'.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 619, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getDescendents", "signature": "(self, node_type)", "symbol_type": "function"}], "getDescendentsFromSQL": [{"docstring": "Get descendents of a node using the database backend.\n\nThis avoids repeated iteration of SQL calls and is therefore much\nquicker than repeatedly calling node.getChildren().", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 408, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getDescendentsFromSQL", "signature": "(self, node, type)", "symbol_type": "function"}], "getDomainBySid": [{"docstring": "Return a domain from its sid.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 295, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getDomainBySid", "signature": "(self, sid)", "symbol_type": "function"}], "getDomainFromSQL": [{"docstring": "Load a node from the SQL backend using sunid or sid.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 343, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getDomainFromSQL", "signature": "(self, sunid = None, sid = None)", "symbol_type": "function"}], "getDomains": [{"docstring": "Return an ordered tuple of all SCOP Domains.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 317, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getDomains", "signature": "(self)", "symbol_type": "function"}], "getNodeBySunid": [{"docstring": "Return a node from its sunid.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 306, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getNodeBySunid", "signature": "(self, sunid)", "symbol_type": "function"}], "getParent": [{"docstring": "Return the parent of this Node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 612, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getParent", "signature": "(self)", "symbol_type": "function"}], "getRoot": [{"docstring": "Get root node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 291, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getRoot", "signature": "(self)", "symbol_type": "function"}], "getSeq": [{"docstring": "Return seq associated with domain.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 858, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getSeq", "signature": "(self, domain)", "symbol_type": "function"}], "getSeqBySid": [{"docstring": "Get the seq record of a given domain from its sid.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 849, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "getSeqBySid", "signature": "(self, domain)", "symbol_type": "function"}], "getSeqMap": [{"docstring": "Get the sequence map for a collection of residues.\n\nArguments:\n - residues -- A Residues instance, or a string that can be\n   converted into a Residues instance.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/Raf.py", "line_number": 86, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.Raf", "name": "getSeqMap", "signature": "(self, residues)", "symbol_type": "function"}], "get_KGML": [{"docstring": "Return the pathway as a string in prettified KGML format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 77, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "get_KGML", "signature": "(self)", "symbol_type": "function"}], "get_Seq_by_acc": [{"docstring": "Get a DBSeqRecord object by accession number.\n\nExample: seq_rec = db.get_Seq_by_acc('X77802')\n\nThe name of this method is misleading since it returns a DBSeqRecord\nrather than a Seq object, and presumably was to mirror BioPerl.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 672, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "get_Seq_by_acc", "signature": "(self, name)", "symbol_type": "function"}], "get_Seq_by_id": [{"docstring": "Get a DBSeqRecord object by its name.\n\nExample: seq_rec = db.get_Seq_by_id('ROA1_HUMAN')\n\nThe name of this method is misleading since it returns a DBSeqRecord\nrather than a Seq object, and presumably was to mirror BioPerl.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 661, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "get_Seq_by_id", "signature": "(self, name)", "symbol_type": "function"}], "get_Seq_by_ver": [{"docstring": "Get a DBSeqRecord object by version number.\n\nExample: seq_rec = db.get_Seq_by_ver('X77802.1')\n\nThe name of this method is misleading since it returns a DBSeqRecord\nrather than a Seq object, and presumably was to mirror BioPerl.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 683, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "get_Seq_by_ver", "signature": "(self, name)", "symbol_type": "function"}], "get_Seqs_by_acc": [{"docstring": "Get a list of DBSeqRecord objects by accession number.\n\nExample: seq_recs = db.get_Seq_by_acc('X77802')\n\nThe name of this method is misleading since it returns a list of\nDBSeqRecord objects rather than a list of Seq objects, and presumably\nwas to mirror BioPerl.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 694, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "get_Seqs_by_acc", "signature": "(self, name)", "symbol_type": "function"}], "get_aa_from_codonre": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/__init__.py", "line_number": 512, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.__init__", "name": "get_aa_from_codonre", "signature": "(re_aa)", "symbol_type": "function"}], "get_accession_by_tax_id": [{"docstring": "Get genome assembly accessions for a given NCBI taxonomy ID.\n\nArgs:\n    tax_id: NCBI taxonomy ID (e.g., \"9606\" for Homo sapiens)\n    \nReturns:\n    List of assembly accessions for the taxon\n    \nRaises:\n    RuntimeError: If ncbi-datasets-pylib not installed or unavailable", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/ncbi.py", "line_number": 65, "module": "src.metainformant.dna.ncbi", "name": "get_accession_by_tax_id", "signature": "(tax_id: str) -> list[str]", "symbol_type": "function"}], "get_acgt": [{"docstring": "Get and return the motif's weights of A, C, G, T.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/xms.py", "line_number": 60, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.xms", "name": "get_acgt", "signature": "(self, node)", "symbol_type": "function"}], "get_alignment_length": [{"docstring": "Return the maximum length of the alignment.\n\nAll objects in the alignment should (hopefully) have the same\nlength. This function will go through and find this length\nby finding the maximum length of sequences in the alignment.\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqRecord import SeqRecord\n>>> from Bio.Align import MultipleSeqAlignment\n>>> a = SeqRecord(Seq(\"ACTGCTAGCTAG\"), id=\"Alpha\")\n>>> b = SeqRecord(Seq(\"ACT-CTAGCTAG\"), id=\"Beta\")\n>>> c = SeqRecord(Seq(\"ACTGCTAGATAG\"), id=\"Gamma\")\n>>> align = MultipleSeqAlignment([a, b, c])\n>>> align.get_alignment_length()\n12\n\nIf you want to know the number of sequences in the alignment,\nuse len(align) instead:\n\n>>> len(align)\n3", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 407, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "get_alignment_length", "signature": "(self)", "symbol_type": "function"}], "get_all_assemblies": [{"docstring": "Retrieve the list of PDB entries with an associated bio assembly.\n\nThe requested list will be cached to avoid multiple calls to the server.\n\n:param str file_format: A legacy parameter that is left to avoid breaking changes\n:return: the assemblies\n:rtype: list", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 463, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "get_all_assemblies", "signature": "(self, file_format: str = '') -> list[tuple[str, str]]", "symbol_type": "function"}], "get_all_entries": [{"docstring": "Retrieve the big file containing all the PDB entries and some annotation.\n\nReturns a list of PDB codes in the index file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 172, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "get_all_entries", "signature": "(self)", "symbol_type": "function"}], "get_all_obsolete": [{"docstring": "Return a list of all obsolete entries ever in the PDB.\n\nReturns a list of all obsolete pdb codes that have ever been\nin the PDB.\n\nGets and parses the file from the PDB server in the format\n(the first pdb_code column is the one used). The file looks\nlike this::\n\n     LIST OF OBSOLETE COORDINATE ENTRIES AND SUCCESSORS\n    OBSLTE    31-JUL-94 116L     216L\n    ...\n    OBSLTE    29-JAN-96 1HFT     2HFT\n    OBSLTE    21-SEP-06 1HFV     2J5X\n    OBSLTE    21-NOV-03 1HG6\n    OBSLTE    18-JUL-84 1HHB     2HHB 3HHB\n    OBSLTE    08-NOV-96 1HID     2HID\n    OBSLTE    01-APR-97 1HIU     2HIU\n    OBSLTE    14-JAN-04 1HKE     1UUZ\n    ...", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 186, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "get_all_obsolete", "signature": "(self)", "symbol_type": "function"}], "get_all_options": [{"docstring": "Return the values of all the options.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_paml.py", "line_number": 67, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._paml", "name": "get_all_options", "signature": "(self)", "symbol_type": "function"}], "get_all_species_state": [{"docstring": "Get current state for all species.\n\nReturns:\n    Dictionary mapping species to their state", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/progress_tracker.py", "line_number": 239, "module": "src.metainformant.rna.progress_tracker", "name": "get_all_species_state", "signature": "(self) -> dict[str, dict[str, Any]]", "symbol_type": "function"}], "get_allof_instances": [{"docstring": "Args:\n    self: the class we are handling\n    model_args (dict): var_name to var_value\n        used to make instances\n    constant_args (dict):\n        metadata arguments:\n        _check_type\n        _path_to_item\n        _spec_property_naming\n        _configuration\n        _visited_composed_classes\n\nReturns\n    composed_instances (list)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1758, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get_allof_instances", "signature": "(self, model_args, constant_args)", "symbol_type": "function"}], "get_aln_length": [{"docstring": "Get alignment length.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonalignment.py", "line_number": 137, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonalignment", "name": "get_aln_length", "signature": "(self)", "symbol_type": "function"}], "get_altloc": [{"docstring": "Return alternative location specifier.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 442, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_altloc", "signature": "(self) -> str", "symbol_type": "function"}], "get_amino_acids_percent": [{"docstring": "Included for backwards compatibility (DEPRECATED).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/ProtParam.py", "line_number": 104, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.ProtParam", "name": "get_amino_acids_percent", "signature": "(self)", "symbol_type": "function"}], "get_ancestors": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/semantic.py", "line_number": 140, "module": "src.metainformant.information.semantic", "name": "get_ancestors", "signature": "(term: str, anc_set: set[str]) -> None", "symbol_type": "function"}], "get_angle": [{"docstring": "Get dihedron or hedron angle for specified key.\n\nSee :meth:`.pick_angle` for key specifications.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 3694, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "get_angle", "signature": "(self, angle_key: EKT | str) -> float | None", "symbol_type": "function"}], "get_anisou": [{"docstring": "Return anisotropic B factor.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 394, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_anisou", "signature": "(self) -> np.ndarray | None", "symbol_type": "function"}], "get_anyof_instances": [{"docstring": "Args:\n    self: the class we are handling\n    model_args (dict): var_name to var_value\n        The input data, e.g. the payload that must match at least one\n        anyOf child schema in the OpenAPI document.\n    constant_args (dict): var_name to var_value\n        args that every model requires, including configuration, server\n        and path to item.\n\nReturns\n    anyof_instances (list)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1881, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get_anyof_instances", "signature": "(self, model_args, constant_args)", "symbol_type": "function"}], "get_api_key_with_prefix": [{"docstring": "Gets API key (with prefix if set).\n\n:param identifier: The identifier of apiKey.\n:param alias: The alternative identifier of apiKey.\n:return: The token for api key authentication.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 351, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "get_api_key_with_prefix", "signature": "(self, identifier, alias = None)", "symbol_type": "function"}], "get_area": [{"docstring": "Get the area under the curve.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/pm_fitting.py", "line_number": 149, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.pm_fitting", "name": "get_area", "signature": "(y, x)", "symbol_type": "function"}], "get_array": [{"docstring": "Return (a copy of) the array of coordinates.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 364, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "get_array", "signature": "(self)", "symbol_type": "function"}], "get_artemis_colorscheme": [{"docstring": "Return the Artemis color scheme as a dictionary.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Colors.py", "line_number": 157, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Colors", "name": "get_artemis_colorscheme", "signature": "(self)", "symbol_type": "function"}], "get_assembly_metadata_by_asm_accessions": [{"docstring": "Return iterable assembly metadata for a list of assembly accessions\n\nWarning/Error code will be printed if the supplied accessions are invalid.\n\nArgs:\n    genome_assembly_accessions: A list of NCBI assembly accessions\n\nReturns:\n    iterable assemblies\n\nSide Effects:\n    Prints error to stdout.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/metadata/genome.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.metadata.genome", "name": "get_assembly_metadata_by_asm_accessions", "signature": "(genome_assembly_accessions: List[str], **kwargs)", "symbol_type": "function"}], "get_assembly_metadata_by_bioproject_accessions": [{"docstring": "Return iterable assembly metadata for a list of BioProject accessions\n\nWarning/Error code will be printed if the supplied BioProject has no assembly.\n\nArgs:\n    bioproject_accessions: A list of NCBI bioproject accessions\n\nReturns:\n    iterable assemblies\n\nSide Effects:\n    Prints error to stdout.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/metadata/genome.py", "line_number": 114, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.metadata.genome", "name": "get_assembly_metadata_by_bioproject_accessions", "signature": "(bioproject_accessions: List[str], **kwargs)", "symbol_type": "function"}], "get_assembly_metadata_by_taxon": [{"docstring": "Return iterable assembly metadata for a taxon\n\nWarning/Error code will be printed if the supplied taxon has no assembly.\n\nArgs:\n    taxon\n\nReturns:\n    iterable assemblies\n\nSide Effects:\n    Prints error to stdout.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/metadata/genome.py", "line_number": 72, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.metadata.genome", "name": "get_assembly_metadata_by_taxon", "signature": "(taxon: Union[str, int], **kwargs)", "symbol_type": "function"}], "get_atoms": [{"docstring": "Return atoms from residues.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Chain.py", "line_number": 184, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Chain", "name": "get_atoms", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return atoms.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Model.py", "line_number": 55, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Model", "name": "get_atoms", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return atoms.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Residue.py", "line_number": 114, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Residue", "name": "get_atoms", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return atoms from residue.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Structure.py", "line_number": 44, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Structure", "name": "get_atoms", "signature": "(self)", "symbol_type": "function"}], "get_average_time": [{"docstring": "Get average execution time for a test.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 302, "module": "tests.conftest", "name": "get_average_time", "signature": "(self, test_name: str) -> float", "symbol_type": "function"}], "get_basic_auth_token": [{"docstring": "Gets HTTP basic authentication header (string).\n\n:return: The token for basic HTTP authentication.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 368, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "get_basic_auth_token", "signature": "(self)", "symbol_type": "function"}], "get_bfactor": [{"docstring": "Return B factor.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 430, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_bfactor", "signature": "(self) -> float | None", "symbol_type": "function"}], "get_ca_list": [{"docstring": "Get list of C-alpha atoms in the polypeptide.\n\n:return: the list of C-alpha atoms\n:rtype: [L{Atom}, L{Atom}, ...]", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Polypeptide.py", "line_number": 190, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Polypeptide", "name": "get_ca_list", "signature": "(self)", "symbol_type": "function"}], "get_cache_info": [{"docstring": "Get information about cache directory contents.\n\nArgs:\n    cache_dir: Path to cache directory\n\nReturns:\n    Dictionary with cache statistics including hit/miss ratios if available", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/cache.py", "line_number": 120, "module": "src.metainformant.core.cache", "name": "get_cache_info", "signature": "(cache_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "get_catalog": [{"docstring": "Return the datasets file catalog as a dictionary", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 138, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_catalog", "signature": "(self) -> Dict[str, Any]", "symbol_type": "function"}], "get_chains": [{"docstring": "Return chains.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Model.py", "line_number": 46, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Model", "name": "get_chains", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return chains from models.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Structure.py", "line_number": 34, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Structure", "name": "get_chains", "signature": "(self)", "symbol_type": "function"}], "get_charge": [{"docstring": "Return charge.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 450, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_charge", "signature": "(self) -> float | None", "symbol_type": "function"}], "get_codon": [{"docstring": "Get the index codon from the sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 96, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "get_codon", "signature": "(self, index)", "symbol_type": "function"}], "get_codon_num": [{"docstring": "Return the number of codons in the CodonSeq.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 127, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "get_codon_num", "signature": "(self)", "symbol_type": "function"}], "get_col_positions": [{"docstring": "Create a mapping of each clade to its column position.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 220, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "get_col_positions", "signature": "(tree)", "symbol_type": "function"}], "get_color_dict": [{"docstring": "Return a dictionary of colours using the provided values as keys.\n\nReturns a dictionary, keyed by the members of iterable l, with a\ncolour assigned to each member.\n\nArguments:\n - l - an iterable representing classes to be coloured\n - kwargs - pass-through arguments to the ColorSpiral object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/ColorSpiral.py", "line_number": 192, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.ColorSpiral", "name": "get_color_dict", "signature": "(l, **kwargs)", "symbol_type": "function"}], "get_color_palette": [{"docstring": "Get a color palette by name.\n\nArgs:\n    name: Palette name ('primary', 'accessible', 'colorblind', 'viridis_like')\n\nReturns:\n    List of color hex codes\n\nExample:\n    >>> from metainformant.visualization.style import get_color_palette\n    >>> colors = get_color_palette('colorblind')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/style.py", "line_number": 80, "module": "src.metainformant.visualization.style", "name": "get_color_palette", "signature": "(name: str = 'primary') -> list[str]", "symbol_type": "function"}], "get_colors": [{"docstring": "Return k colours selected by the ColorSpiral object, as a generator.\n\nArguments:\n - k - the number of colours to return\n - kwargs - pass-through arguments to the ColorSpiral object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/ColorSpiral.py", "line_number": 180, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.ColorSpiral", "name": "get_colors", "signature": "(k, **kwargs)", "symbol_type": "function"}, {"docstring": "Generate k different RBG colours evenly-space on the spiral.\n\nA generator returning the RGB colour space values for k\nevenly-spaced points along the defined spiral in HSV space.\n\nArguments:\n - k - the number of points to return\n - offset - how far along the spiral path to start.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/ColorSpiral.py", "line_number": 79, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.ColorSpiral", "name": "get_colors", "signature": "(self, k, offset = 0.1)", "symbol_type": "function"}], "get_colorscheme": [{"docstring": "Return the user-defined color scheme as a dictionary.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Colors.py", "line_number": 186, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Colors", "name": "get_colorscheme", "signature": "(self)", "symbol_type": "function"}], "get_column": [{"docstring": "Return column of alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/AlignInfo.py", "line_number": 52, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.AlignInfo", "name": "get_column", "signature": "(self, col)", "symbol_type": "function"}, {"docstring": "Get all the wells of a given column.\n\nA column is identified with a number (e.g. '6')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/phen_micro.py", "line_number": 476, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.phen_micro", "name": "get_column", "signature": "(self, column)", "symbol_type": "function"}], "get_config_schema": [{"docstring": "Extract schema/structure from config file.\n\nArgs:\n    config_path: Path to configuration file\n\nReturns:\n    Dictionary with schema information:\n    - top_level_keys: List of top-level keys\n    - nested_structure: Nested structure of config\n    - types: Inferred types for values", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 521, "module": "src.metainformant.core.config", "name": "get_config_schema", "signature": "(config_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "get_connected_components": [{"docstring": "Find all connected components in the network.\n\nUses breadth-first search to identify all connected components\nin an undirected network. For directed networks, finds weakly\nconnected components.\n\nArgs:\n    network: Input biological network\n    \nReturns:\n    List of sets, each containing node IDs in one component\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\", \"D\"])\n    >>> network.add_edge(\"A\", \"B\")\n    >>> network.add_edge(\"C\", \"D\")\n    >>> components = get_connected_components(network)\n    >>> len(components)\n    2", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 985, "module": "src.metainformant.networks.graph", "name": "get_connected_components", "signature": "(network: BiologicalNetwork) -> List[Set[str]]", "symbol_type": "function"}], "get_coord": [{"docstring": "Return atomic coordinates.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 426, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_coord", "signature": "(self) -> np.ndarray", "symbol_type": "function"}], "get_coords": [{"docstring": "Get the CA coordinates in the fragment.\n\n:return: the CA coords in the fragment\n:rtype: NumPy (Nx3) array", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/FragmentMapper.py", "line_number": 134, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.FragmentMapper", "name": "get_coords", "signature": "(self)", "symbol_type": "function"}], "get_count_files": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/cstmm.py", "line_number": 11, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.cstmm", "name": "get_count_files", "signature": "(dir_count)", "symbol_type": "function"}], "get_data": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 42, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "get_data", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 42, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "get_data", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return data as a list of sorted (position, value) tuples.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Graph.py", "line_number": 97, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Graph", "name": "get_data", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a node's data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 174, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "get_data", "signature": "(self)", "symbol_type": "function"}], "get_data_reports": [{"docstring": "Retrieve assembly reports\n\nReturns:\n  Yields a set of AssemblyDataReport protobuf objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 249, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_data_reports", "signature": "(self) -> Iterator[assembly_report_pb2.AssemblyDataReport]", "symbol_type": "function"}, {"docstring": "Retrieve a gene report object\n\nReturns:\n   Yields a set of GeneDescriptor protobuf objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 272, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_data_reports", "signature": "(self) -> Iterator[gene_report_pb2.GeneDescriptor]", "symbol_type": "function"}, {"docstring": "Retrieve virus assembly objects\n\nReturns:\n  Yields a set of virus assembly report protobuf objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 287, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_data_reports", "signature": "(self) -> Iterator[virus_report_pb2.VirusAssembly]", "symbol_type": "function"}, {"docstring": "Retrieve MicroBigge data report objects\n\nReturns:\n  Yields a set of MicroBigge report protobuf objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 302, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_data_reports", "signature": "(self) -> Iterator[microbigge_report_pb2.MicroBiggeReport]", "symbol_type": "function"}], "get_dataset_from_file": [{"docstring": "Create a Dataset-derived object of type 'dataset_type' and return it.\n\nReturns:\n    A subclass of the class 'Dataset' as specified by the caller.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 39, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_dataset_from_file", "signature": "(zip_file_or_directory: str, dataset_type: str) -> 'Dataset'", "symbol_type": "function"}], "get_db_client": [{"docstring": "Get PostgreSQL database client connection and cursor.\n\nLoads configuration from environment variables and establishes connection.\n\nReturns:\n    Tuple of (connection, cursor) objects\n    \nRaises:\n    RuntimeError: If PostgreSQL configuration not found in environment", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/db.py", "line_number": 13, "module": "src.metainformant.core.db", "name": "get_db_client", "signature": "() -> Tuple['psycopg2.extensions.connection', 'psycopg2.extensions.cursor']", "symbol_type": "function"}], "get_dbutils": [{"docstring": "Return the correct dbutils object for the database driver.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/DBUtils.py", "line_number": 148, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.DBUtils", "name": "get_dbutils", "signature": "(module_name)", "symbol_type": "function"}], "get_default_copy": [{"docstring": "Return new instance of configuration.\n\nThis method returns newly created, based on default constructor,\nobject of Configuration class or returns a copy of default\nconfiguration passed by the set_default method.\n\n:return: The configuration object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 253, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "get_default_copy", "signature": "(cls)", "symbol_type": "function"}], "get_directory_size": [{"docstring": "Get total size of all files in a directory.\n\nArgs:\n    path: Directory path\n\nReturns:\n    Total size in bytes", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 124, "module": "src.metainformant.core.paths", "name": "get_directory_size", "signature": "(path: str | Path) -> int", "symbol_type": "function"}], "get_discarded_args": [{"docstring": "Gathers the args that were discarded by configuration.discard_unknown_keys", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1924, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get_discarded_args", "signature": "(self, composed_instances, model_args)", "symbol_type": "function"}], "get_discriminated_classes": [{"docstring": "Returns all the classes that a discriminator converts to\nTODO: lru_cache this", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1125, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get_discriminated_classes", "signature": "(cls)", "symbol_type": "function"}], "get_discriminator_class": [{"docstring": "Returns the child class specified by the discriminator.\n\nArgs:\n    model_class (OpenApiModel): the model class.\n    discr_name (string): the name of the discriminator property.\n    discr_value (any): the discriminator value.\n    cls_visited (list): list of model classes that have been visited.\n        Used to determine the discriminator class without\n        visiting circular references indefinitely.\n\nReturns:\n    used_model_class (class/None): the chosen child class that will be used\n        to deserialize the data, for example dog.Dog.\n        If a class is not found, None is returned.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1285, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get_discriminator_class", "signature": "(model_class, discr_name, discr_value, cls_visited)", "symbol_type": "function"}], "get_disk_space_info": [{"docstring": "Get comprehensive disk space information.\n\nArgs:\n    path: Path to check\n    \nReturns:\n    Dictionary with disk space information", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/disk.py", "line_number": 116, "module": "src.metainformant.core.disk", "name": "get_disk_space_info", "signature": "(path: Path) -> dict[str, float | str]", "symbol_type": "function"}], "get_disk_usage": [{"docstring": "Get disk usage statistics for a path.\n\nArgs:\n    path: Path to check (can be file or directory)\n    \nReturns:\n    Tuple of (total_gb, used_gb, free_gb, percent_used_str)\n    Returns (0, 0, 0, \"0%\") if unable to determine", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/disk.py", "line_number": 11, "module": "src.metainformant.core.disk", "name": "get_disk_usage", "signature": "(path: Path) -> tuple[float, float, float, str]", "symbol_type": "function"}], "get_distance": [{"docstring": "Return a DistanceMatrix for an Alignment or MultipleSeqAlignment object.\n\n:Parameters:\n    msa : Alignment or MultipleSeqAlignment object representing a\n        DNA or protein multiple sequence alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/TreeConstruction.py", "line_number": 549, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.TreeConstruction", "name": "get_distance", "signature": "(self, msa)", "symbol_type": "function"}], "get_dn_ds_matrix": [{"docstring": "Available methods include NG86, LWL85, YN00 and ML.\n\nArgument:\n - method       - Available methods include NG86, LWL85, YN00 and ML.\n - codon_table  - Codon table to use for forward translation.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonalignment.py", "line_number": 151, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonalignment", "name": "get_dn_ds_matrix", "signature": "(self, method = 'NG86', codon_table = None)", "symbol_type": "function"}], "get_dn_ds_tree": [{"docstring": "Construct dn tree and ds tree.\n\nArgument:\n - dn_ds_method - Available methods include NG86, LWL85, YN00 and ML.\n - tree_method  - Available methods include UPGMA and NJ.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonalignment.py", "line_number": 187, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonalignment", "name": "get_dn_ds_tree", "signature": "(self, dn_ds_method = 'NG86', tree_method = 'UPGMA', codon_table = None)", "symbol_type": "function"}], "get_domains": [{"docstring": "Get unique domains in sequence.\n\nReturns:\n    List of unique domains", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 173, "module": "src.metainformant.life_events.events", "name": "get_domains", "signature": "(self) -> List[str]", "symbol_type": "function"}], "get_drawn_levels": [{"docstring": "Return a sorted list of levels occupied by tracks.\n\nThese tracks are not explicitly hidden.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Diagram.py", "line_number": 381, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Diagram", "name": "get_drawn_levels", "signature": "(self)", "symbol_type": "function"}], "get_edge_weight": [{"docstring": "Get weight of edge between two nodes.\n\nArgs:\n    node1: First node identifier\n    node2: Second node identifier\n    \nReturns:\n    Edge weight if edge exists, None otherwise. For undirected networks,\n    returns weight regardless of order (get_edge_weight(A, B) == get_edge_weight(B, A)).\n    \nExamples:\n    >>> network = BiologicalNetwork(directed=False)\n    >>> network.add_edge(\"A\", \"B\", weight=0.75)\n    >>> network.get_edge_weight(\"A\", \"B\")\n    0.75\n    >>> network.get_edge_weight(\"B\", \"A\")  # Undirected\n    0.75", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 143, "module": "src.metainformant.networks.graph", "name": "get_edge_weight", "signature": "(self, node1: str, node2: str) -> Optional[float]", "symbol_type": "function"}], "get_env_or_default": [{"docstring": "Get environment variable value or default.\n\nArgs:\n    env_var: Environment variable name\n    default: Default value if not set\n\nReturns:\n    Environment variable value or default", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 103, "module": "src.metainformant.core.config", "name": "get_env_or_default", "signature": "(env_var: str, default: str) -> str", "symbol_type": "function"}], "get_event": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 114, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "get_event", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 114, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "get_event", "signature": "(self)", "symbol_type": "function"}], "get_event_statistics": [{"docstring": "Compute comprehensive statistics about event sequences.\n\nArgs:\n    sequences: List of EventSequence objects\n    \nReturns:\n    Dictionary with statistics including counts, domains, event types, temporal patterns\n    \nExamples:\n    >>> sequences = [EventSequence(\"p1\", [Event(\"degree\", datetime(2010, 1, 1), \"education\")])]\n    >>> stats = get_event_statistics(sequences)\n    >>> \"total_events\" in stats\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/utils.py", "line_number": 135, "module": "src.metainformant.life_events.utils", "name": "get_event_statistics", "signature": "(sequences: List[EventSequence]) -> dict[str, Any]", "symbol_type": "function"}], "get_event_types": [{"docstring": "Get unique event types in sequence.\n\nReturns:\n    List of unique event types", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 165, "module": "src.metainformant.life_events.events", "name": "get_event_types", "signature": "(self) -> List[str]", "symbol_type": "function"}], "get_expected_index_path": [{"docstring": "Get expected kallisto index path for a species.\n\nArgs:\n    work_dir: Work directory for amalgkit workflow\n    species_name: Species name (with underscores)\n    \nReturns:\n    Expected path to kallisto index file", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/genome_prep.py", "line_number": 626, "module": "src.metainformant.rna.genome_prep", "name": "get_expected_index_path", "signature": "(work_dir: Path, species_name: str) -> Path", "symbol_type": "function"}], "get_fastq_stats": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/integrate.py", "line_number": 13, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.integrate", "name": "get_fastq_stats", "signature": "(args)", "symbol_type": "function"}], "get_feature": [{"docstring": "Return the unwrapped Bio.SeqFeature object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Feature.py", "line_number": 160, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Feature", "name": "get_feature", "signature": "(self)", "symbol_type": "function"}], "get_feature_importance": [{"docstring": "Get feature importance scores.\n\nReturns:\n    Array of feature importance scores, one per feature.\n    Importance scores are non-negative and indicate the relative\n    contribution of each feature to the classification.\n\nRaises:\n    ValueError: If classifier has not been fitted yet.\n\nExamples:\n    >>> clf = BiologicalClassifier(algorithm=\"random_forest\")\n    >>> clf.fit(X_train, y_train)\n    >>> importance = clf.get_feature_importance()\n    >>> top_features = np.argsort(importance)[-5:]", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/classification.py", "line_number": 73, "module": "src.metainformant.ml.classification", "name": "get_feature_importance", "signature": "(self) -> np.ndarray", "symbol_type": "function"}], "get_feature_sigil": [{"docstring": "Return graphics for feature, and any required label for it.\n\nArguments:\n - feature       Feature object\n - locstart      The start position of the feature\n - locend        The end position of the feature", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 304, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "get_feature_sigil", "signature": "(self, feature, locstart, locend, **kwargs)", "symbol_type": "function"}, {"docstring": "Get feature sigil.\n\nArguments:\n - feature       Feature object\n - x0            Start X coordinate on diagram\n - x1            End X coordinate on diagram\n - fragment      The fragment on which the feature appears\n\nReturns a drawable indicator of the feature, and any required label\nfor it.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 1051, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "get_feature_sigil", "signature": "(self, feature, x0, x1, fragment, **kwargs)", "symbol_type": "function"}], "get_features": [{"docstring": "Retrieve features.\n\nArguments:\n - attribute: String, attribute of a Feature object\n - value: The value desired of the attribute\n - comparator: String, how to compare the Feature attribute to the\n   passed value\n\nIf no attribute or value is given, return a list of all features in the\nfeature set.  If both an attribute and value are given, then depending\non the comparator, then a list of all features in the FeatureSet\nmatching (or not) the passed value will be returned.  Allowed comparators\nare: 'startswith', 'not', 'like'.\n\nThe user is expected to make a responsible decision about which feature\nattributes to use with which passed values and comparator settings.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_FeatureSet.py", "line_number": 106, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._FeatureSet", "name": "get_features", "signature": "(self, attribute = None, value = None, comparator = None)", "symbol_type": "function"}], "get_figure_size": [{"docstring": "Get a figure size by name.\n\nArgs:\n    size: Size name (see FIGURE_SIZES)\n\nReturns:\n    Figure size tuple (width, height)\n\nExample:\n    >>> from metainformant.visualization.style import get_figure_size\n    >>> figsize = get_figure_size('large')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/style.py", "line_number": 96, "module": "src.metainformant.visualization.style", "name": "get_figure_size", "signature": "(size: str = 'medium') -> tuple[float, float]", "symbol_type": "function"}], "get_file_content": [{"docstring": "Return full text of file 'file_name'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 181, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_file_content", "signature": "(self, file_name: str) -> str", "symbol_type": "function"}], "get_file_data_and_close_file": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 521, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "get_file_data_and_close_file", "signature": "(file_instance: io.IOBase) -> bytes", "symbol_type": "function"}], "get_file_extension": [{"docstring": "Get file extension from filename.\n\nArgs:\n    filename: Name of file\n\nReturns:\n    File extension including the dot, or empty string", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 63, "module": "src.metainformant.core.paths", "name": "get_file_extension", "signature": "(filename: str) -> str", "symbol_type": "function"}], "get_file_handle": [{"docstring": "Get handle of file using name within dataset directory\n\nParameters:\n    file_name: Name of file within the data directory, e.g. if the full\n               datasets path is ncbi_dataset/data/GCF_000001405.40/chrX.fna,\n               file_name should be GCF_000001405.40/chrX.fna\nReturns:\n    Handle to the specified file", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 189, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_file_handle", "signature": "(self, file_name: str) -> TextIO", "symbol_type": "function"}], "get_file_handles_by_type": [{"docstring": "Return file handles for all files of type 'file_type' along with their names", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 165, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_file_handles_by_type", "signature": "(self, file_type: str) -> Iterator[Tuple[TextIO, str]]", "symbol_type": "function"}], "get_file_names_by_type": [{"docstring": "Return names of all files of type 'file_type', e.g. 'PROTEIN_FASTA'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 150, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_file_names_by_type", "signature": "(self, file_type: str) -> List[str]", "symbol_type": "function"}], "get_file_root_dir": [{"docstring": "Return the data directory within the dataset (e.g. ncbi_dataset/data)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 132, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_file_root_dir", "signature": "(self) -> str", "symbol_type": "function"}], "get_file_size": [{"docstring": "Get file size in bytes.\n\nArgs:\n    path: Path to file\n\nReturns:\n    File size in bytes, or 0 if file doesn't exist", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 109, "module": "src.metainformant.core.paths", "name": "get_file_size", "signature": "(path: str | Path) -> int", "symbol_type": "function"}], "get_file_types": [{"docstring": "Return all file types available in the current dataset", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 173, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_file_types", "signature": "(self) -> List[str]", "symbol_type": "function"}], "get_files_by_type": [{"docstring": "Return contents of all files of type 'file_type' along with their names", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 158, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_files_by_type", "signature": "(self, file_type: str) -> Iterator[Tuple[str, str]]", "symbol_type": "function"}], "get_from_decoded": [{"docstring": "Return structure from decoder.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/__init__.py", "line_number": 23, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.__init__", "name": "get_from_decoded", "signature": "(decoder)", "symbol_type": "function"}], "get_full_id": [{"docstring": "Return the full id of the atom.\n\nThe full id of an atom is a tuple used to uniquely identify\nthe atom and consists of the following elements:\n(structure id, model id, chain id, residue id, atom name, altloc)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 414, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_full_id", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the full id.\n\nThe full id is a tuple containing all id's starting from\nthe top object (Structure) down to the current object. A full id for\na Residue object e.g. is something like:\n\n(\"1abc\", 0, \"A\", (\" \", 10, \"A\"))\n\nThis corresponds to:\n\nStructure with id \"1abc\"\nModel with id 0\nChain with id \"A\"\nResidue with id (\" \", 10, \"A\")\n\nThe Residue id indicates that the residue is not a hetero-residue\n(or a water) because it has a blank hetero field, that its sequence\nidentifier is 10 and its insertion code \"A\".", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 305, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "get_full_id", "signature": "(self)", "symbol_type": "function"}], "get_full_rf_table": [{"docstring": "Return full rf_table of the CodonSeq records.\n\nA full rf_table is different from a normal rf_table in that\nit translate gaps in CodonSeq. It is helpful to construct\nalignment containing frameshift.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 187, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "get_full_rf_table", "signature": "(self)", "symbol_type": "function"}], "get_fullname": [{"docstring": "Return the atom name, including leading and trailing spaces.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 438, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_fullname", "signature": "(self) -> str", "symbol_type": "function"}], "get_gene_pathways": [{"docstring": "Retrieve all pathways containing a specific gene.\n\nArgs:\n    gene: Gene identifier\n    \nReturns:\n    Set of pathway identifiers that include this gene. Returns empty\n    set if gene is not in any pathway.\n    \nExamples:\n    >>> pn = PathwayNetwork()\n    >>> pn.add_pathway(\"path:00010\", [\"GENE1\", \"GENE2\"])\n    >>> pn.add_pathway(\"path:00020\", [\"GENE1\", \"GENE3\"])\n    >>> pn.get_gene_pathways(\"GENE1\")\n    {'path:00010', 'path:00020'}", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 99, "module": "src.metainformant.networks.pathway", "name": "get_gene_pathways", "signature": "(self, gene: str) -> Set[str]", "symbol_type": "function"}], "get_genome_from_ncbi": [{"docstring": "Fetch a sequence record from NCBI nuccore as FASTA.\n\nParameters\n- genome_id: e.g., \"NC_001422.1\" (PhiX174)\n- email: contact email required by NCBI Entrez", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/entrez.py", "line_number": 8, "module": "src.metainformant.dna.entrez", "name": "get_genome_from_ncbi", "signature": "(genome_id: str) -> Any", "symbol_type": "function"}], "get_genome_info": [{"docstring": "Get genome assembly information for a species.\n\nArgs:\n    taxonomy_id: NCBI taxonomy ID\n    species_name: Scientific name\n\nReturns:\n    Genome information dictionary or None", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/discovery.py", "line_number": 163, "module": "src.metainformant.rna.discovery", "name": "get_genome_info", "signature": "(taxonomy_id: str, species_name: str) -> dict[str, Any] | None", "symbol_type": "function"}], "get_getfastq_run_dir": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 625, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "get_getfastq_run_dir", "signature": "(args, sra_id)", "symbol_type": "function"}], "get_graphs": [{"docstring": "Return list of all graphs in the graph set, sorted by id.\n\nSorting is to ensure reliable stacking.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_GraphSet.py", "line_number": 106, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._GraphSet", "name": "get_graphs", "signature": "(self)", "symbol_type": "function"}], "get_guide_coord_from_structure": [{"docstring": "Return the coordinates of guide atoms in the structure.\n\nWe use guide atoms (C-alpha and C4' atoms) since it is much faster than\nusing all atoms in the calculation without a significant loss in\naccuracy.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/cealign.py", "line_number": 59, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.cealign", "name": "get_guide_coord_from_structure", "signature": "(self, structure)", "symbol_type": "function"}], "get_header": [{"docstring": "Return the header.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBParser.py", "line_number": 97, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBParser", "name": "get_header", "signature": "(self)", "symbol_type": "function"}], "get_host_from_settings": [{"docstring": "Gets host URL based on the index and variables\n:param index: array index of the host settings\n:param variables: hash of variable and the corresponding value\n:param servers: an array of host settings or None\n:return: URL based on host settings", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 437, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "get_host_from_settings", "signature": "(self, index, variables = None, servers = None)", "symbol_type": "function"}], "get_host_settings": [{"docstring": "Gets an array of host settings\n\n:return: An array of host settings", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 421, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "get_host_settings", "signature": "(self)", "symbol_type": "function"}], "get_id": [{"docstring": "Return the node's id.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 141, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "get_id", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the id of the atom (which is its atom name).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 410, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_id", "signature": "(self) -> str", "symbol_type": "function"}, {"docstring": "Return the id.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 301, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "get_id", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the id.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 488, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "get_id", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Get identifier for the fragment.\n\n:return: id for the fragment\n:rtype: int", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/FragmentMapper.py", "line_number": 126, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.FragmentMapper", "name": "get_id", "signature": "(self)", "symbol_type": "function"}], "get_ids": [{"docstring": "Return a list of all ids for the feature set.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_FeatureSet.py", "line_number": 162, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._FeatureSet", "name": "get_ids", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a list of all ids for the graph set.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_GraphSet.py", "line_number": 113, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._GraphSet", "name": "get_ids", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the ids of all sets contained in this track.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Track.py", "line_number": 234, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Track", "name": "get_ids", "signature": "(self)", "symbol_type": "function"}], "get_index": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/quant.py", "line_number": 130, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.quant", "name": "get_index", "signature": "(args, sci_name)", "symbol_type": "function"}], "get_indiv": [{"docstring": "Get individual's data from line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/LargeFileParser.py", "line_number": 22, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.LargeFileParser", "name": "get_indiv", "signature": "(line)", "symbol_type": "function"}, {"docstring": "Extract the details of the individual information on the line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/__init__.py", "line_number": 26, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.__init__", "name": "get_indiv", "signature": "(line)", "symbol_type": "function"}], "get_individual": [{"docstring": "Get the next individual.\n\nReturns individual information if there are more individuals\nin the current population.\nReturns True if there are no more individuals in the current\npopulation, but there are more populations. Next read will\nbe of the following pop.\nReturns False if at end of file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/FileParser.py", "line_number": 169, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.FileParser", "name": "get_individual", "signature": "(self)", "symbol_type": "function"}], "get_init_rms": [{"docstring": "Return the root mean square deviation of untransformed coordinates.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/qcprot.py", "line_number": 349, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.qcprot", "name": "get_init_rms", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Root mean square deviation of untransformed coordinates.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SVDSuperimposer/__init__.py", "line_number": 184, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SVDSuperimposer.__init__", "name": "get_init_rms", "signature": "(self)", "symbol_type": "function"}], "get_interactions": [{"docstring": "Retrieve all interactions for a specific protein.\n\nReturns all protein-protein interactions involving the specified\nprotein, optionally filtered by confidence threshold.\n\nArgs:\n    protein: Protein identifier\n    min_confidence: Minimum confidence score (0-1) for including interactions.\n        Default 0.0 includes all interactions regardless of confidence.\n\nReturns:\n    List of tuples, each containing (partner_protein, interaction_data).\n    interaction_data is a dictionary with keys:\n    - confidence: Confidence score\n    - evidence_types: List of evidence type strings\n    - Additional metadata fields if provided\n    \nExamples:\n    >>> ppi = ProteinNetwork()\n    >>> ppi.add_interaction(\"P1\", \"P2\", confidence=0.9)\n    >>> ppi.add_interaction(\"P1\", \"P3\", confidence=0.5)\n    >>> interactions = ppi.get_interactions(\"P1\", min_confidence=0.7)\n    >>> len(interactions)\n    1  # Only P1-P2 above threshold\n    >>> interactions[0][0]\n    'P2'", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 125, "module": "src.metainformant.networks.ppi", "name": "get_interactions", "signature": "(self, protein: str, min_confidence: float = 0.0) -> List[Tuple[str, Dict[str, Any]]]", "symbol_type": "function"}], "get_iterator": [{"docstring": "Return iterator over children.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 285, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "get_iterator", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Create an iterator over all residue pairs.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureAlignment.py", "line_number": 181, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureAlignment", "name": "get_iterator", "signature": "(self)", "symbol_type": "function"}], "get_json_cache": [{"docstring": "Get data from JSON cache file with optional TTL check.\n\nArgs:\n    cache_file: Path to cache file\n    default: Default value if cache miss or expired\n    max_age_seconds: Maximum age in seconds, None for no TTL check\n\nReturns:\n    Cached data or default value", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/cache.py", "line_number": 76, "module": "src.metainformant.core.cache", "name": "get_json_cache", "signature": "(cache_file: Path, default: Any = None, max_age_seconds: float | None = None) -> Any", "symbol_type": "function"}], "get_kmers": [{"docstring": "Extract all k-mers from sequence.\n\nArgs:\n    seq: Sequence string\n    k: K-mer length\n    \nReturns:\n    Set of unique k-mers", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/contamination.py", "line_number": 205, "module": "src.metainformant.quality.contamination", "name": "get_kmers", "signature": "(seq: str, k: int) -> Set[str]", "symbol_type": "function"}], "get_label_color": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 416, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "get_label_color", "signature": "(label)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 406, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "get_label_color", "signature": "(label)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 411, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "get_label_color", "signature": "(label)", "symbol_type": "function"}], "get_layer": [{"docstring": "Retrieve a specific omics layer as DataFrame.\n\nArgs:\n    layer_name: Name of the omics layer (e.g., 'genomics', 'transcriptomics')\n    \nReturns:\n    DataFrame containing the specified omics layer with aligned samples.\n    \nRaises:\n    KeyError: If layer_name is not available in this object\n    \nExamples:\n    >>> data = MultiOmicsData(genomics=genomics_df, transcriptomics=transcriptomics_df)\n    >>> genomics = data.get_layer(\"genomics\")\n    >>> genomics.shape\n    (10, 100)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 147, "module": "src.metainformant.multiomics.integration", "name": "get_layer", "signature": "(self, layer_name: str) -> pd.DataFrame", "symbol_type": "function"}], "get_layout": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 150, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "get_layout", "signature": "(args, metadata)", "symbol_type": "function"}], "get_leaves": [{"docstring": "Get leaf terms (terms with no children).\n\nArgs:\n    onto: Ontology object containing terms\n    namespace: Optional namespace filter\n    \nReturns:\n    Set of leaf term IDs (terms with no children)\n    \nExamples:\n    >>> onto = load_go_obo(\"go.obo\")\n    >>> leaves = get_leaves(onto)\n    >>> len(leaves) > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/query.py", "line_number": 507, "module": "src.metainformant.ontology.query", "name": "get_leaves", "signature": "(onto: Ontology, namespace: str | None = None) -> Set[str]", "symbol_type": "function"}], "get_length": [{"docstring": "Get bond length for specified atom pair.\n\nSee :meth:`.pick_length` for ak_spec and details.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 3832, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "get_length", "signature": "(self, ak_spec: str | BKT) -> float | None", "symbol_type": "function"}, {"docstring": "Get bond length for specified atom pair.\n\n:param tuple ak_tpl: tuple of AtomKeys.\n    Pair of atoms in this Hedron", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4220, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "get_length", "signature": "(self, ak_tpl: BKT) -> float | None", "symbol_type": "function"}], "get_level": [{"docstring": "Return level.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 446, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_level", "signature": "(self) -> str", "symbol_type": "function"}, {"docstring": "Return level in hierarchy.\n\nA - atom\nR - residue\nC - chain\nM - model\nS - structure", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 240, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "get_level", "signature": "(self)", "symbol_type": "function"}], "get_levels": [{"docstring": "Return a sorted list of levels occupied by tracks in the diagram.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Diagram.py", "line_number": 377, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Diagram", "name": "get_levels", "signature": "(self)", "symbol_type": "function"}], "get_list": [{"docstring": "Return a copy of the list of children.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 289, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "get_list", "signature": "(self)", "symbol_type": "function"}], "get_logger": [{"docstring": "Get or create a logger with default console handler.\n\nArgs:\n    name: Logger name (typically __name__)\n    \nReturns:\n    Configured logger with console handler if none exists", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/logging.py", "line_number": 15, "module": "src.metainformant.core.logging", "name": "get_logger", "signature": "(name: str) -> logging.Logger", "symbol_type": "function"}], "get_logger_with_level": [{"docstring": "Get or create a logger with specified log level.\n\nArgs:\n    name: Logger name (typically __name__)\n    level: Logging level as string (\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\")\n        or integer. If None, uses INFO or CORE_LOG_LEVEL environment variable.\n\nReturns:\n    Configured logger with console handler if none exists\n\nExamples:\n    >>> logger = get_logger_with_level(\"my.module\", \"DEBUG\")\n    >>> logger.debug(\"This will be shown\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/logging.py", "line_number": 77, "module": "src.metainformant.core.logging", "name": "get_logger_with_level", "signature": "(name: str, level: str | int | None = None) -> logging.Logger", "symbol_type": "function"}], "get_mapping_rate": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 517, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "get_mapping_rate", "signature": "(metadata, quant_dir)", "symbol_type": "function"}], "get_maps": [{"docstring": "Map residues between the structures.\n\nReturn two dictionaries that map a residue in one structure to\nthe equivealent residue in the other structure.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureAlignment.py", "line_number": 173, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureAlignment", "name": "get_maps", "signature": "(self)", "symbol_type": "function"}], "get_mark": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/reader.py", "line_number": 114, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.reader", "name": "get_mark", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/reader.py", "line_number": 114, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.reader", "name": "get_mark", "signature": "(self)", "symbol_type": "function"}], "get_metadata_by_single_accession": [{"docstring": "Get genome assembly metadata from NCBI Datasets API.\n\nArgs:\n    genome_assembly_accessions: List of assembly accessions\n    \nReturns:\n    Dictionary with assembly metadata (first assembly only)\n    \nRaises:\n    RuntimeError: If ncbi-datasets-pylib not installed or unavailable", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/ncbi.py", "line_number": 43, "module": "src.metainformant.dna.ncbi", "name": "get_metadata_by_single_accession", "signature": "(genome_assembly_accessions: List[str]) -> dict", "symbol_type": "function"}], "get_models": [{"docstring": "Return models.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Structure.py", "line_number": 30, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Structure", "name": "get_models", "signature": "(self)", "symbol_type": "function"}], "get_module_dependencies": [{"docstring": "Extract import dependencies from a module.\n\nArgs:\n    module_path: Path to Python module file\n\nReturns:\n    ModuleDependency with imports and from_imports", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/discovery.py", "line_number": 474, "module": "src.metainformant.core.discovery", "name": "get_module_dependencies", "signature": "(module_path: str | Path) -> ModuleDependency", "symbol_type": "function"}], "get_module_output_base": [{"docstring": "Get default output base for module.\n\nArgs:\n    module_name: Name of the module\n\nReturns:\n    Default output base path string", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 330, "module": "src.metainformant.core.paths", "name": "get_module_output_base", "signature": "(module_name: str) -> str", "symbol_type": "function"}], "get_name": [{"docstring": "Return atom name.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 406, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_name", "signature": "(self) -> str", "symbol_type": "function"}], "get_namespace": [{"docstring": "Get namespace for a term.\n\nArgs:\n    term_id: Term identifier\n    \nReturns:\n    Namespace string if term exists and has namespace, None otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/types.py", "line_number": 177, "module": "src.metainformant.ontology.types", "name": "get_namespace", "signature": "(self, term_id: str) -> str | None", "symbol_type": "function"}], "get_neighbors": [{"docstring": "Get all neighbors of a node.\n\nFor undirected networks, returns all nodes connected by an edge.\nFor directed networks, returns only outgoing neighbors (nodes\nreached by edges from this node).\n\nArgs:\n    node: Node identifier\n    \nReturns:\n    List of neighbor node identifiers. Empty list if node has no neighbors\n    or doesn't exist in the network.\n    \nExamples:\n    >>> network = BiologicalNetwork(directed=False)\n    >>> network.add_edge(\"A\", \"B\"); network.add_edge(\"A\", \"C\")\n    >>> neighbors = network.get_neighbors(\"A\")\n    >>> set(neighbors)\n    {'B', 'C'}", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 97, "module": "src.metainformant.networks.graph", "name": "get_neighbors", "signature": "(self, node: str) -> List[str]", "symbol_type": "function"}], "get_network_statistics": [{"docstring": "Calculate network statistics.\n\nReturns:\n    Dictionary with network statistics including num_proteins, num_interactions, etc.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 238, "module": "src.metainformant.networks.ppi", "name": "get_network_statistics", "signature": "(self) -> Dict[str, Any]", "symbol_type": "function"}, {"docstring": "Calculate network statistics.\n\nReturns:\n    Dictionary with network statistics including num_genes, num_regulations, etc.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 299, "module": "src.metainformant.networks.regulatory", "name": "get_network_statistics", "signature": "(self) -> Dict[str, Any]", "symbol_type": "function"}], "get_newest_intermediate_file_extension": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 445, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "get_newest_intermediate_file_extension", "signature": "(sra_stat, work_dir)", "symbol_type": "function"}], "get_node": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/composer.py", "line_number": 24, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.composer", "name": "get_node", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/composer.py", "line_number": 24, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.composer", "name": "get_node", "signature": "(self)", "symbol_type": "function"}], "get_node_info": [{"docstring": "Create a dictionary containing information about all nodes in the tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 169, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "get_node_info", "signature": "(self, graph, context = None)", "symbol_type": "function"}], "get_nonterminals": [{"docstring": "Get a list of all of this tree's nonterminal (internal) nodes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 406, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "get_nonterminals", "signature": "(self, order = 'preorder')", "symbol_type": "function"}], "get_occupancy": [{"docstring": "Return occupancy.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 434, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_occupancy", "signature": "(self) -> float | None", "symbol_type": "function"}], "get_oneof_instance": [{"docstring": "Find the oneOf schema that matches the input data (e.g. payload).\nIf exactly one schema matches the input data, an instance of that schema\nis returned.\nIf zero or more than one schema match the input data, an exception is raised.\nIn OAS 3.x, the payload MUST, by validation, match exactly one of the\nschemas described by oneOf.\n\nArgs:\n    cls: the class we are handling\n    model_kwargs (dict): var_name to var_value\n        The input data, e.g. the payload that must match a oneOf schema\n        in the OpenAPI document.\n    constant_kwargs (dict): var_name to var_value\n        args that every model requires, including configuration, server\n        and path to item.\n\nKwargs:\n    model_arg: (int, float, bool, str, date, datetime, ModelSimple, None):\n        the value to assign to a primitive class or ModelSimple class\n        Notes:\n        - this is only passed in when oneOf includes types which are not object\n        - None is used to suppress handling of model_arg, nullable models are handled in __new__\n\nReturns\n    oneof_instance (instance)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1798, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get_oneof_instance", "signature": "(cls, model_kwargs, constant_kwargs, model_arg = None)", "symbol_type": "function"}], "get_option": [{"docstring": "Return the value of an option.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_paml.py", "line_number": 60, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._paml", "name": "get_option", "signature": "(self, option)", "symbol_type": "function"}], "get_parent": [{"docstring": "Return parent residue.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 398, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_parent", "signature": "(self) -> Residue | None", "symbol_type": "function"}, {"docstring": "Return the parent Entity object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 297, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "get_parent", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return parent.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 539, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "get_parent", "signature": "(self)", "symbol_type": "function"}], "get_path": [{"docstring": "List the clades directly between this root and the given target.\n\n:returns: list of all clade objects along this path, ending with the\n    given target, but excluding the root clade.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 379, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "get_path", "signature": "(self, target = None, **kwargs)", "symbol_type": "function"}], "get_pathway_genes": [{"docstring": "Retrieve all genes in a specific pathway.\n\nArgs:\n    pathway_id: Pathway identifier\n    \nReturns:\n    Set of gene identifiers in the pathway. Returns empty set if\n    pathway doesn't exist.\n    \nExamples:\n    >>> pn = PathwayNetwork()\n    >>> pn.add_pathway(\"path:00010\", [\"GENE1\", \"GENE2\"])\n    >>> pn.get_pathway_genes(\"path:00010\")\n    {'GENE1', 'GENE2'}", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 81, "module": "src.metainformant.networks.pathway", "name": "get_pathway_genes", "signature": "(self, pathway_id: str) -> Set[str]", "symbol_type": "function"}], "get_phi_psi_list": [{"docstring": "Return the list of phi/psi dihedral angles.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Polypeptide.py", "line_number": 202, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Polypeptide", "name": "get_phi_psi_list", "signature": "(self)", "symbol_type": "function"}], "get_possible_classes": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1142, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get_possible_classes", "signature": "(cls, from_server_context)", "symbol_type": "function"}], "get_predictions": [{"docstring": "Get all AlphaFold predictions for a UniProt accession.\n\n:param qualifier: A UniProt accession, e.g. P00520\n:type qualifier: str\n:return: The AlphaFold predictions\n:rtype: Iterator[dict]", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/alphafold_db.py", "line_number": 18, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.alphafold_db", "name": "get_predictions", "signature": "(qualifier: str) -> Iterator[dict]", "symbol_type": "function"}], "get_prev": [{"docstring": "Return the id of the node's predecessor.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 149, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "get_prev", "signature": "(self)", "symbol_type": "function"}], "get_processor": [{"docstring": "Return the object to process the given format according to the mapping.\n\n:param format: format name\n:type format: string, lower case\n:param mapping: mapping of format name and its processor object\n:type mapping: dictionary {string: object}", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 35, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "get_processor", "signature": "(format, mapping)", "symbol_type": "function"}], "get_prodoc_entry": [{"docstring": "Get a text handle to a PRODOC entry at ExPASy in HTML format.\n\n>>> from Bio import ExPASy\n>>> import os\n>>> with ExPASy.get_prodoc_entry('PDOC00001') as in_handle:\n...     html = in_handle.read()\n...\n>>> with open(\"myprodocrecord.html\", \"w\") as out_handle:\n...     length = out_handle.write(html)\n...\n>>> os.remove(\"myprodocrecord.html\")  # tidy up\n\nFor a non-existing key XXX, ExPASy returns an HTML-formatted page\ncontaining this text: 'There is currently no PROSITE entry for'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/__init__.py", "line_number": 24, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.__init__", "name": "get_prodoc_entry", "signature": "(id, cgi = 'https://prosite.expasy.org/cgi-bin/prosite/get-prodoc-entry')", "symbol_type": "function"}], "get_property_value": [{"docstring": "Extract the value of the motif's property named key_name from node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/xms.py", "line_number": 44, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.xms", "name": "get_property_value", "signature": "(self, node, key_name)", "symbol_type": "function"}], "get_prosite_entry": [{"docstring": "Get a text handle to a PROSITE entry at ExPASy in HTML format.\n\n>>> from Bio import ExPASy\n>>> import os\n>>> with ExPASy.get_prosite_entry('PS00001') as in_handle:\n...     html = in_handle.read()\n...\n>>> with open(\"myprositerecord.html\", \"w\") as out_handle:\n...     length = out_handle.write(html)\n...\n>>> os.remove(\"myprositerecord.html\")  # tidy up\n\nFor a non-existing key XXX, ExPASy returns an HTML-formatted page\ncontaining this text: 'There is currently no PROSITE entry for'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/__init__.py", "line_number": 45, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.__init__", "name": "get_prosite_entry", "signature": "(id, cgi = 'https://prosite.expasy.org/cgi-bin/prosite/get-prosite-entry')", "symbol_type": "function"}], "get_prosite_raw": [{"docstring": "Get a text handle to a raw PROSITE or PRODOC record at ExPASy.\n\nThe cgi argument is deprecated due to changes in the ExPASy\nwebsite.\n\n>>> from Bio import ExPASy\n>>> from Bio.ExPASy import Prosite\n>>> with ExPASy.get_prosite_raw('PS00001') as handle:\n...     record = Prosite.read(handle)\n...\n>>> print(record.accession)\nPS00001\n\nThis function raises a ValueError if the identifier does not exist:\n\n>>> handle = ExPASy.get_prosite_raw(\"DOES_NOT_EXIST\")\nTraceback (most recent call last):\n    ...\nValueError: Failed to find entry 'DOES_NOT_EXIST' on ExPASy", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/__init__.py", "line_number": 66, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.__init__", "name": "get_prosite_raw", "signature": "(id, cgi = None)", "symbol_type": "function"}], "get_protein_partners": [{"docstring": "Get all interaction partner proteins for a specific protein.\n\nConvenience method that returns just the partner protein IDs\n(without interaction metadata) for easier iteration.\n\nArgs:\n    protein: Protein identifier\n    min_confidence: Minimum confidence score (0-1) for including partners.\n        Default 0.0 includes all partners regardless of confidence.\n        \nReturns:\n    List of partner protein identifiers\n    \nExamples:\n    >>> ppi = ProteinNetwork()\n    >>> ppi.add_interaction(\"P1\", \"P2\", confidence=0.9)\n    >>> ppi.add_interaction(\"P1\", \"P3\", confidence=0.5)\n    >>> partners = ppi.get_protein_partners(\"P1\", min_confidence=0.7)\n    >>> partners\n    ['P2']", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 166, "module": "src.metainformant.networks.ppi", "name": "get_protein_partners", "signature": "(self, protein: str, min_confidence: float = 0.0) -> List[str]", "symbol_type": "function"}], "get_qresult_id": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/ExonerateIO/_base.py", "line_number": 535, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.ExonerateIO._base", "name": "get_qresult_id", "signature": "(self, pos)", "symbol_type": "function"}, {"docstring": "Return the query ID of the nearest cigar line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/ExonerateIO/exonerate_cigar.py", "line_number": 94, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.ExonerateIO.exonerate_cigar", "name": "get_qresult_id", "signature": "(self, pos)", "symbol_type": "function"}, {"docstring": "Return the query ID from the nearest \"Query:\" line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/ExonerateIO/exonerate_text.py", "line_number": 489, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.ExonerateIO.exonerate_text", "name": "get_qresult_id", "signature": "(self, pos)", "symbol_type": "function"}, {"docstring": "Return the query ID of the nearest vulgar line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/ExonerateIO/exonerate_vulgar.py", "line_number": 182, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.ExonerateIO.exonerate_vulgar", "name": "get_qresult_id", "signature": "(self, pos)", "symbol_type": "function"}], "get_radius": [{"docstring": "Return radius.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 454, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_radius", "signature": "(self) -> float | None", "symbol_type": "function"}], "get_range": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 59, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "get_range", "signature": "(sra_stat, offset, total_sra_bp, max_bp)", "symbol_type": "function"}], "get_raw": [{"docstring": "Return the raw record from the file as a bytes string (if implemented).\n\nIf the key is not found, a KeyError exception is raised.\n\nThis may not have been implemented for all file formats.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/File.py", "line_number": 139, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.File", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw record from the file as a bytes string.\n\nIf the key is not found, a KeyError exception is raised.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/File.py", "line_number": 248, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.File", "name": "get_raw", "signature": "(self, key)", "symbol_type": "function"}, {"docstring": "Return the raw record from the file as a bytes string.\n\nIf the key is not found, a KeyError exception is raised.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/File.py", "line_number": 585, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.File", "name": "get_raw", "signature": "(self, key)", "symbol_type": "function"}, {"docstring": "Return raw bytes string of a QueryResult object from the given offset.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlatIO.py", "line_number": 601, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlatIO", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw record from the file as a bytes string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/FastaIO.py", "line_number": 565, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.FastaIO", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw bytes string of a QueryResult object from the given offset.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlastIO/blast_tab.py", "line_number": 621, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlastIO.blast_tab", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw record from the file as a bytes string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlastIO/blast_xml.py", "line_number": 636, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlastIO.blast_xml", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw string of a QueryResult object from the given offset.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/ExonerateIO/exonerate_text.py", "line_number": 505, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.ExonerateIO.exonerate_text", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw bytes string of a QueryResult object from the given offset.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/ExonerateIO/exonerate_vulgar.py", "line_number": 192, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.ExonerateIO.exonerate_vulgar", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw record from the file as a bytes string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HmmerIO/_base.py", "line_number": 18, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HmmerIO._base", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw bytes string of a QueryResult object from the given offset.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HmmerIO/hmmer3_tab.py", "line_number": 192, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HmmerIO.hmmer3_tab", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw bytes string of a QueryResult object from the given offset.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/InfernalIO/infernal_tab.py", "line_number": 458, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.InfernalIO.infernal_tab", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw record from the file as a bytes string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/InfernalIO/infernal_text.py", "line_number": 508, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.InfernalIO.infernal_text", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw record from the file as a bytes string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/_index.py", "line_number": 156, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO._index", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw record from the file as a bytes string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/_index.py", "line_number": 233, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO._index", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw record from the file as a bytes string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/_index.py", "line_number": 462, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO._index", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw record from the file as a bytes string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/_index.py", "line_number": 538, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO._index", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw record from the file as a bytes string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/_index.py", "line_number": 578, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO._index", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Return the raw record from the file as a bytes string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/_index.py", "line_number": 652, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO._index", "name": "get_raw", "signature": "(self, offset)", "symbol_type": "function"}, {"docstring": "Get a list of time/signal pairs.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/phen_micro.py", "line_number": 833, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.phen_micro", "name": "get_raw", "signature": "(self)", "symbol_type": "function"}], "get_recent_changes": [{"docstring": "Return three lists of the newest weekly files (added,mod,obsolete).\n\nReads the directories with changed entries from the PDB server and\nreturns a tuple of three URL's to the files of new, modified and\nobsolete entries from the most recent list. The directory with the\nlargest numerical name is used.\nReturns None if something goes wrong.\n\nContents of the data/status dir (20031013 would be used);:\n\n    drwxrwxr-x   2 1002     sysadmin     512 Oct  6 18:28 20031006\n    drwxrwxr-x   2 1002     sysadmin     512 Oct 14 02:14 20031013\n    -rw-r--r--   1 1002     sysadmin    1327 Mar 12  2001 README", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 149, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "get_recent_changes", "signature": "(self)", "symbol_type": "function"}], "get_recommended_batch_size": [{"docstring": "Calculate recommended batch size based on available disk space.\n\nArgs:\n    path: Path to check (directory or file on the drive)\n    sample_size_gb: Estimated size per sample in GB (default: 1.5GB)\n    safety_buffer: Safety buffer as fraction (default: 0.3 = 30% buffer)\n    \nReturns:\n    Recommended batch size (number of samples)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/disk.py", "line_number": 159, "module": "src.metainformant.core.disk", "name": "get_recommended_batch_size", "signature": "(path: Path, sample_size_gb: float = 1.5, safety_buffer: float = 0.3) -> int", "symbol_type": "function"}], "get_recommended_temp_dir": [{"docstring": "Get recommended temporary directory location based on drive size.\n\nPrefers external drive if it's large enough, otherwise falls back to system temp.\n\nArgs:\n    repo_root: Root directory of the repository\n    \nReturns:\n    Path to recommended temporary directory (directory is created if needed)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/disk.py", "line_number": 195, "module": "src.metainformant.core.disk", "name": "get_recommended_temp_dir", "signature": "(repo_root: Path) -> Path", "symbol_type": "function"}], "get_regulators": [{"docstring": "Retrieve all regulators of a specific target gene.\n\nReturns all transcription factors or other regulators that control\nthe specified gene.\n\nArgs:\n    target_gene: Target gene identifier\n\nReturns:\n    List of regulator gene identifiers (strings).\n    \nExamples:\n    >>> grn = GeneRegulatoryNetwork()\n    >>> grn.add_regulation(\"TF1\", \"GENE1\", regulation_type=\"activation\")\n    >>> grn.add_regulation(\"TF2\", \"GENE1\", regulation_type=\"repression\")\n    >>> regulators = grn.get_regulators(\"GENE1\")\n    >>> len(regulators)\n    2\n    >>> set(regulators)\n    {'TF1', 'TF2'}", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 157, "module": "src.metainformant.networks.regulatory", "name": "get_regulators", "signature": "(self, target_gene: str) -> List[str]", "symbol_type": "function"}], "get_regulators_list": [{"docstring": "Get list of regulator gene IDs (without metadata).\n\nConvenience method that returns just regulator gene IDs for easier iteration.\n\nArgs:\n    target_gene: Target gene identifier\n    min_confidence: Minimum confidence score for including regulators\n\nReturns:\n    List of regulator gene identifiers", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 235, "module": "src.metainformant.networks.regulatory", "name": "get_regulators_list", "signature": "(self, target_gene: str, min_confidence: float = 0.0) -> List[str]", "symbol_type": "function"}], "get_relationships": [{"docstring": "Get relationships for a term.\n\nArgs:\n    term_id: Term identifier\n    rel_type: Optional relationship type filter (e.g., \"part_of\", \"regulates\")\n        If None, returns all relationships as a dict.\n        If specified, returns only that relationship type as a set.\n\nReturns:\n    If rel_type is None: Dictionary mapping relationship type -> set of term IDs\n    If rel_type is specified: Set of term IDs for that relationship type\n    \nRaises:\n    KeyError: If term_id not found", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/types.py", "line_number": 131, "module": "src.metainformant.ontology.types", "name": "get_relationships", "signature": "(self, term_id: str, rel_type: str | None = None) -> Dict[str, Set[str]] | Set[str]", "symbol_type": "function"}], "get_required_type_classes": [{"docstring": "Converts the tuple required_types into a tuple and a dict described\nbelow\n\nArgs:\n    required_types_mixed (tuple/list): will contain either classes or\n        instance of list or dict\n    spec_property_naming (bool): if True these values came from the\n        server, and we use the data types in our endpoints.\n        If False, we are client side and we need to include\n        oneOf and discriminator classes inside the data types in our endpoints\n\nReturns:\n    (valid_classes, dict_valid_class_to_child_types_mixed):\n        valid_classes (tuple): the valid classes that the current item\n                               should be\n        dict_valid_class_to_child_types_mixed (dict):\n            valid_class (class): this is the key\n            child_types_mixed (list/dict/tuple): describes the valid child\n                types", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1155, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get_required_type_classes", "signature": "(required_types_mixed, spec_property_naming)", "symbol_type": "function"}], "get_residues": [{"docstring": "Return residues.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Chain.py", "line_number": 180, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Chain", "name": "get_residues", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return residues.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Model.py", "line_number": 50, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Model", "name": "get_residues", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return residues from chains.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Structure.py", "line_number": 39, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Structure", "name": "get_residues", "signature": "(self)", "symbol_type": "function"}], "get_resname": [{"docstring": "Return the residue name.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Residue.py", "line_number": 95, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Residue", "name": "get_resname", "signature": "(self)", "symbol_type": "function"}], "get_resname_list": [{"docstring": "Get residue list.\n\n:return: the residue names\n:rtype: [string, string,...]", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/FragmentMapper.py", "line_number": 118, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.FragmentMapper", "name": "get_resname_list", "signature": "(self)", "symbol_type": "function"}], "get_rms": [{"docstring": "Root mean square deviation of superimposed coordinates.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/qcprot.py", "line_number": 359, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.qcprot", "name": "get_rms", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Root mean square deviation of superimposed coordinates.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SVDSuperimposer/__init__.py", "line_number": 192, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SVDSuperimposer.__init__", "name": "get_rms", "signature": "(self)", "symbol_type": "function"}], "get_roots": [{"docstring": "Get root terms (terms with no parents).\n\nArgs:\n    onto: Ontology object containing terms\n    namespace: Optional namespace filter\n    \nReturns:\n    Set of root term IDs (terms with no parents)\n    \nExamples:\n    >>> onto = load_go_obo(\"go.obo\")\n    >>> roots = get_roots(onto)\n    >>> len(roots) > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/query.py", "line_number": 480, "module": "src.metainformant.ontology.query", "name": "get_roots", "signature": "(onto: Ontology, namespace: str | None = None) -> Set[str]", "symbol_type": "function"}], "get_rotran": [{"docstring": "Return right multiplying rotation matrix and translation vector.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/qcprot.py", "line_number": 343, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.qcprot", "name": "get_rotran", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Right multiplying rotation matrix and translation.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SVDSuperimposer/__init__.py", "line_number": 178, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SVDSuperimposer.__init__", "name": "get_rotran", "signature": "(self)", "symbol_type": "function"}], "get_row": [{"docstring": "Get all the wells of a given row.\n\nA row is identified with a letter (e.g. 'A')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/phen_micro.py", "line_number": 459, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.phen_micro", "name": "get_row", "signature": "(self, row)", "symbol_type": "function"}], "get_row_positions": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 234, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "get_row_positions", "signature": "(tree)", "symbol_type": "function"}], "get_sample_group": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/curate.py", "line_number": 12, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.curate", "name": "get_sample_group", "signature": "(args, metadata)", "symbol_type": "function"}], "get_sample_group_string": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/csca.py", "line_number": 9, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.csca", "name": "get_sample_group_string", "signature": "(args)", "symbol_type": "function"}], "get_sample_status": [{"docstring": "Get detailed status for a single sample.\n\nArgs:\n    config_path: Path to species workflow config file\n    sample_id: SRA accession ID (e.g., \"SRR1234567\")\n    \nReturns:\n    Dictionary with status information:\n    - quantified: bool\n    - has_fastq: bool\n    - has_sra: bool\n    - is_downloading: bool\n    - status: str (\"quantified\", \"downloading\", \"has_fastq\", \"has_sra\", \"undownloaded\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/monitoring.py", "line_number": 66, "module": "src.metainformant.rna.monitoring", "name": "get_sample_status", "signature": "(config_path: Path, sample_id: str) -> dict[str, Any]", "symbol_type": "function"}], "get_score": [{"docstring": "Caller to get the score of a tree for the given alignment.\n\nThis should be implemented in subclass.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/TreeConstruction.py", "line_number": 886, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.TreeConstruction", "name": "get_score", "signature": "(self, tree, alignment)", "symbol_type": "function"}, {"docstring": "Calculate parsimony score using the Fitch algorithm.\n\nCalculate and return the parsimony score given a tree and the\nMSA using either the Fitch algorithm (without a penalty matrix)\nor the Sankoff algorithm (with a matrix).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/TreeConstruction.py", "line_number": 1075, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.TreeConstruction", "name": "get_score", "signature": "(self, tree, alignment)", "symbol_type": "function"}], "get_segid": [{"docstring": "Return the segment identifier.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Residue.py", "line_number": 110, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Residue", "name": "get_segid", "signature": "(self)", "symbol_type": "function"}], "get_segment_info": [{"docstring": "Retrieve the color and label info about the segments.\n\nReturns a list consisting of two tuples specifying the counts and\nlabel name for each segment. The list is ordered according to the\noriginal listing of names. Labels are set as None if no label\nwas specified.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/DisplayRepresentation.py", "line_number": 116, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.DisplayRepresentation", "name": "get_segment_info", "signature": "(self)", "symbol_type": "function"}], "get_seq": [{"docstring": "Return secondary structure string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PSEA.py", "line_number": 114, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PSEA", "name": "get_seq", "signature": "(self)", "symbol_type": "function"}], "get_seqres_file": [{"docstring": "Retrieve and save a (big) file containing all the sequences of PDB entries.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 683, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "get_seqres_file", "signature": "(self, savefile = 'pdb_seqres.txt')", "symbol_type": "function"}], "get_sequence": [{"docstring": "Return the AA sequence as a Seq object.\n\n:return: polypeptide sequence\n:rtype: L{Seq}", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Polypeptide.py", "line_number": 275, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Polypeptide", "name": "get_sequence", "signature": "(self)", "symbol_type": "function"}], "get_sequence_reports": [{"docstring": "Retrieve assembly sequence reports\n\nReturns:\n  Yields a set of Assembly SequenceInfo protobuf objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 257, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "get_sequence_reports", "signature": "(self) -> Iterator[sequence_report_pb2.SequenceInfo]", "symbol_type": "function"}], "get_serial_number": [{"docstring": "Return the serial number.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 402, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_serial_number", "signature": "(self)", "symbol_type": "function"}], "get_sets": [{"docstring": "Return the sets contained in this track.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Track.py", "line_number": 230, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Track", "name": "get_sets", "signature": "(self)", "symbol_type": "function"}], "get_sigatm": [{"docstring": "Return standard deviation of atomic parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 386, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_sigatm", "signature": "(self) -> np.ndarray | None", "symbol_type": "function"}], "get_signals": [{"docstring": "Get a list of the recorded signals (ordered by collection time).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/phen_micro.py", "line_number": 841, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.phen_micro", "name": "get_signals", "signature": "(self)", "symbol_type": "function"}], "get_siguij": [{"docstring": "Return standard deviations of anisotropic temperature factors.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 390, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_siguij", "signature": "(self) -> np.ndarray | None", "symbol_type": "function"}], "get_simple_class": [{"docstring": "Returns an input_value's simple class that we will use for type checking\nPython2:\nfloat and int will return int, where int is the python3 int backport\nstr and unicode will return str, where str is the python3 str backport\nNote: float and int ARE both instances of int backport\nNote: str_py2 and unicode_py2 are NOT both instances of str backport\n\nArgs:\n    input_value (class/class_instance): the item for which we will return\n                                        the simple class", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 792, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get_simple_class", "signature": "(input_value)", "symbol_type": "function"}], "get_single_data": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 47, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "get_single_data", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 47, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "get_single_data", "signature": "(self)", "symbol_type": "function"}], "get_single_node": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/composer.py", "line_number": 29, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.composer", "name": "get_single_node", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/composer.py", "line_number": 29, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.composer", "name": "get_single_node", "signature": "(self)", "symbol_type": "function"}], "get_size": [{"docstring": "Get current total size of all files in the directory.\n\nReturns:\n    Total size in bytes, or 0 if directory doesn't exist", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/download_progress.py", "line_number": 43, "module": "src.metainformant.rna.steps.download_progress", "name": "get_size", "signature": "(self) -> int", "symbol_type": "function"}], "get_snippet": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/error.py", "line_number": 14, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.error", "name": "get_snippet", "signature": "(self, indent = 4, max_length = 75)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/error.py", "line_number": 14, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.error", "name": "get_snippet", "signature": "(self, indent = 4, max_length = 75)", "symbol_type": "function"}], "get_species_state": [{"docstring": "Get current state for a species.\n\nArgs:\n    species: Species identifier\n    \nReturns:\n    Dictionary with category counts and sets", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/progress_tracker.py", "line_number": 217, "module": "src.metainformant.rna.progress_tracker", "name": "get_species_state", "signature": "(self, species: str) -> dict[str, Any]", "symbol_type": "function"}], "get_spherical_coordinates": [{"docstring": "Compute spherical coordinates (r, azimuth, polar_angle) for X,Y,Z point.\n\n:param array xyz: column vector (3 row x 1 column NumPy array)\n:return: tuple of r, azimuth, polar_angle for input coordinate", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 505, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "get_spherical_coordinates", "signature": "(xyz: np.ndarray) -> tuple[float, float, float]", "symbol_type": "function"}], "get_spliced": [{"docstring": "Return a multiple alignment of the exact sequence range provided.\n\nAccepts two lists of start and end positions on target_seqname, representing\nexons to be spliced in silico.  Returns a *MultipleSeqAlignment* of the\ndesired sequences spliced together.\n\n*starts* should be a list of 0-based start coordinates of segments in the reference.\n*ends* should be the list of the corresponding segment ends\n(in the half-open UCSC convention:\nhttp://genome.ucsc.edu/blog/the-ucsc-genome-browser-coordinate-counting-systems/).\n\nTo ask for the alignment portion corresponding to the first 100\nnucleotides of the reference sequence, you would use\n``search([0], [100])``", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/MafIO.py", "line_number": 665, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.MafIO", "name": "get_spliced", "signature": "(self, starts, ends, strand = 1)", "symbol_type": "function"}], "get_spp_from_dir": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/csca.py", "line_number": 19, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.csca", "name": "get_spp_from_dir", "signature": "(dir_curate)", "symbol_type": "function"}], "get_sprot_raw": [{"docstring": "Get a text handle to a raw SwissProt entry at ExPASy.\n\nFor an ID of XXX, fetches http://www.uniprot.org/uniprot/XXX.txt\n(as per the https://www.expasy.org/expasy_urls.html documentation).\n\n>>> from Bio import ExPASy\n>>> from Bio import SwissProt\n>>> with ExPASy.get_sprot_raw(\"O23729\") as handle:\n...     record = SwissProt.read(handle)\n...\n>>> print(record.entry_name)\nCHS3_BROFI\n\nThis function raises a ValueError if the identifier does not exist:\n\n>>> ExPASy.get_sprot_raw(\"DOES_NOT_EXIST\")\nTraceback (most recent call last):\n    ...\nValueError: Failed to find SwissProt entry 'DOES_NOT_EXIST'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/__init__.py", "line_number": 101, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.__init__", "name": "get_sprot_raw", "signature": "(id)", "symbol_type": "function"}], "get_sra_stat": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 426, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "get_sra_stat", "signature": "(sra_id, metadata, num_bp_per_sra = None)", "symbol_type": "function"}], "get_start_end": [{"docstring": "Return position of first and last character which is not in skiplist.\n\nSkiplist defaults to ['-','?'].", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 285, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "get_start_end", "signature": "(sequence, skiplist = ('-', '?'))", "symbol_type": "function"}], "get_state_keys_blacklist": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 486, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "get_state_keys_blacklist", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 486, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "get_state_keys_blacklist", "signature": "(self)", "symbol_type": "function"}], "get_state_keys_blacklist_regexp": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 489, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "get_state_keys_blacklist_regexp", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 489, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "get_state_keys_blacklist_regexp", "signature": "(self)", "symbol_type": "function"}], "get_statistics": [{"docstring": "Compute database-level statistics.\n\nReturns:\n    Dictionary with statistics about the database", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 275, "module": "src.metainformant.life_events.events", "name": "get_statistics", "signature": "(self) -> Dict[str, Any]", "symbol_type": "function"}, {"docstring": "Get pathway network statistics.\n\nReturns:\n    Dictionary with statistics including num_pathways, num_genes, etc.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 118, "module": "src.metainformant.networks.pathway", "name": "get_statistics", "signature": "(self) -> Dict[str, Any]", "symbol_type": "function"}], "get_stats": [{"docstring": "Get cache statistics.\n\nReturns:\n    Dictionary with cache statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/cache.py", "line_number": 238, "module": "src.metainformant.core.cache", "name": "get_stats", "signature": "(self) -> dict[str, Any]", "symbol_type": "function"}], "get_status_list": [{"docstring": "Retrieve a list of pdb codes in the weekly pdb status file from given URL.\n\nUsed by get_recent_changes. Typical contents of the list files parsed\nby this method is now very simply - one PDB name per line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 135, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "get_status_list", "signature": "(url)", "symbol_type": "function"}], "get_structural_models_for": [{"docstring": "Get the PDB structures for a UniProt accession.\n\nDownloads the mmCIF files to the directory if they are not present.\n\n:param qualifier: A UniProt accession, e.g. P00520\n:type qualifier: str\n:param mmcif_parser: The mmCIF parser to use, defaults to ``MMCIFParser()``\n:type mmcif_parser: MMCIFParser, optional\n:param directory: The directory to store the mmCIF data, defaults to the current working directory\n:type directory: Union[int, str, bytes, PathLike], optional\n:return: An iterator over the PDB structures\n:rtype: Iterator[PDBStructure]", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/alphafold_db.py", "line_number": 87, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.alphafold_db", "name": "get_structural_models_for", "signature": "(qualifier: str, mmcif_parser: MMCIFParser | None = None, directory: str | bytes | PathLike | None = None) -> Iterator[StructuralModel]", "symbol_type": "function"}], "get_structure": [{"docstring": "Return the structure.\n\nArguments:\n - structure_id - string, the id that will be used for the structure\n - filename - name of mmCIF file, OR an open text mode file handle", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/MMCIFParser.py", "line_number": 61, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.MMCIFParser", "name": "get_structure", "signature": "(self, structure_id, filename)", "symbol_type": "function"}, {"docstring": "Return the structure.\n\nArguments:\n - structure_id - string, the id that will be used for the structure\n - filename - name of the mmCIF file OR an open filehandle", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/MMCIFParser.py", "line_number": 378, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.MMCIFParser", "name": "get_structure", "signature": "(self, structure_id, filename)", "symbol_type": "function"}, {"docstring": "Parse and return the PDB structure from XML source.\n\n:param Union[int, str, bytes, PathLike, TextIO] source: The XML representation of the PDB structure\n:return: the PDB structure\n:rtype: Bio.PDB.Structure.Structure", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBMLParser.py", "line_number": 115, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBMLParser", "name": "get_structure", "signature": "(self, source: int | str | bytes | PathLike | TextIO) -> Structure", "symbol_type": "function"}, {"docstring": "Return the structure.\n\nArguments:\n - id - string, the id that will be used for the structure\n - file - name of the PDB file OR an open filehandle", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBParser.py", "line_number": 68, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBParser", "name": "get_structure", "signature": "(self, id, file)", "symbol_type": "function"}, {"docstring": "Return the structure.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureBuilder.py", "line_number": 312, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureBuilder", "name": "get_structure", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Parse and return the PDB structure from a BinaryCIF file.\n\n:param str id: the PDB code for this structure\n:param str source: the path to the BinaryCIF file\n:return: the PDB structure\n:rtype: Bio.PDB.Structure.Structure", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/binary_cif.py", "line_number": 242, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.binary_cif", "name": "get_structure", "signature": "(self, id: str | None, source: str) -> Structure", "symbol_type": "function"}, {"docstring": "Get a structure from a file - given a file path.\n\n:param file_path: the input file path\n:return: the structure", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/__init__.py", "line_number": 45, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.__init__", "name": "get_structure", "signature": "(file_path)", "symbol_type": "function"}], "get_structure_from_url": [{"docstring": "Get a structure from a URL - given a PDB id.\n\n:param pdb_id: the input PDB id\n:return: the structure", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/__init__.py", "line_number": 34, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.__init__", "name": "get_structure_from_url", "signature": "(pdb_id)", "symbol_type": "function"}], "get_subseq_as_string": [{"docstring": "Return a substring of a sequence.\n\nArguments:\n - seqid - The internal id for the sequence\n - start - The start position of the sequence; 0-indexed\n - end - The end position of the sequence", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 555, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "get_subseq_as_string", "signature": "(self, seqid, start, end)", "symbol_type": "function"}], "get_succ": [{"docstring": "Return a list of the node's successors.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 145, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "get_succ", "signature": "(self)", "symbol_type": "function"}], "get_summary": [{"docstring": "Get overall progress summary.\n\nReturns:\n    Dictionary with summary statistics:\n    - total_samples: Total number of samples\n    - completed: Number completed\n    - failed: Number failed\n    - active: Number currently downloading\n    - total_size_mb: Total size of all downloads\n    - avg_rate_mbps: Average download rate\n    - elapsed_seconds: Total elapsed time", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/download_progress.py", "line_number": 322, "module": "src.metainformant.rna.steps.download_progress", "name": "get_summary", "signature": "(self) -> dict[str, Any]", "symbol_type": "function"}], "get_support": [{"docstring": "Calculate branch support for a target tree given bootstrap replicate trees.\n\n:Parameters:\n    target_tree : Tree\n        tree to calculate branch support for.\n    trees : iterable\n        iterable of trees used to calculate branch support.\n    len_trees : int\n        optional count of replicates in trees. len_trees must be provided\n        when len(trees) is not a valid operation.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/Consensus.py", "line_number": 501, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.Consensus", "name": "get_support", "signature": "(target_tree, trees, len_trees = None)", "symbol_type": "function"}], "get_supported_formats": [{"docstring": "Get list of supported export formats.\n\nReturns:\n    List of format names\n\nExample:\n    >>> from metainformant.visualization.export import get_supported_formats\n    >>> formats = get_supported_formats()", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/export.py", "line_number": 142, "module": "src.metainformant.visualization.export", "name": "get_supported_formats", "signature": "() -> list[str]", "symbol_type": "function"}], "get_surface": [{"docstring": "Represent molecular surface as a vertex list array.\n\nReturn a NumPy array that represents the vertex list of the\nmolecular surface.\n\nArguments:\n - model - BioPython PDB model object (used to get atoms for input model)\n - MSMS - msms executable (used as argument to subprocess.call)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/ResidueDepth.py", "line_number": 508, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.ResidueDepth", "name": "get_surface", "signature": "(model, MSMS = 'msms')", "symbol_type": "function"}], "get_symbol_metadata": [{"docstring": "Get metadata (docstring, type hints, etc.) for a symbol.\n\nArgs:\n    symbol_path: Path to file containing the symbol\n    symbol_name: Name of the symbol\n\nReturns:\n    Dictionary with symbol metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/symbols.py", "line_number": 431, "module": "src.metainformant.core.symbols", "name": "get_symbol_metadata", "signature": "(symbol_path: str | Path, symbol_name: str) -> dict[str, Any]", "symbol_type": "function"}], "get_symbol_signature": [{"docstring": "Get full signature of a symbol from its file.\n\nArgs:\n    symbol_path: Path to file containing the symbol\n    symbol_name: Name of the symbol\n\nReturns:\n    Signature string or None if not found", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/symbols.py", "line_number": 339, "module": "src.metainformant.core.symbols", "name": "get_symbol_signature", "signature": "(symbol_path: str | Path, symbol_name: str) -> str | None", "symbol_type": "function"}], "get_targets": [{"docstring": "Retrieve all target genes of a specific regulator.\n\nReturns all genes that are regulated by the specified transcription\nfactor or other regulator.\n\nArgs:\n    regulator_gene: Regulator gene identifier\n\nReturns:\n    List of target gene identifiers (strings).\n    \nExamples:\n    >>> grn = GeneRegulatoryNetwork()\n    >>> grn.add_regulation(\"TF1\", \"GENE1\", regulation_type=\"activation\")\n    >>> grn.add_regulation(\"TF1\", \"GENE2\", regulation_type=\"repression\")\n    >>> targets = grn.get_targets(\"TF1\")\n    >>> len(targets)\n    2\n    >>> set(targets)\n    {'GENE1', 'GENE2'}", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 187, "module": "src.metainformant.networks.regulatory", "name": "get_targets", "signature": "(self, regulator_gene: str) -> List[str]", "symbol_type": "function"}], "get_targets_list": [{"docstring": "Get list of target gene IDs (without metadata).\n\nConvenience method that returns just target gene IDs for easier iteration.\n\nArgs:\n    regulator_gene: Regulator gene identifier\n    min_confidence: Minimum confidence score for including targets\n\nReturns:\n    List of target gene identifiers", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 217, "module": "src.metainformant.networks.regulatory", "name": "get_targets_list", "signature": "(self, regulator_gene: str, min_confidence: float = 0.0) -> List[str]", "symbol_type": "function"}], "get_tau_list": [{"docstring": "List of tau torsions angles for all 4 consecutive Calpha atoms.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Polypeptide.py", "line_number": 247, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Polypeptide", "name": "get_tau_list", "signature": "(self)", "symbol_type": "function"}], "get_taxa": [{"docstring": "Return a list of all otus downwards from a node.\n\nnodes = get_taxa(self,node_id=None)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 305, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "get_taxa", "signature": "(self, node_id = None)", "symbol_type": "function"}], "get_temp_imagefilename": [{"docstring": "Return filename of temporary file containing downloaded image.\n\nCreate a new temporary file to hold the image file at the passed URL\nand return the filename.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/KGML_vis.py", "line_number": 85, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.KGML_vis", "name": "get_temp_imagefilename", "signature": "(url)", "symbol_type": "function"}], "get_term": [{"docstring": "Get term by ID.\n\nArgs:\n    term_id: Term identifier to retrieve\n    \nReturns:\n    Term object if found, None otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/types.py", "line_number": 166, "module": "src.metainformant.ontology.types", "name": "get_term", "signature": "(self, term_id: str) -> Term | None", "symbol_type": "function"}], "get_terminals": [{"docstring": "Return a list of all terminal nodes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 326, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "get_terminals", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Get a list of all of this tree's terminal (leaf) nodes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 410, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "get_terminals", "signature": "(self, order = 'preorder')", "symbol_type": "function"}], "get_text": [{"docstring": "Return a string representation of the motif's properties listed on nodelist .", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/xms.py", "line_number": 74, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.xms", "name": "get_text", "signature": "(self, nodelist)", "symbol_type": "function"}], "get_theta_list": [{"docstring": "List of theta angles for all 3 consecutive Calpha atoms.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Polypeptide.py", "line_number": 261, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Polypeptide", "name": "get_theta_list", "signature": "(self)", "symbol_type": "function"}], "get_times": [{"docstring": "Get a list of the recorded time points.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/phen_micro.py", "line_number": 837, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.phen_micro", "name": "get_times", "signature": "(self)", "symbol_type": "function"}], "get_timestamp": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 104, "module": "src.metainformant.life_events.events", "name": "get_timestamp", "signature": "(event: Event) -> float", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 141, "module": "src.metainformant.life_events.events", "name": "get_timestamp", "signature": "(event: Event) -> float", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 44, "module": "src.metainformant.life_events.visualization", "name": "get_timestamp", "signature": "(event)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/workflow.py", "line_number": 386, "module": "src.metainformant.life_events.workflow", "name": "get_timestamp", "signature": "(event)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/phenotype/life_course.py", "line_number": 127, "module": "src.metainformant.phenotype.life_course", "name": "get_timestamp", "signature": "(event)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/phenotype/life_course.py", "line_number": 203, "module": "src.metainformant.phenotype.life_course", "name": "get_timestamp", "signature": "(e)", "symbol_type": "function"}], "get_token": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 135, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "get_token", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 135, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "get_token", "signature": "(self)", "symbol_type": "function"}], "get_tracker": [{"docstring": "Get or create the global progress tracker instance.\n\nArgs:\n    state_file: Optional path to state file\n    dashboard_file: Optional path to dashboard file\n    visualization_file: Optional path to PNG visualization file\n    \nReturns:\n    ProgressTracker instance", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/progress_tracker.py", "line_number": 463, "module": "src.metainformant.rna.progress_tracker", "name": "get_tracker", "signature": "(state_file: Path | None = None, dashboard_file: Path | None = None, visualization_file: Path | None = None) -> ProgressTracker", "symbol_type": "function"}], "get_tracks": [{"docstring": "Return a list of the tracks contained in the diagram.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Diagram.py", "line_number": 339, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Diagram", "name": "get_tracks", "signature": "(self)", "symbol_type": "function"}], "get_trailer": [{"docstring": "Return the trailer.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBParser.py", "line_number": 101, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBParser", "name": "get_trailer", "signature": "(self)", "symbol_type": "function"}], "get_transformed": [{"docstring": "Get the transformed coordinate set.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/qcprot.py", "line_number": 332, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.qcprot", "name": "get_transformed", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Get the transformed coordinate set.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SVDSuperimposer/__init__.py", "line_number": 168, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SVDSuperimposer.__init__", "name": "get_transformed", "signature": "(self)", "symbol_type": "function"}], "get_type_error": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1218, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get_type_error", "signature": "(var_value, path_to_item, valid_classes, key_type = False)", "symbol_type": "function"}], "get_unique_parents": [{"docstring": "Translate a list of entities to a list of their (unique) parents.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Selection.py", "line_number": 27, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Selection", "name": "get_unique_parents", "signature": "(entity_list)", "symbol_type": "function"}], "get_unpacked_list": [{"docstring": "Return a list of undisordered residues.\n\nSome Residue objects hide several disordered residues\n(DisorderedResidue objects). This method unpacks them,\nie. it returns a list of simple Residue objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Chain.py", "line_number": 147, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Chain", "name": "get_unpacked_list", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the list of all atoms, unpack DisorderedAtoms.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Residue.py", "line_number": 99, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Residue", "name": "get_unpacked_list", "signature": "(self)", "symbol_type": "function"}], "get_valid_classes_phrase": [{"docstring": "Returns a string phrase describing what types are allowed\n    ", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1747, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "get_valid_classes_phrase", "signature": "(input_classes)", "symbol_type": "function"}], "get_vector": [{"docstring": "Return coordinates as Vector.\n\n:return: coordinates as 3D vector\n:rtype: Bio.PDB.Vector class", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 480, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "get_vector", "signature": "(self) -> Vector", "symbol_type": "function"}], "get_x_positions": [{"docstring": "Create a mapping of each clade to its horizontal position.\n\nDict of {clade: x-coord}", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 422, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "get_x_positions", "signature": "(tree)", "symbol_type": "function"}], "get_y_positions": [{"docstring": "Create a mapping of each clade to its vertical position.\n\nDict of {clade: y-coord}.\nCoordinates are negative, and integers for tips.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 433, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "get_y_positions", "signature": "(tree)", "symbol_type": "function"}], "getattr_str": [{"docstring": "Return string of the given object's attribute.\n\nDefaults to the given fallback value if attribute is not present.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 11, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "getattr_str", "signature": "(obj, attr, fmt = None, fallback = '?')", "symbol_type": "function"}], "getfastq": [{"docstring": "Run `amalgkit getfastq` (download raw FASTQ files).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 566, "module": "src.metainformant.rna.amalgkit", "name": "getfastq", "signature": "(params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}], "getfastq_getxml": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 26, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "getfastq_getxml", "signature": "(search_term, retmax = 1000)", "symbol_type": "function"}], "getfastq_main": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 771, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "getfastq_main", "signature": "(args)", "symbol_type": "function"}], "getfastq_metadata": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 516, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "getfastq_metadata", "signature": "(args)", "symbol_type": "function"}], "getfastq_search_term": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 18, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "getfastq_search_term", "signature": "(ncbi_id, additional_search_term = None)", "symbol_type": "function"}], "getheader": [{"docstring": "Returns a given response header.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/rest.py", "line_number": 38, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.rest", "name": "getheader", "signature": "(self, name, default = None)", "symbol_type": "function"}], "getheaders": [{"docstring": "Returns a dictionary of the response headers.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/rest.py", "line_number": 34, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.rest", "name": "getheaders", "signature": "(self)", "symbol_type": "function"}], "getter": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 74, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "getter", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 91, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "getter", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 110, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "getter", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 134, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "getter", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 160, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "getter", "signature": "(self)", "symbol_type": "function"}], "getvalue": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1090, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "getvalue", "signature": "(self)", "symbol_type": "function"}], "gi": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 520, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "gi", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 980, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "gi", "signature": "(self, content)", "symbol_type": "function"}], "global_align": [{"docstring": "Global alignment using Needleman-Wunsch algorithm with configurable scoring.\n\nArgs:\n    seq1: First sequence to align\n    seq2: Second sequence to align\n    match_score: Score for matching bases\n    mismatch_score: Penalty for mismatching bases\n    gap_score: Penalty for gaps\n    max_alignments: Maximum number of alignments to return (best first)\n\nReturns:\n    AlignmentResult with aligned sequences and score", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/alignment.py", "line_number": 22, "module": "src.metainformant.dna.alignment", "name": "global_align", "signature": "(seq1: str, seq2: str) -> AlignmentResult", "symbol_type": "function"}], "gompertz": [{"docstring": "Gompertz growth model.\n\nProposed in Zwietering et al., 1990 (PMID: 16348228)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/pm_fitting.py", "line_number": 48, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.pm_fitting", "name": "gompertz", "signature": "(x, A, u, d, v, y0)", "symbol_type": "function"}], "gpa_iterator": [{"docstring": "Read GPA format files.\n\nThis function should be called to read a\ngene_association.goa_uniprot file. Reads the first record and\nreturns a gpa 1.1 or a gpa 1.0 iterator as needed", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/UniProt/GOA.py", "line_number": 269, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.UniProt.GOA", "name": "gpa_iterator", "signature": "(handle)", "symbol_type": "function"}], "gpi_iterator": [{"docstring": "Read GPI format files.\n\nThis function should be called to read a\ngp_information.goa_uniprot file. At the moment, there is\nonly one format, but this may change, so\nthis function is a placeholder a future wrapper.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/UniProt/GOA.py", "line_number": 204, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.UniProt.GOA", "name": "gpi_iterator", "signature": "(handle)", "symbol_type": "function"}], "gravy": [{"docstring": "Calculate the GRAVY (Grand Average of Hydropathy) according to Kyte and Doolitle, 1982.\n\nUtilizes the given Hydrophobicity scale, by default uses the original\nproposed by Kyte and Doolittle (KyteDoolitle). Other options are:\nAboderin, AbrahamLeo, Argos, BlackMould, BullBreese, Casari, Cid,\nCowan3.4, Cowan7.5, Eisenberg, Engelman, Fasman, Fauchere, GoldSack,\nGuy, Jones, Juretic, Kidera, Miyazawa, Parker,Ponnuswamy, Rose,\nRoseman, Sweet, Tanford, Wilson and Zimmerman.\n\nNew scales can be added in ProtParamData.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/ProtParam.py", "line_number": 199, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.ProtParam", "name": "gravy", "signature": "(self, scale = 'KyteDoolitle')", "symbol_type": "function"}], "group_attributes": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 197, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "group_attributes", "signature": "(self, dir_config)", "symbol_type": "function"}], "guess_lag": [{"docstring": "Given two axes returns a guess of the lag point.\n\nThe lag point is defined as the x point where the difference in y\nwith the next point is higher then the mean differences between\nthe points plus one standard deviation. If such point is not found\nor x and y have different lengths the function returns zero.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/pm_fitting.py", "line_number": 76, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.pm_fitting", "name": "guess_lag", "signature": "(x, y)", "symbol_type": "function"}], "guess_plateau": [{"docstring": "Given two axes returns a guess of the plateau point.\n\nThe plateau point is defined as the x point where the y point\nis near one standard deviation of the differences between the y points to\nthe maximum y value. If such point is not found or x and y have\ndifferent lengths the function returns zero.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/pm_fitting.py", "line_number": 107, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.pm_fitting", "name": "guess_plateau", "signature": "(x, y)", "symbol_type": "function"}], "haldane_c_to_d": [{"docstring": "Convert recombination fraction to map distance using inverse Haldane function.\n\nInverse of Haldane's mapping function. Converts observed recombination\nrates to genetic map distances assuming no interference.\n\nArgs:\n    recombination_fraction: Recombination fraction (c) in [0, 0.5]\n    \nReturns:\n    Genetic map distance in Morgans. Returns:\n    - float('inf') if c >= 0.5 (unlinked loci, maximum recombination)\n    - Otherwise: d = -0.5 \u00d7 ln(1 - 2c)\n    \nExamples:\n    >>> haldane_c_to_d(0.1)\n    0.111...\n    >>> haldane_c_to_d(0.25)\n    0.346...\n    >>> haldane_c_to_d(0.5)\n    inf  # Unlinked loci (c = 0.5 is maximum recombination)\n    \nNote:\n    When c = 0.5, loci are unlinked (independent assortment) and the\n    genetic map distance is infinite. This reflects that unlinked loci\n    behave as if they are infinitely far apart on the genetic map.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/ld.py", "line_number": 151, "module": "src.metainformant.math.ld", "name": "haldane_c_to_d", "signature": "(recombination_fraction: float) -> float", "symbol_type": "function"}], "haldane_d_to_c": [{"docstring": "Convert genetic map distance to recombination fraction using Haldane's mapping function.\n\nHaldane's function assumes no interference between crossovers. Suitable for\nchromosomes where crossovers occur independently.\n\nArgs:\n    map_distance_morgans: Genetic map distance in Morgans (d)\n    \nReturns:\n    Recombination fraction in [0, 0.5]. Formula: c = 0.5 \u00d7 (1 - exp(-2d))\n    \nExamples:\n    >>> haldane_d_to_c(0.1)  # 10 cM\n    0.090...\n    >>> haldane_d_to_c(0.5)  # 50 cM (approaches 0.5)\n    0.316...\n    \nReferences:\n    Haldane, J. B. S. (1919). The combination of linkage values and the\n    calculation of distances between the loci of linked factors.\n    Journal of Genetics, 8(4), 299-309.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/ld.py", "line_number": 121, "module": "src.metainformant.math.ld", "name": "haldane_d_to_c", "signature": "(map_distance_morgans: float) -> float", "symbol_type": "function"}], "hamming_distance": [{"docstring": "Hamming distance up to the shorter length.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/mutations.py", "line_number": 23, "module": "src.metainformant.dna.mutations", "name": "hamming_distance", "signature": "(a: str, b: str) -> int", "symbol_type": "function"}], "handleMissingDocumentDefinition": [{"docstring": "Raise an Exception if neither a DTD nor an XML Schema is found.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 534, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "handleMissingDocumentDefinition", "signature": "(self, tag, attrs)", "symbol_type": "function"}], "handle_motif": [{"docstring": "Read the motif's name and column from the node and add the motif record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/xms.py", "line_number": 26, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.xms", "name": "handle_motif", "signature": "(self, node)", "symbol_type": "function"}], "handle_simulation_error": [{"docstring": "Handle simulation errors with context.\n\nArgs:\n    error: Exception that occurred\n    context: Additional context string", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/_common.py", "line_number": 90, "module": "scripts.simulation._common", "name": "handle_simulation_error", "signature": "(error: Exception, context: str = '') -> None", "symbol_type": "function"}], "hardy_weinberg_genotype_freqs": [{"docstring": "Calculate Hardy\u2013Weinberg equilibrium genotype frequencies.\n\nUnder Hardy\u2013Weinberg equilibrium (no selection, mutation, migration, drift),\ngenotype frequencies are determined solely by allele frequencies:\n- AA: p\u00b2\n- Aa: 2pq  \n- aa: q\u00b2\nwhere p is allele A frequency and q = 1 - p is allele a frequency.\n\nArgs:\n    allele_a_frequency: Frequency of allele A (p) in [0, 1]\n    \nReturns:\n    Tuple of (AA_frequency, Aa_frequency, aa_frequency).\n    Returns (0.0, 0.0, 0.0) if input is invalid.\n    \nExamples:\n    >>> hardy_weinberg_genotype_freqs(0.5)\n    (0.25, 0.5, 0.25)\n    >>> hardy_weinberg_genotype_freqs(0.7)\n    (0.49, 0.42, 0.09)\n    \nReferences:\n    Hardy, G. H. (1908). Mendelian proportions in a mixed population.\n    Science, 28(706), 49-50.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 6, "module": "src.metainformant.math.popgen", "name": "hardy_weinberg_genotype_freqs", "signature": "(allele_a_frequency: float) -> tuple[float, float, float]", "symbol_type": "function"}], "hardy_weinberg_test": [{"docstring": "Test for Hardy-Weinberg equilibrium using chi-square test.\n\nCompares observed genotype frequencies to expected frequencies under HWE.\nUses chi-square test with 1 degree of freedom (for biallelic loci).\n\nArgs:\n    genotype_counts: Optional list of (AA, Aa, aa) counts per site\n    genotype_matrix: Optional genotype matrix (individuals \u00d7 sites) with values 0/1/2\n\nReturns:\n    Dictionary with:\n    - chi_square: Chi-square test statistic\n    - p_value: P-value from chi-square distribution\n    - degrees_of_freedom: Degrees of freedom (1 for biallelic)\n    - hwe_deviated: Boolean indicating if HWE is rejected (p < 0.05)\n    \nExamples:\n    >>> # Perfect HWE: p=0.5, expected: 25 AA, 50 Aa, 25 aa\n    >>> result = hardy_weinberg_test(genotype_counts=[(25, 50, 25)])\n    >>> result[\"hwe_deviated\"]\n    False", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 412, "module": "src.metainformant.math.coalescent", "name": "hardy_weinberg_test", "signature": "(genotype_counts: Iterable[tuple[int, int, int]] | None = None, genotype_matrix: Iterable[Iterable[int]] | None = None) -> dict[str, float]", "symbol_type": "function"}], "harmonic_mean_effective_size": [{"docstring": "Calculate effective population size across multiple generations.\n\nUses harmonic mean of census sizes across generations. The harmonic mean\ngives more weight to smaller population sizes, reflecting their greater\nimpact on genetic drift.\n\nArgs:\n    census_sizes: Iterable of census population sizes across generations\n    \nReturns:\n    Harmonic mean effective size. Returns 0.0 if any size is zero or\n    input is empty.\n    Formula: Ne = n / sum(1/N_i) where n is number of generations.\n    \nExamples:\n    >>> harmonic_mean_effective_size([1000, 500, 2000, 800])\n    800.0...\n    >>> harmonic_mean_effective_size([100, 100, 100])\n    100.0\n    \nReferences:\n    Crow, J. F., & Kimura, M. (1970). An introduction to population\n    genetics theory. Harper & Row.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/effective_size.py", "line_number": 6, "module": "src.metainformant.math.effective_size", "name": "harmonic_mean_effective_size", "signature": "(census_sizes: Iterable[float]) -> float", "symbol_type": "function"}], "harmony_integration": [{"docstring": "Harmony-inspired batch integration (simplified implementation).\n\nArgs:\n    data: SingleCellData with batch information\n    batch_key: Column name indicating batch\n    n_components: Number of harmony components\n    theta: Diversity clustering penalty\n    max_iter: Maximum iterations\n\nReturns:\n    SingleCellData with harmony-corrected coordinates", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/integration.py", "line_number": 290, "module": "src.metainformant.singlecell.integration", "name": "harmony_integration", "signature": "(data: SingleCellData, batch_key: str, n_components: int = 50, theta: float = 2.0, max_iter: int = 20) -> SingleCellData", "symbol_type": "function"}], "has_cycle": [{"docstring": "Check for cycles starting from node.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/types.py", "line_number": 225, "module": "src.metainformant.ontology.types", "name": "has_cycle", "signature": "(node: str) -> bool", "symbol_type": "function"}], "has_edge": [{"docstring": "Check if edge exists between two nodes.\n\nArgs:\n    node1: First node identifier\n    node2: Second node identifier\n    \nReturns:\n    True if edge exists, False otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 130, "module": "src.metainformant.networks.graph", "name": "has_edge", "signature": "(self, node1: str, node2: str) -> bool", "symbol_type": "function"}], "has_id": [{"docstring": "Return 1 if a residue with given id is present.\n\nThe id of a residue is (hetero flag, sequence identifier, insertion code).\n\nIf id is an int, it is translated to (\" \", id, \" \") by the _translate_id\nmethod.\n\nArguments:\n - id - (string, int, string) or int", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Chain.py", "line_number": 163, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Chain", "name": "has_id", "signature": "(self, id)", "symbol_type": "function"}, {"docstring": "Check if a child with given id exists.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 293, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "has_id", "signature": "(self, id)", "symbol_type": "function"}], "has_support": [{"docstring": "Return True if any of the nodes has data.support != None.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 559, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "has_support", "signature": "(self, node = None)", "symbol_type": "function"}], "has_term": [{"docstring": "Check if term exists in ontology.\n\nArgs:\n    term_id: Term identifier to check\n    \nReturns:\n    True if term exists, False otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/types.py", "line_number": 189, "module": "src.metainformant.ontology.types", "name": "has_term", "signature": "(self, term_id: str) -> bool", "symbol_type": "function"}], "hash_directory": [{"docstring": "Compute hashes for all files in a directory matching a pattern.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/hash.py", "line_number": 49, "module": "src.metainformant.core.hash", "name": "hash_directory", "signature": "(path: str | Path, pattern: str = '**/*') -> dict[str, str]", "symbol_type": "function"}], "hashedDomainsByEv": [{"docstring": "Get domains clustered by evalue in a dict.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 870, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "hashedDomainsByEv", "signature": "(self, id)", "symbol_type": "function"}], "hashedDomainsById": [{"docstring": "Get domains clustered by sequence identity in a dict.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 862, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "hashedDomainsById", "signature": "(self, id)", "symbol_type": "function"}], "head": [{"docstring": "Return the first ``n`` records as ``FastqRecord`` objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/fastq.py", "line_number": 96, "module": "src.metainformant.dna.fastq", "name": "head", "signature": "(path: Path | str, n: int = 5) -> List[FastqRecord]", "symbol_type": "function"}], "heatmap": [{"docstring": "Heatmap using seaborn; accepts 2D sequences or DataFrame.\n\nArgs:\n    data: 2D array or DataFrame\n    cmap: Colormap name\n    cbar: Whether to show colorbar\n    ax: Matplotlib axes (creates new if None)\n    annot: Whether to annotate cells with values\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> import numpy as np\n    >>> from metainformant.visualization import heatmap\n    >>> data = np.random.random((10, 10))\n    >>> ax = heatmap(data, annot=True)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/basic.py", "line_number": 114, "module": "src.metainformant.visualization.basic", "name": "heatmap", "signature": "(data: Sequence[Sequence[float]] | pd.DataFrame) -> plt.Axes", "symbol_type": "function"}], "hedra_check": [{"docstring": "Confirm both hedra present for dihedron key, use default if set.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 268, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "hedra_check", "signature": "(dk: tuple, ric: IC_Residue) -> None", "symbol_type": "function"}], "herd_immunity_threshold": [{"docstring": "Herd immunity threshold \u2248 1 - 1/R0 (non-negative and \u22641).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/epidemiology.py", "line_number": 108, "module": "src.metainformant.math.epidemiology", "name": "herd_immunity_threshold", "signature": "(R0: float) -> float", "symbol_type": "function"}], "heterozygosity_decay": [{"docstring": "Calculate expected heterozygosity decay under genetic drift.\n\nUnder genetic drift in a finite population, heterozygosity decreases\nover time due to allele fixation and loss. The rate of decay depends\non effective population size.\n\nArgs:\n    initial_heterozygosity: Starting heterozygosity H\u2080\n    effective_population_size: Effective population size (Ne)\n    generations: Number of generations (t)\n    \nReturns:\n    Expected heterozygosity after t generations. Values clamped to [0, 1].\n    Formula: H_t = H\u2080 \u00d7 (1 - 1/(2Ne))^t\n    \nExamples:\n    >>> heterozygosity_decay(initial_heterozygosity=0.5, effective_population_size=100, generations=100)\n    0.303...\n    >>> heterozygosity_decay(initial_heterozygosity=0.5, effective_population_size=1000, generations=100)\n    0.475...  # Slower decay with larger population\n    \nReferences:\n    Nei, M., & Tajima, F. (1981). DNA polymorphism detectable by\n    restriction endonucleases. Genetics, 97(1), 145-163.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 171, "module": "src.metainformant.math.popgen", "name": "heterozygosity_decay", "signature": "(initial_heterozygosity: float, effective_population_size: float, generations: int) -> float", "symbol_type": "function"}], "hide_unused_subplots": [{"docstring": "Hide unused subplots in a grid.\n\nArgs:\n    axes: Array of axes\n    n_used: Number of subplots actually used\n\nExample:\n    >>> from metainformant.visualization.layout import hide_unused_subplots\n    >>> fig, axes = create_subplot_grid(9, ncols=3)\n    >>> # Use first 6 subplots\n    >>> hide_unused_subplots(axes, 6)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/layout.py", "line_number": 134, "module": "src.metainformant.visualization.layout", "name": "hide_unused_subplots", "signature": "(axes: np.ndarray, n_used: int)", "symbol_type": "function"}], "hierarchical_clustering": [{"docstring": "Perform hierarchical clustering on single-cell data.\n\nArgs:\n    data: SingleCellData object\n    n_clusters: Number of clusters\n    linkage: Linkage criterion ('ward', 'complete', 'average', 'single')\n    use_pca: Whether to use PCA coordinates\n    n_pcs: Number of PCs to use\n\nReturns:\n    SingleCellData with cluster assignments in obs['hierarchical']", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/clustering.py", "line_number": 260, "module": "src.metainformant.singlecell.clustering", "name": "hierarchical_clustering", "signature": "(data: SingleCellData, n_clusters: int = 8, linkage: str = 'ward', use_pca: bool = True, n_pcs: int = 40) -> SingleCellData", "symbol_type": "function"}], "hierarchical_communities": [{"docstring": "Detect hierarchical community structure at multiple levels.\n\nPerforms community detection at multiple resolution levels to reveal\nhierarchical organization. Higher levels show larger communities,\nlower levels show more fine-grained structure.\n\nArgs:\n    network: Input biological network\n    levels: Number of hierarchy levels to compute (default 3)\n    resolution: Base resolution parameter (will be scaled for each level)\n    seed: Random seed for reproducible results\n    \nReturns:\n    Dictionary mapping level (0 to levels-1) to community partition.\n    Level 0 has highest resolution (smallest communities),\n    level (levels-1) has lowest resolution (largest communities).\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"])\n    >>> # Add edges to create hierarchy\n    >>> hier = hierarchical_communities(network, levels=3)\n    >>> len(hier[0])  # Finest level\n    6\n    >>> len(set(hier[2].values()))  # Coarsest level\n    2", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/community.py", "line_number": 489, "module": "src.metainformant.networks.community", "name": "hierarchical_communities", "signature": "(network: BiologicalNetwork, levels: int = 3, resolution: float = 1.0, seed: Optional[int] = None) -> Dict[int, Dict[str, int]]", "symbol_type": "function"}], "hierarchical_network_plot": [{"docstring": "Create a hierarchical network plot.\n\nArgs:\n    nodes: List of node names\n    edges: List of (source, target) edge tuples\n    root: Root node for hierarchy (if None, uses first node)\n    node_sizes: Optional list of node sizes\n    node_colors: Optional list of node colors\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import hierarchical_network_plot\n    >>> nodes = ['A', 'B', 'C', 'D']\n    >>> edges = [('A', 'B'), ('A', 'C'), ('C', 'D')]\n    >>> ax = hierarchical_network_plot(nodes, edges, root='A')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/networks.py", "line_number": 142, "module": "src.metainformant.visualization.networks", "name": "hierarchical_network_plot", "signature": "(nodes: list[str], edges: list[tuple[str, str]], root: str | None = None, **kwargs) -> plt.Axes", "symbol_type": "function"}], "histogram": [{"docstring": "Create a histogram.\n\nArgs:\n    data: Data to plot\n    bins: Number of bins or bin edges\n    ax: Matplotlib axes (creates new if None)\n    density: Whether to normalize to density\n    alpha: Bar transparency\n    color: Bar color\n    xlabel: X-axis label\n    ylabel: Y-axis label\n    title: Plot title\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import histogram\n    >>> import numpy as np\n    >>> data = np.random.normal(0, 1, 1000)\n    >>> ax = histogram(data, bins=30)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/statistical.py", "line_number": 29, "module": "src.metainformant.visualization.statistical", "name": "histogram", "signature": "(data: Sequence[float]) -> plt.Axes", "symbol_type": "function"}], "hit_coverage": [{"docstring": "Return the length of the hit covered in the alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Compass/__init__.py", "line_number": 128, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Compass.__init__", "name": "hit_coverage", "signature": "(self)", "symbol_type": "function"}], "hit_filter": [{"docstring": "Create new QueryResult object whose Hit objects pass the filter function.\n\n:param func: filter function\n:type func: callable, accepts Hit, returns bool\n\nHere is an example of using ``hit_filter`` to select Hits whose\ndescription begins with the string 'Homo sapiens', case sensitive::\n\n    >>> from Bio import SearchIO\n    >>> qresult = next(SearchIO.parse('Blast/mirna.xml', 'blast-xml'))\n    >>> def desc_filter(hit):\n    ...     return hit.description.startswith('Homo sapiens')\n    ...\n    >>> len(qresult)\n    100\n    >>> filtered = qresult.hit_filter(desc_filter)\n    >>> len(filtered)\n    39\n    >>> print(filtered[:4])\n    Program: blastn (2.2.27+)\n      Query: 33211 (61)\n             mir_1\n     Target: refseq_rna\n       Hits: ----  -----  ----------------------------------------------------------\n                #  # HSP  ID + description\n             ----  -----  ----------------------------------------------------------\n                0      1  gi|262205317|ref|NR_030195.1|  Homo sapiens microRNA 52...\n                1      2  gi|262205330|ref|NR_030198.1|  Homo sapiens microRNA 52...\n                2      1  gi|262205302|ref|NR_030191.1|  Homo sapiens microRNA 51...\n                3      1  gi|262205451|ref|NR_030222.1|  Homo sapiens microRNA 51...\n\nNote that instance attributes (other than the hits) from the unfiltered\nQueryResult are retained in the filtered object.\n\n    >>> qresult.program == filtered.program\n    True\n    >>> qresult.target == filtered.target\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 472, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "hit_filter", "signature": "(self, func = None)", "symbol_type": "function"}], "hit_keys": [{"docstring": "Hit IDs of the Hit objects contained in the QueryResult.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 216, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "hit_keys", "signature": "(self)", "symbol_type": "function"}], "hit_map": [{"docstring": "Create new QueryResult object, mapping the given function to its Hits.\n\n:param func: map function\n:type func: callable, accepts Hit, returns Hit\n\nHere is an example of using ``hit_map`` with a function that discards all\nHSPs in a Hit except for the first one::\n\n    >>> from Bio import SearchIO\n    >>> qresult = next(SearchIO.parse('Blast/mirna.xml', 'blast-xml'))\n    >>> print(qresult[:8])\n    Program: blastn (2.2.27+)\n      Query: 33211 (61)\n             mir_1\n     Target: refseq_rna\n       Hits: ----  -----  ----------------------------------------------------------\n                #  # HSP  ID + description\n             ----  -----  ----------------------------------------------------------\n                0      1  gi|262205317|ref|NR_030195.1|  Homo sapiens microRNA 52...\n                1      1  gi|301171311|ref|NR_035856.1|  Pan troglodytes microRNA...\n                2      1  gi|270133242|ref|NR_032573.1|  Macaca mulatta microRNA ...\n                3      2  gi|301171322|ref|NR_035857.1|  Pan troglodytes microRNA...\n                4      1  gi|301171267|ref|NR_035851.1|  Pan troglodytes microRNA...\n                5      2  gi|262205330|ref|NR_030198.1|  Homo sapiens microRNA 52...\n                6      1  gi|262205302|ref|NR_030191.1|  Homo sapiens microRNA 51...\n                7      1  gi|301171259|ref|NR_035850.1|  Pan troglodytes microRNA...\n\n    >>> top_hsp = lambda hit: hit[:1]\n    >>> mapped_qresult = qresult.hit_map(top_hsp)\n    >>> print(mapped_qresult[:8])\n    Program: blastn (2.2.27+)\n      Query: 33211 (61)\n             mir_1\n     Target: refseq_rna\n       Hits: ----  -----  ----------------------------------------------------------\n                #  # HSP  ID + description\n             ----  -----  ----------------------------------------------------------\n                0      1  gi|262205317|ref|NR_030195.1|  Homo sapiens microRNA 52...\n                1      1  gi|301171311|ref|NR_035856.1|  Pan troglodytes microRNA...\n                2      1  gi|270133242|ref|NR_032573.1|  Macaca mulatta microRNA ...\n                3      1  gi|301171322|ref|NR_035857.1|  Pan troglodytes microRNA...\n                4      1  gi|301171267|ref|NR_035851.1|  Pan troglodytes microRNA...\n                5      1  gi|262205330|ref|NR_030198.1|  Homo sapiens microRNA 52...\n                6      1  gi|262205302|ref|NR_030191.1|  Homo sapiens microRNA 51...\n                7      1  gi|301171259|ref|NR_035850.1|  Pan troglodytes microRNA...", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 518, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "hit_map", "signature": "(self, func = None)", "symbol_type": "function"}], "hits": [{"docstring": "Hit objects contained in the QueryResult.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 211, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "hits", "signature": "(self)", "symbol_type": "function"}], "homog_rot_mtx": [{"docstring": "Generate a 4x4 single-axis NumPy rotation matrix.\n\n:param float angle_rads: the desired rotation angle in radians\n:param char axis: character specifying the rotation axis", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 391, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "homog_rot_mtx", "signature": "(angle_rads: float, axis: str) -> np.ndarray", "symbol_type": "function"}], "homog_scale_mtx": [{"docstring": "Generate a 4x4 NumPy scaling matrix.\n\n:param float scale: scale multiplier", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 480, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "homog_scale_mtx", "signature": "(scale: float) -> np.ndarray", "symbol_type": "function"}], "homog_trans_mtx": [{"docstring": "Generate a 4x4 NumPy translation matrix.\n\n:param x, y, z: translation in each axis", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 462, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "homog_trans_mtx", "signature": "(x: float, y: float, z: float) -> np.ndarray", "symbol_type": "function"}], "host": [{"docstring": "Return generated host.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 477, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "host", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Fix base path.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 482, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "host", "signature": "(self, value)", "symbol_type": "function"}], "hsp_filter": [{"docstring": "Create new QueryResult object whose HSP objects pass the filter function.\n\n``hsp_filter`` is the same as ``hit_filter``, except that it filters\ndirectly on each HSP object in every Hit. If the filtering removes\nall HSP objects in a given Hit, the entire Hit will be discarded. This\nwill result in the QueryResult having less Hit after filtering.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 573, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "hsp_filter", "signature": "(self, func = None)", "symbol_type": "function"}], "hsp_map": [{"docstring": "Create new QueryResult object, mapping the given function to its HSPs.\n\n``hsp_map`` is the same as ``hit_map``, except that it applies the given\nfunction to all HSP objects in every Hit, instead of the Hit objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 586, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "hsp_map", "signature": "(self, func = None)", "symbol_type": "function"}], "hsps": [{"docstring": "Access the HSP objects contained in the QueryResult.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 412, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "hsps", "signature": "(self)", "symbol_type": "function"}], "hudson_fst": [{"docstring": "Hudson's Fst estimator for two populations.\n\nCalculates Hudson's Fst (1992) which measures population differentiation\nas the proportion of genetic diversity that is between populations rather\nthan within them.\n\nArgs:\n    pop1: Sequence of DNA sequences from population 1\n    pop2: Sequence of DNA sequences from population 2\n\nReturns:\n    Fst value in [0, 1] where:\n    - 0 = no differentiation (populations identical)\n    - 1 = complete differentiation (fixed differences between populations)\n\nNote:\n    If sequences have different lengths, truncates to shortest length.\n    Returns 0.0 if either population is empty.\n\nExamples:\n    >>> pop1 = [\"AAAA\", \"AAAA\"]\n    >>> pop2 = [\"TTTT\", \"TTTT\"]\n    >>> hudson_fst(pop1, pop2)\n    1.0  # Complete differentiation\n    >>> pop1 = [\"AAAA\", \"AAAT\"]\n    >>> pop2 = [\"AAAA\", \"AAAT\"]\n    >>> hudson_fst(pop1, pop2)\n    0.0  # No differentiation\n\nReferences:\n    Hudson, R. R., Slatkin, M., & Maddison, W. P. (1992). Estimation of\n    levels of gene flow from DNA sequence data. *Genetics*, 132(2), 583-589.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population.py", "line_number": 218, "module": "src.metainformant.dna.population", "name": "hudson_fst", "signature": "(pop1: Sequence[str], pop2: Sequence[str]) -> float", "symbol_type": "function"}], "hwe_deviation_plot": [{"docstring": "Hardy-Weinberg equilibrium deviation plot.\n\nShows distribution of HWE p-values. Deviations can indicate\ngenotyping errors or population substructure.\n\nArgs:\n    results: Association results or path with HWE p-values\n    output_path: Output path\n    threshold: HWE significance threshold\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_variants.py", "line_number": 255, "module": "src.metainformant.gwas.visualization_variants", "name": "hwe_deviation_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "id": [{"docstring": "Return identifier.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 179, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "id", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Change the id of this entity.\n\nThis will update the child_dict of this entity's parent\nand invalidate all cached full ids involving this entity.\n\n@raises: ValueError", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 184, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "id", "signature": "(self, value)", "symbol_type": "function"}, {"docstring": "Create identifier object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 589, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "id", "signature": "(self, elem)", "symbol_type": "function"}], "id_all": [{"docstring": "Alternative ID(s) of the Hit.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/hit.py", "line_number": 332, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.hit", "name": "id_all", "signature": "(self)", "symbol_type": "function"}], "identify_accessible_regions": [{"docstring": "Identify accessible chromatin regions from ATAC-seq signal.\n\nATAC-seq typically produces narrow peaks (~150bp) representing nucleosome-free\nregions. This function identifies these accessible regions.\n\nArgs:\n    signal: DataFrame with columns ['chrom', 'start', 'end', 'value']\n    chrom: Chromosome to analyze\n    threshold: Signal threshold. If None, uses 75th percentile\n    min_width: Minimum width for accessible region (default: 150bp for ATAC-seq)\n    \nReturns:\n    DataFrame with accessible regions ['chrom', 'start', 'end', 'peak_id', 'value']", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/atac.py", "line_number": 19, "module": "src.metainformant.epigenome.atac", "name": "identify_accessible_regions", "signature": "(signal: pd.DataFrame, chrom: str, threshold: float | None = None, min_width: int = 150) -> pd.DataFrame", "symbol_type": "function"}], "identify_branch_genes": [{"docstring": "Identify genes associated with trajectory branches.\n\nArgs:\n    data: SingleCellData object\n    trajectory_results: Results from trajectory_analysis()\n    min_expression: Minimum mean expression threshold\n    fold_change_threshold: Minimum fold change between branches\n\nReturns:\n    Dictionary mapping branch/lineage to associated genes", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/trajectory.py", "line_number": 555, "module": "src.metainformant.singlecell.trajectory", "name": "identify_branch_genes", "signature": "(data: SingleCellData, trajectory_results: Dict[str, Any], min_expression: float = 0.1, fold_change_threshold: float = 2.0) -> Dict[str, List[str]]", "symbol_type": "function"}], "identify_domains": [{"docstring": "Identify protein domains from sequence.\n\nUses pattern matching or database lookup to identify known domains.\n\nArgs:\n    sequence: Protein sequence\n    domain_database: Optional dictionary mapping domain names to patterns\n    \nReturns:\n    List of domain annotations with 'name', 'start', 'end', 'confidence'", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/structure_analysis.py", "line_number": 62, "module": "src.metainformant.protein.structure_analysis", "name": "identify_domains", "signature": "(sequence: str, domain_database: Dict[str, str] | None = None) -> List[Dict[str, Any]]", "symbol_type": "function"}], "identify_keystone_species": [{"docstring": "Identify keystone species in interaction network.\n\nKeystone species have disproportionate impact on community structure.\nIdentified using network centrality measures.\n\nArgs:\n    interaction_network: Network dictionary from build_interaction_network\n    method: Centrality measure ('betweenness', 'degree', 'closeness')\n    \nReturns:\n    List of (species_id, centrality_score) tuples, sorted by score (descending)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/interactions.py", "line_number": 118, "module": "src.metainformant.ecology.interactions", "name": "identify_keystone_species", "signature": "(interaction_network: Dict[str, Any], method: str = 'betweenness') -> List[Tuple[str, float]]", "symbol_type": "function"}], "ignore_aliases": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 131, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "ignore_aliases", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 136, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "ignore_aliases", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 131, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "ignore_aliases", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 136, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "ignore_aliases", "signature": "(self, data)", "symbol_type": "function"}], "import_network": [{"docstring": "Import network from file in various formats.\n\nLoads network data from files exported by export_network() or\ncompatible formats.\n\nArgs:\n    filepath: Path to input file\n    format: Import format (\"json\", \"csv\", \"graphml\"). Default \"json\"\n    \nReturns:\n    BiologicalNetwork object with loaded data\n    \nExamples:\n    >>> network = import_network(\"network.json\", format=\"json\")\n    >>> network.num_nodes()\n    10\n    \nRaises:\n    ValueError: If format is not supported\n    FileNotFoundError: If file doesn't exist", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 681, "module": "src.metainformant.networks.graph", "name": "import_network", "signature": "(filepath: str, format: str = 'json') -> BiologicalNetwork", "symbol_type": "function"}], "improving_classifier": [{"docstring": "Classifier that shows improved accuracy with more training data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 523, "module": "tests.test_ml_comprehensive", "name": "improving_classifier", "signature": "(X_train, y_train, X_val, y_val)", "symbol_type": "function"}], "in_range": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 146, "module": "src.metainformant.life_events.events", "name": "in_range", "signature": "(event: Event) -> bool", "symbol_type": "function"}], "inbreeding_coefficient": [{"docstring": "Calculate inbreeding coefficient under genetic drift.\n\nThe inbreeding coefficient F measures the probability that two alleles\nat a locus are identical by descent. Under drift, F increases over time\nas the population becomes more inbred.\n\nArgs:\n    effective_population_size: Effective population size (Ne)\n    generations: Number of generations (t)\n    \nReturns:\n    Inbreeding coefficient F_t in [0, 1]. Returns 0.0 if Ne <= 0.\n    Formula: F_t = 1 - (1 - 1/(2Ne))^t\n    \nExamples:\n    >>> inbreeding_coefficient(effective_population_size=100, generations=100)\n    0.393...\n    >>> inbreeding_coefficient(effective_population_size=1000, generations=100)\n    0.0487...  # Lower inbreeding with larger population\n    \nReferences:\n    Crow, J. F., & Kimura, M. (1970). An introduction to population\n    genetics theory. Harper & Row.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 206, "module": "src.metainformant.math.popgen", "name": "inbreeding_coefficient", "signature": "(effective_population_size: float, generations: int) -> float", "symbol_type": "function"}], "inbreeding_coefficient_from_fst": [{"docstring": "Estimate inbreeding coefficient from Fst.\n\nUnder certain population structure models, Fst is related to the\ninbreeding coefficient F. This provides an approximate conversion.\n\nArgs:\n    fst: Wright's Fst value (population differentiation) in [0, 1]\n    subpopulations: Number of subpopulations (default 2)\n        \nReturns:\n    Estimated inbreeding coefficient F. Returns:\n    - 0.0 if fst <= 0\n    - float('inf') if fst = 1.0 (complete differentiation, infinite inbreeding)\n    - Otherwise: fst / (1 - fst)\n    \nExamples:\n    >>> inbreeding_coefficient_from_fst(0.1, subpopulations=2)\n    0.052...\n    >>> inbreeding_coefficient_from_fst(0.3, subpopulations=5)\n    0.075...\n    >>> inbreeding_coefficient_from_fst(1.0)\n    inf  # Complete population differentiation\n    \nNote:\n    This is an approximation. The exact relationship depends on\n    population structure assumptions. When Fst = 1.0 (complete\n    differentiation between populations), the formula F = Fst / (1 - Fst)\n    evaluates to infinity, indicating that the populations are completely\n    isolated with infinite inbreeding within each subpopulation.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 424, "module": "src.metainformant.math.popgen", "name": "inbreeding_coefficient_from_fst", "signature": "(fst: float, subpopulations: int = 2) -> float", "symbol_type": "function"}], "increase_indent": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 146, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "increase_indent", "signature": "(self, flow = False, indentless = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 146, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "increase_indent", "signature": "(self, flow = False, indentless = False)", "symbol_type": "function"}], "indent_of": [{"docstring": "Calculate indentation level (number of leading spaces).\n\nArgs:\n    s: String to check\n    \nReturns:\n    Number of leading spaces", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 301, "module": "src.metainformant.core.config", "name": "indent_of", "signature": "(s: str) -> int", "symbol_type": "function"}], "independent": [{"docstring": "Check if current bitstr1 is independent of another one bitstr2.\n\nThat is to say the bitstr1.index_one() and bitstr2.index_one() have\nno intersection.\n\nBe careful, all _BitString objects are independent of all-zero _BitString\nof the same length.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/Consensus.py", "line_number": 196, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.Consensus", "name": "independent", "signature": "(self, other)", "symbol_type": "function"}], "index": [{"docstring": "Return the lowest index in data where subsection sub is found.\n\nReturn the lowest index in data where subsection sub is found,\nsuch that sub is contained within data[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaises ValueError when the subsection is not found.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 190, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "index", "signature": "(self, sub, start = None, end = None)", "symbol_type": "function"}, {"docstring": "Return the lowest index in the sequence where subsequence sub is found.\n\nWith optional arguments start and end, return the lowest index in the\nsequence such that the subsequence sub is contained within the sequence\nregion [start:end].\n\nArguments:\n - sub - a string or another Seq or MutableSeq object to search for\n - start - optional integer, slice start\n - end - optional integer, slice end\n\nRaises a ValueError if the subsequence is NOT found.\n\ne.g. Locating the first typical start codon, AUG, in an RNA sequence:\n\n>>> from Bio.Seq import Seq\n>>> my_rna = Seq(\"GUCAUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAGUUG\")\n>>> my_rna.index(\"AUG\")\n3\n\nThe next typical start codon can then be found by starting the search\nat position 4:\n\n>>> my_rna.index(\"AUG\", 4)\n15\n\nThis method performs the same search as the ``find`` method.  However,\nif the subsequence is not found, ``find`` returns -1 while ``index``\nraises a ValueError:\n\n>>> my_rna.index(\"T\")\nTraceback (most recent call last):\n           ...\nValueError: ...\n>>> my_rna.find(\"T\")\n-1\n\nSee the ``search`` method to find the locations of multiple subsequences\nat the same time.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 859, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "index", "signature": "(self, sub, start = None, end = None)", "symbol_type": "function"}, {"docstring": "Return the index of the hit for which the target.id is equal to the key.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/__init__.py", "line_number": 562, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.__init__", "name": "index", "signature": "(self, key)", "symbol_type": "function"}, {"docstring": "Return the index of the SeqMap for the given resid and chainid.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/Raf.py", "line_number": 188, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.Raf", "name": "index", "signature": "(self, resid, chainid = '_')", "symbol_type": "function"}, {"docstring": "Indexes a search output file and returns a dictionary-like object.\n\n - filename     - string giving name of file to be indexed\n - format       - Lower case string denoting one of the supported formats.\n - key_function - Optional callback function which when given a\n                  QueryResult should return a unique key for the dictionary.\n - kwargs       - Format-specific keyword arguments.\n\nIndex returns a pseudo-dictionary object with QueryResult objects as its\nvalues and a string identifier as its keys. The function is mainly useful\nfor dealing with large search output files, as it enables access to any\ngiven QueryResult object much faster than using parse or read.\n\nIndex works by storing in-memory the start locations of all queries in a\nfile. When a user requests access to the query, this function will jump\nto its start position, parse the whole query, and return it as a\nQueryResult object:\n\n>>> from Bio import SearchIO\n>>> search_idx = SearchIO.index('Blast/wnts.xml', 'blast-xml')\n>>> search_idx\nSearchIO.index('Blast/wnts.xml', 'blast-xml', key_function=None)\n>>> sorted(search_idx)\n['gi|156630997:105-1160', 'gi|195230749:301-1383', ..., 'gi|53729353:216-1313']\n>>> search_idx['gi|195230749:301-1383']\nQueryResult(id='gi|195230749:301-1383', 5 hits)\n>>> search_idx.close()\n\nIf the file is BGZF compressed, this is detected automatically. Ordinary\nGZIP files are not supported:\n\n>>> from Bio import SearchIO\n>>> search_idx = SearchIO.index('Blast/wnts.xml.bgz', 'blast-xml')\n>>> search_idx\nSearchIO.index('Blast/wnts.xml.bgz', 'blast-xml', key_function=None)\n>>> search_idx['gi|195230749:301-1383']\nQueryResult(id='gi|195230749:301-1383', 5 hits)\n>>> search_idx.close()\n\nYou can supply a custom callback function to alter the default identifier\nstring. This function should accept as its input the QueryResult ID string\nand return a modified version of it.\n\n>>> from Bio import SearchIO\n>>> key_func = lambda id: id.split('|')[1]\n>>> search_idx = SearchIO.index('Blast/wnts.xml', 'blast-xml', key_func)\n>>> search_idx\nSearchIO.index('Blast/wnts.xml', 'blast-xml', key_function=<function <lambda> at ...>)\n>>> sorted(search_idx)\n['156630997:105-1160', ..., '371502086:108-1205', '53729353:216-1313']\n>>> search_idx['156630997:105-1160']\nQueryResult(id='gi|156630997:105-1160', 5 hits)\n>>> search_idx.close()\n\nNote that the callback function does not change the QueryResult's ID value.\nIt only changes the key value used to retrieve the associated QueryResult.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/__init__.py", "line_number": 426, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.__init__", "name": "index", "signature": "(filename, format = None, key_function = None, **kwargs)", "symbol_type": "function"}, {"docstring": "Return the index of a given HSP object, zero-based.\n\n:param hsp: object to look up\n:type hsp: HSP", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/hit.py", "line_number": 398, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.hit", "name": "index", "signature": "(self, hsp)", "symbol_type": "function"}, {"docstring": "Return the index of a given hit key, zero-based.\n\n:param hit_key: hit ID\n:type hit_key: string\n\nThis method is useful for finding out the integer index (usually\ncorrelated with search rank) of a given hit key.\n\n    >>> from Bio import SearchIO\n    >>> qresult = next(SearchIO.parse('Blast/mirna.xml', 'blast-xml'))\n    >>> qresult.index('gi|301171259|ref|NR_035850.1|')\n    7", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 665, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "index", "signature": "(self, hit_key)", "symbol_type": "function"}, {"docstring": "Indexes a sequence file and returns a dictionary like object.\n\nArguments:\n - filename - string giving name of file to be indexed\n - format   - lower case string describing the file format\n - alphabet - no longer used, leave as None\n - key_function - Optional callback function which when given a\n   SeqRecord identifier string should return a unique key for the\n   dictionary.\n\nThis indexing function will return a dictionary like object, giving the\nSeqRecord objects as values.\n\nAs of Biopython 1.69, this will preserve the ordering of the records in\nfile when iterating over the entries.\n\n>>> from Bio import SeqIO\n>>> records = SeqIO.index(\"Quality/example.fastq\", \"fastq\")\n>>> len(records)\n3\n>>> list(records)  # make a list of the keys\n['EAS54_6_R1_2_1_413_324', 'EAS54_6_R1_2_1_540_792', 'EAS54_6_R1_2_1_443_348']\n>>> print(records[\"EAS54_6_R1_2_1_540_792\"].format(\"fasta\"))\n>EAS54_6_R1_2_1_540_792\nTTGGCAGGCCAAGGCCGATGGATCA\n<BLANKLINE>\n>>> \"EAS54_6_R1_2_1_540_792\" in records\nTrue\n>>> print(records.get(\"Missing\", None))\nNone\n>>> records.close()\n\nIf the file is BGZF compressed, this is detected automatically. Ordinary\nGZIP files are not supported:\n\n>>> from Bio import SeqIO\n>>> records = SeqIO.index(\"Quality/example.fastq.bgz\", \"fastq\")\n>>> len(records)\n3\n>>> print(records[\"EAS54_6_R1_2_1_540_792\"].seq)\nTTGGCAGGCCAAGGCCGATGGATCA\n>>> records.close()\n\nWhen you call the index function, it will scan through the file, noting\nthe location of each record. When you access a particular record via the\ndictionary methods, the code will jump to the appropriate part of the\nfile and then parse that section into a SeqRecord.\n\nNote that not all the input formats supported by Bio.SeqIO can be used\nwith this index function. It is designed to work only with sequential\nfile formats (e.g. \"fasta\", \"gb\", \"fastq\") and is not suitable for any\ninterlaced file format (e.g. alignment formats such as \"clustal\").\n\nFor small files, it may be more efficient to use an in memory Python\ndictionary, e.g.\n\n>>> from Bio import SeqIO\n>>> records = SeqIO.to_dict(SeqIO.parse(\"Quality/example.fastq\", \"fastq\"))\n>>> len(records)\n3\n>>> list(records)  # make a list of the keys\n['EAS54_6_R1_2_1_413_324', 'EAS54_6_R1_2_1_540_792', 'EAS54_6_R1_2_1_443_348']\n>>> print(records[\"EAS54_6_R1_2_1_540_792\"].format(\"fasta\"))\n>EAS54_6_R1_2_1_540_792\nTTGGCAGGCCAAGGCCGATGGATCA\n<BLANKLINE>\n\nAs with the to_dict() function, by default the id string of each record\nis used as the key. You can specify a callback function to transform\nthis (the record identifier string) into your preferred key. For example:\n\n>>> from Bio import SeqIO\n>>> def make_tuple(identifier):\n...     parts = identifier.split(\"_\")\n...     return int(parts[-2]), int(parts[-1])\n>>> records = SeqIO.index(\"Quality/example.fastq\", \"fastq\",\n...                       key_function=make_tuple)\n>>> len(records)\n3\n>>> list(records)  # make a list of the keys\n[(413, 324), (540, 792), (443, 348)]\n>>> print(records[(540, 792)].format(\"fasta\"))\n>EAS54_6_R1_2_1_540_792\nTTGGCAGGCCAAGGCCGATGGATCA\n<BLANKLINE>\n>>> (540, 792) in records\nTrue\n>>> \"EAS54_6_R1_2_1_540_792\" in records\nFalse\n>>> print(records.get(\"Missing\", None))\nNone\n>>> records.close()\n\nAnother common use case would be indexing an NCBI style FASTA file,\nwhere you might want to extract the GI number from the FASTA identifier\nto use as the dictionary key.\n\nNotice that unlike the to_dict() function, here the key_function does\nnot get given the full SeqRecord to use to generate the key. Doing so\nwould impose a severe performance penalty as it would require the file\nto be completely parsed while building the index. Right now this is\nusually avoided.\n\nSee Also: Bio.SeqIO.index_db() and Bio.SeqIO.to_dict()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/__init__.py", "line_number": 806, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.__init__", "name": "index", "signature": "(filename, format, alphabet = None, key_function = None)", "symbol_type": "function"}], "index_classes": [{"docstring": "Build class index across repository.\n\nArgs:\n    repo_root: Root directory of repository\n    use_cache: Whether to use cached index if available\n\nReturns:\n    Dictionary mapping class names to lists of SymbolDefinition objects", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/symbols.py", "line_number": 217, "module": "src.metainformant.core.symbols", "name": "index_classes", "signature": "(repo_root: str | Path, use_cache: bool = True) -> dict[str, list[SymbolDefinition]]", "symbol_type": "function"}], "index_db": [{"docstring": "Indexes several search output files into an SQLite database.\n\n - index_filename - The SQLite filename.\n - filenames    - List of strings specifying file(s) to be indexed, or when\n                  indexing a single file this can be given as a string.\n                  (optional if reloading an existing index, but must match)\n - format       - Lower case string denoting one of the supported formats.\n                  (optional if reloading an existing index, but must match)\n - key_function - Optional callback function which when given a\n                  QueryResult identifier string should return a unique\n                  key for the dictionary.\n - kwargs       - Format-specific keyword arguments.\n\nThe ``index_db`` function is similar to ``index`` in that it indexes the start\nposition of all queries from search output files. The main difference is\ninstead of storing these indices in-memory, they are written to disk as an\nSQLite database file. This allows the indices to persist between Python\nsessions. This enables access to any queries in the file without any\nindexing overhead, provided it has been indexed at least once.\n\n>>> from Bio import SearchIO\n>>> idx_filename = \":memory:\" # Use a real filename, this is in RAM only!\n>>> db_idx = SearchIO.index_db(idx_filename, 'Blast/mirna.xml', 'blast-xml')\n>>> sorted(db_idx)\n['33211', '33212', '33213']\n>>> db_idx['33212']\nQueryResult(id='33212', 44 hits)\n>>> db_idx.close()\n\n``index_db`` can also index multiple files and store them in the same\ndatabase, making it easier to group multiple search files and access them\nfrom a single interface.\n\n>>> from Bio import SearchIO\n>>> idx_filename = \":memory:\" # Use a real filename, this is in RAM only!\n>>> files = ['Blast/mirna.xml', 'Blast/wnts.xml']\n>>> db_idx = SearchIO.index_db(idx_filename, files, 'blast-xml')\n>>> sorted(db_idx)\n['33211', '33212', '33213', 'gi|156630997:105-1160', ..., 'gi|53729353:216-1313']\n>>> db_idx['33212']\nQueryResult(id='33212', 44 hits)\n>>> db_idx.close()\n\nOne common example where this is helpful is if you had a large set of\nquery sequences (say ten thousand) which you split into ten query files\nof one thousand sequences each in order to run as ten separate BLAST jobs\non a cluster. You could use ``index_db`` to index the ten BLAST output\nfiles together for seamless access to all the results as one dictionary.\n\nNote that ':memory:' rather than an index filename tells SQLite to hold\nthe index database in memory. This is useful for quick tests, but using\nthe Bio.SearchIO.index(...) function instead would use less memory.\n\nBGZF compressed files are supported, and detected automatically. Ordinary\nGZIP compressed files are not supported.\n\nSee also Bio.SearchIO.index(), Bio.SearchIO.to_dict(), and the Python module\nglob which is useful for building lists of files.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/__init__.py", "line_number": 497, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.__init__", "name": "index_db", "signature": "(index_filename, filenames = None, format = None, key_function = None, **kwargs)", "symbol_type": "function"}, {"docstring": "Index several sequence files and return a dictionary like object.\n\nThe index is stored in an SQLite database rather than in memory (as in the\nBio.SeqIO.index(...) function).\n\nArguments:\n - index_filename - Where to store the SQLite index\n - filenames - list of strings specifying file(s) to be indexed, or when\n   indexing a single file this can be given as a string.\n   (optional if reloading an existing index, but must match)\n - format   - lower case string describing the file format\n   (optional if reloading an existing index, but must match)\n - alphabet - no longer used, leave as None.\n - key_function - Optional callback function which when given a\n   SeqRecord identifier string should return a unique\n   key for the dictionary.\n\nThis indexing function will return a dictionary like object, giving the\nSeqRecord objects as values:\n\n>>> from Bio import SeqIO\n>>> files = [\"GenBank/NC_000932.faa\", \"GenBank/NC_005816.faa\"]\n>>> def get_gi(name):\n...     parts = name.split(\"|\")\n...     i = parts.index(\"gi\")\n...     assert i != -1\n...     return parts[i+1]\n>>> idx_name = \":memory:\" #use an in memory SQLite DB for this test\n>>> records = SeqIO.index_db(idx_name, files, \"fasta\", key_function=get_gi)\n>>> len(records)\n95\n>>> records[\"7525076\"].description\n'gi|7525076|ref|NP_051101.1| Ycf2 [Arabidopsis thaliana]'\n>>> records[\"45478717\"].description\n'gi|45478717|ref|NP_995572.1| pesticin [Yersinia pestis biovar Microtus str. 91001]'\n>>> records.close()\n\nIn this example the two files contain 85 and 10 records respectively.\n\nBGZF compressed files are supported, and detected automatically. Ordinary\nGZIP compressed files are not supported.\n\nSee Also: Bio.SeqIO.index() and Bio.SeqIO.to_dict(), and the Python module\nglob which is useful for building lists of files.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/__init__.py", "line_number": 949, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.__init__", "name": "index_db", "signature": "(index_filename, filenames = None, format = None, alphabet = None, key_function = None)", "symbol_type": "function"}], "index_functions": [{"docstring": "Build function signature index across repository.\n\nArgs:\n    repo_root: Root directory of repository\n    use_cache: Whether to use cached index if available\n\nReturns:\n    Dictionary mapping function names to lists of SymbolDefinition objects", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/symbols.py", "line_number": 124, "module": "src.metainformant.core.symbols", "name": "index_functions", "signature": "(repo_root: str | Path, use_cache: bool = True) -> dict[str, list[SymbolDefinition]]", "symbol_type": "function"}], "index_getter": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1054, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "index_getter", "signature": "(class_or_instance)", "symbol_type": "function"}], "index_one": [{"docstring": "Return a list of positions where the element is '1'.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/Consensus.py", "line_number": 172, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.Consensus", "name": "index_one", "signature": "(self)", "symbol_type": "function"}], "index_to_one": [{"docstring": "Index to corresponding one letter amino acid name.\n\n>>> index_to_one(0)\n'A'\n>>> index_to_one(19)\n'Y'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Polypeptide.py", "line_number": 83, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Polypeptide", "name": "index_to_one", "signature": "(index)", "symbol_type": "function"}], "index_to_three": [{"docstring": "Index to corresponding three letter amino acid name.\n\n>>> index_to_three(0)\n'ALA'\n>>> index_to_three(19)\n'TYR'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Polypeptide.py", "line_number": 105, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Polypeptide", "name": "index_to_three", "signature": "(i)", "symbol_type": "function"}], "index_zero": [{"docstring": "Return a list of positions where the element is '0'.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/Consensus.py", "line_number": 176, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.Consensus", "name": "index_zero", "signature": "(self)", "symbol_type": "function"}], "indices": [{"docstring": "Return the sequence index of each lettter in the alignment.\n\nThis property returns a 2D NumPy array with the sequence index of each\nletter in the alignment. Gaps are indicated by -1.  The array has the\nsame number of rows and columns as the alignment, as given by\n`self.shape`.\n\nFor example,\n\n>>> from Bio import Align\n>>> aligner = Align.PairwiseAligner()\n>>> aligner.mode = \"local\"\n\n>>> alignments = aligner.align(\"GAACTGG\", \"AATG\")\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            1 AACTG 6\n                  0 ||-|| 5\nquery             0 AA-TG 4\n<BLANKLINE>\n>>> alignment.indices\narray([[ 1,  2,  3,  4,  5],\n       [ 0,  1, -1,  2,  3]])\n>>> alignment = alignments[1]\n>>> print(alignment)\ntarget            2 ACTG 6\n                  0 |.|| 4\nquery             0 AATG 4\n<BLANKLINE>\n>>> alignment.indices\narray([[2, 3, 4, 5],\n       [0, 1, 2, 3]])\n\n>>> alignments = aligner.align(\"GAACTGG\", \"CATT\", strand=\"-\")\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            1 AACTG 6\n                  0 ||-|| 5\nquery             4 AA-TG 0\n<BLANKLINE>\n>>> alignment.indices\narray([[ 1,  2,  3,  4,  5],\n       [ 3,  2, -1,  1,  0]])\n>>> alignment = alignments[1]\n>>> print(alignment)\ntarget            2 ACTG 6\n                  0 |.|| 4\nquery             4 AATG 0\n<BLANKLINE>\n>>> alignment.indices\narray([[2, 3, 4, 5],\n       [3, 2, 1, 0]])", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 3110, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "indices", "signature": "(self)", "symbol_type": "function"}], "infer_grn": [{"docstring": "Infer gene regulatory network from gene expression data.\n\nConstructs a regulatory network by identifying relationships between\nregulators and target genes based on expression patterns. Multiple\ninference methods are available.\n\nArgs:\n    expression_data: Expression matrix of shape (n_samples, n_genes).\n        Each column corresponds to one gene's expression profile.\n    gene_names: List of gene identifiers corresponding to columns\n        in expression_data. Must have length equal to expression_data.shape[1]\n    method: Inference method:\n        - \"correlation\": Pearson correlation between regulator and target\n          expression profiles\n        - \"mutual_info\": Mutual information between discretized expressions\n        - \"granger\": Simplified Granger causality (requires time series data)\n    tf_list: Optional list of known transcription factor gene names.\n        If provided, only these genes can act as regulators. If None,\n        all genes can be regulators.\n    threshold: Minimum correlation/mutual information for regulatory\n        interaction. Interactions with |correlation| >= threshold are included.\n        \nReturns:\n    GeneRegulatoryNetwork object with inferred regulatory interactions.\n    Regulation type is determined by correlation sign (positive=activation,\n    negative=repression). Confidence equals correlation/mutual info strength.\n    \nRaises:\n    ValueError: If number of gene_names doesn't match expression data columns\n    ValueError: If method is unknown\n    tf_genes: Alternative name for tf_list (for compatibility)\n    \nExamples:\n    >>> expression = np.random.randn(100, 200)  # 100 samples, 200 genes\n    >>> gene_names = [f\"GENE_{i}\" for i in range(200)]\n    >>> tf_list = [f\"GENE_{i}\" for i in range(50)]  # First 50 are TFs\n    >>> grn = infer_grn(\n    ...     expression, gene_names,\n    ...     method=\"correlation\",\n    ...     tf_list=tf_list,\n    ...     threshold=0.75\n    ... )\n    >>> grn.regulatory_statistics()[\"total_regulations\"]\n    320\n    \nReferences:\n    Bansal, M., et al. (2007). How to infer gene networks from expression\n    profiles. Molecular Systems Biology, 3(1), 78.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 480, "module": "src.metainformant.networks.regulatory", "name": "infer_grn", "signature": "(expression_data: np.ndarray, gene_names: List[str], method: str = 'correlation', tf_list: Optional[List[str]] = None, threshold: float = 0.5, tf_genes: Optional[List[str]] = None) -> GeneRegulatoryNetwork", "symbol_type": "function"}], "infer_type": [{"docstring": "Infer type of a value.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 544, "module": "src.metainformant.core.config", "name": "infer_type", "signature": "(value: Any) -> str", "symbol_type": "function"}], "information_based_communities": [{"docstring": "Detect communities using information-theoretic measures.\n\nUses mutual information to identify communities with high\ninternal information flow.\n\nArgs:\n    graph: NetworkX graph\n    resolution: Resolution parameter for community detection\n    \nReturns:\n    Dictionary mapping community ID to list of node IDs", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/networks.py", "line_number": 180, "module": "src.metainformant.information.networks", "name": "information_based_communities", "signature": "(graph: Any, resolution: float = 1.0) -> dict[str, list[str]]", "symbol_type": "function"}], "information_coefficient": [{"docstring": "Calculate information coefficient (MIC-like measure).\n\nEstimates mutual information for continuous variables by discretization.\nSimilar to Maximal Information Coefficient (MIC) but simpler.\n\nArgs:\n    x: Sequence of continuous X values\n    y: Sequence of continuous Y values (must match length of x)\n    grid_resolution: Number of bins for discretization\n    \nReturns:\n    Information coefficient in [0, 1] (normalized MI)\n    \nExamples:\n    >>> import numpy as np\n    >>> x = np.random.randn(100)\n    >>> y = x + np.random.randn(100) * 0.1  # Strong correlation\n    >>> ic = information_coefficient(x, y)\n    >>> ic > 0.5  # Should have high IC\n    True\n    \nReferences:\n    Reshef, D. N., et al. (2011). Detecting novel associations in large datasets.\n    Science, 334(6062), 1518-1524.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 721, "module": "src.metainformant.information.syntactic", "name": "information_coefficient", "signature": "(x: Sequence[float], y: Sequence[float], grid_resolution: int = 10) -> float", "symbol_type": "function"}], "information_content": [{"docstring": "Calculate information content of a term.\n\nInformation content measures the specificity of a term. More specific\n(rarer) terms have higher information content.\n\nIC(term) = -log(P(term)) where P(term) is the frequency of the term.\n\nArgs:\n    term_frequencies: Dictionary mapping terms to their frequencies\n    term: Term to calculate information content for\n    total_terms: Total number of terms (if None, sum of frequencies)\n    \nReturns:\n    Information content in bits. Returns 0.0 if term not found.\n    \nExamples:\n    >>> freqs = {\"common_term\": 100, \"rare_term\": 1}\n    >>> information_content(freqs, \"rare_term\") > information_content(freqs, \"common_term\")\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/semantic.py", "line_number": 17, "module": "src.metainformant.information.semantic", "name": "information_content", "signature": "(term_frequencies: dict[str, int], term: str, total_terms: int | None = None) -> float", "symbol_type": "function"}], "information_content_from_annotations": [{"docstring": "Calculate information content for all terms from annotations.\n\nArgs:\n    term_annotations: Dictionary mapping entity IDs to sets of terms\n    \nReturns:\n    Dictionary mapping terms to their information content", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/semantic.py", "line_number": 196, "module": "src.metainformant.information.semantic", "name": "information_content_from_annotations", "signature": "(term_annotations: dict[str, set[str]]) -> dict[str, float]", "symbol_type": "function"}], "information_flow": [{"docstring": "Calculate information flow through network edges.\n\nMeasures how information propagates through the network structure.\n\nArgs:\n    graph: NetworkX graph\n    source_nodes: Optional list of source nodes\n    target_nodes: Optional list of target nodes\n    \nReturns:\n    Dictionary with information flow metrics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/networks.py", "line_number": 66, "module": "src.metainformant.information.networks", "name": "information_flow", "signature": "(graph: Any, source_nodes: list[str] | None = None, target_nodes: list[str] | None = None) -> dict[str, Any]", "symbol_type": "function"}], "information_network_plot": [{"docstring": "Plot network visualization based on mutual information matrix.\n\nArgs:\n    mi_matrix: Mutual information matrix\n    labels: Optional node labels\n    threshold: Minimum MI threshold for edges\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import information_network_plot\n    >>> import numpy as np\n    >>> mi_matrix = np.random.random((5, 5))\n    >>> mi_matrix = (mi_matrix + mi_matrix.T) / 2\n    >>> np.fill_diagonal(mi_matrix, 0)\n    >>> labels = ['A', 'B', 'C', 'D', 'E']\n    >>> ax = information_network_plot(mi_matrix, labels, threshold=0.3)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/information.py", "line_number": 221, "module": "src.metainformant.visualization.information", "name": "information_network_plot", "signature": "(mi_matrix: np.ndarray, labels: Sequence[str] | None = None, **kwargs) -> plt.Axes", "symbol_type": "function"}], "information_profile": [{"docstring": "Calculate comprehensive information profile for a set of sequences.\n\nComputes multiple information-theoretic measures including entropy,\nk-mer frequencies, and sequence complexity.\n\nArgs:\n    sequences: List of sequences (DNA, RNA, or protein)\n    k: K-mer size for analysis\n    \nReturns:\n    Dictionary containing:\n    - entropy: Shannon entropy of k-mer frequencies\n    - kmer_frequencies: Dictionary of k-mer counts\n    - unique_kmers: Number of unique k-mers\n    - sequence_complexity: Normalized entropy (entropy / max_entropy)\n    \nExamples:\n    >>> seqs = [\"ATCG\", \"ATCG\", \"AAAA\"]\n    >>> profile = information_profile(seqs, k=1)\n    >>> profile[\"entropy\"] > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/analysis.py", "line_number": 26, "module": "src.metainformant.information.analysis", "name": "information_profile", "signature": "(sequences: list[str], k: int = 1) -> dict[str, Any]", "symbol_type": "function"}], "information_profile_plot": [{"docstring": "Plot information profile visualization.\n\nArgs:\n    profile_data: Dictionary with information profile data\n    figsize: Figure size tuple\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib Figure object\n\nExample:\n    >>> from metainformant.visualization import information_profile_plot\n    >>> profile = {\n    ...     'kmer_frequencies': {'AA': 10, 'AT': 8, 'TA': 7},\n    ...     'entropy': 1.5,\n    ...     'sequence_complexity': 0.8\n    ... }\n    >>> fig = information_profile_plot(profile)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/information.py", "line_number": 108, "module": "src.metainformant.visualization.information", "name": "information_profile_plot", "signature": "(profile_data: dict[str, Any], **kwargs) -> plt.Figure", "symbol_type": "function"}], "information_report": [{"docstring": "Generate comprehensive information-theoretic report.\n\nArgs:\n    data: Analysis results dictionary\n    output_path: Path to save report\n    format: Report format (\"json\", \"markdown\", \"text\")\n    \nReturns:\n    Report metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/workflows.py", "line_number": 263, "module": "src.metainformant.information.workflows", "name": "information_report", "signature": "(data: dict[str, Any], output_path: Path | str, format: str = 'json') -> dict[str, Any]", "symbol_type": "function"}], "information_signature": [{"docstring": "Calculate information signature for multivariate data.\n\nComputes information-theoretic measures for feature vectors or\ntime series data.\n\nArgs:\n    data: 2D array where rows are samples and columns are features\n    method: Analysis method (\"entropy\", \"mutual_information\", \"total_correlation\")\n    \nReturns:\n    Dictionary containing information signature metrics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/analysis.py", "line_number": 85, "module": "src.metainformant.information.analysis", "name": "information_signature", "signature": "(data: np.ndarray | list[list[float]], method: str = 'entropy') -> dict[str, Any]", "symbol_type": "function"}], "information_workflow": [{"docstring": "Complete information-theoretic workflow for sequence analysis.\n\nArgs:\n    sequences: List of sequences to analyze\n    k_values: List of k-mer sizes to analyze\n    output_dir: Optional output directory for saving results\n    \nReturns:\n    Comprehensive workflow results\n    \nRaises:\n    ValueError: If sequences list is empty or k_values are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/workflows.py", "line_number": 89, "module": "src.metainformant.information.workflows", "name": "information_workflow", "signature": "(sequences: list[str], k_values: list[int] | None = None, output_dir: Path | None = None) -> dict[str, Any]", "symbol_type": "function"}], "init": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 60, "module": "src.metainformant.visualization.animations", "name": "init", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 125, "module": "src.metainformant.visualization.animations", "name": "init", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 196, "module": "src.metainformant.visualization.animations", "name": "init", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 265, "module": "src.metainformant.visualization.animations", "name": "init", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 344, "module": "src.metainformant.visualization.animations", "name": "init", "signature": "()", "symbol_type": "function"}], "init_atom": [{"docstring": "Create a new Atom object.\n\nArguments:\n - name - string, atom name, e.g. CA, spaces should be stripped\n - coord - NumPy array (Float0, length 3), atomic coordinates\n - b_factor - float, B factor\n - occupancy - float\n - altloc - string, alternative location specifier\n - fullname - string, atom name including spaces, e.g. \" CA \"\n - element - string, upper case, e.g. \"HG\" for mercury\n - pqr_charge - float, atom charge (PQR format)\n - radius - float, atom radius (PQR format)\n - is_pqr - boolean, flag to specify if a .pqr file is being parsed", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureBuilder.py", "line_number": 189, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureBuilder", "name": "init_atom", "signature": "(self, name: str, coord: np.ndarray, b_factor: float | None, occupancy: float | None, altloc: str, fullname: str, serial_number = None, element: str | None = None, pqr_charge: float | None = None, radius: float | None = None, is_pqr: bool = False)", "symbol_type": "function"}], "init_atom_coords": [{"docstring": "Set chain level di/hedra initial coords from angles and distances.\n\nInitializes atom coordinates in local coordinate space for hedra and\ndihedra, will be transformed appropriately later by :data:`dCoordSpace`\nmatrices for assembly.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 1311, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "init_atom_coords", "signature": "(self) -> None", "symbol_type": "function"}], "init_chain": [{"docstring": "Create a new Chain object with given id.\n\nArguments:\n - chain_id - string", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureBuilder.py", "line_number": 92, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureBuilder", "name": "init_chain", "signature": "(self, chain_id: str)", "symbol_type": "function"}], "init_edra": [{"docstring": "Create chain and residue di/hedra structures, arrays, atomArray.\n\nInputs:\n    self.ordered_aa_ic_list : list of IC_Residue\nGenerates:\n    * edra objects, self.di/hedra (executes :meth:`._create_edra`)\n    * atomArray and support (executes :meth:`.build_atomArray`)\n    * self.hedraLen : number of hedra in structure\n    * hedraL12 : numpy arrays for lengths, angles (empty)\n    * hedraAngle ..\n    * hedraL23 ..\n    * self.hedraNdx : dict mapping hedrakeys to hedraL12 etc\n    * self.dihedraLen : number of dihedra in structure\n    * dihedraAngle ..\n    * dihedraAngleRads : np arrays for angles (empty)\n    * self.dihedraNdx : dict mapping dihedrakeys to dihedraAngle", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 1262, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "init_edra", "signature": "(self, verbose: bool = False) -> None", "symbol_type": "function"}], "init_fragments": [{"docstring": "Initialize useful values for positioning diagram elements.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 237, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "init_fragments", "signature": "(self)", "symbol_type": "function"}], "init_model": [{"docstring": "Create a new Model object with given id.\n\nArguments:\n - id - int\n - serial_num - int", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureBuilder.py", "line_number": 82, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureBuilder", "name": "init_model", "signature": "(self, model_id: int, serial_num: int | None = None)", "symbol_type": "function"}], "init_residue": [{"docstring": "Create a new Residue object.\n\nArguments:\n - resname - string, e.g. \"ASN\"\n - field - hetero flag, \"W\" for waters, \"H\" for\n   hetero residues, otherwise blank.\n - resseq - int, sequence identifier\n - icode - string, insertion code", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureBuilder.py", "line_number": 117, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureBuilder", "name": "init_residue", "signature": "(self, resname: str, field: str, resseq: int, icode: str)", "symbol_type": "function"}], "init_seg": [{"docstring": "Flag a change in segid.\n\nArguments:\n - segid - string", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureBuilder.py", "line_number": 109, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureBuilder", "name": "init_seg", "signature": "(self, segid: str)", "symbol_type": "function"}], "init_structure": [{"docstring": "Initialize a new Structure object with given id.\n\nArguments:\n - structure_id - string", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureBuilder.py", "line_number": 74, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureBuilder", "name": "init_structure", "signature": "(self, structure_id: str)", "symbol_type": "function"}, {"docstring": "Initialize the structure object.\n\n:param total_num_bonds: the number of bonds in the structure\n:param total_num_atoms: the number of atoms in the structure\n:param total_num_groups: the number of groups in the structure\n:param total_num_chains: the number of chains in the structure\n:param total_num_models: the number of models in the structure\n:param structure_id: the id of the structure (e.g. PDB id)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/DefaultParser.py", "line_number": 21, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.DefaultParser", "name": "init_structure", "signature": "(self, total_num_bonds, total_num_atoms, total_num_groups, total_num_chains, total_num_models, structure_id)", "symbol_type": "function"}], "initialize": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1273, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "initialize", "signature": "(self, bedCount)", "symbol_type": "function"}], "initialize_columns": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 592, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "initialize_columns", "signature": "(metadata, g)", "symbol_type": "function"}], "initialize_global_params": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 758, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "initialize_global_params", "signature": "(args, metadata)", "symbol_type": "function"}], "initialize_progress_tracking": [{"docstring": "Initialize progress tracking for a species.\n\nArgs:\n    config_path: Path to species workflow config file\n    tracker: Optional progress tracker instance\n\nReturns:\n    Dictionary with initialization results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/monitoring.py", "line_number": 450, "module": "src.metainformant.rna.monitoring", "name": "initialize_progress_tracking", "signature": "(config_path: Path) -> dict[str, Any]", "symbol_type": "function"}], "initialize_species": [{"docstring": "Initialize tracking for a species.\n\nArgs:\n    species: Species identifier (e.g., \"cfloridanus\")\n    total_samples: Total number of samples for this species\n    sample_ids: List of all sample IDs (SRA run IDs)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/progress_tracker.py", "line_number": 127, "module": "src.metainformant.rna.progress_tracker", "name": "initialize_species", "signature": "(self, species: str, total_samples: int, sample_ids: list[str]) -> None", "symbol_type": "function"}], "insert": [{"docstring": "Add a subsequence to the mutable sequence object at a given index.\n\n>>> my_seq = MutableSeq('ACTCGACGTCG')\n>>> my_seq.insert(0,'A')\n>>> my_seq\nMutableSeq('AACTCGACGTCG')\n>>> my_seq.insert(8,'G')\n>>> my_seq\nMutableSeq('AACTCGACGGTCG')\n\nNo return value.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2268, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "insert", "signature": "(self, i, c)", "symbol_type": "function"}, {"docstring": "Add a child to the Entity at a specified position.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 276, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "insert", "signature": "(self, pos: int, entity: _Child)", "symbol_type": "function"}, {"docstring": "Insert distances given the name and value.\n\n:Parameters:\n    name : str\n        name of a row/col to be inserted\n    value : list\n        a row/col of values to be inserted", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/TreeConstruction.py", "line_number": 263, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.TreeConstruction", "name": "insert", "signature": "(self, name, value, index = None)", "symbol_type": "function"}], "insert_gap": [{"docstring": "Add a gap into the matrix and adjust charsets and partitions.\n\npos=0: first position\npos=nchar: last position", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 1987, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "insert_gap", "signature": "(self, pos, n = 1, leftgreedy = False)", "symbol_type": "function"}], "instability_index": [{"docstring": "Calculate the instability index according to Guruprasad et al 1990.\n\nImplementation of the method of Guruprasad et al. 1990 to test a\nprotein for stability. Any value above 40 means the protein is unstable\n(has a short half life).\n\nSee: Guruprasad K., Reddy B.V.B., Pandit M.W.\nProtein Engineering 4:155-161(1990).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/ProtParam.py", "line_number": 151, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.ProtParam", "name": "instability_index", "signature": "(self)", "symbol_type": "function"}], "int255_color": [{"docstring": "Map integer (red, green, blue) tuple to a ReportLab Color object.\n\n- values: A tuple of (red, green, blue) intensities as\n  integers in the range 0->255\n\nTakes a tuple of (red, green, blue) intensity values in the range\n0 -> 255 and returns an appropriate colors.Color object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Colors.py", "line_number": 204, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Colors", "name": "int255_color", "signature": "(self, values)", "symbol_type": "function"}], "int_no_zero": [{"docstring": "Return integer of val, or None if is zero.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/__init__.py", "line_number": 29, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.__init__", "name": "int_no_zero", "signature": "(val)", "symbol_type": "function"}], "integrate": [{"docstring": "Run `amalgkit integrate` (combine local FASTQs with metadata).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 551, "module": "src.metainformant.rna.amalgkit", "name": "integrate", "signature": "(params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}], "integrate_datasets": [{"docstring": "Integrate multiple single-cell datasets.\n\nArgs:\n    datasets: List of SingleCellData objects to integrate\n    method: Integration method ('concat', 'intersect', 'union')\n    batch_keys: Batch identifiers for each dataset\n\nReturns:\n    Integrated SingleCellData object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/integration.py", "line_number": 140, "module": "src.metainformant.singlecell.integration", "name": "integrate_datasets", "signature": "(datasets: List[SingleCellData], method: str = 'concat', batch_keys: Optional[List[str]] = None) -> SingleCellData", "symbol_type": "function"}], "integrate_main": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/integrate.py", "line_number": 121, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.integrate", "name": "integrate_main", "signature": "(args)", "symbol_type": "function"}], "integrate_omics_data": [{"docstring": "Load and integrate multiple omics datasets into unified structure.\n\nLoads omics data from DataFrames or file paths, applies sample and feature\nmappings if provided, and creates a MultiOmicsData object with automatic\nsample alignment.\n\nArgs:\n    data_dict: Dictionary mapping omics type names (\"genomics\", \"transcriptomics\",\n        etc.) to either pandas DataFrame or file path. Supported file formats:\n        CSV (.csv), TSV (.tsv, .txt), Excel (.xlsx, .xls)\n    sample_mapping: Optional dictionary mapping dataset names to sample ID\n        transformation dictionaries for harmonizing sample IDs across datasets\n    feature_mapping: Optional nested dictionary mapping dataset names to\n        feature ID transformation dictionaries for harmonizing feature names\n    metadata: Optional sample metadata as DataFrame or file path. Metadata\n        is aligned to common samples after integration.\n        \nReturns:\n    MultiOmicsData object with all provided omics layers integrated and\n    samples aligned to common set.\n    \nRaises:\n    ValueError: If file format is unsupported or required columns are missing\n    ValueError: If no common samples found across datasets\n    \nExamples:\n    >>> data_dict = {\n    ...     \"genomics\": \"data/genomics.csv\",\n    ...     \"transcriptomics\": \"data/expression.tsv\"\n    ... }\n    >>> omics_data = integrate_omics_data(data_dict)\n    >>> omics_data.n_samples\n    50", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 243, "module": "src.metainformant.multiomics.integration", "name": "integrate_omics_data", "signature": "(data_dict: Dict[str, Union[pd.DataFrame, str, Path]], sample_mapping: Optional[Dict[str, str]] = None, feature_mapping: Optional[Dict[str, Dict[str, str]]] = None, metadata: Optional[Union[pd.DataFrame, str, Path]] = None) -> MultiOmicsData", "symbol_type": "function"}], "interactions": [{"docstring": "Return list of the unique interactions in this network.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 312, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "interactions", "signature": "(self)", "symbol_type": "function"}], "intermediate_points": [{"docstring": "Generate intermediate points describing provided graph data..\n\nReturns a list of (start, end, value) tuples describing the passed\ngraph data as 'bins' between position midpoints.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_AbstractDrawer.py", "line_number": 348, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._AbstractDrawer", "name": "intermediate_points", "signature": "(start, end, graph_data)", "symbol_type": "function"}], "internal_to_atom_coordinates": [{"docstring": "Create/update atom coordinates from internal coordinates.\n\n:param verbose bool: default False\n    describe runtime problems\n:param: start, fin integers\n    optional sequence positions for begin, end of subregion to process.\n    N.B. this activates serial residue assembly, <start> residue CA will\n    be at origin\n:raises Exception: if any chain does not have .internal_coord attribute", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Chain.py", "line_number": 201, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Chain", "name": "internal_to_atom_coordinates", "signature": "(self, verbose: bool = False, start: int | None = None, fin: int | None = None)", "symbol_type": "function"}, {"docstring": "Create/update atom coordinates from internal coordinates.\n\n:param verbose bool: default False\n    describe runtime problems\n\n:raises Exception: if any chain does not have .pic attribute", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Model.py", "line_number": 71, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Model", "name": "internal_to_atom_coordinates", "signature": "(self, verbose: bool = False) -> None", "symbol_type": "function"}, {"docstring": "Create/update atom coordinates from internal coordinates.\n\n:param verbose bool: default False\n    describe runtime problems\n\n:raises Exception: if any chain does not have .internal_coord attribute", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Structure.py", "line_number": 61, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Structure", "name": "internal_to_atom_coordinates", "signature": "(self, verbose: bool = False) -> None", "symbol_type": "function"}, {"docstring": "Process IC data to Residue/Atom coords.\n\n:param bool verbose: default False.\n    Describe runtime problems\n:param int start,fin:\n    Optional sequence positions for begin, end of subregion\n    to process.\n\n.. note::\n    Setting start or fin activates serial :meth:`.assemble_residues_ser`\n    instead of (Numpy parallel) :meth:`.assemble_residues`.\n    Start C-alpha will be at origin.\n\n.. seealso::\n    :data:`ParallelAssembleResidues`", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 1549, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "internal_to_atom_coordinates", "signature": "(self, verbose: bool = False, start: int | None = None, fin: int | None = None) -> None", "symbol_type": "function"}], "intervention_analysis": [{"docstring": "Analyze effects of interventions on life courses.\n\nCompares pre- and post-intervention event patterns and outcomes.\n\nArgs:\n    sequences: Event sequences (must not be empty)\n    intervention_time: Time point of intervention (timestamp or numeric)\n    pre_intervention_outcomes: Outcomes before intervention (must match sequence length if provided)\n    post_intervention_outcomes: Outcomes after intervention (must match sequence length if provided)\n    output_dir: Output directory\n    \nReturns:\n    Dictionary with intervention analysis results including pre/post statistics and outcome changes\n    \nRaises:\n    ValueError: If sequences is empty or outcome arrays don't match sequence length\n    \nExamples:\n    >>> from metainformant.life_events import EventSequence, Event, intervention_analysis\n    >>> from datetime import datetime\n    >>> seq = EventSequence(\"p1\", [Event(\"degree\", datetime(2010, 1, 1), \"education\")])\n    >>> results = intervention_analysis([seq], intervention_time=datetime(2015, 1, 1).timestamp())\n    >>> \"pre_intervention\" in results\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/workflow.py", "line_number": 325, "module": "src.metainformant.life_events.workflow", "name": "intervention_analysis", "signature": "(sequences: List[EventSequence], intervention_time: float, pre_intervention_outcomes: Optional[NDArray] = None, post_intervention_outcomes: Optional[NDArray] = None, output_dir: Optional[str | Path] = None) -> Dict[str, Any]", "symbol_type": "function"}], "inverse_indices": [{"docstring": "Return the alignment column index for each letter in each sequence.\n\nThis property returns a list of 1D NumPy arrays; the number of arrays\nis equal to the number of aligned sequences, and the length of each\narray is equal to the length of the corresponding sequence. For each\nletter in each sequence, the array contains the corresponding column\nindex in the alignment. Letters not included in the alignment are\nindicated by -1.\n\nFor example,\n\n>>> from Bio import Align\n>>> aligner = Align.PairwiseAligner()\n>>> aligner.mode = \"local\"\n\n>>> alignments = aligner.align(\"GAACTGG\", \"AATG\")\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            1 AACTG 6\n                  0 ||-|| 5\nquery             0 AA-TG 4\n<BLANKLINE>\n>>> alignment.inverse_indices\n[array([-1,  0,  1,  2,  3,  4, -1]), array([0, 1, 3, 4])]\n>>> alignment = alignments[1]\n>>> print(alignment)\ntarget            2 ACTG 6\n                  0 |.|| 4\nquery             0 AATG 4\n<BLANKLINE>\n>>> alignment.inverse_indices\n[array([-1, -1,  0,  1,  2,  3, -1]), array([0, 1, 2, 3])]\n>>> alignments = aligner.align(\"GAACTGG\", \"CATT\", strand=\"-\")\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            1 AACTG 6\n                  0 ||-|| 5\nquery             4 AA-TG 0\n<BLANKLINE>\n>>> alignment.inverse_indices\n[array([-1,  0,  1,  2,  3,  4, -1]), array([4, 3, 1, 0])]\n>>> alignment = alignments[1]\n>>> print(alignment)\ntarget            2 ACTG 6\n                  0 |.|| 4\nquery             4 AATG 0\n<BLANKLINE>\n>>> alignment.inverse_indices\n[array([-1, -1,  0,  1,  2,  3, -1]), array([3, 2, 1, 0])]", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 3196, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "inverse_indices", "signature": "(self)", "symbol_type": "function"}], "invert": [{"docstring": "Return all character indices that are not in charlist.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 2064, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "invert", "signature": "(self, charlist)", "symbol_type": "function"}], "isDomainInEv": [{"docstring": "Return true if the domain is in the ASTRAL clusters for evalues.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 882, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "isDomainInEv", "signature": "(self, dom, id)", "symbol_type": "function"}], "isDomainInId": [{"docstring": "Return true if the domain is in the astral clusters for percent ID.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 878, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "isDomainInId", "signature": "(self, dom, id)", "symbol_type": "function"}], "is_3overhang": [{"docstring": "Return if the enzyme produces 3' overhanging ends.\n\nTrue if the enzyme produces 3' overhang sticky end.\n\nRelated methods:\n\n- RE.is_5overhang()\n- RE.is_blunt()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1083, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_3overhang", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the enzyme produces 3' overhanging ends.\n\nTrue if the enzyme produces 3' overhang sticky end.\n\nRelated methods:\n\n- RE.is_5overhang()\n- RE.is_blunt()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1211, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_3overhang", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the enzyme produces 3' overhanging ends.\n\nTrue if the enzyme produces 3' overhang sticky end.\n\nRelated methods:\n\n- RE.is_5overhang()\n- RE.is_blunt()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1341, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_3overhang", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the enzyme produces 3' overhanging ends.\n\nTrue if the enzyme produces 3' overhang sticky end.\n\nRelated methods:\n\n- RE.is_5overhang()\n- RE.is_blunt()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1474, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_3overhang", "signature": "(cls)", "symbol_type": "function"}], "is_5overhang": [{"docstring": "Return if the enzymes produces 5' overhanging ends.\n\nTrue if the enzyme produces 5' overhang sticky end.\n\nRelated methods:\n\n- RE.is_3overhang()\n- RE.is_blunt()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1068, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_5overhang", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the enzymes produces 5' overhanging ends.\n\nTrue if the enzyme produces 5' overhang sticky end.\n\nRelated methods:\n\n- RE.is_3overhang()\n- RE.is_blunt()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1196, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_5overhang", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the enzymes produces 5' overhanging ends.\n\nTrue if the enzyme produces 5' overhang sticky end.\n\nRelated methods:\n\n- RE.is_3overhang()\n- RE.is_blunt()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1326, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_5overhang", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the enzymes produces 5' overhanging ends.\n\nTrue if the enzyme produces 5' overhang sticky end.\n\nRelated methods:\n\n- RE.is_3overhang()\n- RE.is_blunt()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1459, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_5overhang", "signature": "(cls)", "symbol_type": "function"}], "is_aa": [{"docstring": "Return True if residue object/string is an amino acid.\n\n:param residue: a L{Residue} object OR a three letter amino acid code\n:type residue: L{Residue} or string\n\n:param standard: flag to check for the 20 AA (default false)\n:type standard: boolean\n\n>>> is_aa('ALA')\nTrue\n\nKnown three letter codes for modified amino acids are supported,\n\n>>> is_aa('FME')\nTrue\n>>> is_aa('FME', standard=True)\nFalse", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Polypeptide.py", "line_number": 127, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Polypeptide", "name": "is_aa", "signature": "(residue, standard = False)", "symbol_type": "function"}], "is_aligned_seq": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 250, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "is_aligned_seq", "signature": "(elem)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 263, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "is_aligned_seq", "signature": "(elem)", "symbol_type": "function"}], "is_ambiguous": [{"docstring": "Return if recognition sequence and cut may be ambiguous.\n\nTrue if the sequence recognised and cut is ambiguous,\ni.e. the recognition site is degenerated AND/OR the enzyme cut outside\nthe site.\n\nRelated methods:\n\n- RE.is_defined()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1550, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_ambiguous", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if recognition sequence and cut may be ambiguous.\n\nTrue if the sequence recognised and cut is ambiguous,\ni.e. the recognition site is degenerated AND/OR the enzyme cut outside\nthe site.\n\nRelated methods:\n\n- RE.is_defined()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1671, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_ambiguous", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if recognition sequence and cut may be ambiguous.\n\nTrue if the sequence recognised and cut is ambiguous,\ni.e. the recognition site is degenerated AND/OR the enzyme cut outside\nthe site.\n\nRelated methods:\n\n- RE.is_defined()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1837, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_ambiguous", "signature": "(cls)", "symbol_type": "function"}], "is_backbone": [{"docstring": "Report True for contains only N, C, CA, O, H atoms.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4032, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "is_backbone", "signature": "(self) -> bool", "symbol_type": "function"}, {"docstring": "Return True if is N, C, CA, O, or H.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4762, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "is_backbone", "signature": "(self) -> bool", "symbol_type": "function"}], "is_bifurcating": [{"docstring": "Return True if tree downstream of node is strictly bifurcating.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 518, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "is_bifurcating", "signature": "(self, node = None)", "symbol_type": "function"}, {"docstring": "Return True if tree downstream of node is strictly bifurcating.\n\nI.e., all nodes have either 2 or 0 children (internal or external,\nrespectively). The root may have 3 descendents and still be considered\npart of a bifurcating tree, because it has no ancestor.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 499, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "is_bifurcating", "signature": "(self)", "symbol_type": "function"}], "is_blunt": [{"docstring": "Return if the enzyme produces blunt ends.\n\nTrue if the enzyme produces blunt end.\n\nRelated methods:\n\n- RE.is_3overhang()\n- RE.is_5overhang()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1053, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_blunt", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the enzyme produces blunt ends.\n\nTrue if the enzyme produces blunt end.\n\nRelated methods:\n\n- RE.is_3overhang()\n- RE.is_5overhang()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1181, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_blunt", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the enzyme produces blunt ends.\n\nTrue if the enzyme produces blunt end.\n\nRelated methods:\n\n- RE.is_3overhang()\n- RE.is_5overhang()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1311, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_blunt", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the enzyme produces blunt ends.\n\nTrue if the enzyme produces blunt end.\n\nRelated methods:\n\n- RE.is_3overhang()\n- RE.is_5overhang()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1444, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_blunt", "signature": "(cls)", "symbol_type": "function"}], "is_comm": [{"docstring": "Return if enzyme is commercially available.\n\nTrue if RE has suppliers.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1940, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_comm", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if enzyme is commercially available.\n\nTrue if RE has suppliers.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1973, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_comm", "signature": "(cls)", "symbol_type": "function"}], "is_compatible": [{"docstring": "Compare branches with support>threshold for compatibility.\n\nresult = is_compatible(self,tree2,threshold)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 422, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "is_compatible", "signature": "(self, tree2, threshold, strict = True)", "symbol_type": "function"}], "is_defined": [{"docstring": "Return if recognition sequence and cut are defined.\n\nTrue if the sequence recognised and cut is constant,\ni.e. the recognition site is not degenerated AND the enzyme cut inside\nthe site.\n\nRelated methods:\n\n- RE.is_ambiguous()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1534, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_defined", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if recognition sequence and cut are defined.\n\nTrue if the sequence recognised and cut is constant,\ni.e. the recognition site is not degenerated AND the enzyme cut inside\nthe site.\n\nRelated methods:\n\n- RE.is_ambiguous()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1655, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_defined", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if recognition sequence and cut are defined.\n\nTrue if the sequence recognised and cut is constant,\ni.e. the recognition site is not degenerated AND the enzyme cut inside\nthe site.\n\nRelated methods:\n\n- RE.is_ambiguous()\n- RE.is_unknown()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1821, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_defined", "signature": "(cls)", "symbol_type": "function"}], "is_disordered": [{"docstring": "Return the disordered flag (1 if disordered, 0 otherwise).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 368, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "is_disordered", "signature": "(self) -> int", "symbol_type": "function"}, {"docstring": "Return 2, indicating that this Entity is a collection of Entities.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 570, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "is_disordered", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return 1 if the residue contains disordered atoms.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Residue.py", "line_number": 91, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Residue", "name": "is_disordered", "signature": "(self)", "symbol_type": "function"}], "is_equischizomer": [{"docstring": "Test for real isoschizomer.\n\nTrue if other is an isoschizomer of RE, but not an neoschizomer,\nelse False.\n\nEquischizomer: same site, same position of restriction.\n\n>>> from Bio.Restriction import SacI, SstI, SmaI, XmaI\n>>> SacI.is_equischizomer(SstI)\nTrue\n>>> SmaI.is_equischizomer(XmaI)\nFalse", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 577, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_equischizomer", "signature": "(cls, other)", "symbol_type": "function"}], "is_even": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 254, "module": "tests.test_core_validation", "name": "is_even", "signature": "(x)", "symbol_type": "function"}], "is_getfastq_output_present": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 562, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "is_getfastq_output_present", "signature": "(sra_stat)", "symbol_type": "function"}], "is_identical": [{"docstring": "Compare tree and tree2 for identity.\n\nresult = is_identical(self,tree2)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 415, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "is_identical", "signature": "(self, tree2)", "symbol_type": "function"}], "is_in_bounds": [{"docstring": "Check if given value is within the region selected for drawing.\n\nArguments:\n - value - A base position", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_AbstractDrawer.py", "line_number": 540, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._AbstractDrawer", "name": "is_in_bounds", "signature": "(self, value)", "symbol_type": "function"}], "is_internal": [{"docstring": "Return True if node is an internal node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 334, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "is_internal", "signature": "(self, node)", "symbol_type": "function"}], "is_isoschizomer": [{"docstring": "Test for same recognition site.\n\nTrue if other has the same recognition site, else False.\n\nIsoschizomer: same site.\n\n>>> from Bio.Restriction import SacI, SstI, SmaI, XmaI\n>>> SacI.is_isoschizomer(SstI)\nTrue\n>>> SmaI.is_isoschizomer(XmaI)\nTrue", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 604, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_isoschizomer", "signature": "(cls, other)", "symbol_type": "function"}], "is_json_validation_enabled": [{"docstring": "Returns true if JSON schema validation is enabled for the specified\nvalidation keyword. This can be used to skip JSON schema structural validation\nas requested in the configuration.\n\nArgs:\n    schema_keyword (string): the name of a JSON schema validation keyword.\n    configuration (Configuration): the configuration class.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 882, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "is_json_validation_enabled", "signature": "(schema_keyword, configuration = None)", "symbol_type": "function"}], "is_linear": [{"docstring": "Return if sequence is linear (True) or circular (False).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 211, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_linear", "signature": "(self)", "symbol_type": "function"}], "is_matching_elem": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 374, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "is_matching_elem", "signature": "(elem)", "symbol_type": "function"}], "is_methylable": [{"docstring": "Return if recognition site can be methylated.\n\nTrue if the recognition site is a methylable.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 931, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_methylable", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if recognition site can be methylated.\n\nTrue if the recognition site is a methylable.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 946, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_methylable", "signature": "(cls)", "symbol_type": "function"}], "is_monophyletic": [{"docstring": "Return node_id of common ancestor if taxon_list is monophyletic, -1 otherwise.\n\nresult = is_monophyletic(self,taxon_list)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 497, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "is_monophyletic", "signature": "(self, taxon_list)", "symbol_type": "function"}, {"docstring": "MRCA of terminals if they comprise a complete subclade, or False.\n\nI.e., there exists a clade such that its terminals are the same set as\nthe given targets.\n\nThe given targets must be terminals of the tree.\n\nTo match both ``Bio.Nexus.Trees`` and the other multi-target methods in\nBio.Phylo, arguments to this method can be specified either of two ways:\n(i) as a single list of targets, or (ii) separately specified targets,\ne.g. is_monophyletic(t1, t2, t3) -- but not both.\n\nFor convenience, this method returns the common ancestor (MCRA) of the\ntargets if they are monophyletic (instead of the value True), and False\notherwise.\n\n:returns: common ancestor if terminals are monophyletic, otherwise False.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 522, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "is_monophyletic", "signature": "(self, terminals, *more_terminals)", "symbol_type": "function"}], "is_neoschizomer": [{"docstring": "Test for neoschizomer.\n\nTrue if other is an isoschizomer of RE, else False.\nNeoschizomer: same site, different position of restriction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 595, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_neoschizomer", "signature": "(cls, other)", "symbol_type": "function"}], "is_nucleic": [{"docstring": "Return True if residue object/string is a nucleic acid.\n\n:param residue: a L{Residue} object OR a three letter code\n:type residue: L{Residue} or string\n\n:param standard: flag to check for the 8 (DNA + RNA) canonical bases.\n    Default is False.\n:type standard: boolean\n\n>>> is_nucleic('DA ')\nTrue\n\n>>> is_nucleic('A  ')\nTrue\n\nKnown three letter codes for modified nucleotides are supported,\n\n>>> is_nucleic('A2L')\nTrue\n>>> is_nucleic('A2L', standard=True)\nFalse", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Polypeptide.py", "line_number": 155, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Polypeptide", "name": "is_nucleic", "signature": "(residue, standard = False)", "symbol_type": "function"}], "is_palindromic": [{"docstring": "Return if the enzyme has a palindromic recognition site.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 981, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_palindromic", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if the enzyme has a palindromic recognition site.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1023, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_palindromic", "signature": "(cls)", "symbol_type": "function"}], "is_parent_of": [{"docstring": "Check if grandchild is a subnode of parent.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 103, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "is_parent_of", "signature": "(self, parent, grandchild)", "symbol_type": "function"}, {"docstring": "Check if target is a descendent of this tree.\n\nNot required to be a direct descendent.\n\nTo check only direct descendents of a clade, simply use list membership\ntesting: ``if subclade in clade: ...``", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 555, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "is_parent_of", "signature": "(self, target = None, **kwargs)", "symbol_type": "function"}], "is_pathlike": [{"docstring": "Test if the given object can be accepted as a path.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/__init__.py", "line_number": 1000, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.__init__", "name": "is_pathlike", "signature": "(obj)", "symbol_type": "function"}], "is_plotly_available": [{"docstring": "Check if Plotly is available.\n\nReturns:\n    True if Plotly is installed\n\nExample:\n    >>> from metainformant.visualization.interactive import is_plotly_available\n    >>> if is_plotly_available():\n    ...     fig = create_interactive_scatter([1, 2, 3], [4, 5, 6])", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/interactive.py", "line_number": 149, "module": "src.metainformant.visualization.interactive", "name": "is_plotly_available", "signature": "() -> bool", "symbol_type": "function"}], "is_positive": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 240, "module": "tests.test_core_validation", "name": "is_positive", "signature": "(x)", "symbol_type": "function"}], "is_preterminal": [{"docstring": "Return True if all successors of a node are terminal ones.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 338, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "is_preterminal", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": "Check if all direct descendents are terminal.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 565, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "is_preterminal", "signature": "(self)", "symbol_type": "function"}], "is_reactant": [{"docstring": "Return true if this Entry participates in any reaction in its parent pathway.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 410, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "is_reactant", "signature": "(self)", "symbol_type": "function"}], "is_restriction": [{"docstring": "Return if enzyme (name) is a known enzyme.\n\nTrue if y or eval(y) is a RestrictionType.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2149, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_restriction", "signature": "(self, y)", "symbol_type": "function"}], "is_safe_path": [{"docstring": "Check if path is safe (no path traversal attempts).\n\nArgs:\n    path: Path string to check\n\nReturns:\n    True if path appears safe", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 41, "module": "src.metainformant.core.paths", "name": "is_safe_path", "signature": "(path: str) -> bool", "symbol_type": "function"}], "is_terminal": [{"docstring": "Return True if node is a terminal node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 330, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "is_terminal", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": "Check if the root of this tree is terminal.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 940, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "is_terminal", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Check if this is a terminal (leaf) node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 1053, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "is_terminal", "signature": "(self)", "symbol_type": "function"}], "is_there_unpaired_file": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 469, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "is_there_unpaired_file", "signature": "(sra_stat, extensions)", "symbol_type": "function"}], "is_type_nullable": [{"docstring": "Returns true if None is an allowed value for the specified input_type.\n\nA type is nullable if at least one of the following conditions is true:\n1. The OAS 'nullable' attribute has been specified,\n1. The type is the 'null' type,\n1. The type is a anyOf/oneOf composed schema, and a child schema is\n   the 'null' type.\nArgs:\n    input_type (type): the class of the input_value that we are\n        checking\nReturns:\n    bool", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1470, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "is_type_nullable", "signature": "(input_type)", "symbol_type": "function"}], "is_unknown": [{"docstring": "Return if recognition sequence is unknown.\n\nTrue if the sequence is unknown,\ni.e. the recognition site has not been characterised yet.\n\nRelated methods:\n\n- RE.is_defined()\n- RE.is_ambiguous()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1566, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_unknown", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if recognition sequence is unknown.\n\nTrue if the sequence is unknown,\ni.e. the recognition site has not been characterised yet.\n\nRelated methods:\n\n- RE.is_defined()\n- RE.is_ambiguous()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1687, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_unknown", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return if recognition sequence is unknown.\n\nTrue if the sequence is unknown,\ni.e. the recognition site has not been characterised yet.\n\nRelated methods:\n\n- RE.is_defined()\n- RE.is_ambiguous()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1853, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "is_unknown", "signature": "(cls)", "symbol_type": "function"}], "is_valid_assembly_accession": [{"docstring": "Return True if the string looks like a valid NCBI assembly accession.\n\nExamples: GCF_000001405.39, GCA_000001405", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/genomes.py", "line_number": 8, "module": "src.metainformant.dna.genomes", "name": "is_valid_assembly_accession", "signature": "(accession: str) -> bool", "symbol_type": "function"}], "is_valid_protein_sequence": [{"docstring": "Check if sequence contains only valid amino acid characters.\n\nArgs:\n    seq: Protein sequence string\n    \nReturns:\n    True if sequence contains only valid amino acids, False otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/sequences.py", "line_number": 38, "module": "src.metainformant.protein.sequences", "name": "is_valid_protein_sequence", "signature": "(seq: str) -> bool", "symbol_type": "function"}], "is_valid_type": [{"docstring": "Args:\n    input_class_simple (class): the class of the input_value that we are\n        checking\n    valid_classes (tuple): the valid classes that the current item\n        should be\nReturns:\n    bool", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1498, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "is_valid_type", "signature": "(input_class_simple, valid_classes)", "symbol_type": "function"}], "is_within": [{"docstring": "Return True if path is inside parent directory (after resolving).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 11, "module": "src.metainformant.core.paths", "name": "is_within", "signature": "(path: str | Path, parent: str | Path) -> bool", "symbol_type": "function"}], "is_zipped": [{"docstring": "Return True if the dataset is stored in a zip file", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 127, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "is_zipped", "signature": "(self) -> bool", "symbol_type": "function"}], "isatty": [{"docstring": "Return True if connected to a TTY device.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 777, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "isatty", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return True if connected to a TTY device.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 912, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "isatty", "signature": "(self)", "symbol_type": "function"}], "iscompatible": [{"docstring": "Check if current bitstr1 is compatible with another bitstr2.\n\nTwo conditions are considered as compatible:\n 1. bitstr1.contain(bitstr2) or vice versa;\n 2. bitstr1.independent(bitstr2).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/Consensus.py", "line_number": 208, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.Consensus", "name": "iscompatible", "signature": "(self, other)", "symbol_type": "function"}], "island_model_update": [{"docstring": "Calculate allele frequency after one generation of Wright's island model.\n\nThe island model describes migration between a local population and a\nlarge migrant pool. Local frequency changes due to migration from the\nmigrant pool.\n\nArgs:\n    local_frequency: Current local allele A frequency (p)\n    migration_rate: Fraction of population replaced by migrants per generation (m)\n    migrant_pool_frequency: Allele A frequency in migrant pool (p_m)\n    \nReturns:\n    New local allele frequency after migration. All inputs clamped to [0, 1].\n    Formula: p' = (1 - m) \u00d7 p + m \u00d7 p_m\n    \nExamples:\n    >>> island_model_update(local_frequency=0.2, migration_rate=0.1, migrant_pool_frequency=0.5)\n    0.23\n    \nReferences:\n    Wright, S. (1931). Evolution in Mendelian populations. Genetics,\n    16(2), 97-159.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 273, "module": "src.metainformant.math.popgen", "name": "island_model_update", "signature": "(local_frequency: float, migration_rate: float, migrant_pool_frequency: float) -> float", "symbol_type": "function"}], "islower": [{"docstring": "Return True if all ASCII characters in data are lowercase.\n\nIf there are no cased characters, the method returns False.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 320, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "islower", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return True if all ASCII characters in data are lowercase.\n\nIf there are no cased characters, the method returns False.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1516, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "islower", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return True if all ASCII characters in data are lowercase.\n\nIf there are no cased characters, the method returns False.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2431, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "islower", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return True if all ASCII characters in data are lowercase.\n\nIf there are no cased characters, the method returns False.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2637, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "islower", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return True if all ASCII characters in the record's sequence are lowercase.\n\nIf there are no cased characters, the method returns False.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 1195, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "islower", "signature": "(self)", "symbol_type": "function"}], "isoelectric_point": [{"docstring": "Calculate the isoelectric point.\n\nUses the module IsoelectricPoint to calculate the pI of a protein.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/ProtParam.py", "line_number": 310, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.ProtParam", "name": "isoelectric_point", "signature": "(self)", "symbol_type": "function"}], "isolated_tmp_dir": [{"docstring": "Provide a clean temporary directory for each test function.\n\nThis fixture ensures complete isolation between tests by providing\na fresh temporary directory that is automatically cleaned up.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 41, "module": "tests.conftest", "name": "isolated_tmp_dir", "signature": "() -> Iterator[Path]", "symbol_type": "function"}], "isoschizomers": [{"docstring": "List all isoschizomers of the enzyme.\n\nReturn a tuple of all the equischizomers and neoschizomers of RE.\nIf batch is supplied it is used instead of the default AllEnzymes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 652, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "isoschizomers", "signature": "(cls, batch = None)", "symbol_type": "function"}], "isupper": [{"docstring": "Return True if all ASCII characters in data are uppercase.\n\nIf there are no cased characters, the method returns False.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 313, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "isupper", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return True if all ASCII characters in data are uppercase.\n\nIf there are no cased characters, the method returns False.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1509, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "isupper", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return True if all ASCII characters in data are uppercase.\n\nIf there are no cased characters, the method returns False.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2423, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "isupper", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return True if all ASCII characters in data are uppercase.\n\nIf there are no cased characters, the method returns False.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2629, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "isupper", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return True if all ASCII characters in the record's sequence are uppercase.\n\nIf there are no cased characters, the method returns False.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 1188, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "isupper", "signature": "(self)", "symbol_type": "function"}], "items": [{"docstring": "Return an iterator of (key, value) pairs in the array.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/substitution_matrices/__init__.py", "line_number": 268, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.substitution_matrices.__init__", "name": "items", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return Event's items.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 777, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "items", "signature": "(self)", "symbol_type": "function"}, {"docstring": "List of tuples of Hit IDs and Hit objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 221, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "items", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Iterate over (namespace, BioSeqDatabase) in the database.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 224, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "items", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Iterate over (id, DBSeqRecord) for the namespace (sub database).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 763, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "items", "signature": "(self)", "symbol_type": "function"}], "iter_fastq": [{"docstring": "Yield FASTQ records as (read_id, sequence, quality).\n\n- Supports plain text and ``.gz`` files\n- Minimal validation (``@`` on header, ``+`` separator); skips incomplete trailing records\n- Quality string is not validated beyond length consistency with sequence", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/fastq.py", "line_number": 59, "module": "src.metainformant.dna.fastq", "name": "iter_fastq", "signature": "(path: Path | str) -> Iterator[Tuple[str, str, str]]", "symbol_type": "function"}], "iterate_reply": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/metadata/genome.py", "line_number": 137, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.metadata.genome", "name": "iterate_reply", "signature": "(genome_api_func, func_arg, **kwargs)", "symbol_type": "function"}], "iterhit_keys": [{"docstring": "Return an iterator over the ID of the Hit objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 229, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "iterhit_keys", "signature": "(self)", "symbol_type": "function"}], "iterhits": [{"docstring": "Return an iterator over the Hit objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 225, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "iterhits", "signature": "(self)", "symbol_type": "function"}], "iteritems": [{"docstring": "Return an iterator yielding tuples of Hit ID and Hit objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 233, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "iteritems", "signature": "(self)", "symbol_type": "function"}], "jaccard_similarity": [{"docstring": "Calculate Jaccard similarity coefficient between two sites.\n\nJ = |A \u2229 B| / |A \u222a B|\n\nArgs:\n    site1, site2: Species abundance vectors\n    presence_threshold: Minimum abundance to consider species present\n\nReturns:\n    Jaccard similarity coefficient (0-1)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/community.py", "line_number": 138, "module": "src.metainformant.ecology.community", "name": "jaccard_similarity", "signature": "(site1: Sequence[float], site2: Sequence[float], presence_threshold: float = 0.0) -> float", "symbol_type": "function"}], "jc69_distance": [{"docstring": "Jukes-Cantor 69 distance from p-distance.\n\nd = -3/4 * ln(1 - 4/3 * p)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/distances.py", "line_number": 19, "module": "src.metainformant.dna.distances", "name": "jc69_distance", "signature": "(s1: str, s2: str) -> float", "symbol_type": "function"}], "jensen_shannon_divergence": [{"docstring": "Calculate Jensen-Shannon divergence between two probability distributions.\n\nJS divergence is a symmetrized version of Kullback-Leibler divergence,\nmeasuring the distance between two probability distributions. Always\nbounded in [0, 1] when using log base 2.\n\nArgs:\n    p: First probability distribution (list of probabilities)\n    q: Second probability distribution (must have same length as p)\n    base: Logarithm base\n    \nReturns:\n    Jensen-Shannon divergence. Returns 0.0 if distributions are identical\n    or if either distribution sums to zero.\n    Formula: JS(P||Q) = H(M) - [H(P) + H(Q)]/2 where M = (P+Q)/2\n    \nExamples:\n    >>> p = [0.5, 0.5]\n    >>> q = [0.5, 0.5]\n    >>> jensen_shannon_divergence(p, q)\n    0.0  # Identical distributions\n    \n    >>> p = [1.0, 0.0]\n    >>> q = [0.0, 1.0]\n    >>> js = jensen_shannon_divergence(p, q)\n    >>> js > 0.0  # Divergent distributions\n    True\n    \nRaises:\n    ValueError: If distributions have different lengths\n    \nReferences:\n    Lin, J. (1991). Divergence measures based on the Shannon entropy.\n    IEEE Transactions on Information Theory, 37(1), 145-151.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 489, "module": "src.metainformant.information.syntactic", "name": "jensen_shannon_divergence", "signature": "(p: Sequence[float], q: Sequence[float], base: float = 2.0) -> float", "symbol_type": "function"}, {"docstring": "Calculate Jensen-Shannon divergence between two probability distributions.\n\nJS divergence is a symmetrized version of Kullback-Leibler divergence,\nmeasuring the distance between two probability distributions. Always\nbounded in [0, 1] when using log base 2.\n\nArgs:\n    p: First probability distribution (list of probabilities)\n    q: Second probability distribution (must have same length as p)\n    \nReturns:\n    Jensen-Shannon divergence. Returns 0.0 if distributions are identical\n    or if either distribution sums to zero.\n    Formula: JS(P||Q) = H(M) - [H(P) + H(Q)]/2 where M = (P+Q)/2\n    \nExamples:\n    >>> p = [0.5, 0.5]\n    >>> q = [0.5, 0.5]\n    >>> jensen_shannon_divergence(p, q)\n    0.0  # Identical distributions\n    \n    >>> p = [1.0, 0.0]\n    >>> q = [0.0, 1.0]\n    >>> js = jensen_shannon_divergence(p, q)\n    >>> js > 0.0  # Divergent distributions\n    True\n    \nRaises:\n    ValueError: If distributions have different lengths\n    \nReferences:\n    Lin, J. (1991). Divergence measures based on the Shannon entropy.\n    IEEE Transactions on Information Theory, 37(1), 145-151.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/__init__.py", "line_number": 487, "module": "src.metainformant.math.__init__", "name": "jensen_shannon_divergence", "signature": "(p: list[float], q: list[float]) -> float", "symbol_type": "function"}], "join": [{"docstring": "Return a merge of the sequences in other, spaced by the sequence from self.\n\nAccepts a Seq object, MutableSeq object, or string (and iterates over\nthe letters), or an iterable containing Seq, MutableSeq, or string\nobjects. These arguments will be concatenated with the calling sequence\nas the spacer:\n\n>>> concatenated = Seq('NNNNN').join([Seq(\"AAA\"), Seq(\"TTT\"), Seq(\"PPP\")])\n>>> concatenated\nSeq('AAANNNNNTTTNNNNNPPP')\n\nJoining the letters of a single sequence:\n\n>>> Seq('NNNNN').join(Seq(\"ACGT\"))\nSeq('ANNNNNCNNNNNGNNNNNT')\n>>> Seq('NNNNN').join(\"ACGT\")\nSeq('ANNNNNCNNNNNGNNNNNT')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1916, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "join", "signature": "(self, other)", "symbol_type": "function"}], "joint_entropy": [{"docstring": "Calculate joint entropy of two random variables.\n\nMeasures the total uncertainty in the joint distribution of X and Y.\n\nArgs:\n    joint_probs: Joint probability distribution as dictionary of\n        (x, y) -> probability pairs, or 2D array\n    base: Logarithm base\n    \nReturns:\n    Joint entropy H(X, Y)\n    \nExamples:\n    >>> joint_entropy({(0, 0): 0.25, (0, 1): 0.25, (1, 0): 0.25, (1, 1): 0.25})\n    2.0  # Independent variables, maximum entropy", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 82, "module": "src.metainformant.information.syntactic", "name": "joint_entropy", "signature": "(joint_probs: dict[tuple[Any, Any], float] | np.ndarray, base: float = 2.0) -> float", "symbol_type": "function"}], "joint_nmf": [{"docstring": "Perform joint Non-negative Matrix Factorization across omics layers.\n\nFactorizes each omics layer X_i \u2248 W * H_i where W (sample factors) is shared\nacross all layers and H_i (feature factors) are layer-specific. Uses alternating\noptimization with L2 regularization.\n\nArgs:\n    omics_data: Multi-omics data object with aligned samples. All data\n        must be non-negative (will be shifted if needed)\n    n_components: Number of latent factors (components) to extract\n    max_iter: Maximum number of optimization iterations\n    regularization: L2 regularization strength for factors (default 0.01)\n    random_state: Random seed for reproducible initialization\n    \nReturns:\n    Tuple containing:\n    - sample_factors: Shared sample factor matrix W of shape (n_samples, n_components)\n    - layer_feature_factors: Dictionary mapping layer names to feature factor\n      matrices H_i of shape (n_components, n_features_in_layer)\n      \nExamples:\n    >>> W, H = joint_nmf(omics_data, n_components=10, random_state=42)\n    >>> W.shape\n    (100, 10)\n    >>> H[\"transcriptomics\"].shape\n    (10, 200)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 434, "module": "src.metainformant.multiomics.integration", "name": "joint_nmf", "signature": "(omics_data: MultiOmicsData, n_components: int = 20, max_iter: int = 200, regularization: float = 0.01, random_state: Optional[int] = None) -> Tuple[np.ndarray, Dict[str, np.ndarray]]", "symbol_type": "function"}], "joint_pca": [{"docstring": "Perform joint Principal Component Analysis across multiple omics layers.\n\nConcatenates features from all omics layers (optionally weighted and standardized)\nand performs PCA on the combined feature space. Returns joint embeddings and\nlayer-specific loadings.\n\nArgs:\n    omics_data: Multi-omics data object with aligned samples\n    n_components: Number of principal components to extract\n    layer_weights: Optional dictionary mapping layer names to relative weights.\n        If None, all layers weighted equally (1.0). Weights are applied as\n        sqrt(weight) scaling before concatenation.\n    standardize: If True (default), features are z-score standardized\n        (mean 0, std 1) per layer before concatenation\n        \nReturns:\n    Tuple containing:\n    - joint_embeddings: Array of shape (n_samples, n_components) with joint\n      low-dimensional representation\n    - layer_loadings: Dictionary mapping layer names to loading matrices\n      of shape (n_features_in_layer, n_components)\n    - explained_variance: Array of explained variance ratios for each component\n    \nExamples:\n    >>> embeddings, loadings, var = joint_pca(omics_data, n_components=10)\n    >>> embeddings.shape\n    (100, 10)\n    >>> \"genomics\" in loadings\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 340, "module": "src.metainformant.multiomics.integration", "name": "joint_pca", "signature": "(omics_data: MultiOmicsData, n_components: int = 50, layer_weights: Optional[Dict[str, float]] = None, standardize: bool = True) -> Tuple[np.ndarray, Dict[str, np.ndarray], np.ndarray]", "symbol_type": "function"}], "journal": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 652, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "journal", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1032, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "journal", "signature": "(self, content)", "symbol_type": "function"}], "k_fold_split": [{"docstring": "Generate k-fold cross-validation splits.\n\nArgs:\n    X: Feature matrix\n    y: Target vector\n    k: Number of folds\n    random_state: Random seed\n    stratified: Whether to use stratified k-fold\n\nReturns:\n    List of (train_indices, val_indices) tuples", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/validation.py", "line_number": 67, "module": "src.metainformant.ml.validation", "name": "k_fold_split", "signature": "(X: np.ndarray, y: np.ndarray, k: int = 5, random_state: Optional[int] = None, stratified: bool = False) -> List[Tuple[np.ndarray, np.ndarray]]", "symbol_type": "function"}], "kcluster": [{"docstring": "Perform k-means clustering.\n\nThis function performs k-means clustering on the values in data, and\nreturns the cluster assignments, the within-cluster sum of distances\nof the optimal k-means clustering solution, and the number of times\nthe optimal solution was found.\n\nKeyword arguments:\n - data: nrows x ncolumns array containing the data values.\n - nclusters: number of clusters (the 'k' in k-means).\n - mask: nrows x ncolumns array of integers, showing which data\n   are missing. If mask[i,j]==0, then data[i,j] is missing.\n - weight: the weights to be used when calculating distances\n - transpose:\n   - if False: rows are clustered;\n   - if True: columns are clustered.\n - npass: number of times the k-means clustering algorithm is\n   performed, each time with a different (random) initial\n   condition.\n - method: specifies how the center of a cluster is found:\n   - method == 'a': arithmetic mean;\n   - method == 'm': median.\n - dist: specifies the distance function to be used:\n   - dist == 'e': Euclidean distance;\n   - dist == 'b': City Block distance;\n   - dist == 'c': Pearson correlation;\n   - dist == 'a': absolute value of the correlation;\n   - dist == 'u': uncentered correlation;\n   - dist == 'x': absolute uncentered correlation;\n   - dist == 's': Spearman's rank correlation;\n   - dist == 'k': Kendall's tau.\n - initialid: the initial clustering from which the algorithm\n   should start.\n   If initialid is None, the routine carries out npass\n   repetitions of the EM algorithm, each time starting from a\n   different random initial clustering. If initialid is given,\n   the routine carries out the EM algorithm only once, starting\n   from the given initial clustering and without randomizing the\n   order in which items are assigned to clusters (i.e., using\n   the same order as in the data matrix). In that case, the\n   k-means algorithm is fully deterministic.\n\nReturn values:\n - clusterid: array containing the index of the cluster to which each\n   item was assigned in the best k-means clustering solution that was\n   found in the npass runs;\n - error: the within-cluster sum of distances for the returned k-means\n   clustering solution;\n - nfound: the number of times this solution was found.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 104, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "kcluster", "signature": "(data, nclusters = 2, mask = None, weight = None, transpose = False, npass = 1, method = 'a', dist = 'e', initialid = None)", "symbol_type": "function"}, {"docstring": "Apply k-means or k-median clustering.\n\nThis method returns a tuple (clusterid, error, nfound).\n\nKeyword arguments:\n - nclusters: number of clusters (the 'k' in k-means)\n - transpose: if False, genes (rows) are clustered;\n              if True, samples (columns) are clustered.\n - npass: number of times the k-means clustering algorithm is\n   performed, each time with a different (random) initial condition.\n - method: specifies how the center of a cluster is found:\n   - method == 'a': arithmetic mean\n   - method == 'm': median\n - dist: specifies the distance function to be used:\n   - dist == 'e': Euclidean distance\n   - dist == 'b': City Block distance\n   - dist == 'c': Pearson correlation\n   - dist == 'a': absolute value of the correlation\n   - dist == 'u': uncentered correlation\n   - dist == 'x': absolute uncentered correlation\n   - dist == 's': Spearman's rank correlation\n   - dist == 'k': Kendall's tau\n - initialid: the initial clustering from which the algorithm should\n   start. If initialid is None, the routine carries out npass\n   repetitions of the EM algorithm, each time starting from a different\n   random initial clustering. If initialid is given, the routine\n   carries out the EM algorithm only once, starting from the given\n   initial clustering and without randomizing the order in which items\n   are assigned to clusters (i.e., using the same order as in the data\n   matrix). In that case, the k-means algorithm is fully deterministic.\n\nReturn values:\n - clusterid: array containing the number of the cluster to which each\n   gene/sample was assigned in the best k-means clustering\n   solution that was found in the npass runs;\n - error: the within-cluster sum of distances for the returned\n   k-means clustering solution;\n - nfound: the number of times this solution was found.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 773, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "kcluster", "signature": "(self, nclusters = 2, transpose = False, npass = 1, method = 'a', dist = 'e', initialid = None)", "symbol_type": "function"}], "kegg_conv": [{"docstring": "KEGG conv - convert KEGG identifiers to/from outside identifiers.\n\nArguments:\n - target_db - Target database\n - source_db_or_dbentries - source database or database entries\n - option - Can be \"turtle\" or \"n-triple\" (string).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/REST.py", "line_number": 228, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.REST", "name": "kegg_conv", "signature": "(target_db, source_db, option = None)", "symbol_type": "function"}], "kegg_find": [{"docstring": "KEGG find - Data search.\n\nFinds entries with matching query keywords or other query data in\na given database.\n\ndb - database or organism (string)\nquery - search terms (string)\noption - search option (string), see below.\n\nFor the compound and drug database, set option to the string 'formula',\n'exact_mass' or 'mol_weight' to search on that field only. The\nchemical formula search is a partial match irrespective of the order\nof atoms given. The exact mass (or molecular weight) is checked by\nrounding off to the same decimal place as the query data. A range of\nvalues may also be specified with the minus(-) sign.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/REST.py", "line_number": 145, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.REST", "name": "kegg_find", "signature": "(database, query, option = None)", "symbol_type": "function"}], "kegg_get": [{"docstring": "KEGG get - Data retrieval.\n\ndbentries - Identifiers (single string, or list of strings), see below.\noption - One of \"aaseq\", \"ntseq\", \"mol\", \"kcf\", \"image\", \"kgml\" (string)\n\nThe input is limited up to 10 entries.\nThe input is limited to one pathway entry with the image or kgml option.\nThe input is limited to one compound/glycan/drug entry with the image option.\n\nReturns a handle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/REST.py", "line_number": 192, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.REST", "name": "kegg_get", "signature": "(dbentries, option = None)", "symbol_type": "function"}], "kegg_info": [{"docstring": "KEGG info - Displays the current statistics of a given database.\n\ndb - database or organism (string)\n\nThe argument db can be a KEGG database name (e.g. 'pathway' or its\nofficial abbreviation, 'path'), or a KEGG organism code or T number\n(e.g. 'hsa' or 'T01001' for human).\n\nA valid list of organism codes and their T numbers can be obtained\nvia kegg_info('organism') or https://rest.kegg.jp/list/organism", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/REST.py", "line_number": 71, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.REST", "name": "kegg_info", "signature": "(database)", "symbol_type": "function"}], "kegg_link": [{"docstring": "KEGG link - find related entries by using database cross-references.\n\ntarget_db - Target database\nsource_db_or_dbentries - source database\noption - Can be \"turtle\" or \"n-triple\" (string).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/REST.py", "line_number": 293, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.REST", "name": "kegg_link", "signature": "(target_db, source_db, option = None)", "symbol_type": "function"}], "kegg_list": [{"docstring": "KEGG list - Entry list for database, or specified database entries.\n\ndb - database or organism (string)\norg - optional organism (string), see below.\n\nFor the pathway and module databases the optional organism can be\nused to restrict the results.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/REST.py", "line_number": 97, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.REST", "name": "kegg_list", "signature": "(database, org = None)", "symbol_type": "function"}], "key_fun": [{"docstring": "Sort on start position.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 1399, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "key_fun", "signature": "(f)", "symbol_type": "function"}], "keys": [{"docstring": "Return a tuple with the keys associated with the array.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/substitution_matrices/__init__.py", "line_number": 284, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.substitution_matrices.__init__", "name": "keys", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a list of the target.id of each hit.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/__init__.py", "line_number": 552, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.__init__", "name": "keys", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the list of residues.\n\n:return: list of residues for which the property was calculated\n:rtype: [(chain_id, res_id), (chain_id, res_id),...]", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/AbstractPropertyMap.py", "line_number": 67, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.AbstractPropertyMap", "name": "keys", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return Event's keys.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 781, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "keys", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a list with the names of the sequences in the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/TwoBitIO.py", "line_number": 257, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.TwoBitIO", "name": "keys", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Iterate over namespaces (sub-databases) in the database.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 215, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "keys", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Iterate over ids (which may not be meaningful outside this database).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 754, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "keys", "signature": "(self)", "symbol_type": "function"}], "keywords": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 523, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "keywords", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 983, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "keywords", "signature": "(self, content)", "symbol_type": "function"}], "kill": [{"docstring": "Kill a node from chain without caring to what it is connected.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 74, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "kill", "signature": "(self, id)", "symbol_type": "function"}], "kimura_2p_distance": [{"docstring": "Kimura 2-parameter distance model accounting for transitions/transversions.\n\nK = -0.5 * ln((1 - 2P - Q) * sqrt(1 - 2Q))\nwhere P = transition frequency, Q = transversion frequency", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/distances.py", "line_number": 31, "module": "src.metainformant.dna.distances", "name": "kimura_2p_distance", "signature": "(s1: str, s2: str) -> float", "symbol_type": "function"}], "kin_selection_response": [{"docstring": "Calculate Hamilton's rule for kin selection.\n\nHamilton's rule states that a trait will be favored by natural selection when\nthe genetic relatedness (r) times the benefit to the recipient (b) exceeds\nthe cost to the actor (c): r * b > c\n\nArgs:\n    relatedness: Genetic relatedness between actor and recipient (r)\n    benefit: Benefit to recipient (b)\n    cost: Cost to actor (c)\n    \nReturns:\n    Hamilton's rule value: r * b - c. Positive values indicate selection\n    favors the trait, negative values indicate selection against.\n    \nExamples:\n    >>> kin_selection_response(relatedness=0.5, benefit=0.4, cost=0.1)\n    0.1\n    >>> kin_selection_response(relatedness=0.25, benefit=0.3, cost=0.2)\n    -0.125\n    \nReferences:\n    Hamilton, W. D. (1964). The genetical evolution of social behaviour.\n    Journal of Theoretical Biology, 7(1), 1-52.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection.py", "line_number": 6, "module": "src.metainformant.math.selection", "name": "kin_selection_response", "signature": "(relatedness: float, benefit: float, cost: float) -> float", "symbol_type": "function"}], "kinship_heatmap": [{"docstring": "Heatmap visualization of kinship matrix.\n\nArgs:\n    kinship_matrix: Path to TSV or numpy array\n    output_path: Save path\n    title: Plot title\n    sample_labels: Optional sample labels\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_enhanced.py", "line_number": 698, "module": "src.metainformant.gwas.visualization_enhanced", "name": "kinship_heatmap", "signature": "(kinship_matrix: Path | np.ndarray, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Heatmap of kinship/relatedness matrix.\n\nVisualizes pairwise genetic relationships between samples.\nIdentifies related individuals and population clusters.\n\nArgs:\n    kinship_file: Path to kinship matrix (TSV)\n    output_path: Output path\n    title: Plot title\n    max_samples: Downsample if more samples (for visualization)\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_population.py", "line_number": 229, "module": "src.metainformant.gwas.visualization_population", "name": "kinship_heatmap", "signature": "(kinship_file: Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "kl_divergence": [{"docstring": "Calculate Kullback-Leibler divergence D_KL(P||Q).\n\nMeasures how different distribution Q is from distribution P.\nAlso known as relative entropy.\n\nArgs:\n    p: Probability distribution P\n    q: Probability distribution Q (must have same length as p)\n    base: Logarithm base\n    \nReturns:\n    KL divergence. Returns inf if Q has zeros where P has positives.\n    \nExamples:\n    >>> p = [0.5, 0.5]\n    >>> q = [0.5, 0.5]\n    >>> kl_divergence(p, q)  # Identical distributions\n    0.0\n    \nReferences:\n    Kullback, S., & Leibler, R. A. (1951). On information and sufficiency.\n    The Annals of Mathematical Statistics, 22(1), 79-86.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 286, "module": "src.metainformant.information.syntactic", "name": "kl_divergence", "signature": "(p: Sequence[float], q: Sequence[float], base: float = 2.0) -> float", "symbol_type": "function"}], "kl_divergence_continuous": [{"docstring": "Estimate KL divergence between continuous distributions from samples.\n\nArgs:\n    p_samples: Samples from distribution P\n    q_samples: Samples from distribution Q\n    method: Estimation method (\"histogram\")\n    bins: Number of bins for histogram method\n    \nReturns:\n    KL divergence estimate in nats\n    \nExamples:\n    >>> import numpy as np\n    >>> p_samples = np.random.normal(0, 1, 1000)\n    >>> q_samples = np.random.normal(0, 1, 1000)  # Same distribution\n    >>> kl = kl_divergence_continuous(p_samples, q_samples)\n    >>> abs(kl) < 0.5  # Should be close to zero\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/continuous.py", "line_number": 185, "module": "src.metainformant.information.continuous", "name": "kl_divergence_continuous", "signature": "(p_samples: np.ndarray, q_samples: np.ndarray, method: str = 'histogram', bins: int | None = None) -> float", "symbol_type": "function"}], "kl_divergence_estimator": [{"docstring": "Estimate KL divergence from samples with bias correction.\n\nArgs:\n    p_samples: Samples from distribution P\n    q_samples: Samples from distribution Q\n    method: Estimation method (\"plugin\")\n    bias_correction: Whether to apply bias correction\n    \nReturns:\n    KL divergence estimate in bits", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/estimation.py", "line_number": 190, "module": "src.metainformant.information.estimation", "name": "kl_divergence_estimator", "signature": "(p_samples: list[Any], q_samples: list[Any], method: str = 'plugin', bias_correction: bool = True) -> float", "symbol_type": "function"}], "kmeans_clustering": [{"docstring": "Perform K-means clustering on single-cell data.\n\nArgs:\n    data: SingleCellData object\n    n_clusters: Number of clusters\n    use_pca: Whether to use PCA coordinates\n    n_pcs: Number of PCs to use\n    random_state: Random seed\n\nReturns:\n    SingleCellData with cluster assignments in obs['kmeans']", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/clustering.py", "line_number": 203, "module": "src.metainformant.singlecell.clustering", "name": "kmeans_clustering", "signature": "(data: SingleCellData, n_clusters: int = 8, use_pca: bool = True, n_pcs: int = 40, random_state: int = 42) -> SingleCellData", "symbol_type": "function"}], "kmedoids": [{"docstring": "Perform k-medoids clustering.\n\nThis function performs k-medoids clustering, and returns the cluster\nassignments, the within-cluster sum of distances of the optimal\nk-medoids clustering solution, and the number of times the optimal\nsolution was found.\n\nKeyword arguments:\n - distance: The distance matrix between the items. There are three\n   ways in which you can pass a distance matrix:\n   1. a 2D NumPy array (in which only the left-lower part of the array\n   will be accessed);\n   2. a 1D NumPy array containing the distances consecutively;\n   3. a list of rows containing the lower-triangular part of\n   the distance matrix.\n\n   Examples are:\n\n       >>> from numpy import array\n       >>> # option 1:\n       >>> distance = array([[0.0, 1.1, 2.3],\n       ...                   [1.1, 0.0, 4.5],\n       ...                   [2.3, 4.5, 0.0]])\n       >>> # option 2:\n       >>> distance = array([1.1, 2.3, 4.5])\n       >>> # option 3:\n       >>> distance = [array([]),\n       ...             array([1.1]),\n       ...             array([2.3, 4.5])]\n\n\n   These three correspond to the same distance matrix.\n - nclusters: number of clusters (the 'k' in k-medoids)\n - npass: the number of times the k-medoids clustering algorithm\n   is performed, each time with a different (random) initial\n   condition.\n - initialid: the initial clustering from which the algorithm should start.\n   If initialid is not given, the routine carries out npass\n   repetitions of the EM algorithm, each time starting from a\n   different random initial clustering. If initialid is given,\n   the routine carries out the EM algorithm only once, starting\n   from the initial clustering specified by initialid and\n   without randomizing the order in which items are assigned to\n   clusters (i.e., using the same order as in the data matrix).\n   In that case, the k-medoids algorithm is fully deterministic.\n\nReturn values:\n - clusterid: array containing the index of the cluster to which each\n   item was assigned in the best k-medoids clustering solution that was\n   found in the npass runs; note that the index of a cluster is the index\n   of the item that is the medoid of the cluster;\n - error: the within-cluster sum of distances for the returned k-medoids\n   clustering solution;\n - nfound: the number of times this solution was found.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 180, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "kmedoids", "signature": "(distance, nclusters = 2, npass = 1, initialid = None)", "symbol_type": "function"}], "kmer_counts": [{"docstring": "Count k-mers (substrings of length k) in a sequence.\n\nArgs:\n    seq: DNA sequence string\n    k: K-mer length\n    \nReturns:\n    Dictionary mapping k-mer to count", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 48, "module": "src.metainformant.dna.sequences", "name": "kmer_counts", "signature": "(seq: str, k: int) -> Dict[str, int]", "symbol_type": "function"}], "kmer_distance": [{"docstring": "Compute distance between two sequences using k-mer frequency vectors.\n\nArgs:\n    a, b: Input sequences\n    k: K-mer length\n    metric: Distance metric ('cosine', 'euclidean', 'manhattan', 'jaccard')\n    dna_only: If True, filter out non-ACGT k-mers\n\nReturns:\n    Distance value (0 = identical, higher = more different)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/distances.py", "line_number": 77, "module": "src.metainformant.dna.distances", "name": "kmer_distance", "signature": "(a: str, b: str) -> float", "symbol_type": "function"}], "kmer_distance_matrix": [{"docstring": "Compute pairwise k-mer distance matrix for a set of sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/distances.py", "line_number": 117, "module": "src.metainformant.dna.distances", "name": "kmer_distance_matrix", "signature": "(id_to_seq: Dict[str, str]) -> List[List[float]]", "symbol_type": "function"}], "kmer_frequencies": [{"docstring": "Calculate k-mer frequencies (normalized counts).\n\nArgs:\n    seq: DNA sequence string\n    k: K-mer length\n    \nReturns:\n    Dictionary mapping k-mer to frequency (0.0 to 1.0)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 63, "module": "src.metainformant.dna.sequences", "name": "kmer_frequencies", "signature": "(seq: str, k: int) -> Dict[str, float]", "symbol_type": "function"}, {"docstring": "Calculate k-mer frequencies in a protein sequence.\n\nArgs:\n    seq: Protein sequence string\n    k: K-mer length (must be positive)\n    \nReturns:\n    Dictionary mapping k-mers to their counts\n    \nRaises:\n    ValueError: If k is not positive", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/sequences.py", "line_number": 69, "module": "src.metainformant.protein.sequences", "name": "kmer_frequencies", "signature": "(seq: str) -> Dict[str, int]", "symbol_type": "function"}], "kosambi_c_to_d": [{"docstring": "Convert recombination fraction to map distance using inverse Kosambi function.\n\nInverse of Kosambi's mapping function. Accounts for crossover interference\nwhen converting recombination rates to genetic map distances.\n\nArgs:\n    recombination_fraction: Recombination fraction (c) in [0, 0.5]\n    \nReturns:\n    Genetic map distance in Morgans. Returns:\n    - float('inf') if c >= 0.5 (unlinked loci, maximum recombination)\n    - Otherwise: d = 0.25 \u00d7 ln((1 + 2c) / (1 - 2c))\n    \nExamples:\n    >>> kosambi_c_to_d(0.1)\n    0.100...\n    >>> kosambi_c_to_d(0.25)\n    0.549...\n    >>> kosambi_c_to_d(0.5)\n    inf  # Unlinked loci (c = 0.5 is maximum recombination)\n    \nNote:\n    When c = 0.5, loci are unlinked (independent assortment) and the\n    genetic map distance is infinite. This reflects that unlinked loci\n    behave as if they are infinitely far apart on the genetic map, even\n    when accounting for crossover interference (Kosambi's function).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/ld.py", "line_number": 216, "module": "src.metainformant.math.ld", "name": "kosambi_c_to_d", "signature": "(recombination_fraction: float) -> float", "symbol_type": "function"}], "kosambi_d_to_c": [{"docstring": "Convert genetic map distance to recombination fraction using Kosambi's mapping function.\n\nKosambi's function accounts for crossover interference, where one crossover\nreduces the probability of nearby crossovers. More realistic for many\nchromosomes than Haldane's function.\n\nArgs:\n    map_distance_morgans: Genetic map distance in Morgans (d)\n    \nReturns:\n    Recombination fraction in [0, 0.5]. Formula: c = 0.5 \u00d7 tanh(2d)\n    \nExamples:\n    >>> kosambi_d_to_c(0.1)  # 10 cM\n    0.099...\n    >>> kosambi_d_to_c(0.5)  # 50 cM\n    0.462...\n    \nReferences:\n    Kosambi, D. D. (1944). The estimation of map distances from\n    recombination values. Annals of Eugenics, 12(1), 172-175.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/ld.py", "line_number": 186, "module": "src.metainformant.math.ld", "name": "kosambi_d_to_c", "signature": "(map_distance_morgans: float) -> float", "symbol_type": "function"}], "label_sampled_data": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 314, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "label_sampled_data", "signature": "(self, max_sample = 10)", "symbol_type": "function"}], "labels": [{"docstring": "Return a list of all the edge labels in this graph.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/Graph.py", "line_number": 99, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.Graph", "name": "labels", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a list of all the edge labels in this graph.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/MultiGraph.py", "line_number": 91, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.MultiGraph", "name": "labels", "signature": "(self)", "symbol_type": "function"}], "ladderize": [{"docstring": "Sort clades in-place according to the number of terminal nodes.\n\nDeepest clades are last by default. Use ``reverse=True`` to sort clades\ndeepest-to-shallowest.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 650, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "ladderize", "signature": "(self, reverse = False)", "symbol_type": "function"}], "ladderize_nodes": [{"docstring": "Sort node numbers according to the number of terminal nodes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 710, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "ladderize_nodes", "signature": "(nodes, ladderize = None)", "symbol_type": "function"}], "lambda_gc_plot": [{"docstring": "Lambda GC plot across different subsets.\n\nVisualizes genomic inflation across chromosomes or other subsets\nto identify localized issues.\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    subsets: Subset labels (e.g., chromosomes), default is by chromosome\n    title: Plot title\n\nReturns:\n    Plot metadata with lambda_GC per subset", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_statistical.py", "line_number": 288, "module": "src.metainformant.gwas.visualization_statistical", "name": "lambda_gc_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "lambdasplit": [{"docstring": "Filter enzymes in batch with supplied function.\n\nThe new batch will contain only the enzymes for which\nfunc return True.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2060, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "lambdasplit", "signature": "(self, func)", "symbol_type": "function"}], "lande_equation_response": [{"docstring": "Calculate multivariate response to selection: \u0394z = G \u03b2.\n\nLande's equation extends the breeder's equation to multiple traits,\naccounting for genetic correlations between traits through the G matrix.\n\nArgs:\n    gradient: Selection gradient vector (\u03b2), one element per trait\n    G_matrix: Genetic variance-covariance matrix (G). Should be symmetric\n        positive semidefinite. Each row/column corresponds to a trait.\n        \nReturns:\n    Tuple of response vectors (\u0394z), one element per trait.\n    Returns empty tuple if dimensions don't match or inputs invalid.\n    \nExamples:\n    >>> gradient = [0.5, 0.3]\n    >>> G = [[0.4, 0.1], [0.1, 0.3]]\n    >>> response = lande_equation_response(gradient, G)\n    >>> len(response)\n    2\n    \nReferences:\n    Lande, R. (1979). Quantitative genetic analysis of multivariate\n    evolution, applied to brain:body size allometry. Evolution, 33(1), 402-416.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/quantgen.py", "line_number": 70, "module": "src.metainformant.math.quantgen", "name": "lande_equation_response", "signature": "(gradient: Sequence[float], G_matrix: Sequence[Sequence[float]]) -> Tuple[float, ...]", "symbol_type": "function"}], "last_id": [{"docstring": "Return the last row id for the selected table.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 359, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "last_id", "signature": "(self, table)", "symbol_type": "function"}, {"docstring": "Return the last used id for a table.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/DBUtils.py", "line_number": 33, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.DBUtils", "name": "last_id", "signature": "(self, cursor, table)", "symbol_type": "function"}, {"docstring": "Return the last used id for a table.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/DBUtils.py", "line_number": 82, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.DBUtils", "name": "last_id", "signature": "(self, cursor, table)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/DBUtils.py", "line_number": 109, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.DBUtils", "name": "last_id", "signature": "(self, cursor, table)", "symbol_type": "function"}], "layer_names": [{"docstring": "Get names of all available omics layers.\n\nReturns:\n    List of layer names (e.g., ['genomics', 'transcriptomics']).\n    Only includes layers that were provided (not None).\n    \nExamples:\n    >>> data = MultiOmicsData(genomics=genomics_df, transcriptomics=transcriptomics_df)\n    >>> data.layer_names\n    ['genomics', 'transcriptomics']", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 133, "module": "src.metainformant.multiomics.integration", "name": "layer_names", "signature": "(self) -> List[str]", "symbol_type": "function"}], "lazy_import": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_peptide.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_peptide", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_bio_project_lineage.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_bio_project_lineage", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_prokaryote_gene_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_prokaryote_gene_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_gene.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_gene", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response_edges_entry.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response_edges_entry", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_dataset_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_dataset_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_filter.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_filter", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sci_name_and_ids.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sci_name_and_ids", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_metadata_response.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_metadata_response", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_message.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_message", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_feature_counts.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_feature_counts", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_match.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_match", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_conserved_domain.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_conserved_domain", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_query_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_query_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_warning.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_warning", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request_sort.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request_sort", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_match.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_match", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ortholog_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ortholog_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_transcript.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_transcript", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_count_by_type.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_count_by_type", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptor.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptor", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_range.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_range", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_range.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_range", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_genomic_region.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_genomic_region", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_dataset_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_dataset_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ref_gene_catalog_dataset_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ref_gene_catalog_dataset_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_micro_bigge_dataset_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_micro_bigge_dataset_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_assembly.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_assembly", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_metadata_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_metadata_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_protein.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_protein", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_match.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_match", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_description.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_description", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_seq_range_set.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_seq_range_set", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_genomic_location.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_genomic_location", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_seq_range_set_fasta.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_seq_range_set_fasta", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sars2_protein_dataset_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sars2_protein_dataset_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_assembly_file.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_assembly_file", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_error.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_error", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ortholog_set.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ortholog_set", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_data_report_page.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_data_report_page", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_node_count_by_type.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_node_count_by_type", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/rpc_status.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.rpc_status", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_data_report_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_data_report_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptor.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptor", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_descriptor.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_descriptor", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_metadata.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_metadata", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_annotation.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_annotation", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_organism.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_organism", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_assembly.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_assembly", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_request.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_request", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_owner.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_owner", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptors.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptors", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary_available_files.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary_available_files", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response_edge.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response_edge", "name": "lazy_import", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_node.py", "line_number": 32, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_node", "name": "lazy_import", "signature": "()", "symbol_type": "function"}], "lcc_mult": [{"docstring": "Calculate Local Composition Complexity (LCC) values over sliding window.\n\nReturns a list of floats, the LCC values for a sliding window over\nthe sequence.\n\nseq - an unambiguous DNA sequence (a string or Seq object)\nwsize - window size, integer\n\nThe result is the same as applying lcc_simp multiple times, but this\nversion is optimized for speed. The optimization works by using the\nvalue of previous window as a base to compute the next one.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/lcc.py", "line_number": 13, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.lcc", "name": "lcc_mult", "signature": "(seq, wsize)", "symbol_type": "function"}], "lcc_simp": [{"docstring": "Calculate Local Composition Complexity (LCC) for a sequence.\n\nseq - an unambiguous DNA sequence (a string or Seq object)\n\nReturns the Local Composition Complexity (LCC) value for the entire\nsequence (as a float).\n\nReference:\nAndrzej K Konopka (2005) Sequence Complexity and Composition\nhttps://doi.org/10.1038/npg.els.0005260", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/lcc.py", "line_number": 120, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.lcc", "name": "lcc_simp", "signature": "(seq)", "symbol_type": "function"}], "ld_coefficients": [{"docstring": "Compute linkage disequilibrium D and normalized D' given haplotype frequencies.\n\nCalculates the linkage disequilibrium (LD) coefficient D, which measures\nthe deviation from random association between alleles at two loci. Also\ncomputes D', the normalized LD coefficient adjusted for allele frequencies.\n\nArgs:\n    pA: Frequency of allele A at first locus\n    pa: Frequency of allele a at first locus (should satisfy pA + pa = 1)\n    pB: Frequency of allele B at second locus\n    pb: Frequency of allele b at second locus (should satisfy pB + pb = 1)\n    haplotype_pAB: Observed frequency of AB haplotype\n    \nReturns:\n    Tuple of (D, D_prime):\n    - D: Linkage disequilibrium coefficient. D = pAB - pA \u00d7 pB.\n      Positive D indicates AB and ab haplotypes are more common than expected.\n    - D_prime: Normalized LD coefficient in [-1, 1]. D' = D / D_max where\n      D_max is the maximum possible |D| given allele frequencies.\n    \n    Returns (0.0, 0.0) if inputs violate constraints or are invalid.\n    \nExamples:\n    >>> ld_coefficients(pA=0.6, pa=0.4, pB=0.7, pb=0.3, haplotype_pAB=0.5)\n    (0.08, 0.333...)  # Positive LD\n    >>> ld_coefficients(pA=0.5, pa=0.5, pB=0.5, pb=0.5, haplotype_pAB=0.25)\n    (0.0, 0.0)  # Linkage equilibrium\n    \nReferences:\n    Lewontin, R. C. (1964). The interaction of selection and linkage.\n    I. General considerations; heterotic models. Genetics, 49(1), 49-67.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/ld.py", "line_number": 6, "module": "src.metainformant.math.ld", "name": "ld_coefficients", "signature": "(pA: float, pa: float, pB: float, pb: float, haplotype_pAB: float) -> Tuple[float, float]", "symbol_type": "function"}], "ld_decay_r2": [{"docstring": "Calculate expected r\u00b2 decay over generations due to recombination.\n\nModels the decay of linkage disequilibrium as recombination breaks down\nhaplotype associations. Under random mating, LD decreases exponentially\nwith time.\n\nArgs:\n    r2_initial: Initial r\u00b2 value (LD at generation 0)\n    recombination_rate: Recombination fraction per generation (c) in [0, 0.5]\n    generations: Number of generations (t)\n    \nReturns:\n    Expected r\u00b2 after t generations. Values clamped to [0, 1].\n    Formula: r\u00b2_t \u2248 r\u00b2_0 \u00d7 (1 - c)^(2t)\n    \nExamples:\n    >>> ld_decay_r2(r2_initial=0.8, recombination_rate=0.01, generations=50)\n    0.296...\n    >>> ld_decay_r2(r2_initial=0.8, recombination_rate=0.1, generations=10)\n    0.010...  # Faster decay with higher recombination\n    \nReferences:\n    Sved, J. A. (1971). Linkage disequilibrium and homozygosity of\n    chromosome segments in finite populations. Theoretical Population Biology,\n    2(2), 125-141.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/ld.py", "line_number": 88, "module": "src.metainformant.math.ld", "name": "ld_decay_r2", "signature": "(r2_initial: float, recombination_rate: float, generations: int) -> float", "symbol_type": "function"}], "learn_event_embeddings": [{"docstring": "Learn dense vector representations of events using Word2Vec-style methods.\n\nImplements Skip-gram or CBOW to learn embeddings where similar events\n(those that appear in similar contexts) have similar vectors.\n\nArgs:\n    sequences: List of event sequences, where each sequence is a list of\n        event tokens (e.g., \"health:diagnosis\" or \"occupation:job_change\")\n    embedding_dim: Dimension of embedding vectors\n    window_size: Size of context window for training\n    method: Embedding method (\"skipgram\" or \"cbow\")\n    epochs: Number of training epochs\n    learning_rate: Learning rate for gradient descent\n    random_state: Random seed for reproducibility\n    verbose: If True, print progress information for large datasets\n    \nReturns:\n    Dictionary mapping event tokens to embedding vectors\n    \nExamples:\n    >>> sequences = [\n    ...     [\"health:diagnosis\", \"occupation:job_change\", \"income:raise\"],\n    ...     [\"education:degree\", \"occupation:job_change\", \"address:move\"],\n    ... ]\n    >>> embeddings = learn_event_embeddings(sequences, embedding_dim=50)\n    >>> \"health:diagnosis\" in embeddings\n    True\n    >>> embeddings[\"health:diagnosis\"].shape\n    (50,)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/embeddings.py", "line_number": 41, "module": "src.metainformant.life_events.embeddings", "name": "learn_event_embeddings", "signature": "(sequences: List[List[str]], embedding_dim: int = 100, window_size: int = 5, method: str = 'skipgram', epochs: int = 10, learning_rate: float = 0.01, random_state: Optional[int] = None, verbose: bool = False) -> Dict[str, NDArray[np.float64]]", "symbol_type": "function"}], "learning_curve": [{"docstring": "Generate learning curves.\n\nArgs:\n    model_func: Function that returns trained model\n    X: Feature matrix\n    y: Target vector\n    train_sizes: Training set sizes to evaluate\n    cv: Number of cross-validation folds\n    scoring: Scoring metric\n    random_state: Random seed\n    classifier_func: Alias for model_func (for compatibility)\n    cv_folds: Alias for cv (for compatibility)\n    **model_kwargs: Parameters for model_func\n\nReturns:\n    Dictionary with learning curve data including train_sizes, train_scores, val_scores", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/validation.py", "line_number": 367, "module": "src.metainformant.ml.validation", "name": "learning_curve", "signature": "(model_func: Callable = None, X: np.ndarray = None, y: np.ndarray = None, train_sizes: Optional[np.ndarray] = None, cv: int = 5, scoring: str = 'accuracy', random_state: Optional[int] = None, classifier_func: Callable = None, cv_folds: int = None, **model_kwargs) -> Dict[str, Any]", "symbol_type": "function"}], "left_multiply": [{"docstring": "Return Vector=Matrix x Vector.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 368, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "left_multiply", "signature": "(self, matrix)", "symbol_type": "function"}], "leiden_clustering": [{"docstring": "Perform Leiden clustering on single-cell data.\n\nArgs:\n    data: SingleCellData with neighbor graph\n    resolution: Resolution parameter (higher = more clusters)\n    random_state: Random seed\n    n_iterations: Number of iterations (-1 for auto)\n\nReturns:\n    SingleCellData with cluster assignments in obs['leiden']", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/clustering.py", "line_number": 44, "module": "src.metainformant.singlecell.clustering", "name": "leiden_clustering", "signature": "(data: SingleCellData, resolution: float = 0.5, random_state: int = 42, n_iterations: int = -1) -> SingleCellData", "symbol_type": "function"}], "len12": [{"docstring": "Get first length for Hedron.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4190, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "len12", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set first length for Hedron; sets needs_update.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4198, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "len12", "signature": "(self, len)", "symbol_type": "function"}], "len23": [{"docstring": "Get second length for Hedron.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4206, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "len23", "signature": "(self) -> float", "symbol_type": "function"}, {"docstring": "Set second length for Hedron; sets needs_update.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4214, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "len23", "signature": "(self, len)", "symbol_type": "function"}], "length": [{"docstring": "Return the alignment length, i.e. the number of columns when printed..\n\nThe alignment length is the number of columns in the alignment when it\nis printed, and is equal to the sum of the number of matches, number of\nmismatches, and the total length of gaps in the target and query.\nSequence sections beyond the aligned segment are not included in the\nnumber of columns.\n\nFor example,\n\n>>> from Bio import Align\n>>> aligner = Align.PairwiseAligner()\n>>> aligner.mode = \"global\"\n>>> alignments = aligner.align(\"GACCTG\", \"CGATCG\")\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            0 -GACCTG 6\n                  0 -||.|-| 7\nquery             0 CGATC-G 6\n<BLANKLINE>\n>>> alignment.length\n7\n>>> aligner.mode = \"local\"\n>>> alignments = aligner.align(\"GACCTG\", \"CGATCG\")\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            0 GACC 4\n                  0 ||.| 4\nquery             1 GATC 5\n<BLANKLINE>\n>>> len(alignment)\n2\n>>> alignment.length\n4", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 2895, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "length", "signature": "(self)", "symbol_type": "function"}], "letter_annotations": [{"docstring": "Dictionary of per-letter-annotation for the sequence.\n\nFor example, this can hold quality scores used in FASTQ or QUAL files.\nConsider this example using Bio.SeqIO to read in an example Solexa\nvariant FASTQ file as a SeqRecord:\n\n>>> from Bio import SeqIO\n>>> record = SeqIO.read(\"Quality/solexa_faked.fastq\", \"fastq-solexa\")\n>>> print(\"%s %s\" % (record.id, record.seq))\nslxa_0001_1_0001_01 ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTNNNNNN\n>>> print(list(record.letter_annotations))\n['solexa_quality']\n>>> print(record.letter_annotations[\"solexa_quality\"])\n[40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5]\n\nThe letter_annotations get sliced automatically if you slice the\nparent SeqRecord, for example taking the last ten bases:\n\n>>> sub_record = record[-10:]\n>>> print(\"%s %s\" % (sub_record.id, sub_record.seq))\nslxa_0001_1_0001_01 ACGTNNNNNN\n>>> print(sub_record.letter_annotations[\"solexa_quality\"])\n[4, 3, 2, 1, 0, -1, -2, -3, -4, -5]\n\nAny python sequence (i.e. list, tuple or string) can be recorded in\nthe SeqRecord's letter_annotations dictionary as long as the length\nmatches that of the SeqRecord's sequence.  e.g.\n\n>>> len(sub_record.letter_annotations)\n1\n>>> sub_record.letter_annotations[\"dummy\"] = \"abcdefghij\"\n>>> len(sub_record.letter_annotations)\n2\n\nYou can delete entries from the letter_annotations dictionary as usual:\n\n>>> del sub_record.letter_annotations[\"solexa_quality\"]\n>>> sub_record.letter_annotations\n{'dummy': 'abcdefghij'}\n\nYou can completely clear the dictionary easily as follows:\n\n>>> sub_record.letter_annotations = {}\n>>> sub_record.letter_annotations\n{}\n\nNote that if replacing the record's sequence with a sequence of a\ndifferent length you must first clear the letter_annotations dict.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 262, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "letter_annotations", "signature": "(self) -> dict[str, Sequence[Any]]", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 319, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "letter_annotations", "signature": "(self, value: dict[str, Sequence[Any]]) -> None", "symbol_type": "function"}], "leverage_plot": [{"docstring": "Create a leverage plot for regression diagnostics.\n\nArgs:\n    X: Feature matrix\n    y: Target values\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments for scatter\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import leverage_plot\n    >>> import numpy as np\n    >>> X = np.random.random((100, 2))\n    >>> y = np.random.random(100)\n    >>> ax = leverage_plot(X, y)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/statistical.py", "line_number": 531, "module": "src.metainformant.visualization.statistical", "name": "leverage_plot", "signature": "(X: Sequence[Sequence[float]], y: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "lin_phi": [{"docstring": "Linear transformation function with noise scaled by selection strength.\n\nArgs:\n    z: Input trait values\n    s_hat: Selection strength parameter\n    \nReturns:\n    Transformed values with noise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/model.py", "line_number": 88, "module": "src.metainformant.math.selection_experiments.model", "name": "lin_phi", "signature": "(z: np.ndarray, s_hat: float) -> np.ndarray", "symbol_type": "function"}], "lin_phi_bar": [{"docstring": "Linear transformation function without noise.\n\nArgs:\n    z: Input trait values\n    \nReturns:\n    Transformed values (a*z^2 + b)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/model.py", "line_number": 76, "module": "src.metainformant.math.selection_experiments.model", "name": "lin_phi_bar", "signature": "(z: np.ndarray) -> np.ndarray", "symbol_type": "function"}], "lin_phi_inv": [{"docstring": "Inverse linear transformation function.\n\nArgs:\n    q: Transformed values\n    \nReturns:\n    Original trait values ((q - b) / a)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/model.py", "line_number": 104, "module": "src.metainformant.math.selection_experiments.model", "name": "lin_phi_inv", "signature": "(q: np.ndarray) -> np.ndarray", "symbol_type": "function"}], "lineage_analysis": [{"docstring": "Analyze lineage relationships between cell clusters.\n\nArgs:\n    data: SingleCellData with clustering and pseudotime\n    start_cluster: Starting cluster (root)\n    end_clusters: Terminal clusters (leaves)\n    cluster_key: Column name for cluster assignments\n\nReturns:\n    Dictionary with lineage analysis results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/trajectory.py", "line_number": 283, "module": "src.metainformant.singlecell.trajectory", "name": "lineage_analysis", "signature": "(data: SingleCellData, start_cluster: Optional[str] = None, end_clusters: Optional[List[str]] = None, cluster_key: str = 'leiden') -> Dict[str, Any]", "symbol_type": "function"}], "linear_regression": [{"docstring": "Calculate linear regression: y = mx + b.\n\nPerforms least-squares linear regression to fit a line through data points\nand calculates the goodness of fit.\n\nArgs:\n    x: Independent variable values\n    y: Dependent variable values (must match length of x)\n    \nReturns:\n    Tuple of (slope, intercept, r_squared):\n    - slope: Regression coefficient (m)\n    - intercept: Y-axis intercept (b)\n    - r_squared: Coefficient of determination (0 to 1)\n    \n    Returns (0.0, 0.0, 0.0) if:\n    - Lists have fewer than 2 elements\n    - X has zero variance\n    \nRaises:\n    ValueError: If lists have different lengths\n    \nExamples:\n    >>> slope, intercept, r2 = linear_regression([1, 2, 3], [2, 4, 6])\n    >>> abs(slope - 2.0) < 0.01\n    True\n    >>> abs(r2 - 1.0) < 0.01  # Perfect fit\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/__init__.py", "line_number": 319, "module": "src.metainformant.math.__init__", "name": "linear_regression", "signature": "(x: list[float], y: list[float]) -> tuple[float, float, float]", "symbol_type": "function"}], "linearise": [{"docstring": "Linearise sequence in place.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 195, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "linearise", "signature": "(self)", "symbol_type": "function"}], "lineplot": [{"docstring": "Simple line plot wrapper returning the Axes.\n\nIf x is None, indices are used.\n\nArgs:\n    x: X-axis values (if None, uses indices)\n    y: Y-axis values\n    label: Label for legend\n    ax: Matplotlib axes (creates new if None)\n    style: Line style (e.g., '-', '--', '-.')\n    color: Line color\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import lineplot\n    >>> ax = lineplot(None, [1, 4, 2, 8, 5])\n    >>> ax.set_xlabel(\"Index\")\n    >>> ax.set_ylabel(\"Value\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/basic.py", "line_number": 27, "module": "src.metainformant.visualization.basic", "name": "lineplot", "signature": "(x: Sequence[float] | None, y: Sequence[float]) -> plt.Axes", "symbol_type": "function"}], "link": [{"docstring": "Connect son to parent.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 92, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "link", "signature": "(self, parent, child)", "symbol_type": "function"}], "link_residues": [{"docstring": "Set next and prev links between i-1 and i-2 residues.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 175, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "link_residues", "signature": "(ppr: list[Residue], pr: list[Residue]) -> None", "symbol_type": "function"}], "linkage_disequilibrium_decay_distance": [{"docstring": "Estimate genetic distance from observed r\u00b2 and recombination rate.\n\nUses the relationship between LD decay and recombination to infer genetic\nmap distance. Assumes LD is at equilibrium under mutation-drift-recombination\nbalance.\n\nArgs:\n    r_squared: Observed r\u00b2 value (linkage disequilibrium measure)\n    recombination_rate: Recombination fraction (c) in [0, 0.5]\n    \nReturns:\n    Estimated genetic distance in Morgans. Returns:\n    - 0.0 if inputs invalid (r\u00b2 <= 0 or r\u00b2 >= 1)\n    - float('inf') if recombination_rate = 0 (no recombination, infinite distance)\n    - Otherwise: -ln(r\u00b2) / (2 \u00d7 recombination_rate)\n    \nExamples:\n    >>> linkage_disequilibrium_decay_distance(r_squared=0.5, recombination_rate=0.01)\n    34.65...\n    >>> linkage_disequilibrium_decay_distance(r_squared=0.1, recombination_rate=0.0)\n    inf  # No recombination, infinite distance\n    \nNote:\n    This is an approximation. Actual distance depends on population history\n    and mutation rates. When recombination_rate = 0, the formula evaluates\n    to infinity because there is no recombination to break down LD, so the\n    effective distance is infinite.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 463, "module": "src.metainformant.math.popgen", "name": "linkage_disequilibrium_decay_distance", "signature": "(r_squared: float, recombination_rate: float) -> float", "symbol_type": "function"}], "list_ambiguous_codons": [{"docstring": "Extend a codon list to include all possible ambiguous codons.\n\ne.g.::\n\n     ['TAG', 'TAA'] -> ['TAG', 'TAA', 'TAR']\n     ['UAG', 'UGA'] -> ['UAG', 'UGA', 'URA']\n\nNote that ['TAG', 'TGA'] -> ['TAG', 'TGA'], this does not add 'TRR'\n(which could also mean 'TAA' or 'TGG').\nThus only two more codons are added in the following:\n\ne.g.::\n\n    ['TGA', 'TAA', 'TAG'] -> ['TGA', 'TAA', 'TAG', 'TRA', 'TAR']\n\nReturns a new (longer) list of codon strings.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Data/CodonTable.py", "line_number": 265, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Data.CodonTable", "name": "list_ambiguous_codons", "signature": "(codons, ambiguous_nucleotide_values)", "symbol_type": "function"}], "list_any_ids": [{"docstring": "Return ids given a SQL statement to select for them.\n\nThis assumes that the given SQL does a SELECT statement that\nreturns a list of items. This parses them out of the 2D list\nthey come as and just returns them in a list.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 526, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "list_any_ids", "signature": "(self, sql, args)", "symbol_type": "function"}], "list_biodatabase_names": [{"docstring": "Return a list of all of the sub-databases.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 500, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "list_biodatabase_names", "signature": "(self)", "symbol_type": "function"}], "list_bioentry_display_ids": [{"docstring": "Return a list of all sequence names in a sub-databae.\n\nArguments:\n - dbid - The internal id for a sub-database", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 515, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "list_bioentry_display_ids", "signature": "(self, dbid)", "symbol_type": "function"}], "list_bioentry_ids": [{"docstring": "Return a list of internal ids for all of the sequences in a sub-databae.\n\nArguments:\n - dbid - The internal id for a sub-database", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 504, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "list_bioentry_ids", "signature": "(self, dbid)", "symbol_type": "function"}], "list_config_templates": [{"docstring": "List available config templates.\n\nArgs:\n    repo_root: Root directory of repository\n\nReturns:\n    List of template information dictionaries:\n    - path: Path to template file\n    - domain: Domain name\n    - name: Template name", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 619, "module": "src.metainformant.core.config", "name": "list_config_templates", "signature": "(repo_root: str | Path | None = None) -> list[dict[str, Any]]", "symbol_type": "function"}], "list_duplicates": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/sanity.py", "line_number": 6, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.sanity", "name": "list_duplicates", "signature": "(seq)", "symbol_type": "function"}], "list_output_structure": [{"docstring": "Map entire output directory structure.\n\nArgs:\n    repo_root: Root directory of repository\n\nReturns:\n    Dictionary with output structure information:\n    - total_dirs: Total number of directories\n    - total_files: Total number of files\n    - total_size: Total size in bytes\n    - structure: Nested structure of directories", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 346, "module": "src.metainformant.core.paths", "name": "list_output_structure", "signature": "(repo_root: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "list_possible_proteins": [{"docstring": "Return all possible encoded amino acids for ambiguous codon.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Data/CodonTable.py", "line_number": 239, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Data.CodonTable", "name": "list_possible_proteins", "signature": "(codon, forward_table, ambiguous_nucleotide_values)", "symbol_type": "function"}], "load": [{"docstring": "Parse the first YAML document in a stream\nand produce the corresponding Python object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 74, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "load", "signature": "(stream, Loader)", "symbol_type": "function"}, {"docstring": "Parse the first YAML document in a stream\nand produce the corresponding Python object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 74, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "load", "signature": "(stream, Loader)", "symbol_type": "function"}, {"docstring": "Load and return a precalculated substitution matrix.\n\n>>> from Bio.Align import substitution_matrices\n>>> names = substitution_matrices.load()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/substitution_matrices/__init__.py", "line_number": 488, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.substitution_matrices.__init__", "name": "load", "signature": "(name = None)", "symbol_type": "function"}, {"docstring": "Load a set of SeqRecords into the BioSQL database.\n\nrecord_iterator is either a list of SeqRecord objects, or an\nIterator object that returns SeqRecord objects (such as the\noutput from the Bio.SeqIO.parse() function), which will be\nused to populate the database.\n\nfetch_NCBI_taxonomy is boolean flag allowing or preventing\nconnection to the taxonomic database on the NCBI server\n(via Bio.Entrez) to fetch a detailed taxonomy for each\nSeqRecord.\n\nExample::\n\n    from Bio import SeqIO\n    count = db.load(SeqIO.parse(open(filename), format))\n\nReturns the number of records loaded.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 788, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "load", "signature": "(self, record_iterator, fetch_NCBI_taxonomy = False)", "symbol_type": "function"}], "load_all": [{"docstring": "Parse all YAML documents in a stream\nand produce corresponding Python objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 85, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "load_all", "signature": "(stream, Loader)", "symbol_type": "function"}, {"docstring": "Parse all YAML documents in a stream\nand produce corresponding Python objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 85, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "load_all", "signature": "(stream, Loader)", "symbol_type": "function"}], "load_antwiki_json": [{"docstring": "Load AntWiki phenotype data from JSON file.\n\nParses JSON files containing AntWiki species phenotype information,\nincluding morphological measurements and behavioral traits. Uses core.io\nutilities for robust file handling with gzip support and proper error\nreporting.\n\nArgs:\n    path: Path to JSON file containing AntWiki data\n    validate: If True, validate that entries have expected structure (species/taxon, measurements, traits)\n    \nReturns:\n    List of dictionaries, each representing a species or observation.\n    If input is a single dictionary, returns list with one element.\n    \nRaises:\n    FileNotFoundError: If the file does not exist\n    CoreIOError: If file read fails or JSON parsing fails\n    ValidationError: If data structure is invalid (not list or dict) or entries don't have expected structure\n    \nExamples:\n    >>> from pathlib import Path\n    >>> data = load_antwiki_json(Path(\"antwiki_data.json\"))\n    >>> len(data)\n    150\n    >>> data[0].keys()\n    dict_keys(['species', 'measurements', 'traits'])\n    \nNote:\n    AntWiki provides comprehensive ant species phenotype databases.\n    This loader supports both single-object and array JSON formats.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/phenotype/antwiki.py", "line_number": 53, "module": "src.metainformant.phenotype.antwiki", "name": "load_antwiki_json", "signature": "(path: Path, validate: bool = True) -> list[dict[str, Any]]", "symbol_type": "function"}], "load_cached_json": [{"docstring": "Load cached JSON with thread-safe access.\n\nArgs:\n    cache_dir: Cache directory\n    key: Cache key\n    ttl_seconds: Time to live in seconds\n    \nReturns:\n    Cached object or None if not found or expired", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/cache.py", "line_number": 54, "module": "src.metainformant.core.cache", "name": "load_cached_json", "signature": "(cache_dir: Path, key: str) -> Any | None", "symbol_type": "function"}], "load_config_file": [{"docstring": "Load configuration from YAML, TOML, or JSON file.\n\nArgs:\n    config_path: Path to configuration file\n\nReturns:\n    Configuration dictionary\n\nRaises:\n    ValueError: If file format not supported or file cannot be parsed", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 69, "module": "src.metainformant.core.config", "name": "load_config_file", "signature": "(config_path: Path) -> dict[str, Any]", "symbol_type": "function"}], "load_count_matrix": [{"docstring": "Load single-cell count matrix from various formats.\n\nArgs:\n    path: Path to count matrix file\n    format: File format ('mtx', 'csv', 'tsv', 'h5', 'h5ad')\n    delimiter: Delimiter for text formats\n    transpose: Whether to transpose the matrix (genes \u00d7 cells -> cells \u00d7 genes)\n\nReturns:\n    SingleCellData object with loaded expression matrix", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/preprocessing.py", "line_number": 92, "module": "src.metainformant.singlecell.preprocessing", "name": "load_count_matrix", "signature": "(path: Union[str, Path], format: str = 'mtx', delimiter: str = '\\t', transpose: bool = False) -> SingleCellData", "symbol_type": "function"}], "load_cpg_table": [{"docstring": "Load a simple CpG count table with columns chrom,pos,methylated,unmethylated (TSV).\n\nReturns a DataFrame with proper dtypes: chrom as object, pos as int, counts as int.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/methylation.py", "line_number": 10, "module": "src.metainformant.epigenome.methylation", "name": "load_cpg_table", "signature": "(path: str | Path) -> pd.DataFrame", "symbol_type": "function"}], "load_database_sql": [{"docstring": "Load a database schema into the given database.\n\nThis is used to create tables, etc when a database is first created.\nsql_file should specify the complete path to a file containing\nSQL entries for building the tables.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 246, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "load_database_sql", "signature": "(self, sql_file)", "symbol_type": "function"}], "load_go_obo": [{"docstring": "Load Gene Ontology from an OBO format file.\n\nParses a Gene Ontology (GO) OBO file and constructs an Ontology object\nrepresenting the GO term hierarchy and relationships.\n\nArgs:\n    path: Path to OBO format file (typically go.obo or go-basic.obo)\n    \nReturns:\n    Ontology object containing all GO terms and their relationships\n    \nRaises:\n    IOError: If file does not exist or cannot be read\n    ValidationError: If file is malformed or contains invalid data\n    \nExamples:\n    >>> onto = load_go_obo(\"data/go.obo\")\n    >>> onto.num_terms()\n    45000\n    >>> onto.has_term(\"GO:0008150\")\n    True\n    \nNote:\n    This is a lightweight reader suitable for standard GO OBO files.\n    For advanced features (relationship types beyond is_a, complex qualifiers),\n    consider specialized OBO parsing libraries.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/go.py", "line_number": 30, "module": "src.metainformant.ontology.go", "name": "load_go_obo", "signature": "(path: str | Path) -> Ontology", "symbol_type": "function"}], "load_gwas_config": [{"docstring": "Load GWASWorkflowConfig from a config file with env overrides.\n\nExpected top-level keys:\n  - work_dir (str)\n  - log_dir (str, optional)\n  - threads (int, default: 8)\n  - genome (mapping, optional)\n  - variants (mapping, optional)\n  - qc (mapping, optional)\n  - samples (mapping, optional)\n  - structure (mapping, optional)\n  - association (mapping, optional)\n  - correction (mapping, optional)\n  - output (mapping, optional)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/config.py", "line_number": 29, "module": "src.metainformant.gwas.config", "name": "load_gwas_config", "signature": "(config_file: str | Path) -> GWASWorkflowConfig", "symbol_type": "function"}], "load_interactions": [{"docstring": "Load interaction data from file.\n\nArgs:\n    input_path: Path to input file\n    \nReturns:\n    List of (node1, node2, weight) tuples", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/networks/run_network_analysis.py", "line_number": 91, "module": "scripts.networks.run_network_analysis", "name": "load_interactions", "signature": "(input_path: Path) -> list[tuple[str, str, float]]", "symbol_type": "function"}], "load_json": [{"docstring": "Load JSON data from a file.\n\nArgs:\n    path: Path to JSON file (supports gzip compression automatically)\n    \nReturns:\n    Parsed JSON data (dict, list, or primitive types)\n\nRaises:\n    IOError: If file read fails or JSON parsing fails\n    FileNotFoundError: If file does not exist", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 32, "module": "src.metainformant.core.io", "name": "load_json", "signature": "(path: str | Path) -> Any", "symbol_type": "function"}], "load_json_gz": [{"docstring": "Load object from gzipped JSON file.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 98, "module": "src.metainformant.core.io", "name": "load_json_gz", "signature": "(path: str | Path) -> Any", "symbol_type": "function"}], "load_life_events_config": [{"docstring": "Load LifeEventsWorkflowConfig from a config file with env overrides.\n\nExpected top-level keys:\n  - work_dir (str): Working directory for outputs\n  - log_dir (str, optional): Directory for logs\n  - threads (int, default: 4): Number of threads for parallel processing\n  - embedding (mapping, optional): Embedding configuration\n    - embedding_dim (int, default: 100)\n    - window_size (int, default: 5)\n    - epochs (int, default: 10)\n    - method (str, default: \"skipgram\")\n    - learning_rate (float, default: 0.01)\n  - model (mapping, optional): Model configuration\n    - model_type (str, default: \"embedding\")\n    - task_type (str, default: \"classification\")\n    - random_state (int, optional)\n  - workflow (mapping, optional): Workflow-specific settings\n  - output (mapping, optional): Output configuration\n\nEnvironment variables can override config values using prefix \"LE\":\n  - LE_WORK_DIR\n  - LE_THREADS\n  - LE_EMBEDDING_DIM\n  - LE_WINDOW_SIZE\n  - etc.\n\nArgs:\n    config_file: Path to configuration file (YAML, TOML, or JSON)\n\nReturns:\n    LifeEventsWorkflowConfig instance\n\nExamples:\n    >>> config = load_life_events_config(\"config/life_events.yaml\")\n    >>> print(config.work_dir)\n    >>> print(config.embedding[\"embedding_dim\"])", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/config.py", "line_number": 25, "module": "src.metainformant.life_events.config", "name": "load_life_events_config", "signature": "(config_file: str | Path) -> LifeEventsWorkflowConfig", "symbol_type": "function"}], "load_mapping_from_file": [{"docstring": "Load a structured mapping from YAML, TOML or JSON file.\n\n- Supports .yaml/.yml (if PyYAML available), .toml (if tomllib available), and .json via stdlib\n- Returns a Python dict; raises ValueError if format unsupported or parsing fails", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 159, "module": "src.metainformant.core.config", "name": "load_mapping_from_file", "signature": "(config_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "load_metadata": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 382, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "load_metadata", "signature": "(args, dir_subcommand = 'metadata')", "symbol_type": "function"}], "load_model": [{"docstring": "Load a trained model from disk.\n\nReconstructs an EventSequencePredictor from a saved model file.\nThe model will be in fitted state and ready for prediction.\n\nArgs:\n    path: Path to saved model file (JSON format)\n    \nReturns:\n    Reconstructed EventSequencePredictor instance\n    \nRaises:\n    FileNotFoundError: If model file does not exist\n    ValueError: If model file format is invalid\n    \nExamples:\n    >>> predictor = EventSequencePredictor.load_model(\"output/model.json\")\n    >>> predictions = predictor.predict(new_sequences)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 440, "module": "src.metainformant.life_events.models", "name": "load_model", "signature": "(cls, path: str | Path) -> 'EventSequencePredictor'", "symbol_type": "function"}], "load_ontology": [{"docstring": "Load ontology from JSON file.\n\nDeserializes an Ontology object from JSON format, reconstructing all\nterm attributes and relationships.\n\nArgs:\n    path: Path to JSON file\n    \nReturns:\n    Ontology object reconstructed from JSON\n    \nRaises:\n    IOError: If file does not exist or cannot be read\n    ValidationError: If file format is invalid\n    \nExamples:\n    >>> onto = save_ontology(original_onto, \"go.json\")\n    >>> loaded = load_ontology(\"go.json\")\n    >>> loaded.num_terms() == original_onto.num_terms()\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/serialize.py", "line_number": 88, "module": "src.metainformant.ontology.serialize", "name": "load_ontology", "signature": "(path: str | Path) -> Ontology", "symbol_type": "function"}], "load_pathway_database": [{"docstring": "Load pathway database from file or dictionary.\n\nSupports multiple file formats for pathway databases including GMT\n(Gene Matrix Transposed) format commonly used for pathway databases\nlike MSigDB, and tabular formats. Also supports loading from dictionary.\n\nArgs:\n    pathway_file: Path to pathway database file OR dictionary mapping pathway_id -> gene_list\n    format: File format:\n        - \"gmt\": GMT format (tab-separated: pathway_id, description, genes...)\n        - \"csv\": CSV format (columns: pathway_id, gene_id, optionally pathway_name)\n        - \"tsv\": TSV format (same as CSV but tab-separated)\n        - \"dict\": Dictionary format (pathway_file should be a dict)\n        \nReturns:\n    PathwayNetwork object with loaded pathways\n    \nRaises:\n    ValueError: If format is unsupported\n    \nExamples:\n    >>> # Load GMT format (MSigDB, KEGG, etc.)\n    >>> pathway_db = load_pathway_database(\"kegg_pathways.gmt\", format=\"gmt\")\n    >>> pathway_db.get_pathway_genes(\"KEGG_PATH:00010\")\n    {'GENE1', 'GENE2', ...}\n    \n    >>> # Load from dictionary\n    >>> pathway_data = {\"path1\": [\"GENE1\", \"GENE2\"], \"path2\": [\"GENE2\", \"GENE3\"]}\n    >>> pathway_db = load_pathway_database(pathway_data, format=\"dict\")\n    >>> len(pathway_db.pathways)\n    2", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 307, "module": "src.metainformant.networks.pathway", "name": "load_pathway_database", "signature": "(pathway_file: Union[str, Path, Dict[str, Any]], format: str = 'gmt') -> PathwayNetwork", "symbol_type": "function"}], "load_phenotype_data": [{"docstring": "Load phenotype data from various formats.\n\nArgs:\n    input_path: Path to input file\n    \nReturns:\n    Dictionary with loaded data and metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/phenotype/run_phenotype_analysis.py", "line_number": 81, "module": "scripts.phenotype.run_phenotype_analysis", "name": "load_phenotype_data", "signature": "(input_path: Path) -> dict[str, Any]", "symbol_type": "function"}], "load_postgres_config_from_env": [{"docstring": "Load PostgreSQL configuration from environment variables.\n\nArgs:\n    prefix: Environment variable prefix (default: \"PG\")\n        Looks for: {prefix}_HOST, {prefix}_PORT, {prefix}_DATABASE,\n        {prefix}_USER, {prefix}_PASSWORD\n        Also checks: DB_NAME, DB_USER, DB_PASSWORD\n        \nReturns:\n    PostgresConfig if all required variables are set, None otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 40, "module": "src.metainformant.core.config", "name": "load_postgres_config_from_env", "signature": "(prefix: str = 'PG') -> PostgresConfig | None", "symbol_type": "function"}], "load_progress_state": [{"docstring": "Load progress state from JSON file.\n\nArgs:\n    state_file: Path to progress_state.json file\n    \nReturns:\n    Dictionary mapping species to their state data\n    \nRaises:\n    FileNotFoundError: If state file doesn't exist\n    json.JSONDecodeError: If file is invalid JSON", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/amalgkit_visualization.py", "line_number": 63, "module": "src.metainformant.visualization.amalgkit_visualization", "name": "load_progress_state", "signature": "(state_file: Path | str) -> dict[str, Any]", "symbol_type": "function"}], "load_results": [{"docstring": "Load GWAS results from file or dict.\n\nArgs:\n    results: Path to results file or dict of results\n    \nReturns:\n    List of result records", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_comparison.py", "line_number": 62, "module": "src.metainformant.gwas.visualization_comparison", "name": "load_results", "signature": "(results)", "symbol_type": "function"}, {"docstring": "Load GWAS results from file or dict (concordance plot version).\n\nArgs:\n    results: Path to results file or dict of results\n    \nReturns:\n    List of result records", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_comparison.py", "line_number": 365, "module": "src.metainformant.gwas.visualization_comparison", "name": "load_results", "signature": "(results)", "symbol_type": "function"}], "load_seqrecord": [{"docstring": "Load a Biopython SeqRecord into the database.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/Loader.py", "line_number": 59, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.Loader", "name": "load_seqrecord", "signature": "(self, record)", "symbol_type": "function"}], "load_sequences": [{"docstring": "Load event sequences from file.\n\nArgs:\n    input_path: Path to input file\n    \nReturns:\n    List of EventSequence objects", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/run_life_events_analysis.py", "line_number": 186, "module": "scripts.life_events.run_life_events_analysis", "name": "load_sequences", "signature": "(input_path: Path) -> list", "symbol_type": "function"}], "load_sequences_from_json": [{"docstring": "Load event sequences from JSON file.\n\nSupports both single sequence and database formats.\n\nArgs:\n    path: Path to JSON file containing event sequences\n    \nReturns:\n    List of EventSequence objects\n    \nRaises:\n    FileNotFoundError: If file doesn't exist\n    ValueError: If file format is invalid\n    \nExamples:\n    >>> sequences = load_sequences_from_json(\"data/events.json\")\n    >>> len(sequences)\n    10", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/utils.py", "line_number": 20, "module": "src.metainformant.life_events.utils", "name": "load_sequences_from_json", "signature": "(path: str | Path) -> List[EventSequence]", "symbol_type": "function"}], "load_string_interactions": [{"docstring": "Load protein-protein interactions from STRING database format.\n\nParses STRING database interaction files (TSV format) and creates a\nProteinNetwork object. STRING provides confidence scores and evidence\ntypes for protein interactions.\n\nArgs:\n    string_file: Path to STRING interactions file (TSV format).\n        Expected columns: protein1, protein2, combined_score\n        Optional columns: experimental, database, textmining, coexpression\n    score_threshold: Minimum combined score (0-1000) for including interactions.\n        Default 400 (medium confidence). Higher values (e.g., 700) give\n        high-confidence interactions only.\n    limit_organisms: Optional list of organism taxonomy IDs (e.g., [\"9606\"])\n        to filter interactions. If None, includes all organisms.\n        \nReturns:\n    ProteinNetwork object with loaded interactions. Confidence scores\n    are converted from STRING scale (0-1000) to [0-1] range.\n    \nExamples:\n    >>> ppi = load_string_interactions(\n    ...     \"string_interactions.tsv\",\n    ...     score_threshold=700,  # High confidence only\n    ...     limit_organisms=[\"9606\"]  # Human only\n    ... )\n    >>> ppi.network_statistics()[\"total_interactions\"]\n    5000\n    \nReferences:\n    STRING database: https://string-db.org/", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 378, "module": "src.metainformant.networks.ppi", "name": "load_string_interactions", "signature": "(string_file: str = None, score_threshold: int = 400, limit_organisms: Optional[List[str]] = None, interactions_df: pd.DataFrame = None, proteins_df: pd.DataFrame = None, confidence_threshold: int = None) -> ProteinNetwork", "symbol_type": "function"}], "load_typed_env": [{"docstring": "Load a mapping of env vars with types.\n\nExample:\n    load_typed_env(prefix=\"APP\", keys={\"PORT\": int, \"DEBUG\": bool})", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 120, "module": "src.metainformant.core.config", "name": "load_typed_env", "signature": "() -> dict[str, Any]", "symbol_type": "function"}], "load_workflow_config": [{"docstring": "Load `AmalgkitWorkflowConfig` from a config file with env overrides.\n\nPaths in the config file are resolved relative to repository root.\nThis allows configs to work whether the repo is on `/home/q/...` or `/media/q/ext6/...`.\n\nExpected top-level keys:\n  - work_dir (str) - resolved relative to repo root\n  - log_dir (str, optional) - resolved relative to repo root\n  - threads (int)\n  - species_list (list[str])\n  - steps (mapping of step name -> params mapping)\n  - auto_install_amalgkit (bool, optional)\n  - genome (mapping, optional) - dest_dir resolved relative to repo root", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/workflow.py", "line_number": 1073, "module": "src.metainformant.rna.workflow", "name": "load_workflow_config", "signature": "(config_file: str | Path) -> AmalgkitWorkflowConfig", "symbol_type": "function"}], "local_align": [{"docstring": "Perform local (Smith-Waterman) sequence alignment.\n\nArgs:\n    seq1: First sequence to align\n    seq2: Second sequence to align\n    \nReturns:\n    AlignmentResult with best local alignment", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/alignment.py", "line_number": 78, "module": "src.metainformant.dna.alignment", "name": "local_align", "signature": "(seq1: str, seq2: str) -> AlignmentResult", "symbol_type": "function"}], "location": [{"docstring": "Parse out location information from the location string.\n\nThis uses simple Python code with some regular expressions to do the\nparsing, and then translates the results into appropriate objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 697, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "location", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1093, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "location", "signature": "(self, content)", "symbol_type": "function"}], "locus": [{"docstring": "Set the locus name is set as the name of the Sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 324, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "locus", "signature": "(self, locus_name)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 906, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "locus", "signature": "(self, content)", "symbol_type": "function"}], "log_fold_change_plot": [{"docstring": "Plot distribution of log fold changes.\n\nArgs:\n    data: DataFrame with log fold change values\n    log2fc_col: Column name for log2 fold change\n    group_col: Optional column for grouping\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import log_fold_change_plot\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> data = pd.DataFrame({\n    ...     'log2fc': np.random.normal(0, 1, 100)\n    ... })\n    >>> ax = log_fold_change_plot(data)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/expression.py", "line_number": 246, "module": "src.metainformant.visualization.expression", "name": "log_fold_change_plot", "signature": "(data: pd.DataFrame, log2fc_col: str = 'log2fc', group_col: str | None = None, **kwargs) -> plt.Axes", "symbol_type": "function"}], "log_odds": [{"docstring": "Return the Position-Specific Scoring Matrix.\n\nThe Position-Specific Scoring Matrix (PSSM) contains the log-odds\nscores computed from the probability matrix and the background\nprobabilities. If the background is None, a uniform background\ndistribution is assumed.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 361, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "log_odds", "signature": "(self, background = None)", "symbol_type": "function"}], "log_progress": [{"docstring": "Log progress for an operation.\n\nArgs:\n    current: Current progress count\n    total: Total count (None for indeterminate)\n    message: Optional message to include\n\nExample:\n    log_progress(5, 10, \"Processing items\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/progress.py", "line_number": 118, "module": "src.metainformant.core.progress", "name": "log_progress", "signature": "(current: int, total: int | None, message: str = '') -> None", "symbol_type": "function"}], "log_simulation_complete": [{"docstring": "Log simulation completion.\n\nArgs:\n    output_file: Path to output file", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/_common.py", "line_number": 81, "module": "scripts.simulation._common", "name": "log_simulation_complete", "signature": "(output_file: Path | str) -> None", "symbol_type": "function"}], "log_simulation_start": [{"docstring": "Log simulation start with parameters.\n\nArgs:\n    simulation_type: Type of simulation\n    **params: Simulation parameters to log", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/_common.py", "line_number": 69, "module": "scripts.simulation._common", "name": "log_simulation_start", "signature": "(simulation_type: str, **params: Any) -> None", "symbol_type": "function"}], "log_transform": [{"docstring": "Apply log transformation to expression data.\n\nArgs:\n    data: SingleCellData object (should be normalized)\n    base: Logarithm base (e for natural log, 2 for log2, 10 for log10)\n\nReturns:\n    Log-transformed SingleCellData object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/preprocessing.py", "line_number": 446, "module": "src.metainformant.singlecell.preprocessing", "name": "log_transform", "signature": "(data: SingleCellData, base: float = np.e) -> SingleCellData", "symbol_type": "function"}], "log_with_metadata": [{"docstring": "Log message with structured metadata.\n\nArgs:\n    logger: Logger instance\n    message: Log message\n    metadata: Dictionary of metadata to include\n    level: Log level to use (\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\")\n    structured: If True, writes metadata as separate JSON log entry for\n        structured logging systems. If False, appends JSON to message.\n\nExamples:\n    >>> logger = get_logger(__name__)\n    >>> log_with_metadata(logger, \"Processing complete\", {\n    ...     \"samples\": 100, \"time_seconds\": 45.2\n    ... })\n    >>> # With structured logging\n    >>> log_with_metadata(logger, \"Batch processed\", {\n    ...     \"batch_id\": \"batch_001\", \"records\": 1000\n    ... }, structured=True)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/logging.py", "line_number": 131, "module": "src.metainformant.core.logging", "name": "log_with_metadata", "signature": "(logger: logging.Logger, message: str, metadata: dict) -> None", "symbol_type": "function"}], "logger_file": [{"docstring": "The logger file.\n\nIf the logger_file is None, then add stream handler and remove file\nhandler. Otherwise, add file handler and remove stream handler.\n\n:param value: The logger_file path.\n:type: str", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 267, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "logger_file", "signature": "(self)", "symbol_type": "function"}, {"docstring": "The logger file.\n\nIf the logger_file is None, then add stream handler and remove file\nhandler. Otherwise, add file handler and remove stream handler.\n\n:param value: The logger_file path.\n:type: str", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 279, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "logger_file", "signature": "(self, value)", "symbol_type": "function"}], "logger_format": [{"docstring": "The logger format.\n\nThe logger_formatter will be updated when sets logger_format.\n\n:param value: The format string.\n:type: str", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 329, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "logger_format", "signature": "(self)", "symbol_type": "function"}, {"docstring": "The logger format.\n\nThe logger_formatter will be updated when sets logger_format.\n\n:param value: The format string.\n:type: str", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 340, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "logger_format", "signature": "(self, value)", "symbol_type": "function"}], "logistic": [{"docstring": "Logistic growth model.\n\nProposed in Zwietering et al., 1990 (PMID: 16348228)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/pm_fitting.py", "line_number": 39, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.pm_fitting", "name": "logistic", "signature": "(x, A, u, d, v, y0)", "symbol_type": "function"}], "logistic_fitness": [{"docstring": "Create logistic fitness function.\n\nArgs:\n    k: Steepness parameter\n    s_opt: Optimal trait value\n    \nReturns:\n    Logistic fitness function", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/model.py", "line_number": 144, "module": "src.metainformant.math.selection_experiments.model", "name": "logistic_fitness", "signature": "(k: float, s_opt: float) -> Callable[[np.ndarray], np.ndarray]", "symbol_type": "function"}], "logistic_map": [{"docstring": "Iterate the logistic map: x_{t+1} = r * x_t * (1 - x_t).\n\nThe logistic map is a classic example of discrete-time population dynamics\nthat can exhibit chaotic behavior for certain parameter values. Used to model\npopulation growth with density dependence.\n\nArgs:\n    r: Growth rate parameter (typically in [0, 4])\n    x0: Initial population value (clamped to [0, 1])\n    steps: Number of iterations to perform\n    \nReturns:\n    List of population values over time, starting with x0.\n    Values are clamped to [0, 1] at each step.\n    \nExamples:\n    >>> logistic_map(r=2.5, x0=0.5, steps=5)\n    [0.5, 0.625, 0.5859375, 0.606536865234375, 0.5966247408685684, ...]\n    \nReferences:\n    May, R. M. (1976). Simple mathematical models with very complicated dynamics.\n    Nature, 261(5560), 459-467.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/dynamics.py", "line_number": 7, "module": "src.metainformant.math.dynamics", "name": "logistic_map", "signature": "(r: float, x0: float, steps: int) -> list[float]", "symbol_type": "function"}], "lookup": [{"docstring": "Return a DBSeqRecord using an acceptable identifier.\n\nArguments:\n - kwargs - A single key-value pair where the key is one\n   of primary_id, gi, display_id, name, accession, version", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 768, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "lookup", "signature": "(self, **kwargs)", "symbol_type": "function"}], "lotka_volterra_step": [{"docstring": "Perform single Euler integration step for Lotka\u2013Volterra predator-prey model.\n\nThe Lotka\u2013Volterra equations model population dynamics of interacting species:\n- Prey growth: dx/dt = alpha*x - beta*x*y\n- Predator growth: dy/dt = delta*x*y - gamma*y\n\nArgs:\n    prey: Current prey population size\n    predator: Current predator population size\n    alpha: Prey intrinsic growth rate\n    beta: Predation rate (predator efficiency at consuming prey)\n    delta: Predator growth efficiency (conversion of prey to predators)\n    gamma: Predator mortality rate\n    dt: Time step size for Euler integration (default 0.01)\n    \nReturns:\n    Tuple of (next_prey, next_predator) after one time step.\n    Populations are clamped to non-negative values.\n    \nExamples:\n    >>> prey, pred = lotka_volterra_step(\n    ...     prey=100.0, predator=10.0,\n    ...     alpha=1.0, beta=0.1, delta=0.075, gamma=1.5, dt=0.01\n    ... )\n    >>> prey > 0 and pred > 0\n    True\n    \nReferences:\n    Lotka, A. J. (1925). Elements of physical biology. Williams & Wilkins.\n    Volterra, V. (1926). Variazioni e fluttuazioni del numero d'individui\n    in specie animali conviventi. Mem. Acad. Lincei Roma, 2, 31-113.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/dynamics.py", "line_number": 40, "module": "src.metainformant.math.dynamics", "name": "lotka_volterra_step", "signature": "(prey: float, predator: float, alpha: float, beta: float, delta: float, gamma: float, dt: float = 0.01) -> tuple[float, float]", "symbol_type": "function"}], "louvain_clustering": [{"docstring": "Perform Louvain clustering on single-cell data.\n\nArgs:\n    data: SingleCellData with neighbor graph\n    resolution: Resolution parameter (higher = more clusters)\n    random_state: Random seed\n\nReturns:\n    SingleCellData with cluster assignments in obs['louvain']", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/clustering.py", "line_number": 128, "module": "src.metainformant.singlecell.clustering", "name": "louvain_clustering", "signature": "(data: SingleCellData, resolution: float = 0.5, random_state: int = 42) -> SingleCellData", "symbol_type": "function"}], "lower": [{"docstring": "Return a copy of data with all ASCII characters converted to lowercase.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 309, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "lower", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the sequence in lower case.\n\nAn lower-case copy of the sequence is returned if inplace is False,\nthe default value:\n\n>>> from Bio.Seq import Seq, MutableSeq\n>>> my_seq = Seq(\"VHLTPeeK*\")\n>>> my_seq\nSeq('VHLTPeeK*')\n>>> my_seq.lower()\nSeq('vhltpeek*')\n>>> my_seq.upper()\nSeq('VHLTPEEK*')\n>>> my_seq\nSeq('VHLTPeeK*')\n\nThe sequence is modified in-place and returned if inplace is True:\n\n>>> my_seq = MutableSeq(\"VHLTPeeK*\")\n>>> my_seq\nMutableSeq('VHLTPeeK*')\n>>> my_seq.lower()\nMutableSeq('vhltpeek*')\n>>> my_seq.upper()\nMutableSeq('VHLTPEEK*')\n>>> my_seq\nMutableSeq('VHLTPeeK*')\n\n>>> my_seq.lower(inplace=True)\nMutableSeq('vhltpeek*')\n>>> my_seq\nMutableSeq('vhltpeek*')\n>>> my_seq.upper(inplace=True)\nMutableSeq('VHLTPEEK*')\n>>> my_seq\nMutableSeq('VHLTPEEK*')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if\n``lower`` is called on a ``Seq`` object with ``inplace=True``.\n\nSee also the ``upper`` method.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1457, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "lower", "signature": "(self, inplace = False)", "symbol_type": "function"}, {"docstring": "Return a lower case copy of the sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2417, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "lower", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a lower case copy of the sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2624, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "lower", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a copy of the record with a lower case sequence.\n\nAll the annotation is preserved unchanged. e.g.\n\n>>> from Bio import SeqIO\n>>> record = SeqIO.read(\"Fasta/aster.pro\", \"fasta\")\n>>> print(record.format(\"fasta\"))\n>gi|3298468|dbj|BAA31520.1| SAMIPF\nGGHVNPAVTFGAFVGGNITLLRGIVYIIAQLLGSTVACLLLKFVTNDMAVGVFSLSAGVG\nVTNALVFEIVMTFGLVYTVYATAIDPKKGSLGTIAPIAIGFIVGANI\n<BLANKLINE>\n>>> print(record.lower().format(\"fasta\"))\n>gi|3298468|dbj|BAA31520.1| SAMIPF\ngghvnpavtfgafvggnitllrgivyiiaqllgstvaclllkfvtndmavgvfslsagvg\nvtnalvfeivmtfglvytvyataidpkkgslgtiapiaigfivgani\n<BLANKLINE>\n\nTo take a more annotation rich example,\n\n>>> from Bio import SeqIO\n>>> old = SeqIO.read(\"EMBL/TRBG361.embl\", \"embl\")\n>>> len(old.features)\n3\n>>> new = old.lower()\n>>> len(old.features) == len(new.features)\nTrue\n>>> old.annotations[\"organism\"] == new.annotations[\"organism\"]\nTrue\n>>> old.dbxrefs == new.dbxrefs\nTrue", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 1137, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "lower", "signature": "(self) -> 'SeqRecord'", "symbol_type": "function"}, {"docstring": "Extend the sequence mask to the full sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/TwoBitIO.py", "line_number": 162, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.TwoBitIO", "name": "lower", "signature": "(self)", "symbol_type": "function"}], "lstrip": [{"docstring": "Strip leading characters contained in the argument.\n\nIf the argument is omitted or None, strip leading ASCII whitespace.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 265, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "lstrip", "signature": "(self, chars = None)", "symbol_type": "function"}, {"docstring": "Return a sequence object with leading and trailing ends stripped.\n\nWith default arguments, leading whitespace is removed:\n\n>>> seq = Seq(\" ACGT \")\n>>> seq.lstrip()\nSeq('ACGT ')\n>>> seq\nSeq(' ACGT ')\n\nIf ``chars`` is given and not ``None``, remove characters in ``chars``\nfrom the leading end instead.  The order of the characters to be removed\nis not important:\n\n>>> Seq(\"ACGACGTTACG\").lstrip(\"GCA\")\nSeq('TTACG')\n\nA copy of the sequence is returned if ``inplace`` is ``False`` (the\ndefault value).  If ``inplace`` is ``True``, the sequence is stripped\nin-place and returned.\n\n>>> seq = MutableSeq(\" ACGT \")\n>>> seq.lstrip()\nMutableSeq('ACGT ')\n>>> seq\nMutableSeq(' ACGT ')\n>>> seq.lstrip(inplace=True)\nMutableSeq('ACGT ')\n>>> seq\nMutableSeq('ACGT ')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if\n``lstrip`` is called on a ``Seq`` object with ``inplace=True``.\n\nSee also the strip and rstrip methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1210, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "lstrip", "signature": "(self, chars = None, inplace = False)", "symbol_type": "function"}], "m2rotaxis": [{"docstring": "Return angles, axis pair that corresponds to rotation matrix m.\n\nThe case where ``m`` is the identity matrix corresponds to a singularity\nwhere any rotation axis is valid. In that case, ``Vector([1, 0, 0])``,\nis returned.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 15, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "m2rotaxis", "signature": "(m)", "symbol_type": "function"}], "maf_distribution": [{"docstring": "Plot minor allele frequency distribution.\n\nArgs:\n    results: Results or path\n    output_path: Save path\n    bins: Number of histogram bins\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_enhanced.py", "line_number": 766, "module": "src.metainformant.gwas.visualization_enhanced", "name": "maf_distribution", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Minor allele frequency distribution (allele frequency spectrum).\n\nShows distribution of allele frequencies, useful for assessing\npopulation history and QC filtering effects.\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    bins: Number of histogram bins\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_variants.py", "line_number": 32, "module": "src.metainformant.gwas.visualization_variants", "name": "maf_distribution", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "main": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/_template_working.py", "line_number": 18, "module": "scripts._template_working", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main audit function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/audit_docstrings.py", "line_number": 80, "module": "scripts.audit_docstrings", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Run comprehensive verification.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/verify_rna_docs.py", "line_number": 170, "module": "scripts.verify_rna_docs", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Run comprehensive verification.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/verify_rna.py", "line_number": 170, "module": "scripts.verify_rna", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Run comprehensive triple-check verification.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/triple_check_rna.py", "line_number": 180, "module": "scripts.triple_check_rna", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Run comprehensive validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/validate_all_species_workflow.py", "line_number": 197, "module": "scripts.validate_all_species_workflow", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/archive/rna/run_quant_cleanup.py", "line_number": 25, "module": "scripts.archive.rna.run_quant_cleanup", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Run complete demonstration workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/core/run_demo.py", "line_number": 26, "module": "scripts.core.run_demo", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/dna/run_dna_analysis.py", "line_number": 348, "module": "scripts.dna.run_dna_analysis", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/ecology/run_ecology_analysis.py", "line_number": 233, "module": "scripts.ecology.run_ecology_analysis", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/epigenome/run_epigenome_analysis.py", "line_number": 191, "module": "scripts.epigenome.run_epigenome_analysis", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Download real Apis mellifera variant data.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/download_real_honeybee_variants.py", "line_number": 57, "module": "scripts.gwas.download_real_honeybee_variants", "name": "main", "signature": "() -> None", "symbol_type": "function"}, {"docstring": "Query metadata for key Apis mellifera BioProjects.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/query_bioproject_metadata.py", "line_number": 95, "module": "scripts.gwas.query_bioproject_metadata", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/run_genome_scale_gwas.py", "line_number": 170, "module": "scripts.gwas.run_genome_scale_gwas", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main workflow function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/run_life_events_analysis.py", "line_number": 414, "module": "scripts.life_events.run_life_events_analysis", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/generate_synthetic_data.py", "line_number": 106, "module": "scripts.life_events.generate_synthetic_data", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/learn_embeddings.py", "line_number": 92, "module": "scripts.life_events.learn_embeddings", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/train_model.py", "line_number": 97, "module": "scripts.life_events.train_model", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/predict_outcomes.py", "line_number": 61, "module": "scripts.life_events.predict_outcomes", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/visualize_sequences.py", "line_number": 76, "module": "scripts.life_events.visualize_sequences", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/compare_groups.py", "line_number": 66, "module": "scripts.life_events.compare_groups", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/analyze_intervention.py", "line_number": 81, "module": "scripts.life_events.analyze_intervention", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/interpret_predictions.py", "line_number": 70, "module": "scripts.life_events.interpret_predictions", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/export_embeddings.py", "line_number": 97, "module": "scripts.life_events.export_embeddings", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/validate_data.py", "line_number": 53, "module": "scripts.life_events.validate_data", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Generate all visualizations.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/generate_all_visualizations.py", "line_number": 36, "module": "scripts.life_events.generate_all_visualizations", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Generate comprehensive statistical summary.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/generate_statistical_summary.py", "line_number": 157, "module": "scripts.life_events.generate_statistical_summary", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main example function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/life_course_example.py", "line_number": 71, "module": "scripts.life_events.life_course_example", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/math/run_math_modeling.py", "line_number": 287, "module": "scripts.math.run_math_modeling", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/ml/run_ml_pipeline.py", "line_number": 279, "module": "scripts.ml.run_ml_pipeline", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/multiomics/run_multiomics_integration.py", "line_number": 268, "module": "scripts.multiomics.run_multiomics_integration", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/networks/run_network_analysis.py", "line_number": 331, "module": "scripts.networks.run_network_analysis", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/ontology/run_ontology_analysis.py", "line_number": 223, "module": "scripts.ontology.run_ontology_analysis", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/phenotype/run_phenotype_analysis.py", "line_number": 334, "module": "scripts.phenotype.run_phenotype_analysis", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main example function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/phenotype/load_antwiki_example.py", "line_number": 28, "module": "scripts.phenotype.load_antwiki_example", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main execution function.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/popgen/analysis.py", "line_number": 999, "module": "scripts.popgen.analysis", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/protein/run_protein_analysis.py", "line_number": 376, "module": "scripts.protein.run_protein_analysis", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/quality/run_quality_control.py", "line_number": 197, "module": "scripts.quality.run_quality_control", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Convert existing SRA files to FASTQ.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/convert_existing_sra.py", "line_number": 33, "module": "scripts.rna.convert_existing_sra", "name": "main", "signature": "() -> int", "symbol_type": "function"}, {"docstring": "Run all environment checks and report results.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/check_environment.py", "line_number": 31, "module": "scripts.rna.check_environment", "name": "main", "signature": "() -> int", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/run_workflow.py", "line_number": 49, "module": "scripts.rna.run_workflow", "name": "main", "signature": "() -> int", "symbol_type": "function"}, {"docstring": "Run all tests.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/test_getfastq_fix.py", "line_number": 125, "module": "scripts.rna.test_getfastq_fix", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/setup_genome.py", "line_number": 41, "module": "scripts.rna.setup_genome", "name": "main", "signature": "() -> int", "symbol_type": "function"}, {"docstring": "Run all tests.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/test_genome_prep.py", "line_number": 66, "module": "scripts.rna.test_genome_prep", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Run end-to-end workflow for P. barbatus.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/run_e2e_pbarbatus.py", "line_number": 26, "module": "scripts.rna.run_e2e_pbarbatus", "name": "main", "signature": "() -> int", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/discover_species.py", "line_number": 42, "module": "scripts.rna.discover_species", "name": "main", "signature": "() -> int", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/run_simulation.py", "line_number": 234, "module": "scripts.simulation.run_simulation", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_dna.py", "line_number": 270, "module": "scripts.simulation.simulate_dna", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_rna.py", "line_number": 280, "module": "scripts.simulation.simulate_rna", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_protein.py", "line_number": 248, "module": "scripts.simulation.simulate_protein", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_epigenome.py", "line_number": 180, "module": "scripts.simulation.simulate_epigenome", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_ontology.py", "line_number": 129, "module": "scripts.simulation.simulate_ontology", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_phenotype.py", "line_number": 166, "module": "scripts.simulation.simulate_phenotype", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_ecology.py", "line_number": 160, "module": "scripts.simulation.simulate_ecology", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_math.py", "line_number": 179, "module": "scripts.simulation.simulate_math", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_visualization.py", "line_number": 178, "module": "scripts.simulation.simulate_visualization", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_singlecell.py", "line_number": 320, "module": "scripts.simulation.simulate_singlecell", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_quality.py", "line_number": 203, "module": "scripts.simulation.simulate_quality", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_networks.py", "line_number": 185, "module": "scripts.simulation.simulate_networks", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_ml.py", "line_number": 200, "module": "scripts.simulation.simulate_ml", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_multiomics.py", "line_number": 165, "module": "scripts.simulation.simulate_multiomics", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_gwas.py", "line_number": 307, "module": "scripts.simulation.simulate_gwas", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_life_events.py", "line_number": 202, "module": "scripts.simulation.simulate_life_events", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_information.py", "line_number": 149, "module": "scripts.simulation.simulate_information", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_core.py", "line_number": 237, "module": "scripts.simulation.simulate_core", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/singlecell/run_singlecell_analysis.py", "line_number": 277, "module": "scripts.singlecell.run_singlecell_analysis", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": "Main entry point.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/visualization/run_visualization.py", "line_number": 242, "module": "scripts.visualization.run_visualization", "name": "main", "signature": "()", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/__main__.py", "line_number": 18, "module": "src.metainformant.__main__", "name": "main", "signature": "() -> None", "symbol_type": "function"}], "majority_consensus": [{"docstring": "Search majority rule consensus tree from multiple trees.\n\nThis is an extend majority rule method, which means the you can set any\ncutoff between 0 ~ 1 instead of 0.5. The default value of cutoff is 0 to\ncreate a relaxed binary consensus tree in any condition (as long as one of\nthe provided trees is a binary tree). The branch length of each consensus\nclade in the result consensus tree is the average length of all counts for\nthat clade.\n\n:Parameters:\n    trees : iterable\n        iterable of trees to produce consensus tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/Consensus.py", "line_number": 274, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.Consensus", "name": "majority_consensus", "signature": "(trees, cutoff = 0)", "symbol_type": "function"}], "make_back_table": [{"docstring": "Back a back-table (naive single codon mapping).\n\nONLY RETURNS A SINGLE CODON, chosen from the possible alternatives\nbased on their sort order.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Data/CodonTable.py", "line_number": 149, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Data.CodonTable", "name": "make_back_table", "signature": "(table, default_stop_codon)", "symbol_type": "function"}], "make_dssp_dict": [{"docstring": "DSSP dictionary mapping identifiers to properties.\n\nReturn a DSSP dictionary that maps (chainid, resid) to\naa, ss and accessibility, from a DSSP file.\n\nParameters\n----------\nfilename : string\n    the DSSP output file", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/DSSP.py", "line_number": 207, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.DSSP", "name": "make_dssp_dict", "signature": "(filename)", "symbol_type": "function"}], "make_extended": [{"docstring": "Set all psi and phi angles to extended conformation (123, -104).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 2206, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "make_extended", "signature": "(self)", "symbol_type": "function"}], "make_format": [{"docstring": "Virtual method used for formatting results.\n\nVirtual method.\nHere to be pointed to one of the _make_* methods.\nYou can as well create a new method and point make_format to it.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/PrintFormat.py", "line_number": 152, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.PrintFormat", "name": "make_format", "signature": "(self, cut = (), title = '', nc = (), s1 = '')", "symbol_type": "function"}], "make_info_string": [{"docstring": "Create nicely formatted support/branchlengths.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 673, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "make_info_string", "signature": "(data, terminal = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NewickIO.py", "line_number": 340, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NewickIO", "name": "make_info_string", "signature": "(clade, terminal = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NewickIO.py", "line_number": 345, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NewickIO", "name": "make_info_string", "signature": "(clade, terminal = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NewickIO.py", "line_number": 358, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NewickIO", "name": "make_info_string", "signature": "(clade, terminal = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NewickIO.py", "line_number": 365, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NewickIO", "name": "make_info_string", "signature": "(clade, terminal = False)", "symbol_type": "function"}], "make_python_instance": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 579, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "make_python_instance", "signature": "(self, suffix, node, args = None, kwds = None, newobj = False, unsafe = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 721, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "make_python_instance", "signature": "(self, suffix, node, args = None, kwds = None, newobj = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 579, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "make_python_instance", "signature": "(self, suffix, node, args = None, kwds = None, newobj = False, unsafe = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 721, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "make_python_instance", "signature": "(self, suffix, node, args = None, kwds = None, newobj = False)", "symbol_type": "function"}], "make_table": [{"docstring": "Return a table with thermodynamic parameters (as dictionary).\n\nArguments:\n - oldtable: An existing dictionary with thermodynamic parameters.\n - values: A dictionary with new or updated values.\n\nE.g., to replace the initiation parameters in the Sugimoto '96 dataset with\nthe initiation parameters from Allawi & SantaLucia '97:\n\n>>> from Bio.SeqUtils.MeltingTemp import make_table, DNA_NN2\n>>> table = DNA_NN2                               # Sugimoto '96\n>>> table['init_A/T']\n(0, 0)\n>>> newtable = make_table(oldtable=DNA_NN2, values={'init': (0, 0),\n...                       'init_A/T': (2.3, 4.1),\n...                       'init_G/C': (0.1, -2.8)})\n>>> print(\"%0.1f, %0.1f\" % newtable['init_A/T'])\n2.3, 4.1", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/MeltingTemp.py", "line_number": 379, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.MeltingTemp", "name": "make_table", "signature": "(oldtable = None, values = None)", "symbol_type": "function"}], "make_virtual_offset": [{"docstring": "Compute a BGZF virtual offset from block start and within block offsets.\n\nThe BAM indexing scheme records read positions using a 64 bit\n'virtual offset', comprising in C terms:\n\nblock_start_offset << 16 | within_block_offset\n\nHere block_start_offset is the file offset of the BGZF block\nstart (unsigned integer using up to 64-16 = 48 bits), and\nwithin_block_offset within the (decompressed) block (unsigned\n16 bit integer).\n\n>>> make_virtual_offset(0, 0)\n0\n>>> make_virtual_offset(0, 1)\n1\n>>> make_virtual_offset(0, 2**16 - 1)\n65535\n>>> make_virtual_offset(0, 2**16)\nTraceback (most recent call last):\n...\nValueError: Require 0 <= within_block_offset < 2**16, got 65536\n\n>>> 65536 == make_virtual_offset(1, 0)\nTrue\n>>> 65537 == make_virtual_offset(1, 1)\nTrue\n>>> 131071 == make_virtual_offset(1, 2**16 - 1)\nTrue\n\n>>> 6553600000 == make_virtual_offset(100000, 0)\nTrue\n>>> 6553600001 == make_virtual_offset(100000, 1)\nTrue\n>>> 6553600010 == make_virtual_offset(100000, 10)\nTrue\n\n>>> make_virtual_offset(2**48, 0)\nTraceback (most recent call last):\n...\nValueError: Require 0 <= block_start_offset < 2**48, got 281474976710656", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 280, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "make_virtual_offset", "signature": "(block_start_offset, within_block_offset)", "symbol_type": "function"}], "manhattan_plot": [{"docstring": "Generate Manhattan plot for GWAS results.\n\nArgs:\n    results: List of result dictionaries or path to results file (TSV)\n    output_path: Path to save plot\n    significance_threshold: P-value threshold for genome-wide significance (default: 5e-8)\n    suggestiveness_threshold: P-value threshold for suggestiveness (default: 1e-5)\n    chrom_colors: List of colors to alternate for chromosomes\n    title: Plot title\n\nReturns:\n    Dictionary with plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization.py", "line_number": 30, "module": "src.metainformant.gwas.visualization", "name": "manhattan_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Generate Manhattan plot for GWAS results (genome-scale optimized).\n\nHandles millions of SNPs efficiently by implementing:\n- Point thinning for non-significant regions\n- Memory-efficient data structures\n- Optimized rendering\n\nArgs:\n    results: List of result dictionaries or path to results file (TSV)\n    output_path: Path to save plot\n    significance_threshold: P-value threshold for genome-wide significance (default: 5e-8)\n    suggestiveness_threshold: P-value threshold for suggestiveness (default: 1e-5)\n    chrom_colors: List of colors to alternate for chromosomes\n    title: Plot title\n    max_points: Maximum points to plot per chromosome (for thinning)\n\nReturns:\n    Dictionary with plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_enhanced.py", "line_number": 44, "module": "src.metainformant.gwas.visualization_enhanced", "name": "manhattan_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Manhattan plot optimized for genome-scale data (millions of SNPs).\n\nImplements intelligent point thinning:\n- Keeps all significant/suggestive variants\n- Samples non-significant variants to reduce rendering time\n- Maintains visual appearance while improving performance\n\nArgs:\n    results: Association results or path to TSV file\n    output_path: Output path for plot\n    significance_threshold: Genome-wide significance (default 5e-8)\n    suggestiveness_threshold: Suggestive threshold (default 1e-5)\n    chrom_colors: List of colors for chromosomes\n    title: Plot title\n    max_points_per_chrom: Max points per chromosome for thinning\n    point_size: Marker size\n\nReturns:\n    Plot metadata with statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_genome.py", "line_number": 33, "module": "src.metainformant.gwas.visualization_genome", "name": "manhattan_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Create a Manhattan plot for genome-wide association studies.\n\nArgs:\n    data: DataFrame with genomic positions and p-values\n    x_col: Column name for x-axis (genomic position)\n    y_col: Column name for y-axis (usually -log10(p-value), or raw p-values)\n    chromosome_col: Column name for chromosome information\n    p_threshold: P-value threshold for significance\n    highlight_color: Color for significant points\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments for scatter\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import manhattan_plot\n    >>> import pandas as pd\n    >>> data = pd.DataFrame({\n    ...     'position': [1000, 2000, 3000],\n    ...     'pvalue': [1e-6, 1e-9, 0.01],\n    ...     'chromosome': ['chr1', 'chr1', 'chr2']\n    ... })\n    >>> data['neg_log10_p'] = -np.log10(data['pvalue'])\n    >>> ax = manhattan_plot(data, 'position', 'neg_log10_p', 'chromosome')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/genomics.py", "line_number": 19, "module": "src.metainformant.visualization.genomics", "name": "manhattan_plot", "signature": "(data: pd.DataFrame, x_col: str, y_col: str, chromosome_col: str = 'chromosome', **kwargs) -> plt.Axes", "symbol_type": "function"}], "map": [{"docstring": "Map the alignment to self.target and return the resulting alignment.\n\nHere, self.query and alignment.target are the same sequence.\n\nA typical example is where self is the pairwise alignment between a\nchromosome and a transcript, the argument is the pairwise alignment\nbetween the transcript and a sequence (e.g., as obtained by RNA-seq),\nand we want to find the alignment of the sequence to the chromosome:\n\n>>> from Bio import Align\n>>> aligner = Align.PairwiseAligner()\n>>> aligner.mode = 'local'\n>>> aligner.open_gap_score = -1\n>>> aligner.extend_gap_score = 0\n>>> chromosome = \"AAAAAAAACCCCCCCAAAAAAAAAAAGGGGGGAAAAAAAA\"\n>>> transcript = \"CCCCCCCGGGGGG\"\n>>> alignments1 = aligner.align(chromosome, transcript)\n>>> len(alignments1)\n1\n>>> alignment1 = alignments1[0]\n>>> print(alignment1)\ntarget            8 CCCCCCCAAAAAAAAAAAGGGGGG 32\n                  0 |||||||-----------|||||| 24\nquery             0 CCCCCCC-----------GGGGGG 13\n<BLANKLINE>\n>>> sequence = \"CCCCGGGG\"\n>>> alignments2 = aligner.align(transcript, sequence)\n>>> len(alignments2)\n1\n>>> alignment2 = alignments2[0]\n>>> print(alignment2)\ntarget            3 CCCCGGGG 11\n                  0 ||||||||  8\nquery             0 CCCCGGGG  8\n<BLANKLINE>\n>>> alignment = alignment1.map(alignment2)\n>>> print(alignment)\ntarget           11 CCCCAAAAAAAAAAAGGGG 30\n                  0 ||||-----------|||| 19\nquery             0 CCCC-----------GGGG  8\n<BLANKLINE>\n>>> format(alignment, \"psl\")\n'8\\t0\\t0\\t0\\t0\\t0\\t1\\t11\\t+\\tquery\\t8\\t0\\t8\\ttarget\\t40\\t11\\t30\\t2\\t4,4,\\t0,4,\\t11,26,\\n'\n\nMapping the alignment does not depend on the sequence contents. If we\ndelete the sequence contents, the same alignment is found in PSL format\n(though we obviously lose the ability to print the sequence alignment):\n\n>>> alignment1.target = Seq(None, len(alignment1.target))\n>>> alignment1.query = Seq(None, len(alignment1.query))\n>>> alignment2.target = Seq(None, len(alignment2.target))\n>>> alignment2.query = Seq(None, len(alignment2.query))\n>>> alignment = alignment1.map(alignment2)\n>>> format(alignment, \"psl\")\n'8\\t0\\t0\\t0\\t0\\t0\\t1\\t11\\t+\\tquery\\t8\\t0\\t8\\ttarget\\t40\\t11\\t30\\t2\\t4,4,\\t0,4,\\t11,26,\\n'\n\nThe map method can also be used to lift over an alignment between\ndifferent genome assemblies. In this case, self is a DNA alignment\nbetween two genome assemblies, and the argument is an alignment of a\ntranscript against one of the genome assemblies:\n\n>>> np.set_printoptions(threshold=5)  # print 5 array elements per row\n>>> chain = Align.read(\"Blat/panTro5ToPanTro6.over.chain\", \"chain\")\n>>> chain.sequences[0].id\n'chr1'\n>>> len(chain.sequences[0].seq)\n228573443\n>>> chain.sequences[1].id\n'chr1'\n>>> len(chain.sequences[1].seq)\n224244399\n>>> print(chain.coordinates)\n[[122250000 122250400 122250400 ... 122909818 122909819 122909835]\n [111776384 111776784 111776785 ... 112019962 112019962 112019978]]\n\nshowing that the range 122250000:122909835 of chr1 on chimpanzee genome\nassembly panTro5 aligns to range 111776384:112019978 of chr1 of\nchimpanzee genome assembly panTro6.\n\n>>> alignment = Align.read(\"Blat/est.panTro5.psl\", \"psl\")\n>>> alignment.sequences[0].id\n'chr1'\n>>> len(alignment.sequences[0].seq)\n228573443\n>>> alignment.sequences[1].id\n'DC525629'\n>>> len(alignment.sequences[1].seq)\n407\n>>> print(alignment.coordinates)\n[[122835789 122835847 122840993 122841145 122907212 122907314]\n [       32        90        90       242       242       344]]\n\nThis shows that nucleotide range 32:344 of expressed sequence tag\nDC525629 aligns to range 122835789:122907314 of chr1 of chimpanzee\ngenome assembly panTro5.\n\nNote that the target sequence chain.sequences[0].seq and the target\nsequence alignment.sequences[0] have the same length:\n\n>>> len(chain.sequences[0].seq) == len(alignment.sequences[0].seq)\nTrue\n\nWe swap the target and query of the chain such that the query of the\nchain corresponds to the target of alignment:\n\n>>> chain = chain[::-1]\n>>> chain.sequences[0].id\n'chr1'\n>>> len(chain.sequences[0].seq)\n224244399\n>>> chain.sequences[1].id\n'chr1'\n>>> len(chain.sequences[1].seq)\n228573443\n>>> print(chain.coordinates)\n[[111776384 111776784 111776785 ... 112019962 112019962 112019978]\n [122250000 122250400 122250400 ... 122909818 122909819 122909835]]\n\nNow we can get the coordinates of DC525629 against chimpanzee genome\nassembly panTro6 by calling map on the chain, with alignment as the\nargument:\n\n>>> lifted_alignment = chain.map(alignment)\n>>> lifted_alignment.sequences[0].id\n'chr1'\n>>> len(lifted_alignment.sequences[0].seq)\n224244399\n>>> lifted_alignment.sequences[1].id\n'DC525629'\n>>> len(lifted_alignment.sequences[1].seq)\n407\n>>> print(lifted_alignment.coordinates)\n[[111982717 111982775 111987921 111988073 112009200 112009302]\n [       32        90        90       242       242       344]]\n\nThis shows that nucleotide range 32:344 of expressed sequence tag\nDC525629 aligns to range 111982717:112009302 of chr1 of chimpanzee\ngenome assembly panTro6. Note that the genome span of DC525629 on\nchimpanzee genome assembly panTro5 is 122907314 - 122835789 = 71525 bp,\nwhile on panTro6 the genome span is 112009302 - 111982717 = 26585 bp.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 3341, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "map", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Create new Hit object, mapping the given function to its HSPs.\n\n:param func: function for mapping\n:type func: callable, accepts HSP, returns HSP\n\n``map`` is analogous to Python's built-in ``map`` function. It is applied to\nall HSPs contained in the Hit object and returns a new Hit object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/hit.py", "line_number": 407, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.hit", "name": "map", "signature": "(self, func = None)", "symbol_type": "function"}], "map_events_to_traits": [{"docstring": "Map events to phenotypic trait categories.\n\nMaps events in a sequence to predefined trait categories based on\nevent types. Uses default mapping if none provided.\n\nArgs:\n    sequence: EventSequence to map (single sequence, not list)\n    trait_mapping: Optional mapping of trait names to event types.\n                  If None, uses default mapping for health, education, occupation, and mobility.\n    \nReturns:\n    Dictionary mapping trait names to dictionaries containing:\n    - count: Number of events matching this trait\n    - events: List of event types matching this trait\n    - timestamps: List of event timestamps (ISO format for datetime)\n    \nRaises:\n    ImportError: If life_events module is not available\n    ValidationError: If sequence is invalid\n    \nExamples:\n    >>> from metainformant.life_events import EventSequence, Event\n    >>> from datetime import datetime\n    >>> from metainformant.phenotype import map_events_to_traits\n    >>> seq = EventSequence(\"p1\", [\n    ...     Event(\"diagnosis\", datetime(2020, 1, 1), \"health\"),\n    ...     Event(\"degree\", datetime(2010, 1, 1), \"education\"),\n    ... ])\n    >>> traits = map_events_to_traits(seq)\n    >>> \"health_issues\" in traits\n    True\n    >>> traits[\"health_issues\"][\"count\"]\n    1", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/phenotype/life_course.py", "line_number": 279, "module": "src.metainformant.phenotype.life_course", "name": "map_events_to_traits", "signature": "(sequence: EventSequence, trait_mapping: Optional[Dict[str, List[str]]] = None) -> Dict[str, Any]", "symbol_type": "function"}], "map_ids_uniprot": [{"docstring": "Map UniProt accessions/IDs to canonical UniProtKB primary accession.\n\nPerforms an ID mapping job and polls until finished, then returns a mapping\nof input id \u2192 primaryAccession for minimal functionality under tests.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/uniprot.py", "line_number": 11, "module": "src.metainformant.protein.uniprot", "name": "map_ids_uniprot", "signature": "(ids: Iterable[str]) -> Dict[str, str]", "symbol_type": "function"}], "map_variants_to_transcripts": [{"docstring": "Map genetic variants to nearby transcripts.\n\nIdentifies transcripts that overlap or are near genetic variants,\nuseful for understanding variant effects on gene expression.\n\nArgs:\n    variants: DataFrame with 'chrom', 'pos' columns (and optionally 'ref', 'alt')\n    transcript_annotations: DataFrame with 'chrom', 'start', 'end', 'transcript_id' columns\n    window_size: Window size around transcript boundaries to consider (default: 5kb)\n    \nReturns:\n    DataFrame with variant-transcript mappings:\n    - 'variant_chrom', 'variant_pos': Variant coordinates\n    - 'transcript_id': Transcript identifier\n    - 'distance': Distance from variant to transcript (0 if overlapping)\n    - 'overlaps': Boolean indicating if variant overlaps transcript", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/rna_integration.py", "line_number": 16, "module": "src.metainformant.dna.rna_integration", "name": "map_variants_to_transcripts", "signature": "(variants: pd.DataFrame, transcript_annotations: pd.DataFrame, window_size: int = 5000) -> pd.DataFrame", "symbol_type": "function"}], "mapall": [{"docstring": "Map each of the alignments to self, and return the mapped alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 3586, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "mapall", "signature": "(self, alignments)", "symbol_type": "function"}], "maps": [{"docstring": "Get a list of entries of type map.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 192, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "maps", "signature": "(self)", "symbol_type": "function"}], "mark_complete": [{"docstring": "Mark download as complete.\n\nArgs:\n    success: If True, download succeeded; if False, it failed", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/download_progress.py", "line_number": 181, "module": "src.metainformant.rna.steps.download_progress", "name": "mark_complete", "signature": "(self, success: bool = True) -> None", "symbol_type": "function"}], "mark_exclude_keywords": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 225, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "mark_exclude_keywords", "signature": "(self, dir_config)", "symbol_type": "function"}], "mark_redundant_biosample": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 287, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "mark_redundant_biosample", "signature": "(self, exe_flag)", "symbol_type": "function"}], "mark_treatment_terms": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 250, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "mark_treatment_terms", "signature": "(self, dir_config)", "symbol_type": "function"}], "match": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 75, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "match", "signature": "(node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 84, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "match", "signature": "(node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 91, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "match", "signature": "(node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 114, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "match", "signature": "(node)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 147, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "match", "signature": "(node)", "symbol_type": "function"}], "match_attrs": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 364, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "match_attrs", "signature": "(elem)", "symbol_type": "function"}], "match_is_valid": [{"docstring": "Return True if match is not a Consensus column (PRIVATE).\n\nIt's not possible to distinguish a sequence line from a Consensus line with\na regexp, so need to check the ID column.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HHsuiteIO/hhsuite2_text.py", "line_number": 169, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HHsuiteIO.hhsuite2_text", "name": "match_is_valid", "signature": "(match)", "symbol_type": "function"}], "matches": [{"docstring": "Check for matches in both CDAO and OBO namespaces.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NeXMLIO.py", "line_number": 53, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NeXMLIO", "name": "matches", "signature": "(s)", "symbol_type": "function"}], "max": [{"docstring": "Maximal possible score for this motif.\n\nreturns the score computed for the consensus sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 489, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "max", "signature": "(self)", "symbol_type": "function"}], "mean": [{"docstring": "Return the mean value for the data points (float).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Graph.py", "line_number": 134, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Graph", "name": "mean", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return expected value of the score of a motif.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 517, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "mean", "signature": "(self, background = None)", "symbol_type": "function"}], "medline_id": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 658, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "medline_id", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1035, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "medline_id", "signature": "(self, content)", "symbol_type": "function"}], "melting_temperature": [{"docstring": "Very rough Tm estimate.\n\n- Short sequences (<= 14): Wallace rule 2*(A+T) + 4*(G+C)\n- Otherwise: 64.9 + 41*(G+C-16.4)/N", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/composition.py", "line_number": 32, "module": "src.metainformant.dna.composition", "name": "melting_temperature", "signature": "(seq: str) -> float", "symbol_type": "function"}], "merge": [{"docstring": "Run `amalgkit merge` (combine per-sample quantifications).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 576, "module": "src.metainformant.rna.amalgkit", "name": "merge", "signature": "(params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}], "merge_configs": [{"docstring": "Deep merge two configuration dictionaries.\n\nArgs:\n    base: Base configuration\n    override: Configuration to override with\n    \nReturns:\n    Merged configuration (override takes precedence)\n\nExample:\n    base = {\"a\": 1, \"b\": {\"c\": 2}}\n    override = {\"b\": {\"d\": 3}}\n    merged = merge_configs(base, override)\n    # Result: {\"a\": 1, \"b\": {\"c\": 2, \"d\": 3}}", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 196, "module": "src.metainformant.core.config", "name": "merge_configs", "signature": "(base: dict[str, Any], override: dict[str, Any]) -> dict[str, Any]", "symbol_type": "function"}], "merge_main": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/merge.py", "line_number": 7, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.merge", "name": "merge_main", "signature": "(args)", "symbol_type": "function"}], "merge_params": [{"docstring": "Merge common parameters with step-specific overrides.\n\nArgs:\n    extra: Step-specific parameter overrides\n    \nReturns:\n    Merged parameter dictionary", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/workflow.py", "line_number": 174, "module": "src.metainformant.rna.workflow", "name": "merge_params", "signature": "(extra: Mapping[str, Any] | None = None) -> AmalgkitParams", "symbol_type": "function"}], "merge_table": [{"docstring": "Path to merged abundance table file.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/configs.py", "line_number": 44, "module": "src.metainformant.rna.configs", "name": "merge_table", "signature": "(self) -> Path", "symbol_type": "function"}], "merge_vcf_files": [{"docstring": "Merge multiple VCF files into a single VCF.\n\nArgs:\n    vcf_list: List of VCF file paths to merge\n    output_vcf: Path to output merged VCF file\n\nReturns:\n    Dictionary with merge metadata and result status\n\nNote:\n    Requires bcftools to be available. Files should have same sample IDs\n    or be indexed appropriately.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/calling.py", "line_number": 273, "module": "src.metainformant.gwas.calling", "name": "merge_vcf_files", "signature": "(vcf_list: list[str | Path], output_vcf: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "merge_with_support": [{"docstring": "Merge clade support (from consensus or list of bootstrap-trees) with phylogeny.\n\ntree=merge_bootstrap(phylo,bs_tree=<list_of_trees>)\nor\ntree=merge_bootstrap(phylo,consree=consensus_tree with clade support)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 878, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "merge_with_support", "signature": "(self, bstrees = None, constree = None, threshold = 0.5, outgroup = None)", "symbol_type": "function"}], "metadata": [{"docstring": "Run `amalgkit metadata` (fetch SRA/ENA metadata).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 546, "module": "src.metainformant.rna.amalgkit", "name": "metadata", "signature": "(params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}], "metadata_main": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/metadata.py", "line_number": 64, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.metadata", "name": "metadata_main", "signature": "(args)", "symbol_type": "function"}], "miami_plot": [{"docstring": "Miami plot (back-to-back Manhattan) for two traits.\n\nShows GWAS results for two phenotypes in a mirrored Manhattan plot,\nuseful for identifying pleiotropic loci.\n\nArgs:\n    results1: Association results for trait 1\n    results2: Association results for trait 2\n    output_path: Output path\n    trait1_name: Name of trait 1\n    trait2_name: Name of trait 2\n    significance_threshold: P-value threshold\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_comparison.py", "line_number": 32, "module": "src.metainformant.gwas.visualization_comparison", "name": "miami_plot", "signature": "(results1: list[dict[str, Any]] | Path, results2: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "min": [{"docstring": "Minimal possible score for this motif.\n\nreturns the score computed for the anticonsensus sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 501, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "min", "signature": "(self)", "symbol_type": "function"}], "min_dist": [{"docstring": "Return minimum distance between coord and surface.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/ResidueDepth.py", "line_number": 556, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.ResidueDepth", "name": "min_dist", "signature": "(coord, surface)", "symbol_type": "function"}], "missingness_plot": [{"docstring": "Missing data patterns (by sample or by variant).\n\nVisualizes missingness rates to identify problematic samples\nor variants with poor genotyping.\n\nArgs:\n    vcf_path: Path to VCF file\n    output_path: Output path\n    by_sample: Plot by sample (True) or by variant (False)\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_variants.py", "line_number": 355, "module": "src.metainformant.gwas.visualization_variants", "name": "missingness_plot", "signature": "(vcf_path: Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "mktest": [{"docstring": "McDonald-Kreitman test for neutrality.\n\nImplement the McDonald-Kreitman test for neutrality (PMID: 1904993)\nThis method counts changes rather than sites\n(http://mkt.uab.es/mkt/help_mkt.asp).\n\nArguments:\n - alignment    - Alignment of gene nucleotide sequences to compare.\n - species      - List of the species ID for each sequence in the alignment.\n   Typically, the species ID is the species name as a string, or an integer.\n - codon_table  - Codon table to use for forward translation.\n\nReturn the p-value of test result.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/analysis.py", "line_number": 1041, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.analysis", "name": "mktest", "signature": "(alignment, species = None, codon_table = None)", "symbol_type": "function"}, {"docstring": "McDonald-Kreitman test for neutrality.\n\nImplement the McDonald-Kreitman test for neutrality (PMID: 1904993)\nThis method counts changes rather than sites\n(http://mkt.uab.es/mkt/help_mkt.asp).\n\nArguments:\n - codon_alns  - list of CodonAlignment to compare (each\n   CodonAlignment object corresponds to gene sampled from a species)\n\nReturn the p-value of test result.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonalignment.py", "line_number": 231, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonalignment", "name": "mktest", "signature": "(codon_alns, codon_table = None, alpha = 0.05)", "symbol_type": "function"}], "ml_integration": [{"docstring": "Information-theoretic feature selection for ML.\n\nArgs:\n    X: Feature matrix (samples x features)\n    y: Target vector\n    method: Selection method (\"feature_mi\", \"feature_entropy\")\n    \nReturns:\n    Feature analysis results\n    \nExamples:\n    >>> import numpy as np\n    >>> X = np.random.randn(100, 50)\n    >>> y = np.random.randint(0, 2, 100)\n    >>> results = ml_integration(X, y, method=\"feature_mi\")\n    \nRaises:\n    ValueError: If X or y are empty, shapes don't match, or method is invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/integration.py", "line_number": 408, "module": "src.metainformant.information.integration", "name": "ml_integration", "signature": "(X: np.ndarray, y: np.ndarray, method: str = 'feature_mi') -> dict[str, Any]", "symbol_type": "function"}], "model_to_dict": [{"docstring": "Returns the model properties as a dict\n\nArgs:\n    model_instance (one of your model instances): the model instance that\n        will be converted to a dict.\n\nKeyword Args:\n    serialize (bool): if True, the keys in the dict will be values from\n        attribute_map", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1648, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "model_to_dict", "signature": "(model_instance, serialize = True)", "symbol_type": "function"}], "modes": [{"docstring": "File modes (binary or text) that the parser can handle.\n\nThis property must be \"t\" (for text mode only), \"b\" (for binary mode\nonly), \"tb\" (if both text and binary mode are accepted, but text mode\nis preferred), or \"bt\" (if both text and binary mode are accepted, but\nbinary mode is preferred).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/Interfaces.py", "line_number": 46, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.Interfaces", "name": "modes", "signature": "(self)", "symbol_type": "function"}, {"docstring": "File modes (binary or text) that the writer can handle.\n\nThis property must be \"t\" (for text mode only), \"b\" (for binary mode\nonly), \"tb\" (if both text and binary mode are accepted, but text mode\nis preferred), or \"bt\" (if both text and binary mode are accepted, but\nbinary mode is preferred).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/Interfaces.py", "line_number": 169, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.Interfaces", "name": "modes", "signature": "(self)", "symbol_type": "function"}], "modify": [{"docstring": "Modify motifs and background density.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/thresholds.py", "line_number": 58, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.thresholds", "name": "modify", "signature": "(self, scores, mo_probs, bg_probs)", "symbol_type": "function"}], "modularity": [{"docstring": "Calculate modularity of a network partition.\n\nModularity measures how much more connected nodes within communities\nare compared to a random network with the same degree distribution.\nHigher modularity indicates better community structure.\n\nArgs:\n    network: Input biological network\n    communities: Dictionary mapping node identifier to community ID\n    resolution: Resolution parameter for modularity. Higher values\n        favor smaller communities, lower values favor larger communities.\n        Default 1.0.\n        \nReturns:\n    Modularity score. Typically ranges from -1 to 1, but can exceed 1\n    for very modular networks. Positive values indicate good partitioning.\n    Formula: Q = (1/2m) \u03a3\u1d62\u2c7c [A\u1d62\u2c7c - (\u03b3 k\u1d62 k\u2c7c)/(2m)] \u03b4(c\u1d62, c\u2c7c)\n    where m is total edge weight, A is adjacency, k is degree,\n    \u03b3 is resolution, and \u03b4 is community indicator.\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\", \"D\"], directed=False)\n    >>> network.add_edge(\"A\", \"B\"); network.add_edge(\"C\", \"D\")\n    >>> communities = {\"A\": 0, \"B\": 0, \"C\": 1, \"D\": 1}\n    >>> mod = modularity(network, communities)\n    >>> mod > 0.0  # Should have positive modularity\n    True\n    \nReferences:\n    Newman, M. E. J. (2006). Modularity and community structure in networks.\n    Proceedings of the National Academy of Sciences, 103(23), 8577-8582.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/community.py", "line_number": 67, "module": "src.metainformant.networks.community", "name": "modularity", "signature": "(network: BiologicalNetwork, communities: Dict[str, int], resolution: float = 1.0) -> float", "symbol_type": "function"}], "mol_seq": [{"docstring": "Create molecular sequence object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 594, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "mol_seq", "signature": "(self, elem)", "symbol_type": "function"}], "molar_extinction_coefficient": [{"docstring": "Calculate the molar extinction coefficient.\n\nCalculates the molar extinction coefficient assuming cysteines\n(reduced) and cystines residues (Cys-Cys-bond)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/ProtParam.py", "line_number": 350, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.ProtParam", "name": "molar_extinction_coefficient", "signature": "(self)", "symbol_type": "function"}], "molecular_weight": [{"docstring": "Calculate MW from Protein sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/ProtParam.py", "line_number": 132, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.ProtParam", "name": "molecular_weight", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Calculate the molecular mass of DNA, RNA or protein sequences as float.\n\nOnly unambiguous letters are allowed. Nucleotide sequences are assumed to\nhave a 5' phosphate.\n\nArguments:\n - seq: string, Seq, or SeqRecord object.\n - seq_type: The default is to assume DNA; override this with a string\n   \"DNA\", \"RNA\", or \"protein\".\n - double_stranded: Calculate the mass for the double stranded molecule?\n - circular: Is the molecule circular (has no ends)?\n - monoisotopic: Use the monoisotopic mass tables?\n\n>>> print(\"%0.2f\" % molecular_weight(\"AGC\"))\n949.61\n>>> print(\"%0.2f\" % molecular_weight(Seq(\"AGC\")))\n949.61\n\nHowever, it is better to be explicit - for example with strings:\n\n>>> print(\"%0.2f\" % molecular_weight(\"AGC\", \"DNA\"))\n949.61\n>>> print(\"%0.2f\" % molecular_weight(\"AGC\", \"RNA\"))\n997.61\n>>> print(\"%0.2f\" % molecular_weight(\"AGC\", \"protein\"))\n249.29", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/__init__.py", "line_number": 420, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.__init__", "name": "molecular_weight", "signature": "(seq, seq_type = 'DNA', double_stranded = False, circular = False, monoisotopic = False)", "symbol_type": "function"}], "molecule_type": [{"docstring": "Validate and record the molecule type (for round-trip etc).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 353, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "molecule_type", "signature": "(self, mol_type)", "symbol_type": "function"}, {"docstring": "Validate and record the molecule type (for round-trip etc).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 935, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "molecule_type", "signature": "(self, mol_type)", "symbol_type": "function"}], "monitor_workflows": [{"docstring": "Real-time monitoring of workflows.\n\nArgs:\n    species_configs: Dictionary mapping species_id -> config_path\n    watch_interval: Update interval in seconds", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/orchestration.py", "line_number": 565, "module": "src.metainformant.rna.orchestration", "name": "monitor_workflows", "signature": "(species_configs: dict[str, Path], watch_interval: int = 60) -> None", "symbol_type": "function"}], "move_track": [{"docstring": "Move a track from one level on the diagram to another.\n\nArguments:\n - from_level   - an integer. The level at which the track to be\n   moved is found.\n - to_level     - an integer. The level to move the track to.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Diagram.py", "line_number": 343, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Diagram", "name": "move_track", "signature": "(self, from_level, to_level)", "symbol_type": "function"}], "mqtl_analysis": [{"docstring": "Perform methylation quantitative trait locus (mQTL) analysis.\n\nIdentifies genetic variants associated with methylation levels.\n\nArgs:\n    methylation_df: DataFrame with 'chrom', 'pos', 'beta' columns\n    genotypes: Optional dictionary mapping variant_id -> genotype list\n    variant_positions: Optional list of (chrom, pos) tuples for variants\n    window_size: Window size around CpG sites to search for variants (default: 1Mb)\n    \nReturns:\n    DataFrame with mQTL associations:\n    - 'cpg_chrom', 'cpg_pos': CpG site coordinates\n    - 'variant_chrom', 'variant_pos': Variant coordinates\n    - 'correlation': Correlation between genotype and methylation\n    - 'p_value': Statistical significance (if scipy available)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/methylation.py", "line_number": 117, "module": "src.metainformant.epigenome.methylation", "name": "mqtl_analysis", "signature": "(methylation_df: pd.DataFrame, genotypes: dict[str, list[int]] | None = None, variant_positions: list[tuple[str, int]] | None = None, window_size: int = 1000000) -> pd.DataFrame", "symbol_type": "function"}], "multi_coord_space": [{"docstring": "Generate [dLen] transform matrices to coord space defined by 3 points.\n\nNew coordinate space will have:\n    acs[0] on XZ plane\n    acs[1] origin\n    acs[2] on +Z axis\n\n:param NumPy array [entries]x3x3 [entries] XYZ coords for 3 atoms\n:param bool rev: if True, also return reverse transformation matrix\n(to return from coord_space)\n:returns: [entries] 4x4 NumPy arrays, x2 if rev=True", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 665, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "multi_coord_space", "signature": "(a3: np.ndarray, dLen: int, rev: bool = False) -> np.ndarray", "symbol_type": "function"}], "multi_rot_Y": [{"docstring": "Create [entries] NumPy Y rotation matrices for [entries] angles.\n\n:param entries: int number of matrices generated.\n:param angle_rads: NumPy array of angles\n:returns: entries x 4 x 4 homogeneous rotation matrices", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 649, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "multi_rot_Y", "signature": "(angle_rads: np.ndarray) -> np.ndarray", "symbol_type": "function"}], "multi_rot_Z": [{"docstring": "Create [entries] NumPy Z rotation matrices for [entries] angles.\n\n:param entries: int number of matrices generated.\n:param angle_rads: NumPy array of angles\n:returns: entries x 4 x 4 homogeneous rotation matrices", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 634, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "multi_rot_Z", "signature": "(angle_rads: np.ndarray) -> np.ndarray", "symbol_type": "function"}], "multi_trait_manhattan": [{"docstring": "Multi-trait Manhattan plot (stacked or faceted).\n\nShows GWAS results for multiple phenotypes simultaneously.\n\nArgs:\n    results_dict: Dictionary of {trait_name: results}\n    output_path: Output path\n    significance_threshold: P-value threshold\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_comparison.py", "line_number": 212, "module": "src.metainformant.gwas.visualization_comparison", "name": "multi_trait_manhattan", "signature": "(results_dict: dict[str, list[dict[str, Any]] | Path], output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "multilevel_selection_decomposition": [{"docstring": "Decompose multilevel selection into between-group and within-group components.\n\nSeparates selection acting at different levels: selection between groups\n(group-level fitness differences) and selection within groups (individual-level\nfitness differences). Useful for understanding the balance of group vs.\nindividual selection.\n\nArgs:\n    group_means: Sequence of mean trait values for each group\n    individual_deviations: Sequence of individual deviations from their\n        group means (individual_value - group_mean for each individual)\n    selection_strength_group: Selection coefficient for group-level selection (s_g)\n    selection_strength_individual: Selection coefficient for individual-level\n        selection (s_i)\n        \nReturns:\n    Tuple of (between_group_selection, within_group_selection, total_selection):\n    - between_group: Selection due to group-level variance = s_g \u00d7 Var(group_means)\n    - within_group: Selection due to individual variance = s_i \u00d7 Var(deviations)\n    - total: Sum of both components\n    \nExamples:\n    >>> group_means = [0.5, 0.7, 0.3]\n    >>> deviations = [0.1, -0.1, 0.05, -0.05, 0.2, -0.2]\n    >>> between, within, total = multilevel_selection_decomposition(\n    ...     group_means, deviations, selection_strength_group=0.5, selection_strength_individual=0.3\n    ... )\n    >>> total == between + within\n    True\n    \nReferences:\n    Price, G. R. (1972). Extension of covariance selection mathematics.\n    Annals of Human Genetics, 35(4), 485-490.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection.py", "line_number": 35, "module": "src.metainformant.math.selection", "name": "multilevel_selection_decomposition", "signature": "(group_means: Sequence[float], individual_deviations: Sequence[float], selection_strength_group: float, selection_strength_individual: float) -> Tuple[float, float, float]", "symbol_type": "function"}], "multiomics_integration": [{"docstring": "Information-theoretic analysis across multiple omics platforms.\n\nArgs:\n    genomics_data: Genomic data matrix (samples x features)\n    transcriptomics_data: Transcriptomic data matrix (samples x features)\n    proteomics_data: Proteomic data matrix (samples x features)\n    method: Analysis method (\"cross_platform_mi\", \"platform_entropy\")\n    feature_indices: Optional dictionary mapping platform names to feature indices.\n        For example: {\"genomics\": [0, 1, 2], \"transcriptomics\": [0, 3, 5]}.\n        If None, uses first feature [0]. Single integers are converted to lists.\n    \nReturns:\n    Analysis results dictionary with consistent matrix format:\n    - {platform1}_{platform2}_mi_matrix: MI matrix\n    - {platform1}_feature_indices: List of indices used\n    - {platform2}_feature_indices: List of indices used\n    - {platform1}_{platform2}_mean_mi: Mean MI\n    - {platform1}_{platform2}_max_mi: Max MI\n    - {platform1}_{platform2}_min_mi: Min MI\n    \nExamples:\n    >>> import numpy as np\n    >>> genomics = np.random.randn(100, 50)\n    >>> transcriptomics = np.random.randn(100, 50)\n    >>> # Use first feature (default)\n    >>> results = multiomics_integration(genomics, transcriptomics, method=\"cross_platform_mi\")\n    >>> # Use specific features\n    >>> results = multiomics_integration(\n    ...     genomics, transcriptomics,\n    ...     method=\"cross_platform_mi\",\n    ...     feature_indices={\"genomics\": [0, 1], \"transcriptomics\": [0, 2]}\n    ... )", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/integration.py", "line_number": 297, "module": "src.metainformant.information.integration", "name": "multiomics_integration", "signature": "(genomics_data: np.ndarray | None = None, transcriptomics_data: np.ndarray | None = None, proteomics_data: np.ndarray | None = None, method: str = 'cross_platform_mi', feature_indices: dict[str, int | list[int]] | None = None) -> dict[str, Any]", "symbol_type": "function"}], "mutate_sequence": [{"docstring": "Introduce random mutations into a sequence.\n\nArgs:\n    seq: DNA or protein sequence string\n    n_mut: Number of mutations to introduce\n    rng: Random number generator (default: random module)\n    \nReturns:\n    Mutated sequence with random substitutions\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/sequences.py", "line_number": 58, "module": "src.metainformant.simulation.sequences", "name": "mutate_sequence", "signature": "(seq: str, n_mut: int) -> str", "symbol_type": "function"}], "mutation_selection_balance_dominant": [{"docstring": "Calculate equilibrium frequency under mutation-selection balance (dominant).\n\nFor a fully dominant deleterious allele, heterozygotes and homozygotes\nboth experience selection. Equilibrium frequency is typically much lower\nthan for recessive alleles.\n\nArgs:\n    mutation_rate: Mutation rate creating deleterious allele (\u03bc)\n    selection_coefficient: Selection coefficient (s, applies to heterozygotes\n        and homozygotes for dominant allele)\n        \nReturns:\n    Equilibrium frequency of deleterious allele. Returns 0.0 if s <= 0.\n    Formula: q_eq \u2248 \u03bc / s\n    \nExamples:\n    >>> mutation_selection_balance_dominant(mutation_rate=0.0001, selection_coefficient=0.1)\n    0.001\n    >>> mutation_selection_balance_dominant(mutation_rate=0.0001, selection_coefficient=0.01)\n    0.01\n    \nReferences:\n    Haldane, J. B. S. (1927). A mathematical theory of natural and artificial\n    selection, part V: selection and mutation. Mathematical Proceedings of\n    the Cambridge Philosophical Society, 23(7), 838-844.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 335, "module": "src.metainformant.math.popgen", "name": "mutation_selection_balance_dominant", "signature": "(mutation_rate: float, selection_coefficient: float) -> float", "symbol_type": "function"}], "mutation_selection_balance_recessive": [{"docstring": "Calculate equilibrium frequency under mutation-selection balance (recessive).\n\nFor a fully recessive deleterious allele, the equilibrium frequency is\ndetermined by the balance between mutation creating the allele and selection\nagainst homozygotes.\n\nArgs:\n    mutation_rate: Mutation rate creating deleterious allele (\u03bc)\n    selection_coefficient: Selection coefficient against homozygote (s)\n        \nReturns:\n    Equilibrium frequency of deleterious allele. Returns 0.0 if s <= 0.\n    Formula: q_eq \u2248 \u221a(\u03bc / s)\n    \nExamples:\n    >>> mutation_selection_balance_recessive(mutation_rate=0.0001, selection_coefficient=0.1)\n    0.0316...\n    >>> mutation_selection_balance_recessive(mutation_rate=0.0001, selection_coefficient=0.01)\n    0.1\n    \nReferences:\n    Crow, J. F., & Kimura, M. (1970). An introduction to population\n    genetics theory. Harper & Row.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 303, "module": "src.metainformant.math.popgen", "name": "mutation_selection_balance_recessive", "signature": "(mutation_rate: float, selection_coefficient: float) -> float", "symbol_type": "function"}], "mutation_update": [{"docstring": "Calculate allele frequency after one generation of bidirectional mutation.\n\nModels mutation as a reversible process with forward mutation rate \u03bc (A\u2192a)\nand backward mutation rate \u03bd (a\u2192A). Approaches equilibrium frequency\n\u03bd / (\u03bc + \u03bd) over many generations.\n\nArgs:\n    allele_a_frequency: Current frequency of allele A (p)\n    mu: Forward mutation rate from A to a (\u03bc)\n    nu: Backward mutation rate from a to A (\u03bd)\n    \nReturns:\n    New allele A frequency after mutation. Returns original frequency if\n    input is invalid.\n    Formula: p' = p(1 - \u03bc) + (1 - p)\u03bd\n    \nExamples:\n    >>> mutation_update(0.5, mu=0.01, nu=0.005)\n    0.5025...\n    \nReferences:\n    Crow, J. F., & Kimura, M. (1970). An introduction to population\n    genetics theory. Harper & Row.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 86, "module": "src.metainformant.math.popgen", "name": "mutation_update", "signature": "(allele_a_frequency: float, mu: float, nu: float) -> float", "symbol_type": "function"}], "mutual_information": [{"docstring": "Calculate mutual information I(X; Y).\n\nMeasures the amount of information shared between X and Y.\nI(X; Y) = H(X) + H(Y) - H(X, Y) = H(X) - H(X|Y)\n\nArgs:\n    x: Sequence of X values\n    y: Sequence of Y values (must match length of x)\n    base: Logarithm base\n    \nReturns:\n    Mutual information in bits (or nats/dits depending on base)\n    \nExamples:\n    >>> x = [0, 1, 0, 1]\n    >>> y = [0, 1, 0, 1]  # Perfect correlation\n    >>> mutual_information(x, y)  # Should equal H(X) = 1.0\n    1.0\n    \nReferences:\n    Cover, T. M., & Thomas, J. A. (2006). Elements of Information Theory.\n    John Wiley & Sons.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 184, "module": "src.metainformant.information.syntactic", "name": "mutual_information", "signature": "(x: Sequence[Any], y: Sequence[Any], base: float = 2.0) -> float", "symbol_type": "function"}], "mutual_information_continuous": [{"docstring": "Calculate mutual information for continuous variables.\n\nEstimates MI between continuous variables using binning or KDE.\n\nArgs:\n    x: Array of X samples\n    y: Array of Y samples (must match length of x)\n    method: Estimation method (\"histogram\" or \"kde\")\n    bins: Number of bins for histogram method\n    \nReturns:\n    Mutual information estimate in nats\n    \nExamples:\n    >>> import numpy as np\n    >>> x = np.random.randn(1000)\n    >>> y = x + np.random.randn(1000) * 0.1  # Strong correlation\n    >>> mi = mutual_information_continuous(x, y)\n    >>> mi > 0  # Should be positive\n    True\n    \nRaises:\n    ValueError: If x or y are empty, have different lengths, or method is invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/continuous.py", "line_number": 94, "module": "src.metainformant.information.continuous", "name": "mutual_information_continuous", "signature": "(x: np.ndarray, y: np.ndarray, method: str = 'histogram', bins: int | None = None) -> float", "symbol_type": "function"}], "mutual_information_estimator": [{"docstring": "Estimate mutual information with bias correction.\n\nArgs:\n    x: Sequence of X values\n    y: Sequence of Y values\n    method: Estimation method (\"plugin\", \"shrinkage\", \"jackknife\")\n    bias_correction: Whether to apply bias correction\n    \nReturns:\n    Mutual information estimate in bits\n    \nExamples:\n    >>> x = [0, 1, 0, 1, 0, 1]\n    >>> y = [0, 1, 0, 1, 0, 1]  # Perfect correlation\n    >>> mi = mutual_information_estimator(x, y)\n    >>> mi > 0.5  # Should be high\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/estimation.py", "line_number": 113, "module": "src.metainformant.information.estimation", "name": "mutual_information_estimator", "signature": "(x: list[Any], y: list[Any], method: str = 'plugin', bias_correction: bool = True) -> float", "symbol_type": "function"}], "mutual_information_network": [{"docstring": "Calculate mutual information matrix from network structure.\n\nUses network topology to estimate mutual information between nodes.\n\nArgs:\n    graph: NetworkX graph\n    node_attributes: Optional dictionary mapping node IDs to attribute vectors\n    \nReturns:\n    Mutual information matrix", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/networks.py", "line_number": 123, "module": "src.metainformant.information.networks", "name": "mutual_information_network", "signature": "(graph: Any, node_attributes: dict[str, list[float]] | None = None) -> np.ndarray", "symbol_type": "function"}], "mutual_information_plot": [{"docstring": "Plot mutual information matrix as heatmap.\n\nArgs:\n    mi_matrix: Square matrix of mutual information values\n    labels: Optional labels for rows/columns\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import mutual_information_plot\n    >>> import numpy as np\n    >>> mi_matrix = np.random.random((5, 5))\n    >>> mi_matrix = (mi_matrix + mi_matrix.T) / 2  # Symmetric\n    >>> np.fill_diagonal(mi_matrix, 1.0)\n    >>> ax = mutual_information_plot(mi_matrix)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/information.py", "line_number": 61, "module": "src.metainformant.visualization.information", "name": "mutual_information_plot", "signature": "(mi_matrix: np.ndarray, labels: Sequence[str] | None = None, **kwargs) -> plt.Axes", "symbol_type": "function"}], "nUri": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 343, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "nUri", "signature": "(s)", "symbol_type": "function"}], "n_content_per_position": [{"docstring": "Analyze N content at each position.\n\nArgs:\n    reads: List of FASTQ records\n\nReturns:\n    Dictionary with N content per position", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/fastq.py", "line_number": 414, "module": "src.metainformant.quality.fastq", "name": "n_content_per_position", "signature": "(reads: List[FastqRecord]) -> Dict[str, Any]", "symbol_type": "function"}], "n_samples": [{"docstring": "Get number of aligned samples across all omics layers.\n\nReturns:\n    Integer count of samples present in all layers.\n    \nExamples:\n    >>> data = MultiOmicsData(genomics=genomics_df, transcriptomics=transcriptomics_df)\n    >>> data.n_samples\n    10", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 119, "module": "src.metainformant.multiomics.integration", "name": "n_samples", "signature": "(self) -> int", "symbol_type": "function"}], "narrow_sense_heritability": [{"docstring": "Calculate narrow-sense heritability h\u00b2 = VA / VP.\n\nNarrow-sense heritability is the proportion of phenotypic variance\nexplained by additive genetic variance. This is the component that\nresponds to selection.\n\nArgs:\n    additive_variance: Additive genetic variance (VA)\n    phenotypic_variance: Total phenotypic variance (VP)\n    \nReturns:\n    Narrow-sense heritability in [0, 1]. Returns 0.0 if VP <= 0.\n    Values clamped to [0, 1] range.\n    \nExamples:\n    >>> narrow_sense_heritability(additive_variance=0.3, phenotypic_variance=0.5)\n    0.6\n    >>> narrow_sense_heritability(additive_variance=0.2, phenotypic_variance=1.0)\n    0.2\n    \nReferences:\n    Falconer, D. S., & Mackay, T. F. C. (1996). Introduction to quantitative\n    genetics. Longman.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/quantgen.py", "line_number": 6, "module": "src.metainformant.math.quantgen", "name": "narrow_sense_heritability", "signature": "(additive_variance: float, phenotypic_variance: float) -> float", "symbol_type": "function"}], "need_events": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 133, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "need_events", "signature": "(self, count)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 133, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "need_events", "signature": "(self, count)", "symbol_type": "function"}], "need_more_events": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 120, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "need_more_events", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 120, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "need_more_events", "signature": "(self)", "symbol_type": "function"}], "need_more_tokens": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 145, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "need_more_tokens", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 145, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "need_more_tokens", "signature": "(self)", "symbol_type": "function"}], "needleman_wunsch": [{"docstring": "Very small Needleman\u2013Wunsch global alignment implementation returning (score, align_a, align_b).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/alignment.py", "line_number": 20, "module": "src.metainformant.protein.alignment", "name": "needleman_wunsch", "signature": "(a: str, b: str) -> Tuple[int, str, str]", "symbol_type": "function"}], "neighbor_joining_tree": [{"docstring": "Build neighbor-joining phylogenetic tree from sequences.\n\nArgs:\n    id_to_seq: Dictionary mapping sequence IDs to DNA sequences\n    \nReturns:\n    Bio.Phylo tree object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/phylogeny.py", "line_number": 16, "module": "src.metainformant.dna.phylogeny", "name": "neighbor_joining_tree", "signature": "(id_to_seq: Dict[str, str]) -> Tree", "symbol_type": "function"}], "neoschizomers": [{"docstring": "List neoschizomers of the enzyme.\n\nReturn a tuple of all the neoschizomers of RE.\nIf batch is supplied it is used instead of the default AllEnzymes.\n\nNeoschizomer: same site, different position of restriction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 638, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "neoschizomers", "signature": "(cls, batch = None)", "symbol_type": "function"}], "network_enrichment_analysis": [{"docstring": "Analyze pathway enrichment for network modules.\n\nIdentifies pathways enriched in a gene/protein network, either by\nsimple overlap with all network genes or by focusing on central\nhub genes.\n\nArgs:\n    gene_network: Biological network of genes/proteins (optional if gene_list provided)\n    pathway_network: PathwayNetwork object containing pathways to test\n    method: Analysis method:\n        - \"overlap\": Enrichment based on all genes in network\n        - \"centrality\": Enrichment based on top 20% most central genes\n          (by degree centrality)\n    gene_list: List of gene identifiers (alternative to gene_network)\n          \nReturns:\n    Dictionary containing:\n    - method: Analysis method used\n    - network_size: Number of genes in network (for \"overlap\")\n    - central_genes: List of central gene IDs (for \"centrality\")\n    - enrichment_results: List of enriched pathways with statistics\n    \nRaises:\n    ValueError: If method is unknown or neither gene_network nor gene_list provided\n    \nExamples:\n    >>> from metainformant.networks import create_network\n    >>> network = create_network([\"GENE1\", \"GENE2\", \"GENE3\"])\n    >>> enrichment = network_enrichment_analysis(network, pathway_network)\n    >>> enrichment[\"method\"]\n    'overlap'\n    >>> len(enrichment[\"enrichment_results\"]) > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 514, "module": "src.metainformant.networks.pathway", "name": "network_enrichment_analysis", "signature": "(gene_network: BiologicalNetwork = None, pathway_network: PathwayNetwork = None, method: str = 'overlap', gene_list: List[str] = None, ppi_network: BiologicalNetwork = None) -> Dict[str, Any]", "symbol_type": "function"}], "network_entropy": [{"docstring": "Calculate information entropy of a network.\n\nMeasures the information content of the network structure or\nnode attributes.\n\nArgs:\n    graph: NetworkX graph or network object\n    attribute: Optional node attribute to analyze\n    \nReturns:\n    Network entropy in bits", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/networks.py", "line_number": 28, "module": "src.metainformant.information.networks", "name": "network_entropy", "signature": "(graph: Any, attribute: str | None = None) -> float", "symbol_type": "function"}], "network_intersection": [{"docstring": "Create intersection of two networks.\n\nCreates a new network containing only nodes and edges present in\nboth networks. Edge weights are averaged if an edge exists in both.\n\nArgs:\n    network1: First biological network\n    network2: Second biological network\n    \nReturns:\n    New BiologicalNetwork object containing intersection\n    \nExamples:\n    >>> net1 = create_network([\"A\", \"B\", \"C\"])\n    >>> net1.add_edge(\"A\", \"B\", weight=0.5)\n    >>> net2 = create_network([\"A\", \"B\", \"D\"])\n    >>> net2.add_edge(\"A\", \"B\", weight=0.3)\n    >>> intersection = network_intersection(net1, net2)\n    >>> intersection.num_nodes()\n    2\n    >>> intersection.num_edges()\n    1", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 1092, "module": "src.metainformant.networks.graph", "name": "network_intersection", "signature": "(network1: BiologicalNetwork, network2: BiologicalNetwork) -> BiologicalNetwork", "symbol_type": "function"}], "network_metrics": [{"docstring": "Calculate basic network topology metrics.\n\nComputes fundamental network statistics including size, connectivity,\nand degree distributions.\n\nArgs:\n    network: Input biological network\n    \nReturns:\n    Dictionary with keys:\n    - num_nodes: Total number of nodes\n    - num_edges: Total number of edges\n    - density: Edge density (fraction of possible edges present)\n    - avg_degree: Average node degree\n    - max_degree: Maximum node degree\n    - min_degree: Minimum node degree\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\"])\n    >>> network.add_edge(\"A\", \"B\")\n    >>> metrics = network_metrics(network)\n    >>> metrics[\"num_nodes\"]\n    3\n    >>> metrics[\"density\"]\n    0.333...", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 304, "module": "src.metainformant.networks.graph", "name": "network_metrics", "signature": "(network: BiologicalNetwork) -> Dict[str, float]", "symbol_type": "function"}], "network_plot": [{"docstring": "Create a network graph visualization.\n\nArgs:\n    nodes: List of node names\n    edges: List of (source, target) edge tuples\n    node_sizes: Optional list of node sizes\n    node_colors: Optional list of node colors\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments for networkx.draw\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import network_plot\n    >>> nodes = ['A', 'B', 'C']\n    >>> edges = [('A', 'B'), ('B', 'C')]\n    >>> ax = network_plot(nodes, edges)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/networks.py", "line_number": 20, "module": "src.metainformant.visualization.networks", "name": "network_plot", "signature": "(nodes: list[str], edges: list[tuple[str, str]], **kwargs) -> plt.Axes", "symbol_type": "function"}], "network_similarity": [{"docstring": "Calculate similarity metrics between two networks.\n\nComputes various similarity measures including Jaccard similarity\nof nodes/edges, edge overlap, and structural similarity.\n\nArgs:\n    network1: First biological network\n    network2: Second biological network\n    \nReturns:\n    Dictionary containing similarity metrics:\n    - node_jaccard: Jaccard similarity of node sets\n    - edge_jaccard: Jaccard similarity of edge sets\n    - edge_overlap: Fraction of edges in common\n    - node_overlap: Fraction of nodes in common\n    - structural_similarity: Similarity of edge weights (for common edges)\n    \nExamples:\n    >>> net1 = create_network([\"A\", \"B\", \"C\"])\n    >>> net1.add_edge(\"A\", \"B\")\n    >>> net2 = create_network([\"A\", \"B\", \"D\"])\n    >>> net2.add_edge(\"A\", \"B\")\n    >>> sim = network_similarity(net1, net2)\n    >>> sim[\"node_jaccard\"]\n    0.5", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 783, "module": "src.metainformant.networks.graph", "name": "network_similarity", "signature": "(network1: BiologicalNetwork, network2: BiologicalNetwork) -> Dict[str, float]", "symbol_type": "function"}], "network_statistics": [{"docstring": "Calculate comprehensive PPI network statistics.\n\nComputes network topology metrics, centrality measures, and identifies\nhub proteins (top 10% by degree centrality).\n\nReturns:\n    Dictionary containing:\n    - total_proteins: Number of unique proteins\n    - total_interactions: Number of interactions\n    - network_metrics: Basic topology metrics (nodes, edges, density, degrees)\n    - hub_proteins: List of hub protein IDs (top 10% by degree)\n    - avg_degree_centrality: Average degree centrality across all proteins\n    - avg_betweenness_centrality: Average betweenness centrality\n    \nExamples:\n    >>> stats = ppi_network.network_statistics()\n    >>> stats[\"total_proteins\"]\n    150\n    >>> len(stats[\"hub_proteins\"])\n    15", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 334, "module": "src.metainformant.networks.ppi", "name": "network_statistics", "signature": "(self) -> Dict[str, Any]", "symbol_type": "function"}], "network_union": [{"docstring": "Create union of two networks.\n\nCreates a new network containing all nodes and edges from both\nnetworks. Edge weights are summed if an edge exists in both networks.\n\nArgs:\n    network1: First biological network\n    network2: Second biological network\n    \nReturns:\n    New BiologicalNetwork object containing union\n    \nExamples:\n    >>> net1 = create_network([\"A\", \"B\"])\n    >>> net1.add_edge(\"A\", \"B\", weight=0.5)\n    >>> net2 = create_network([\"A\", \"B\", \"C\"])\n    >>> net2.add_edge(\"A\", \"B\", weight=0.3)\n    >>> net2.add_edge(\"B\", \"C\", weight=0.8)\n    >>> union = network_union(net1, net2)\n    >>> union.num_edges()\n    2\n    >>> union.get_edge_weight(\"A\", \"B\")\n    0.8  # Sum of weights", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 1036, "module": "src.metainformant.networks.graph", "name": "network_union", "signature": "(network1: BiologicalNetwork, network2: BiologicalNetwork) -> BiologicalNetwork", "symbol_type": "function"}], "neutrality_test_suite": [{"docstring": "Run a suite of neutrality tests on sequence data.\n\nComputes multiple neutrality test statistics to assess whether observed\nvariation is consistent with neutral evolution. Combines Tajima's D,\nnucleotide diversity, and Watterson's theta.\n\nArgs:\n    sequences: Sequence of DNA sequences (strings)\n\nReturns:\n    Dictionary containing:\n    - tajimas_d: Tajima's D statistic\n    - nucleotide_diversity: \u03c0 (average pairwise differences)\n    - wattersons_theta: \u03b8_W (Watterson's estimator)\n    - segregating_sites: Number of polymorphic sites\n    - pi_theta_ratio: Ratio of \u03c0 to \u03b8_W (should be ~1 under neutrality)\n    - interpretation: Qualitative assessment of neutrality\n\nExamples:\n    >>> seqs = [\"AAAA\", \"AAAT\", \"AATT\", \"ATTT\"]\n    >>> results = neutrality_test_suite(seqs)\n    >>> results[\"tajimas_d\"]\n    -0.5...\n    >>> results[\"interpretation\"]\n    'negative_d' or 'neutral' or 'positive_d'", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_analysis.py", "line_number": 164, "module": "src.metainformant.dna.population_analysis", "name": "neutrality_test_suite", "signature": "(sequences: Sequence[str]) -> dict[str, Any]", "symbol_type": "function"}], "new_clade": [{"docstring": "Return a CDAO.Clade object for a given named node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 153, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "new_clade", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": "Return new Newick.Clade, optionally with temporary reference to parent.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NewickIO.py", "line_number": 224, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NewickIO", "name": "new_clade", "signature": "(self, parent = None)", "symbol_type": "function"}], "new_database": [{"docstring": "Add a new database to the server and return it.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 237, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "new_database", "signature": "(self, db_name, authority = None, description = None)", "symbol_type": "function"}], "new_graph": [{"docstring": "Add a GraphData object to the diagram.\n\nArguments:\n - data      List of (position, value) int tuples\n - name      String, description of the graph\n - style     String ('bar', 'heat', 'line') describing how the graph\n   will be drawn\n - color    colors.Color describing the color to draw all or 'high'\n   (some styles) data (overridden by backwards compatible\n   argument with UK spelling, colour).\n - altcolor  colors.Color describing the color to draw 'low' (some\n   styles) data (overridden by backwards compatible argument\n   with UK spelling, colour).\n - linewidth     Float describing linewidth for graph\n - center        Float setting the value at which the x-axis\n   crosses the y-axis (overridden by backwards\n   compatible argument with UK spelling, centre)\n\nAdd a GraphData object to the diagram (will be stored internally).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_GraphSet.py", "line_number": 54, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._GraphSet", "name": "new_graph", "signature": "(self, data, name = None, style = 'bar', color = colors.lightgreen, altcolor = colors.darkseagreen, linewidth = 1, center = None, colour = None, altcolour = None, centre = None)", "symbol_type": "function"}], "new_label": [{"docstring": "Create new labels for the NeXML writer.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NeXMLIO.py", "line_number": 221, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NeXMLIO", "name": "new_label", "signature": "(self, obj_type)", "symbol_type": "function"}], "new_set": [{"docstring": "Create a new FeatureSet or GraphSet object.\n\nCreate a new FeatureSet or GraphSet object, add it to the\ntrack, and return for user manipulation", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Track.py", "line_number": 210, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Track", "name": "new_set", "signature": "(self, type = 'feature', **args)", "symbol_type": "function"}], "new_track": [{"docstring": "Add a new Track to the diagram at a given level.\n\nThe track is returned for further user manipulation.\n\nArguments:\n    - track_level   - an integer. The level at which the track will be\n      drawn (above an arbitrary baseline).\n\nnew_track(self, track_level)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Diagram.py", "line_number": 299, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Diagram", "name": "new_track", "signature": "(self, track_level, **args)", "symbol_type": "function"}], "newickize": [{"docstring": "Convert a node tree to a newick tree recursively.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 726, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "newickize", "signature": "(node, ladderize = None)", "symbol_type": "function"}, {"docstring": "Convert a node tree to a Newick tree string, recursively.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NewickIO.py", "line_number": 296, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NewickIO", "name": "newickize", "signature": "(clade)", "symbol_type": "function"}], "next_id": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/DBUtils.py", "line_number": 102, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.DBUtils", "name": "next_id", "signature": "(self, cursor, table)", "symbol_type": "function"}], "next_nonwhitespace": [{"docstring": "Check for next non whitespace character in NEXUS file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 100, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "next_nonwhitespace", "signature": "(self)", "symbol_type": "function"}], "next_possible_simple_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 264, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "next_possible_simple_key", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 264, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "next_possible_simple_key", "signature": "(self)", "symbol_type": "function"}], "next_until": [{"docstring": "Iterate over the NEXUS file until a target character is reached.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 115, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "next_until", "signature": "(self, target)", "symbol_type": "function"}], "next_word": [{"docstring": "Return the next NEXUS word from a string.\n\nThis deals with single and double quotes, whitespace and punctuation.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 133, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "next_word", "signature": "(self)", "symbol_type": "function"}], "nid": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 426, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "nid", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 968, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "nid", "signature": "(self, content)", "symbol_type": "function"}], "nj": [{"docstring": "Construct and return a Neighbor Joining tree.\n\n:Parameters:\n    distance_matrix : DistanceMatrix\n        The distance matrix for tree construction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/TreeConstruction.py", "line_number": 767, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.TreeConstruction", "name": "nj", "signature": "(self, distance_matrix)", "symbol_type": "function"}], "nj_tree_from_kmer": [{"docstring": "Build NJ tree from k-mer distances via `distances.kmer_distance_matrix`.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/phylogeny.py", "line_number": 219, "module": "src.metainformant.dna.phylogeny", "name": "nj_tree_from_kmer", "signature": "(id_to_seq: Dict[str, str]) -> Tree", "symbol_type": "function"}], "node": [{"docstring": "Return the instance of node_id.\n\nnode = node(self,node_id)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 232, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "node", "signature": "(self, node_id)", "symbol_type": "function"}], "node2clade": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NexusIO.py", "line_number": 45, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NexusIO", "name": "node2clade", "signature": "(nxtree, node)", "symbol_type": "function"}], "nodes": [{"docstring": "Return a list of the nodes in this graph.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/Graph.py", "line_number": 103, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.Graph", "name": "nodes", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a list of the nodes in this graph.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/MultiGraph.py", "line_number": 95, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.MultiGraph", "name": "nodes", "signature": "(self)", "symbol_type": "function"}], "noise": [{"docstring": "Create noise function with linear scaling.\n\nArgs:\n    k: Linear scaling factor\n    mu: Mean offset\n    sigma: Standard deviation\n    \nReturns:\n    Noise function that takes trait values and returns noisy values", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/model.py", "line_number": 116, "module": "src.metainformant.math.selection_experiments.model", "name": "noise", "signature": "(k: float, mu: float, sigma: float) -> Callable[[np.ndarray], np.ndarray]", "symbol_type": "function"}], "norm": [{"docstring": "Return vector norm.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 327, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "norm", "signature": "(self)", "symbol_type": "function"}], "normalize": [{"docstring": "Normalize the Vector object.\n\nChanges the state of ``self`` and doesn't return a value.\nIf you need to chain function calls or create a new object\nuse the ``normalized`` method.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 335, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "normalize", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Create and return a position-weight matrix by normalizing the counts matrix.\n\nIf pseudocounts is None (default), no pseudocounts are added\nto the counts.\n\nIf pseudocounts is a number, it is added to the counts before\ncalculating the position-weight matrix.\n\nAlternatively, the pseudocounts can be a dictionary with a key\nfor each letter in the alphabet associated with the motif.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 319, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "normalize", "signature": "(self, pseudocounts = None)", "symbol_type": "function"}], "normalize_anchor": [{"docstring": "Convert heading text to markdown anchor format.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/verify_rna.py", "line_number": 20, "module": "scripts.verify_rna", "name": "normalize_anchor", "signature": "(text: str) -> str", "symbol_type": "function"}, {"docstring": "Convert heading to markdown anchor.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/triple_check_rna.py", "line_number": 144, "module": "scripts.triple_check_rna", "name": "normalize_anchor", "signature": "(text: str) -> str", "symbol_type": "function"}], "normalize_counts": [{"docstring": "Normalize count data.\n\nArgs:\n    data: SingleCellData object\n    target_sum: Target sum for normalization (e.g., 10,000 for CPM)\n    method: Normalization method ('total_count', 'median', 'size_factor')\n\nReturns:\n    Normalized SingleCellData object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/preprocessing.py", "line_number": 365, "module": "src.metainformant.singlecell.preprocessing", "name": "normalize_counts", "signature": "(data: SingleCellData, target_sum: float = 10000.0, method: str = 'total_count') -> SingleCellData", "symbol_type": "function"}], "normalize_letters": [{"docstring": "Convert RAF one-letter amino acid codes into IUPAC standard codes.\n\nLetters are uppercased, and \".\" (\"Unknown\") is converted to \"X\".", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/Raf.py", "line_number": 33, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.Raf", "name": "normalize_letters", "signature": "(one_letter_code)", "symbol_type": "function"}], "normalize_whitespace": [{"docstring": "Collapse all whitespace to single spaces and strip ends.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/text.py", "line_number": 10, "module": "src.metainformant.core.text", "name": "normalize_whitespace", "signature": "(s: str) -> str", "symbol_type": "function"}], "normalized": [{"docstring": "Return a normalized copy of the Vector.\n\nTo avoid allocating new objects use the ``normalize`` method.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 345, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "normalized", "signature": "(self)", "symbol_type": "function"}], "normalized_mutual_information": [{"docstring": "Calculate normalized mutual information (NMI).\n\nNMI normalizes mutual information to [0, 1] range for easier comparison.\nCommon normalization methods: arithmetic mean, geometric mean, min, max.\n\nArgs:\n    x: Sequence of X values\n    y: Sequence of Y values (must match length of x)\n    method: Normalization method (\"arithmetic\", \"geometric\", \"min\", \"max\")\n    base: Logarithm base\n    \nReturns:\n    Normalized mutual information in [0, 1]\n    \nExamples:\n    >>> x = [0, 1, 0, 1]\n    >>> y = [0, 1, 0, 1]  # Perfect correlation\n    >>> nmi = normalized_mutual_information(x, y)\n    >>> abs(nmi - 1.0) < 1e-10  # Should be 1.0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 659, "module": "src.metainformant.information.syntactic", "name": "normalized_mutual_information", "signature": "(x: Sequence[Any], y: Sequence[Any], method: str = 'arithmetic', base: float = 2.0) -> float", "symbol_type": "function"}], "normsq": [{"docstring": "Return square of vector norm.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 331, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "normsq", "signature": "(self)", "symbol_type": "function"}], "nspot_cutoff": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 280, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "nspot_cutoff", "signature": "(self, min_nspots)", "symbol_type": "function"}], "nt_search": [{"docstring": "Search for a DNA subseq in seq, return list of [subseq, positions].\n\nUse ambiguous values (like N = A or T or C or G, R = A or G etc.),\nsearches only on forward strand.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/__init__.py", "line_number": 277, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.__init__", "name": "nt_search", "signature": "(seq, subseq)", "symbol_type": "function"}], "nucleotide_diversity": [{"docstring": "Average pairwise nucleotide difference per site (\u03c0).\n\nCalculates nucleotide diversity (\u03c0) as the average number of pairwise\nnucleotide differences per site across all pairs of sequences.\n\nArgs:\n    seqs: Sequence of DNA sequences (strings). If sequences have different\n        lengths, they will be truncated to the shortest length.\n\nReturns:\n    Average pairwise diversity per site (float). Returns 0.0 if:\n    - Less than 2 sequences provided\n    - All sequences are identical\n    - Sequences have zero length\n\nExamples:\n    >>> seqs = [\"AAAA\", \"AAAT\"]\n    >>> nucleotide_diversity(seqs)\n    0.25  # 1 difference in 4 sites = 0.25 per site\n    >>> seqs = [\"AAAA\", \"AAAA\", \"AAAA\"]\n    >>> nucleotide_diversity(seqs)\n    0.0  # All sequences identical\n\nReferences:\n    Nei, M., & Li, W. H. (1979). Mathematical model for studying genetic\n    variation in terms of restriction endonucleases. *Proceedings of the\n    National Academy of Sciences*, 76(10), 5269-5273.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population.py", "line_number": 91, "module": "src.metainformant.dna.population", "name": "nucleotide_diversity", "signature": "(seqs: Sequence[str]) -> float", "symbol_type": "function"}], "num_edges": [{"docstring": "Get the number of edges in the network.\n\nReturns:\n    Integer count of unique edges. For undirected networks,\n    each edge is counted once regardless of direction.\n    \nExamples:\n    >>> network = BiologicalNetwork(directed=False)\n    >>> network.add_edge(\"A\", \"B\"); network.add_edge(\"B\", \"C\")\n    >>> network.num_edges()\n    2", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 179, "module": "src.metainformant.networks.graph", "name": "num_edges", "signature": "(self) -> int", "symbol_type": "function"}], "num_nodes": [{"docstring": "Get the number of nodes in the network.\n\nReturns:\n    Integer count of unique nodes in the network.\n    \nExamples:\n    >>> network = BiologicalNetwork()\n    >>> network.add_node(\"A\"); network.add_node(\"B\")\n    >>> network.num_nodes()\n    2", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 165, "module": "src.metainformant.networks.graph", "name": "num_nodes", "signature": "(self) -> int", "symbol_type": "function"}], "num_terms": [{"docstring": "Get total number of terms in ontology.\n\nReturns:\n    Count of terms", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/types.py", "line_number": 200, "module": "src.metainformant.ontology.types", "name": "num_terms", "signature": "(self) -> int", "symbol_type": "function"}], "observed_heterozygosity": [{"docstring": "Proportion of heterozygous individuals among diploid genotypes.\n\nCalculates the observed heterozygosity as the fraction of individuals\nthat are heterozygous (have different alleles at the two homologous chromosomes).\n\nArgs:\n    genotypes: Iterable of tuples (a1, a2) representing diploid genotypes.\n        Each tuple contains two alleles encoded as 0 (reference) or 1 (alternate).\n\nReturns:\n    Float in [0, 1] representing the proportion of heterozygous individuals.\n    Returns 0.0 if input is empty.\n\nRaises:\n    ValueError: If genotype tuples contain invalid allele values.\n\nExamples:\n    >>> genotypes = [(0, 0), (0, 1), (1, 1), (1, 0)]\n    >>> observed_heterozygosity(genotypes)\n    0.5  # 2 of 4 are heterozygous\n    >>> observed_heterozygosity([(0, 0), (1, 1)])\n    0.0  # All homozygous", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population.py", "line_number": 53, "module": "src.metainformant.dna.population", "name": "observed_heterozygosity", "signature": "(genotypes: Iterable[tuple[int, int]]) -> float", "symbol_type": "function"}], "on_delete_complete": [{"docstring": "Report that FASTQ deletion has completed.\n\nArgs:\n    species: Species identifier\n    sample_id: SRA run ID", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/progress_tracker.py", "line_number": 202, "module": "src.metainformant.rna.progress_tracker", "name": "on_delete_complete", "signature": "(self, species: str, sample_id: str) -> None", "symbol_type": "function"}], "on_download_complete": [{"docstring": "Report that a download has completed.\n\nArgs:\n    species: Species identifier\n    sample_id: SRA run ID", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/progress_tracker.py", "line_number": 156, "module": "src.metainformant.rna.progress_tracker", "name": "on_download_complete", "signature": "(self, species: str, sample_id: str) -> None", "symbol_type": "function"}], "on_download_failed": [{"docstring": "Report that a download has failed.\n\nArgs:\n    species: Species identifier\n    sample_id: SRA run ID", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/progress_tracker.py", "line_number": 172, "module": "src.metainformant.rna.progress_tracker", "name": "on_download_failed", "signature": "(self, species: str, sample_id: str) -> None", "symbol_type": "function"}], "on_download_start": [{"docstring": "Report that a download has started.\n\nArgs:\n    species: Species identifier\n    sample_id: SRA run ID (e.g., \"SRR1234567\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/progress_tracker.py", "line_number": 142, "module": "src.metainformant.rna.progress_tracker", "name": "on_download_start", "signature": "(self, species: str, sample_id: str) -> None", "symbol_type": "function"}], "on_quant_complete": [{"docstring": "Report that quantification has completed.\n\nArgs:\n    species: Species identifier\n    sample_id: SRA run ID", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/progress_tracker.py", "line_number": 187, "module": "src.metainformant.rna.progress_tracker", "name": "on_quant_complete", "signature": "(self, species: str, sample_id: str) -> None", "symbol_type": "function"}], "one_to_index": [{"docstring": "One letter code to index.\n\n>>> one_to_index('A')\n0\n>>> one_to_index('Y')\n19", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Polypeptide.py", "line_number": 94, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Polypeptide", "name": "one_to_index", "signature": "(s)", "symbol_type": "function"}], "only_between": [{"docstring": "Return only results from enzymes that only cut within start, end.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2451, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "only_between", "signature": "(self, start, end, dct = None)", "symbol_type": "function"}], "only_outside": [{"docstring": "Return only results from enzymes that only cut outside start, end.\n\nEnzymes that cut the sequence outside of the region\nin between start and end but do not cut inside.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2506, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "only_outside", "signature": "(self, start, end, dct = None)", "symbol_type": "function"}], "open": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/serializer.py", "line_number": 27, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.serializer", "name": "open", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/serializer.py", "line_number": 27, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.serializer", "name": "open", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Open a BGZF file for reading, writing or appending.\n\nIf text mode is requested, in order to avoid multi-byte characters, this is\nhard coded to use the \"latin1\" encoding, and \"\\r\" and \"\\n\" are passed as is\n(without implementing universal new line mode).\n\nIf your data is in UTF-8 or any other incompatible encoding, you must use\nbinary mode, and decode the appropriate fragments yourself.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 262, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "open", "signature": "(filename, mode = 'rb')", "symbol_type": "function"}], "open_database": [{"docstring": "Load an existing BioSQL-style database.\n\nThis function is the easiest way to retrieve a connection to a\ndatabase, doing something like::\n\n    from BioSQL import BioSeqDatabase\n    server = BioSeqDatabase.open_database(user=\"root\", db=\"minidb\")\n\nArguments:\n - driver - The name of the database driver to use for connecting. The\n   driver should implement the python DB API. By default, the MySQLdb\n   driver is used.\n - user -the username to connect to the database with.\n - password, passwd - the password to connect with\n - host - the hostname of the database\n - database or db - the name of the database", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 28, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "open_database", "signature": "(driver = 'MySQLdb', **kwargs)", "symbol_type": "function"}], "open_dtd_file": [{"docstring": "Open specified DTD file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 1031, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "open_dtd_file", "signature": "(self, filename)", "symbol_type": "function"}], "open_text_auto": [{"docstring": "Open a text file, handling gzip transparently based on suffix.\n\nSupports text modes only (\"rt\", \"wt\", \"at\").", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 18, "module": "src.metainformant.core.io", "name": "open_text_auto", "signature": "(path: str | Path, mode: str = 'rt', encoding: str = 'utf-8') -> io.TextIOBase", "symbol_type": "function"}], "open_xsd_file": [{"docstring": "Open specified XSD file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 1050, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "open_xsd_file", "signature": "(self, filename)", "symbol_type": "function"}], "openapi_types": [{"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_assembly_completeness.py", "line_number": 75, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_assembly_completeness", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_peptide.py", "line_number": 85, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_peptide", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_bio_project_lineage.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_bio_project_lineage", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request_content_type.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request_content_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_prokaryote_gene_request.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_prokaryote_gene_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_gene.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_gene", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response_edges_entry.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response_edges_entry", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_dataset_request.py", "line_number": 83, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_dataset_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_error_virus_error_code.py", "line_number": 73, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_error_virus_error_code", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_filter.py", "line_number": 83, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_filter", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptor_chromosome.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptor_chromosome", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_genomic_region_genomic_region_type.py", "line_number": 77, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_genomic_region_genomic_region_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sci_name_and_ids.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sci_name_and_ids", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_metadata_response.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_metadata_response", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_message.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_message", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_filter_assembly_source.py", "line_number": 75, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_filter_assembly_source", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_project.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_project", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_feature_counts.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_feature_counts", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_query_request_tax_rank_filter.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_query_request_tax_rank_filter", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request_sort_field.py", "line_number": 76, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request_sort_field", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_match.py", "line_number": 83, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_match", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotated_assemblies.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotated_assemblies", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request.py", "line_number": 85, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_prokaryote_gene_request_gene_flank_config.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_prokaryote_gene_request_gene_flank_config", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_table_format.py", "line_number": 75, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_table_format", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_conserved_domain.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_conserved_domain", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_query_request.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_query_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_assembly_status.py", "line_number": 77, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_assembly_status", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_warning.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_warning", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request_sort.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request_sort", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_query_request_taxon_resource_filter.py", "line_number": 75, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_query_request_taxon_resource_filter", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_micro_bigge_dataset_request_file_type.py", "line_number": 77, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_micro_bigge_dataset_request_file_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_match.py", "line_number": 85, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_match", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_attribute.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_attribute", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_prokaryote_gene_location_completeness.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_prokaryote_gene_location_completeness", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata_request.py", "line_number": 85, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_mature_peptide.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_mature_peptide", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_availability_request.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_availability_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response_edge_child_status.py", "line_number": 75, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response_edge_child_status", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ortholog_request.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ortholog_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_filter_assembly_level.py", "line_number": 76, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_filter_assembly_level", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptor_rna_type.py", "line_number": 75, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptor_rna_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sleep_request.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sleep_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sort_direction.py", "line_number": 75, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sort_direction", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_id.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_id", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_request_resolution.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_request_resolution", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_transcript.py", "line_number": 85, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_transcript", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary_dehydrated.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary_dehydrated", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_counts.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_counts", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_gene_descriptor_gene_type.py", "line_number": 85, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_gene_descriptor_gene_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_count_by_type.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_count_by_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_group.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_group", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_fasta.py", "line_number": 80, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_fasta", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_peptide_uni_prot_id.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_peptide_uni_prot_id", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptor.py", "line_number": 87, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptor", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_range.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_range", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_range.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_range", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_error_assembly_error_code.py", "line_number": 77, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_error_assembly_error_code", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_transcript_transcript_type.py", "line_number": 77, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_transcript_transcript_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_element_flank_config.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_element_flank_config", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_availability.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_availability", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_error_gene_error_code.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_error_gene_error_code", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_genomic_region.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_genomic_region", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_assembly_type.py", "line_number": 82, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_assembly_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_dataset_request.py", "line_number": 83, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_dataset_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ref_gene_catalog_dataset_request.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ref_gene_catalog_dataset_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_tax_tree_request.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_tax_tree_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_micro_bigge_dataset_request.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_micro_bigge_dataset_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_busco_stat.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_busco_stat", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_availability.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_availability", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_assembly.py", "line_number": 91, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_assembly", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_data_report_request_content_type.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_data_report_request_content_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_assembly_collection_location.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_assembly_collection_location", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_table_field.py", "line_number": 94, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_table_field", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_request.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_metadata_request.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_metadata_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_protein.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_protein", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary.py", "line_number": 87, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_match.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_match", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_virus_type.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_virus_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response.py", "line_number": 83, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_description.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_description", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_purpose_of_sampling.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_purpose_of_sampling", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_seq_range_set.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_seq_range_set", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_genomic_location.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_genomic_location", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_request_content_type.py", "line_number": 75, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_request_content_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_orientation.py", "line_number": 75, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_orientation", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata_request_bioprojects.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata_request_bioprojects", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_seq_range_set_fasta.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_seq_range_set_fasta", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_contact.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_contact", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_warning_replaced_id.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_warning_replaced_id", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_lineage_organism.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_lineage_organism", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sars2_protein_dataset_request.py", "line_number": 83, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sars2_protein_dataset_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_assembly_file.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_assembly_file", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_descriptors_filter_assembly_version.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_descriptors_filter_assembly_version", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism_rank_type.py", "line_number": 117, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism_rank_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_metadata_request_content_type.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_metadata_request_content_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_error.py", "line_number": 83, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_error", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_count_type.py", "line_number": 87, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_count_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary_file_summary.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary_file_summary", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_linked_assembly_linked_assembly_type.py", "line_number": 82, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_linked_assembly_linked_assembly_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ortholog_set.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ortholog_set", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_data_report_page.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_data_report_page", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_method_payload_request.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_method_payload_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_node_count_by_type.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_node_count_by_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/rpc_status.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.rpc_status", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_data_report_request.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_data_report_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptor.py", "line_number": 97, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptor", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sleep_reply.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sleep_reply", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_counts.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_counts", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_tabular_output.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_tabular_output", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_organism.py", "line_number": 83, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_organism", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_bio_project.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_bio_project", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_sci_name_and_ids_sci_name_and_id.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_sci_name_and_ids_sci_name_and_id", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_nomenclature_authority.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_nomenclature_authority", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_descriptor.py", "line_number": 89, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_descriptor", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_metadata.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_metadata", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_genomic_region_genomic_region_type.py", "line_number": 77, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_genomic_region_genomic_region_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_annotation.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_annotation", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_organism.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_organism", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_transcript_transcript_type.py", "line_number": 77, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_transcript_transcript_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary_hydrated.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary_hydrated", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_status.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_status", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_annotation_for_assembly.py", "line_number": 83, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_annotation_for_assembly", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_warning_gene_warning_code.py", "line_number": 80, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_warning_gene_warning_code", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_orientation.py", "line_number": 75, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_orientation", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_gene_descriptor_rna_type.py", "line_number": 75, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_gene_descriptor_rna_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_dataset_request.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_dataset_request", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_version_reply.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_version_reply", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptor_gene_type.py", "line_number": 85, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptor_gene_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_bio_sample_owner.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_bio_sample_owner", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/protobuf_any.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.protobuf_any", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_virus_dataset_filter.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_virus_dataset_filter", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_dataset_request_symbols_for_taxon.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_dataset_request_symbols_for_taxon", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_accessions.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_accessions", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_gene_descriptors.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_gene_descriptors", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata_request_content_type.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata_request_content_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1reports_virus_assembly_isolate.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1reports_virus_assembly_isolate", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ref_gene_catalog_dataset_request_file_type.py", "line_number": 76, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ref_gene_catalog_dataset_request_file_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_download_summary_available_files.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_download_summary_available_files", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_assembly_metadata.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_assembly_metadata", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_filtered_subtree_response_edge.py", "line_number": 79, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_filtered_subtree_response_edge", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_taxonomy_node.py", "line_number": 81, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_taxonomy_node", "name": "openapi_types", "signature": "()", "symbol_type": "function"}, {"docstring": "This must be a method because a model may have properties that are\nof type self, this must run after the class is loaded\n\nReturns\n    openapi_types (dict): The key is attribute name\n        and the value is attribute type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model/v1_ortholog_request_content_type.py", "line_number": 74, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model.v1_ortholog_request_content_type", "name": "openapi_types", "signature": "()", "symbol_type": "function"}], "optimize": [{"docstring": "Return a new DNA sequence with preferred codons only.\n\nUses the codon adaptiveness table defined by the CodonAdaptationIndex\nobject to generate DNA sequences with only preferred codons.\nMay be useful when designing DNA sequences for transgenic protein\nexpression or codon-optimized proteins like fluorophores.\n\nArguments:\n    - sequence: DNA, RNA, or protein sequence to codon-optimize.\n                Supplied as a str, Seq, or SeqRecord object.\n    - seq_type: String specifying type of sequence provided.\n                Options are \"DNA\", \"RNA\", and \"protein\". Default is \"DNA\".\n    - strict:   Determines whether an exception should be raised when\n                two codons are equally preferred for a given amino acid.\nReturns:\n    Seq object with DNA encoding the same protein as the sequence argument,\n    but using only preferred codons as defined by the codon adaptation index.\n    If multiple codons are equally preferred, a warning is issued\n    and one codon is chosen for use in the optimized sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/__init__.py", "line_number": 667, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.__init__", "name": "optimize", "signature": "(self, sequence, seq_type = 'DNA', strict = True)", "symbol_type": "function"}], "optimize_resolution": [{"docstring": "Find optimal resolution parameter for community detection.\n\nTests multiple resolution values and selects the one that maximizes\nmodularity or other quality metrics.\n\nArgs:\n    network: Input biological network\n    resolution_range: (min, max) resolution values to test\n    n_points: Number of resolution values to test\n    method: Community detection algorithm\n    \nReturns:\n    Dictionary containing:\n    - optimal_resolution: Resolution value with highest modularity\n    - optimal_modularity: Modularity at optimal resolution\n    - resolution_values: List of tested resolution values\n    - modularity_values: List of modularity values for each resolution\n    - optimal_communities: Community partition at optimal resolution\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"])\n    >>> result = optimize_resolution(network, resolution_range=(0.5, 2.0), n_points=10)\n    >>> result[\"optimal_resolution\"] > 0.0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/community.py", "line_number": 637, "module": "src.metainformant.networks.community", "name": "optimize_resolution", "signature": "(network: BiologicalNetwork, resolution_range: Tuple[float, float] = (0.1, 2.0), n_points: int = 20, method: str = 'louvain') -> Dict[str, Any]", "symbol_type": "function"}], "optionalcascade": [{"docstring": "Return a getter property with a cascading setter.\n\nThis is used for the ``id`` and ``description`` properties of the container\nobjects with zero or more items. These items have their own private\nattributes that stores query and/or hit ID and description. When the\ncontainer has zero items, attribute values are always retrieved from the\ncontainer's attribute. Otherwise, the first item's attribute is used.\n\nTo keep the container items' query and/or hit ID and description in-sync,\nthe setter cascades any new value given to the items' values.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 120, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "optionalcascade", "signature": "(cont_attr, item_attr, doc = '')", "symbol_type": "function"}], "orchestrate_genome_setup": [{"docstring": "Orchestrate complete genome setup pipeline.\n\nArgs:\n    config_path: Path to species config file\n    repo_root: Repository root directory (optional)\n    skip_verify_initial: Skip initial verification\n    skip_download: Skip genome download\n    skip_prepare: Skip transcriptome preparation\n    skip_build: Skip kallisto index building\n    skip_verify_final: Skip final verification\n    kmer_size: k-mer size for kallisto index\n    dry_run: If True, only report what would be done\n\nReturns:\n    Dictionary with orchestration results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/genome_prep.py", "line_number": 833, "module": "src.metainformant.rna.genome_prep", "name": "orchestrate_genome_setup", "signature": "(config_path: Path) -> dict[str, Any]", "symbol_type": "function"}], "order_response_types": [{"docstring": "Returns the required types sorted in coercion order\n\nArgs:\n    required_types (list/tuple): collection of classes or instance of\n        list or dict with class information inside it.\n\nReturns:\n    (list): coercion order sorted collection of classes or instance\n        of list or dict with class information inside it.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1042, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "order_response_types", "signature": "(required_types)", "symbol_type": "function"}], "organism": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 545, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "organism", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 998, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "organism", "signature": "(self, content)", "symbol_type": "function"}], "origin_name": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 796, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "origin_name", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1136, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "origin_name", "signature": "(self, content)", "symbol_type": "function"}], "orthogroup2genecount": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 546, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "orthogroup2genecount", "signature": "(file_orthogroup, file_genecount, spp)", "symbol_type": "function"}], "orthologs": [{"docstring": "Get a list of entries of type ortholog.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 197, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "orthologs", "signature": "(self)", "symbol_type": "function"}], "other": [{"docstring": "Create an Other object, a non-phyloXML element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 475, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "other", "signature": "(self, elem, namespace, localtag)", "symbol_type": "function"}, {"docstring": "Convert other to Etree element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 736, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "other", "signature": "(self, obj)", "symbol_type": "function"}], "out_block": [{"docstring": "Format text in blocks of 80 chars with an additional optional prefix.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Geo/Record.py", "line_number": 84, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Geo.Record", "name": "out_block", "signature": "(text, prefix = '')", "symbol_type": "function"}], "outside": [{"docstring": "Return only results from enzymes that at least cut outside borders.\n\nEnzymes that cut outside the region in between start and end.\nThey may cut inside as well.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2528, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "outside", "signature": "(self, start, end, dct = None)", "symbol_type": "function"}], "over_ride": [{"docstring": "Over-ride molecule in-place.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/__init__.py", "line_number": 465, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.__init__", "name": "over_ride", "signature": "(alignment)", "symbol_type": "function"}, {"docstring": "Over-ride molecule in-place.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/__init__.py", "line_number": 1162, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.__init__", "name": "over_ride", "signature": "(record)", "symbol_type": "function"}], "overhang": [{"docstring": "Return the type of the enzyme's overhang as string.\n\nCan be \"3' overhang\", \"5' overhang\", \"blunt\", \"unknown\".", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1098, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "overhang", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return the type of the enzyme's overhang as string.\n\nCan be \"3' overhang\", \"5' overhang\", \"blunt\", \"unknown\".", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1226, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "overhang", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return the type of the enzyme's overhang as string.\n\nCan be \"3' overhang\", \"5' overhang\", \"blunt\", \"unknown\".", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1356, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "overhang", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return the type of the enzyme's overhang as string.\n\nCan be \"3' overhang\", \"5' overhang\", \"blunt\", \"unknown\".", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1489, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "overhang", "signature": "(cls)", "symbol_type": "function"}], "overhang3": [{"docstring": "Return only cuts that have 3' overhangs.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2398, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "overhang3", "signature": "(self, dct = None)", "symbol_type": "function"}], "overhang5": [{"docstring": "Return only cuts that have 5' overhangs.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2392, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "overhang5", "signature": "(self, dct = None)", "symbol_type": "function"}], "overrepresented_sequences": [{"docstring": "Identify overrepresented sequences.\n\nArgs:\n    reads: List of FASTQ records\n    min_count: Minimum count to consider overrepresented\n    min_percentage: Minimum percentage to consider overrepresented\n\nReturns:\n    Dictionary with overrepresented sequence analysis", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/fastq.py", "line_number": 337, "module": "src.metainformant.quality.fastq", "name": "overrepresented_sequences", "signature": "(reads: List[FastqRecord], min_count: int = 10, min_percentage: float = 0.1) -> Dict[str, Any]", "symbol_type": "function"}], "pUri": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 347, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "pUri", "signature": "(s)", "symbol_type": "function"}], "p_distance": [{"docstring": "Proportion of differing sites between two sequences (Hamming/L).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/distances.py", "line_number": 8, "module": "src.metainformant.dna.distances", "name": "p_distance", "signature": "(s1: str, s2: str) -> float", "symbol_type": "function"}], "pad_to_length": [{"docstring": "Pad sequence to target length with gap characters.\n\nArgs:\n    s: Sequence string\n    n: Target length\n    \nReturns:\n    Padded sequence (or original if already longer)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/msa.py", "line_number": 29, "module": "src.metainformant.dna.msa", "name": "pad_to_length", "signature": "(s: str, n: int) -> str", "symbol_type": "function"}], "page_sizes": [{"docstring": "Convert size string into a Reportlab pagesize.\n\nArguments:\n - size - A string representing a standard page size, eg 'A4' or 'LETTER'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_AbstractDrawer.py", "line_number": 50, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._AbstractDrawer", "name": "page_sizes", "signature": "(size)", "symbol_type": "function"}], "pair_as_kwarg_string": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 239, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "pair_as_kwarg_string", "signature": "(key, val)", "symbol_type": "function"}], "pairplot_dataframe": [{"docstring": "Pairplot for a tidy DataFrame, returns seaborn PairGrid or matplotlib figure.\n\nArgs:\n    df: DataFrame with numeric columns\n    hue: Optional column name for coloring\n\nReturns:\n    seaborn PairGrid or matplotlib Figure\n\nExample:\n    >>> from metainformant.visualization import pairplot_dataframe\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> df = pd.DataFrame(np.random.random((100, 3)), columns=['A', 'B', 'C'])\n    >>> grid = pairplot_dataframe(df)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/multidim.py", "line_number": 35, "module": "src.metainformant.visualization.multidim", "name": "pairplot_dataframe", "signature": "(df: pd.DataFrame) -> Union[Figure, 'PairGrid']", "symbol_type": "function"}], "pairwise_identity": [{"docstring": "Compute simple pairwise identity for equal-length strings.\n\nIf lengths differ, compare up to min length.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/alignment.py", "line_number": 6, "module": "src.metainformant.protein.alignment", "name": "pairwise_identity", "signature": "(a: str, b: str) -> float", "symbol_type": "function"}], "parallel_batch": [{"docstring": "Process items in batches using parallel execution.\n\nArgs:\n    func: Function that takes a batch of items and returns processed results\n    items: Items to process\n    batch_size: Number of items per batch\n    max_workers: Maximum number of worker threads\n\nReturns:\n    List of all results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/parallel.py", "line_number": 122, "module": "src.metainformant.core.parallel", "name": "parallel_batch", "signature": "(func: Callable[[list[T]], list[U]], items: list[T]) -> list[U]", "symbol_type": "function"}], "parallel_coordinates_plot": [{"docstring": "Create a parallel coordinates plot.\n\nArgs:\n    data: DataFrame with numeric columns\n    class_column: Optional column name for class coloring\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import parallel_coordinates_plot\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> df = pd.DataFrame(np.random.random((20, 4)), columns=['A', 'B', 'C', 'D'])\n    >>> df['class'] = ['X' if i < 10 else 'Y' for i in range(20)]\n    >>> ax = parallel_coordinates_plot(df, class_column='class')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/multidim.py", "line_number": 83, "module": "src.metainformant.visualization.multidim", "name": "parallel_coordinates_plot", "signature": "(data: pd.DataFrame, class_column: str | None = None, **kwargs) -> plt.Axes", "symbol_type": "function"}], "parameters_to_multipart": [{"docstring": "Get parameters as list of tuples, formatting as json if value is collection_types\n\n:param params: Parameters as list of two-tuples\n:param dict collection_types: Parameter collection types\n:return: Parameters as list of tuple or urllib3.fields.RequestField", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 237, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "parameters_to_multipart", "signature": "(self, params, collection_types)", "symbol_type": "function"}], "parameters_to_tuples": [{"docstring": "Get parameters as list of tuples, formatting collections.\n\n:param params: Parameters as dict or list of two-tuples\n:param dict collection_formats: Parameter collection formats\n:return: Parameters as list of tuples, collections formatted", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 490, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "parameters_to_tuples", "signature": "(self, params, collection_formats)", "symbol_type": "function"}], "parent_edges": [{"docstring": "Return a list of (parent, label) pairs for child.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/Graph.py", "line_number": 107, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.Graph", "name": "parent_edges", "signature": "(self, child)", "symbol_type": "function"}, {"docstring": "Return a list of (parent, label) pairs for child.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/MultiGraph.py", "line_number": 99, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.MultiGraph", "name": "parent_edges", "signature": "(self, child)", "symbol_type": "function"}], "parents": [{"docstring": "Return a list of unique parents for child.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/Graph.py", "line_number": 118, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.Graph", "name": "parents", "signature": "(self, child)", "symbol_type": "function"}, {"docstring": "Return a list of unique parents for child.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/MultiGraph.py", "line_number": 110, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.MultiGraph", "name": "parents", "signature": "(self, child)", "symbol_type": "function"}], "parse": [{"docstring": "Parse a YAML stream and produce parsing events.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 40, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "parse", "signature": "(stream, Loader = Loader)", "symbol_type": "function"}, {"docstring": "Parse a YAML stream and produce parsing events.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 40, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "parse", "signature": "(stream, Loader = Loader)", "symbol_type": "function"}, {"docstring": "Parse an alignment file and return an iterator over alignments.\n\nArguments:\n - source - File or file-like object to read from, or filename as string.\n - fmt    - String describing the file format (case-insensitive).\n\nTypical usage, opening a file to read in, and looping over the alignments:\n\n>>> from Bio import Align\n>>> filename = \"Exonerate/exn_22_m_ner_cigar.exn\"\n>>> for alignment in Align.parse(filename, \"exonerate\"):\n...    print(\"Number of sequences in alignment\", len(alignment))\n...    print(\"Alignment score:\", alignment.score)\nNumber of sequences in alignment 2\nAlignment score: 6150.0\nNumber of sequences in alignment 2\nAlignment score: 502.0\nNumber of sequences in alignment 2\nAlignment score: 440.0\n\nFor lazy-loading file formats such as bigMaf, for which the file contents\nis read on demand only, ensure that the file remains open while extracting\nalignment data.\n\nYou can use the Bio.Align.read(...) function when the file contains only\none alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 4882, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "parse", "signature": "(source, fmt)", "symbol_type": "function"}, {"docstring": "Iterate over an alignment file as MultipleSeqAlignment objects.\n\nArguments:\n - handle    - handle to the file, or the filename as a string\n   (note older versions of Biopython only took a handle).\n - format    - string describing the file format.\n - seq_count - Optional integer, number of sequences expected in each\n   alignment.  Recommended for fasta format files.\n\nIf you have the file name in a string 'filename', use:\n\n>>> from Bio import AlignIO\n>>> filename = \"Emboss/needle.txt\"\n>>> format = \"emboss\"\n>>> for alignment in AlignIO.parse(filename, format):\n...     print(\"Alignment of length %i\" % alignment.get_alignment_length())\nAlignment of length 124\nAlignment of length 119\nAlignment of length 120\nAlignment of length 118\nAlignment of length 125\n\nIf you have a string 'data' containing the file contents, use::\n\n  from Bio import AlignIO\n  from io import StringIO\n  my_iterator = AlignIO.parse(StringIO(data), format)\n\nUse the Bio.AlignIO.read() function when you expect a single record only.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/__init__.py", "line_number": 280, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.__init__", "name": "parse", "signature": "(handle, format, seq_count = None)", "symbol_type": "function"}, {"docstring": "Return an iterator a Blast record for each query.\n\nIncremental parser, this is an iterator that returns\nBlast records.  It uses the BlastParser internally.\n\nhandle - file handle to and XML file to parse\ndebug - integer, amount of debug information to print\n\nThis is a generator function that returns multiple Blast records\nobjects - one for each query sequence given to blast.  The file\nis read incrementally, returning complete records as they are read\nin.\n\nShould cope with new BLAST 2.2.14+ which gives a single XML file\nfor multiple query records.\n\nShould also cope with XML output from older versions BLAST which\ngave multiple XML files concatenated together (giving a single file\nwhich strictly speaking wasn't valid XML).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIXML.py", "line_number": 1217, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIXML", "name": "parse", "signature": "(handle, debug = 0)", "symbol_type": "function"}, {"docstring": "Parse an XML file containing BLAST output and return a Bio.Blast.Records object.\n\nThis returns an iterator object; iterating over it returns Bio.Blast.Record\nobjects one by one.\n\nThe source can be a file stream or the path to an XML file containing the\nBLAST output. If a file stream, source  must be in binary mode. This allows\nthe parser to detect the encoding from the XML file,and to use it to convert\nany text in the XML to the correct Unicode string. The qblast function in\nBio.Blast returns a file stream in binary mode. For files, please use mode\n\"rb\" when opening the file, as in\n\n>>> from Bio import Blast\n>>> stream = open(\"Blast/wnts.xml\", \"rb\")  # opened in binary mode\n>>> records = Blast.parse(stream)\n>>> for record in records:\n...     print(record.query.id, record.query.description)\n...\nQuery_1 gi|195230749:301-1383 Homo sapiens wingless-type MMTV integration site family member 2 (WNT2), transcript variant 1, mRNA\nQuery_2 gi|325053704:108-1166 Homo sapiens wingless-type MMTV integration site family, member 3A (WNT3A), mRNA\nQuery_3 gi|156630997:105-1160 Homo sapiens wingless-type MMTV integration site family, member 4 (WNT4), mRNA\nQuery_4 gi|371502086:108-1205 Homo sapiens wingless-type MMTV integration site family, member 5A (WNT5A), transcript variant 2, mRNA\nQuery_5 gi|53729353:216-1313 Homo sapiens wingless-type MMTV integration site family, member 6 (WNT6), mRNA\n>>> stream.close()", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/__init__.py", "line_number": 887, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.__init__", "name": "parse", "signature": "(source)", "symbol_type": "function"}, {"docstring": "Iterate over records in a COMPASS file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Compass/__init__.py", "line_number": 56, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Compass.__init__", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Iterate over primer3 output as Bio.Emboss.Primer3.Record objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Emboss/Primer3.py", "line_number": 95, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Emboss.Primer3", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Set up the parser and let it read the XML results.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 439, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "parse", "signature": "(self, source)", "symbol_type": "function"}, {"docstring": "Parse an XML file from the NCBI Entrez Utilities into python objects.\n\nThis function parses an XML file created by NCBI's Entrez Utilities,\nreturning a multilevel data structure of Python lists and dictionaries.\nThis function is suitable for XML files that (in Python) can be represented\nas a list of individual records. Whereas 'read' reads the complete file\nand returns a single Python list, 'parse' is a generator function that\nreturns the records one by one. This function is therefore particularly\nuseful for parsing large files.\n\nMost XML files returned by NCBI's Entrez Utilities can be parsed by\nthis function, provided its DTD is available. Biopython includes the\nDTDs for most commonly used Entrez Utilities.\n\nThe argument ``source`` must be a file or file-like object opened in binary\nmode, or a filename. The parser detects the encoding from the XML file, and\nuses it to convert all text in the XML to the correct Unicode string. The\nfunctions in Bio.Entrez to access NCBI Entrez will automatically return XML\ndata in binary mode. For files, use mode \"rb\" when opening the file, as in\n\n    >>> from Bio import Entrez\n    >>> path = \"Entrez/pubmed1.xml\"\n    >>> stream = open(path, \"rb\")  # opened in binary mode\n    >>> records = Entrez.parse(stream)\n    >>> for record in records:\n    ...     print(record['MedlineCitation']['Article']['Journal']['Title'])\n    ...\n    Social justice (San Francisco, Calif.)\n    Biochimica et biophysica acta\n    >>> stream.close()\n\nAlternatively, you can use the filename directly, as in\n\n    >>> records = Entrez.parse(path)\n    >>> for record in records:\n    ...     print(record['MedlineCitation']['Article']['Journal']['Title'])\n    ...\n    Social justice (San Francisco, Calif.)\n    Biochimica et biophysica acta\n\nwhich is safer, as the file stream will automatically be closed after all\nthe records have been read, or if an error occurs.\n\nIf validate is True (default), the parser will validate the XML file\nagainst the DTD, and raise an error if the XML file contains tags that\nare not represented in the DTD. If validate is False, the parser will\nsimply skip such tags.\n\nIf escape is True, all characters that are not valid HTML are replaced\nby HTML escape characters to guarantee that the returned strings are\nvalid HTML fragments. For example, a less-than sign (<) is replaced by\n&lt;. If escape is False (default), the string is returned as is.\n\nIf ignore_errors is False (default), any error messages in the XML file\nwill raise a RuntimeError. If ignore_errors is True, error messages will\nbe stored as ErrorElement items, without raising an exception.\n\nWhereas the data structure seems to consist of generic Python lists,\ndictionaries, strings, and so on, each of these is actually a class\nderived from the base type. This allows us to store the attributes\n(if any) of each element in a dictionary my_element.attributes, and\nthe tag name in my_element.tag.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/__init__.py", "line_number": 533, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.__init__", "name": "parse", "signature": "(source, validate = True, escape = False, ignore_errors = False)", "symbol_type": "function"}, {"docstring": "Parse ENZYME records.\n\nThis function is for parsing ENZYME files containing multiple\nrecords.\n\nArguments:\n - handle   - handle to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/Enzyme.py", "line_number": 23, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.Enzyme", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Iterate over the records in a Prodoc file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/Prodoc.py", "line_number": 37, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.Prodoc", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse Prosite records.\n\nThis function is for parsing Prosite files containing multiple\nrecords.\n\nArguments:\n - handle   - handle to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/Prosite.py", "line_number": 26, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.Prosite", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse cell line records.\n\nThis function is for parsing cell line files containing multiple\nrecords.\n\nArguments:\n - handle   - handle to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/cellosaurus.py", "line_number": 50, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.cellosaurus", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Return a SeqRecord (with SeqFeatures if do_features=True).\n\nSee also the method parse_records() for use on multi-record files.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/Scanner.py", "line_number": 483, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.Scanner", "name": "parse", "signature": "(self, handle, do_features = True)", "symbol_type": "function"}, {"docstring": "Iterate over GenBank formatted entries as Record objects.\n\n>>> from Bio import GenBank\n>>> with open(\"GenBank/NC_000932.gb\") as handle:\n...     for record in GenBank.parse(handle):\n...         print(record.accession)\n['NC_000932']\n\nTo get SeqRecord objects use Bio.SeqIO.parse(..., format=\"gb\")\ninstead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1163, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse the specified handle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 149, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "parse", "signature": "(self, handle)", "symbol_type": "function"}, {"docstring": "Parse the specified handle into a GenBank record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 178, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "parse", "signature": "(self, handle)", "symbol_type": "function"}, {"docstring": "Read Gene Expression Omnibus records from file handle.\n\nReturns a generator object which yields Bio.Geo.Record() objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Geo/__init__.py", "line_number": 27, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Geo.__init__", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse a KEGG Ligan/Compound file, returning Record objects.\n\nThis is an iterator function, typically used in a for loop.  For\nexample, using one of the example KEGG files in the Biopython\ntest suite,\n\n>>> with open(\"KEGG/compound.sample\") as handle:\n...     for record in parse(handle):\n...         print(\"%s %s\" % (record.entry, record.name[0]))\n...\nC00023 Iron\nC00017 Protein\nC00099 beta-Alanine\nC00294 Inosine\nC00298 Trypsin\nC00348 all-trans-Undecaprenyl phosphate\nC00349 2-Methyl-3-oxopropanoate\nC01386 NH2Mec", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/Compound/__init__.py", "line_number": 113, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.Compound.__init__", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse a KEGG Enzyme file, returning Record objects.\n\nThis is an iterator function, typically used in a for loop.  For\nexample, using one of the example KEGG files in the Biopython\ntest suite,\n\n>>> with open(\"KEGG/enzyme.sample\") as handle:\n...     for record in parse(handle):\n...         print(\"%s %s\" % (record.entry, record.name[0]))\n...\n1.1.1.1 alcohol dehydrogenase\n1.1.1.62 17beta-estradiol 17-dehydrogenase\n1.1.1.68 Transferred to 1.5.1.20\n1.6.5.3 NADH:ubiquinone reductase (H+-translocating)\n1.14.13.28 3,9-dihydroxypterocarpan 6a-monooxygenase\n2.4.1.68 glycoprotein 6-alpha-L-fucosyltransferase\n3.1.1.6 acetylesterase\n2.7.2.1 acetate kinase", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/Enzyme/__init__.py", "line_number": 197, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.Enzyme.__init__", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse a KEGG Gene file, returning Record objects.\n\nThis is an iterator function, typically used in a for loop.  For\nexample, using one of the example KEGG files in the Biopython\ntest suite,\n\n>>> with open(\"KEGG/gene.sample\") as handle:\n...     for record in parse(handle):\n...         print(\"%s %s\" % (record.entry, record.name[0]))\n...\nb1174 minE\nb1175 minD", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/Gene/__init__.py", "line_number": 77, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.Gene.__init__", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Return an iterator over Pathway elements.\n\nArguments:\n - handle - file handle to a KGML file for parsing, or a KGML string\n\nThis is a generator for the return of multiple Pathway objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_parser.py", "line_number": 52, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_parser", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse the input elements.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_parser.py", "line_number": 110, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_parser", "name": "parse", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Parse a KEGG pathway map.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/Map/__init__.py", "line_number": 24, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.Map.__init__", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read Medline records one by one from the handle.\n\nThe handle is either is a Medline file, a file-like object, or a list\nof lines describing one or more Medline records.\n\nTypical usage::\n\n    >>> from Bio import Medline\n    >>> with open(\"Medline/pubmed_result2.txt\") as handle:\n    ...     records = Medline.parse(handle)\n    ...     for record in records:\n    ...         print(record['TI'])\n    ...\n    A high level interface to SCOP and ASTRAL ...\n    GenomeDiagram: a python package for the visualization of ...\n    Open source clustering software.\n    PDB file parser and structure class implemented in Python.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Medline/__init__.py", "line_number": 106, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Medline.__init__", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Iterate over the trees in a CDAO file handle.\n\n:returns: generator of Bio.Phylo.CDAO.Tree objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 73, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "parse", "signature": "(handle, **kwargs)", "symbol_type": "function"}, {"docstring": "Parse the text stream this object was initialized with.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 112, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "parse", "signature": "(self, **kwargs)", "symbol_type": "function"}, {"docstring": "Iterate over the trees in a NeXML file handle.\n\n:returns: generator of Bio.Phylo.NeXML.Tree objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NeXMLIO.py", "line_number": 69, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NeXMLIO", "name": "parse", "signature": "(handle, **kwargs)", "symbol_type": "function"}, {"docstring": "Parse the text stream this object was initialized with.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NeXMLIO.py", "line_number": 119, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NeXMLIO", "name": "parse", "signature": "(self, values_are_confidence = False, rooted = False)", "symbol_type": "function"}, {"docstring": "Iterate over the trees in a Newick file handle.\n\n:returns: generator of Bio.Phylo.Newick.Tree objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NewickIO.py", "line_number": 44, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NewickIO", "name": "parse", "signature": "(handle, **kwargs)", "symbol_type": "function"}, {"docstring": "Parse the text stream this object was initialized with.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NewickIO.py", "line_number": 112, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NewickIO", "name": "parse", "signature": "(self, values_are_confidence = False, comments_are_confidence = False, rooted = False)", "symbol_type": "function"}, {"docstring": "Parse the trees in a Nexus file.\n\nUses the old Nexus.Trees parser to extract the trees, converts them back to\nplain Newick trees, and feeds those strings through the new Newick parser.\nThis way we don't have to modify the Nexus module yet. (Perhaps we'll\neventually change Nexus to use the new NewickIO parser directly.)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NexusIO.py", "line_number": 32, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NexusIO", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Iterate over the phylogenetic trees in a phyloXML file.\n\nThis ignores any additional data stored at the top level, but may be more\nmemory-efficient than the ``read`` function.\n\n:returns: a generator of ``Bio.Phylo.PhyloXML.Phylogeny`` objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 64, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "parse", "signature": "(file)", "symbol_type": "function"}, {"docstring": "Parse the phyloXML file incrementally and return each phylogeny.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 305, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "parse", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Parse a file iteratively, and yield each of the trees it contains.\n\nIf a file only contains one tree, this still returns an iterable object that\ncontains one element.\n\nExamples\n--------\n>>> import Bio.Phylo\n>>> trees = Bio.Phylo.parse('PhyloXML/apaf.xml', 'phyloxml')\n>>> for tree in trees:\n...     print(tree.rooted)\nTrue", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_io.py", "line_number": 36, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._io", "name": "parse", "signature": "(file, format, **kwargs)", "symbol_type": "function"}, {"docstring": "Iterate over a CLA file as Cla records for each line.\n\nArguments:\n - handle - file-like object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/Cla.py", "line_number": 81, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.Cla", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Iterate over a DES file as a Des record for each line.\n\nArguments:\n - handle - file-like object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/Des.py", "line_number": 79, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.Des", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Iterate over a DOM file as a Dom record for each line.\n\nArguments:\n - handle -- file-like object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/Dom.py", "line_number": 66, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.Dom", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Iterate over a HIE file as Hie records for each line.\n\nArguments:\n - handle - file-like object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/Hie.py", "line_number": 96, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.Hie", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Iterate over RAF file, giving a SeqMap object for each line.\n\nArguments:\n - handle -- file-like object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/Raf.py", "line_number": 311, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.Raf", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Iterate over search tool output file as QueryResult objects.\n\nArguments:\n - handle - Handle to the file, or the filename as a string.\n - format - Lower case string denoting one of the supported formats.\n - kwargs - Format-specific keyword arguments.\n\nThis function is used to iterate over each query in a given search output\nfile:\n\n>>> from Bio import SearchIO\n>>> qresults = SearchIO.parse('Blast/mirna.xml', 'blast-xml')\n>>> qresults\n<generator object ...>\n>>> for qresult in qresults:\n...     print(\"Search %s has %i hits\" % (qresult.id, len(qresult)))\n...\nSearch 33211 has 100 hits\nSearch 33212 has 44 hits\nSearch 33213 has 95 hits\n\nDepending on the file format, ``parse`` may also accept additional keyword\nargument(s) that modifies the behavior of the format parser. Here is a\nsimple example, where the keyword argument enables parsing of a commented\nBLAST tabular output file:\n\n>>> from Bio import SearchIO\n>>> for qresult in SearchIO.parse('Blast/mirna.tab', 'blast-tab', comments=True):\n...     print(\"Search %s has %i hits\" % (qresult.id, len(qresult)))\n...\nSearch 33211 has 100 hits\nSearch 33212 has 44 hits\nSearch 33213 has 95 hits", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/__init__.py", "line_number": 264, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.__init__", "name": "parse", "signature": "(handle, format = None, **kwargs)", "symbol_type": "function"}, {"docstring": "Turn a sequence file into an iterator returning SeqRecords.\n\nArguments:\n - handle   - handle to the file, or the filename as a string\n - format   - lower case string describing the file format.\n - alphabet - no longer used, should be None.\n\nTypical usage, opening a file to read in, and looping over the record(s):\n\n>>> from Bio import SeqIO\n>>> filename = \"Fasta/sweetpea.nu\"\n>>> for record in SeqIO.parse(filename, \"fasta\"):\n...    print(\"ID %s\" % record.id)\n...    print(\"Sequence length %i\" % len(record))\nID gi|3176602|gb|U78617.1|LOU78617\nSequence length 309\n\nFor lazy-loading file formats such as twobit, for which the file contents\nis read on demand only, ensure that the file remains open while extracting\nsequence data.\n\nIf you have a string 'data' containing the file contents, you must\nfirst turn this into a handle in order to parse it:\n\n>>> data = \">Alpha\\nACCGGATGTA\\n>Beta\\nAGGCTCGGTTA\\n\"\n>>> from Bio import SeqIO\n>>> from io import StringIO\n>>> for record in SeqIO.parse(StringIO(data), \"fasta\"):\n...     print(\"%s %s\" % (record.id, record.seq))\nAlpha ACCGGATGTA\nBeta AGGCTCGGTTA\n\nUse the Bio.SeqIO.read(...) function when you expect a single record\nonly.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/__init__.py", "line_number": 622, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.__init__", "name": "parse", "signature": "(handle, format, alphabet = None)", "symbol_type": "function"}, {"docstring": "Iterate of ACE file contig by contig.\n\nArgument source is a file-like object or a path to a file.\n\nThis function returns an iterator that allows you to iterate\nover the ACE file record by record::\n\n    records = parse(source)\n    for record in records:\n        # do something with the record\n\nwhere each record is a Contig object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Sequencing/Ace.py", "line_number": 491, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Sequencing.Ace", "name": "parse", "signature": "(source)", "symbol_type": "function"}, {"docstring": "Iterate over a file yielding multiple PHD records.\n\nArgument source is a file-like object opened in text mode, or a path\nto a file.\n\nThe data is read line by line from the source.\n\nTypical usage::\n\n    records = parse(handle)\n    for record in records:\n        # do something with the record object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Sequencing/Phd.py", "line_number": 75, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Sequencing.Phd", "name": "parse", "signature": "(source)", "symbol_type": "function"}, {"docstring": "Parse the keyword list from file handle.\n\nReturns a generator object which yields keyword entries as\nBio.SwissProt.KeyWList.Record() object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SwissProt/KeyWList.py", "line_number": 52, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SwissProt.KeyWList", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read multiple SwissProt records from file.\n\nArgument source is a file-like object or a path to a file.\n\nReturns a generator object which yields Bio.SwissProt.Record() objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SwissProt/__init__.py", "line_number": 224, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SwissProt.__init__", "name": "parse", "signature": "(source)", "symbol_type": "function"}, {"docstring": "Read and load a UniGene records, for files containing multiple records.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/UniGene/__init__.py", "line_number": 256, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.UniGene.__init__", "name": "parse", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse an output file from a motif finding program.\n\nCurrently supported formats (case is ignored):\n - AlignAce:         AlignAce output file format\n - ClusterBuster:    Cluster Buster position frequency matrix format\n - XMS:              XMS matrix format\n - MEME:             MEME output file motif\n - MINIMAL:          MINIMAL MEME output file motif\n - MAST:             MAST output file motif\n - TRANSFAC:         TRANSFAC database file format\n - pfm-four-columns: Generic position-frequency matrix format with four columns. (CIS-BP, HOMER, HOCOMOCO, Neph, Tiffin)\n - pfm-four-rows:    Generic position-frequency matrix format with four row. (ScerTF, YeTFaSCo, hDPI, iDMMPMM, FlyFactorSurvey, Cys2His2 Zinc Finger Proteins PWM Predictor)\n - pfm:              JASPAR-style position-frequency matrix\n - jaspar:           JASPAR-style multiple PFM format\n - sites:            JASPAR-style sites file\n\nAs files in the pfm and sites formats contain only a single motif,\nit is easier to use Bio.motifs.read() instead of Bio.motifs.parse()\nfor those.\n\nFor example:\n\n>>> from Bio import motifs\n>>> with open(\"motifs/alignace.out\") as handle:\n...     for m in motifs.parse(handle, \"AlignAce\"):\n...         print(m.consensus)\n...\nTCTACGATTGAG\nCTGCACCTAGCTACGAGTGAG\nGTGCCCTAAGCATACTAGGCG\nGCCACTAGCAGAGCAGGGGGC\nCGACTCAGAGGTT\nCCACGCTAAGAGAAGTGCCGGAG\nGCACGTCCCTGAGCA\nGTCCATCGCAAAGCGTGGGGC\nGAGATCAGAGGGCCG\nTGGACGCGGGG\nGACCAGAGCCTCGCATGGGGG\nAGCGCGCGTG\nGCCGGTTGCTGTTCATTAGG\nACCGACGGCAGCTAAAAGGG\nGACGCCGGGGAT\nCGACTCGCGCTTACAAGG\n\nIf strict is True (default), the parser will raise a ValueError if the\nfile contents does not strictly comply with the specified file format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/__init__.py", "line_number": 41, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.__init__", "name": "parse", "signature": "(handle, fmt, strict = True)", "symbol_type": "function"}, {"docstring": "Turn a phenotype file into an iterator returning PlateRecords.\n\n - handle   - handle to the file, or the filename as a string\n              (note older versions of Biopython only took a handle).\n - format   - lower case string describing the file format.\n\nTypical usage, opening a file to read in, and looping over the record(s):\n\n>>> from Bio import phenotype\n>>> filename = \"phenotype/Plates.csv\"\n>>> for record in phenotype.parse(filename, \"pm-csv\"):\n...    print(\"ID %s\" % record.id)\n...    print(\"Number of wells %i\" % len(record))\n...\nID PM01\nNumber of wells 96\nID PM09\nNumber of wells 96\n\nUse the Bio.phenotype.read(...) function when you expect a single record\nonly.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/__init__.py", "line_number": 150, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.__init__", "name": "parse", "signature": "(handle, format)", "symbol_type": "function"}], "parseFile": [{"docstring": "Parse a DTD file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/_parser.py", "line_number": 81, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast._parser", "name": "parseFile", "signature": "(self, filename)", "symbol_type": "function"}], "parse_alignment_block": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/ExonerateIO/_base.py", "line_number": 388, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.ExonerateIO._base", "name": "parse_alignment_block", "signature": "(self, header)", "symbol_type": "function"}, {"docstring": "Parse alignment block for cigar format, return query results, hits, hsps.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/ExonerateIO/exonerate_cigar.py", "line_number": 33, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.ExonerateIO.exonerate_cigar", "name": "parse_alignment_block", "signature": "(self, header)", "symbol_type": "function"}, {"docstring": "Parse alignment block, return query result, hits, hsps.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/ExonerateIO/exonerate_text.py", "line_number": 318, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.ExonerateIO.exonerate_text", "name": "parse_alignment_block", "signature": "(self, header)", "symbol_type": "function"}, {"docstring": "Parse alignment block for vulgar format, return query results, hits, hsps.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/ExonerateIO/exonerate_vulgar.py", "line_number": 128, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.ExonerateIO.exonerate_vulgar", "name": "parse_alignment_block", "signature": "(self, header)", "symbol_type": "function"}], "parse_args": [{"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/dna/run_dna_analysis.py", "line_number": 29, "module": "scripts.dna.run_dna_analysis", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/ecology/run_ecology_analysis.py", "line_number": 28, "module": "scripts.ecology.run_ecology_analysis", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/epigenome/run_epigenome_analysis.py", "line_number": 28, "module": "scripts.epigenome.run_epigenome_analysis", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/run_life_events_analysis.py", "line_number": 29, "module": "scripts.life_events.run_life_events_analysis", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/generate_synthetic_data.py", "line_number": 27, "module": "scripts.life_events.generate_synthetic_data", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/learn_embeddings.py", "line_number": 28, "module": "scripts.life_events.learn_embeddings", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/train_model.py", "line_number": 32, "module": "scripts.life_events.train_model", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/predict_outcomes.py", "line_number": 29, "module": "scripts.life_events.predict_outcomes", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/visualize_sequences.py", "line_number": 30, "module": "scripts.life_events.visualize_sequences", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/compare_groups.py", "line_number": 27, "module": "scripts.life_events.compare_groups", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/analyze_intervention.py", "line_number": 30, "module": "scripts.life_events.analyze_intervention", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/interpret_predictions.py", "line_number": 30, "module": "scripts.life_events.interpret_predictions", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/export_embeddings.py", "line_number": 25, "module": "scripts.life_events.export_embeddings", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/validate_data.py", "line_number": 27, "module": "scripts.life_events.validate_data", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/math/run_math_modeling.py", "line_number": 29, "module": "scripts.math.run_math_modeling", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/ml/run_ml_pipeline.py", "line_number": 28, "module": "scripts.ml.run_ml_pipeline", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/multiomics/run_multiomics_integration.py", "line_number": 28, "module": "scripts.multiomics.run_multiomics_integration", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/networks/run_network_analysis.py", "line_number": 28, "module": "scripts.networks.run_network_analysis", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/ontology/run_ontology_analysis.py", "line_number": 28, "module": "scripts.ontology.run_ontology_analysis", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/phenotype/run_phenotype_analysis.py", "line_number": 28, "module": "scripts.phenotype.run_phenotype_analysis", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/protein/run_protein_analysis.py", "line_number": 29, "module": "scripts.protein.run_protein_analysis", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/quality/run_quality_control.py", "line_number": 28, "module": "scripts.quality.run_quality_control", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/run_simulation.py", "line_number": 30, "module": "scripts.simulation.run_simulation", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/singlecell/run_singlecell_analysis.py", "line_number": 28, "module": "scripts.singlecell.run_singlecell_analysis", "name": "parse_args", "signature": "()", "symbol_type": "function"}, {"docstring": "Parse command-line arguments.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/visualization/run_visualization.py", "line_number": 28, "module": "scripts.visualization.run_visualization", "name": "parse_args", "signature": "()", "symbol_type": "function"}], "parse_basics": [{"docstring": "Parse the basics that should be present in most baseml results files.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_baseml.py", "line_number": 15, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_baseml", "name": "parse_basics", "signature": "(lines, results)", "symbol_type": "function"}, {"docstring": "Parse the basic information that should be present in most codeml output files.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_codeml.py", "line_number": 15, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_codeml", "name": "parse_basics", "signature": "(lines, results)", "symbol_type": "function"}], "parse_block_mapping_first_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 422, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_block_mapping_first_key", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 422, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_block_mapping_first_key", "signature": "(self)", "symbol_type": "function"}], "parse_block_mapping_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 427, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_block_mapping_key", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 427, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_block_mapping_key", "signature": "(self)", "symbol_type": "function"}], "parse_block_mapping_value": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 446, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_block_mapping_value", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 446, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_block_mapping_value", "signature": "(self)", "symbol_type": "function"}], "parse_block_node": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 264, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_block_node", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 264, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_block_node", "signature": "(self)", "symbol_type": "function"}], "parse_block_node_or_indentless_sequence": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 270, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_block_node_or_indentless_sequence", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 270, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_block_node_or_indentless_sequence", "signature": "(self)", "symbol_type": "function"}], "parse_block_sequence_entry": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 381, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_block_sequence_entry", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 381, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_block_sequence_entry", "signature": "(self)", "symbol_type": "function"}], "parse_block_sequence_first_entry": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 376, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_block_sequence_first_entry", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 376, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_block_sequence_first_entry", "signature": "(self)", "symbol_type": "function"}], "parse_branch_site_a": [{"docstring": "Parse results specific to the branch site A model.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_codeml.py", "line_number": 381, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_codeml", "name": "parse_branch_site_a", "signature": "(foreground, line_floats, site_classes)", "symbol_type": "function"}], "parse_btop": [{"docstring": "Parse a BTOP string and return alignment coordinates.\n\nA BTOP (Blast trace-back operations) string is used by BLAST to\ndescribe a sequence alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/tabular.py", "line_number": 334, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.tabular", "name": "parse_btop", "signature": "(self, btop)", "symbol_type": "function"}], "parse_cds_features": [{"docstring": "Parse CDS features, return SeqRecord object iterator.\n\nEach CDS feature becomes a SeqRecord.\n\nArguments:\n - alphabet - Obsolete, should be left as None.\n - tags2id  - Tuple of three strings, the feature keys to use\n   for the record id, name and description,\n\nThis method is intended for use in Bio.SeqIO", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/Scanner.py", "line_number": 527, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.Scanner", "name": "parse_cds_features", "signature": "(self, handle, alphabet = None, tags2id = ('protein_id', 'locus_tag', 'product'))", "symbol_type": "function"}], "parse_children": [{"docstring": "Traverse the tree to create a nested clade structure.\n\nReturn a CDAO.Clade, and calls itself recursively for each child,\ntraversing the entire tree and creating a nested structure of CDAO.Clade\nobjects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 241, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "parse_children", "signature": "(self, node)", "symbol_type": "function"}], "parse_cigar": [{"docstring": "Parse a CIGAR string and return alignment coordinates.\n\nA CIGAR string, as defined by the SAM Sequence Alignment/Map format,\ndescribes a sequence alignment as a series of lengths and operation\n(alignment/insertion/deletion) codes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/tabular.py", "line_number": 378, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.tabular", "name": "parse_cigar", "signature": "(self, cigar)", "symbol_type": "function"}], "parse_clademodelc": [{"docstring": "Parse results specific to the clade model C.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_codeml.py", "line_number": 370, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_codeml", "name": "parse_clademodelc", "signature": "(branch_type_no, line_floats, site_classes)", "symbol_type": "function"}], "parse_distances": [{"docstring": "Parse amino acid sequence distance results.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_codeml.py", "line_number": 440, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_codeml", "name": "parse_distances", "signature": "(lines, results)", "symbol_type": "function"}], "parse_document_content": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 208, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_document_content", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 208, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_document_content", "signature": "(self)", "symbol_type": "function"}], "parse_document_end": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 190, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_document_end", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 190, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_document_end", "signature": "(self)", "symbol_type": "function"}], "parse_document_start": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 159, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_document_start", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 159, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_document_start", "signature": "(self)", "symbol_type": "function"}], "parse_domain": [{"docstring": "Convert an ASTRAL header string into a Scop domain.\n\nAn ASTRAL (http://astral.stanford.edu/) header contains a concise\ndescription of a SCOP domain. A very similar format is used when a\nDomain object is converted into a string.  The Domain returned by this\nmethod contains most of the SCOP information, but it will not be located\nwithin the SCOP hierarchy (i.e. The parent node will be None). The\ndescription is composed of the SCOP protein and species descriptions.\n\nA typical ASTRAL header looks like --\n>d1tpt_1 a.46.2.1 (1-70) Thymidine phosphorylase {Escherichia coli}", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 126, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "parse_domain", "signature": "(term)", "symbol_type": "function"}], "parse_fasta": [{"docstring": "Parse FASTA file and return dictionary of sequence ID to sequence.\n\nArgs:\n    path: Path to FASTA file\n    \nReturns:\n    Dictionary mapping sequence IDs to sequences", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/sequences.py", "line_number": 10, "module": "src.metainformant.protein.sequences", "name": "parse_fasta", "signature": "(path: Path) -> Dict[str, str]", "symbol_type": "function"}], "parse_feature": [{"docstring": "Parse a feature given as a list of strings into a tuple.\n\nExpects a feature as a list of strings, returns a tuple (key, location,\nqualifiers)\n\nFor example given this GenBank feature::\n\n     CDS             complement(join(490883..490885,1..879))\n                     /locus_tag=\"NEQ001\"\n                     /note=\"conserved hypothetical [Methanococcus jannaschii];\n                     COG1583:Uncharacterized ACR; IPR001472:Bipartite nuclear\n                     localization signal; IPR002743: Protein of unknown\n                     function DUF57\"\n                     /codon_start=1\n                     /transl_table=11\n                     /product=\"hypothetical protein\"\n                     /protein_id=\"NP_963295.1\"\n                     /db_xref=\"GI:41614797\"\n                     /db_xref=\"GeneID:2732620\"\n                     /translation=\"MRLLLELKALNSIDKKQLSNYLIQGFIYNILKNTEYSWLHNWKK\n                     EKYFNFTLIPKKDIIENKRYYLIISSPDKRFIEVLHNKIKDLDIITIGLAQFQLRKTK\n                     KFDPKLRFPWVTITPIVLREGKIVILKGDKYYKVFVKRLEELKKYNLIKKKEPILEEP\n                     IEISLNQIKDGWKIIDVKDRYYDFRNKSFSAFSNWLRDLKEQSLRKYNNFCGKNFYFE\n                     EAIFEGFTFYKTVSIRIRINRGEAVYIGTLWKELNVYRKLDKEEREFYKFLYDCGLGS\n                     LNSMGFGFVNTKKNSAR\"\n\nThen should give input key=\"CDS\" and the rest of the data as a list of strings\nlines=[\"complement(join(490883..490885,1..879))\", ..., \"LNSMGFGFVNTKKNSAR\"]\nwhere the leading spaces and trailing newlines have been removed.\n\nReturns tuple containing: (key as string, location string, qualifiers as list)\nas follows for this example:\n\nkey = \"CDS\", string\nlocation = \"complement(join(490883..490885,1..879))\", string\nqualifiers = list of string tuples:\n\n[('locus_tag', '\"NEQ001\"'),\n ('note', '\"conserved hypothetical [Methanococcus jannaschii];\\nCOG1583:...\"'),\n ('codon_start', '1'),\n ('transl_table', '11'),\n ('product', '\"hypothetical protein\"'),\n ('protein_id', '\"NP_963295.1\"'),\n ('db_xref', '\"GI:41614797\"'),\n ('db_xref', '\"GeneID:2732620\"'),\n ('translation', '\"MRLLLELKALNSIDKKQLSNYLIQGFIYNILKNTEYSWLHNWKK\\nEKYFNFT...\"')]\n\nIn the above example, the \"note\" and \"translation\" were edited for compactness,\nand they would contain multiple new line characters (displayed above as \\n)\n\nIf a qualifier is quoted (in this case, everything except codon_start and\ntransl_table) then the quotes are NOT removed.\n\nNote that no whitespace is removed.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/Scanner.py", "line_number": 233, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.Scanner", "name": "parse_feature", "signature": "(self, feature_key, lines)", "symbol_type": "function"}], "parse_features": [{"docstring": "Return list of tuples for the features (if present).\n\nEach feature is returned as a tuple (key, location, qualifiers)\nwhere key and location are strings (e.g. \"CDS\" and\n\"complement(join(490883..490885,1..879))\") while qualifiers\nis a list of two string tuples (feature qualifier keys and values).\n\nAssumes you have already read to the start of the features table.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/Scanner.py", "line_number": 146, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.Scanner", "name": "parse_features", "signature": "(self, skip = False)", "symbol_type": "function"}, {"docstring": "Return list of tuples for the features (if present).\n\nEach feature is returned as a tuple (key, location, qualifiers)\nwhere key and location are strings (e.g. \"CDS\" and\n\"complement(join(490883..490885,1..879))\") while qualifiers\nis a list of two string tuples (feature qualifier keys and values).\n\nAssumes you have already read to the start of the features table.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/Scanner.py", "line_number": 1075, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.Scanner", "name": "parse_features", "signature": "(self, skip = False)", "symbol_type": "function"}], "parse_flow_mapping_empty_value": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 583, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_flow_mapping_empty_value", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 583, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_flow_mapping_empty_value", "signature": "(self)", "symbol_type": "function"}], "parse_flow_mapping_first_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 537, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_flow_mapping_first_key", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 537, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_flow_mapping_first_key", "signature": "(self)", "symbol_type": "function"}], "parse_flow_mapping_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 542, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_flow_mapping_key", "signature": "(self, first = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 542, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_flow_mapping_key", "signature": "(self, first = False)", "symbol_type": "function"}], "parse_flow_mapping_value": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 569, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_flow_mapping_value", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 569, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_flow_mapping_value", "signature": "(self)", "symbol_type": "function"}], "parse_flow_node": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 267, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_flow_node", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 267, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_flow_node", "signature": "(self)", "symbol_type": "function"}], "parse_flow_sequence_entry": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 476, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_flow_sequence_entry", "signature": "(self, first = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 476, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_flow_sequence_entry", "signature": "(self, first = False)", "symbol_type": "function"}], "parse_flow_sequence_entry_mapping_end": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 526, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_flow_sequence_entry_mapping_end", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 526, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_flow_sequence_entry_mapping_end", "signature": "(self)", "symbol_type": "function"}], "parse_flow_sequence_entry_mapping_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 502, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_flow_sequence_entry_mapping_key", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 502, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_flow_sequence_entry_mapping_key", "signature": "(self)", "symbol_type": "function"}], "parse_flow_sequence_entry_mapping_value": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 512, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_flow_sequence_entry_mapping_value", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 512, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_flow_sequence_entry_mapping_value", "signature": "(self)", "symbol_type": "function"}], "parse_flow_sequence_first_entry": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 471, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_flow_sequence_first_entry", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 471, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_flow_sequence_first_entry", "signature": "(self)", "symbol_type": "function"}], "parse_footer": [{"docstring": "Return a tuple containing a list of any misc strings, and the sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/Scanner.py", "line_number": 369, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.Scanner", "name": "parse_footer", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a tuple containing a list of any misc strings, and the sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/Scanner.py", "line_number": 633, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.Scanner", "name": "parse_footer", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a tuple containing a list of any misc strings, and the sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/Scanner.py", "line_number": 1189, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.Scanner", "name": "parse_footer", "signature": "(self)", "symbol_type": "function"}], "parse_freqs": [{"docstring": "Parse the basepair frequencies.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_baseml.py", "line_number": 188, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_baseml", "name": "parse_freqs", "signature": "(lines, parameters)", "symbol_type": "function"}], "parse_graph": [{"docstring": "Iterate over RDF model yielding CDAO.Tree instances.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 140, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "parse_graph", "signature": "(self, graph = None, context = None)", "symbol_type": "function"}], "parse_handle_to_graph": [{"docstring": "Parse self.handle into RDF model self.model.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 117, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "parse_handle_to_graph", "signature": "(self, rooted = False, parse_format = 'turtle', context = None, **kwargs)", "symbol_type": "function"}], "parse_header": [{"docstring": "Return list of strings making up the header.\n\nNew line characters are removed.\n\nAssumes you have just read in the ID/LOCUS line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/Scanner.py", "line_number": 113, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.Scanner", "name": "parse_header", "signature": "(self)", "symbol_type": "function"}], "parse_hits": [{"docstring": "Parse a HMMER2 hit block, beginning with the hit table.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HmmerIO/hmmer2_text.py", "line_number": 140, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HmmerIO.hmmer2_text", "name": "parse_hits", "signature": "(self)", "symbol_type": "function"}], "parse_hsp_alignments": [{"docstring": "Parse a HMMER2 HSP alignment block.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HmmerIO/hmmer2_text.py", "line_number": 243, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HmmerIO.hmmer2_text", "name": "parse_hsp_alignments", "signature": "(self)", "symbol_type": "function"}], "parse_hsps": [{"docstring": "Parse a HMMER2 hsp block, beginning with the hsp table.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HmmerIO/hmmer2_text.py", "line_number": 173, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HmmerIO.hmmer2_text", "name": "parse_hsps", "signature": "(self, hit_placeholders)", "symbol_type": "function"}], "parse_implicit_document_start": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 139, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_implicit_document_start", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 139, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_implicit_document_start", "signature": "(self)", "symbol_type": "function"}], "parse_indentless_sequence_entry": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 402, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_indentless_sequence_entry", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 402, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_indentless_sequence_entry", "signature": "(self)", "symbol_type": "function"}], "parse_inline_dict": [{"docstring": "Parse inline dictionary string like '{a: 1, b: 2}'.\n\nArgs:\n    s: String containing inline dict (with braces)\n    \nReturns:\n    Parsed dictionary", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 331, "module": "src.metainformant.core.config", "name": "parse_inline_dict", "signature": "(s: str) -> dict[str, Any]", "symbol_type": "function"}], "parse_kappas": [{"docstring": "Parse out the kappa parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_baseml.py", "line_number": 94, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_baseml", "name": "parse_kappas", "signature": "(lines, parameters)", "symbol_type": "function"}], "parse_key_value": [{"docstring": "Parse key-value pair separated by colon.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HmmerIO/hmmer2_text.py", "line_number": 69, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HmmerIO.hmmer2_text", "name": "parse_key_value", "signature": "(self)", "symbol_type": "function"}], "parse_metadata": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/sanity.py", "line_number": 15, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.sanity", "name": "parse_metadata", "signature": "(args, metadata)", "symbol_type": "function"}], "parse_model": [{"docstring": "Parse an individual NSsites model's results.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_codeml.py", "line_number": 156, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_codeml", "name": "parse_model", "signature": "(lines, results)", "symbol_type": "function"}], "parse_ng86": [{"docstring": "Parse the Nei & Gojobori (1986) section of the results.\n\nNei_Gojobori results are organized in a lower\ntriangular matrix, with the sequence names labeling\nthe rows and statistics in the format:\nw (dN dS) per column\nExample row (2 columns):\n0.0000 (0.0000 0.0207) 0.0000 (0.0000 0.0421)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_yn00.py", "line_number": 13, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_yn00", "name": "parse_ng86", "signature": "(lines, results)", "symbol_type": "function"}], "parse_node": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 273, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_node", "signature": "(self, block = False, indentless_sequence = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 273, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_node", "signature": "(self, block = False, indentless_sequence = False)", "symbol_type": "function"}], "parse_nssites": [{"docstring": "Determine which NSsites models are present and parse them.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_codeml.py", "line_number": 76, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_codeml", "name": "parse_nssites", "signature": "(lines, results, multi_models, multi_genes)", "symbol_type": "function"}], "parse_obo": [{"docstring": "Parse OBO (Open Biological and Biomedical Ontologies) format file.\n\nParses a subset of OBO format sufficient for Gene Ontology and similar\nhierarchical ontologies. Supports essential fields for term representation\nand hierarchy traversal.\n\nArgs:\n    path: Path to OBO format file (typically .obo extension)\n    \nReturns:\n    Ontology object containing all parsed terms and their relationships.\n    Each term includes identifier, name, namespace, definition, alternative\n    IDs, and parent relationships (is_a).\n    \nRaises:\n    IOError: If file does not exist or cannot be read\n    ValidationError: If file is malformed or contains invalid data\n    \nSupported OBO Fields:\n    - id: Term identifier (e.g., \"GO:0008150\")\n    - name: Human-readable term name\n    - namespace: Ontology namespace/category\n    - def: Term definition (with optional citations)\n    - alt_id: Alternative identifiers for the term\n    - is_a: Parent term relationships (creates hierarchy)\n    \nExamples:\n    >>> onto = parse_obo(\"go-basic.obo\")\n    >>> onto.num_terms()\n    45000\n    >>> onto.has_term(\"GO:0008150\")\n    True\n    >>> term = onto.terms[\"GO:0008150\"]\n    >>> term.name\n    'biological_process'\n    \nNote:\n    This is a lightweight parser for standard OBO files. Complex\n    relationship types beyond is_a, qualifiers, and advanced OBO\n    features may require specialized parsing libraries.\n    \nReferences:\n    OBO Format Specification: https://owlcollab.github.io/oboformat/doc/GO.format.html", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/obo.py", "line_number": 35, "module": "src.metainformant.ontology.obo", "name": "parse_obo", "signature": "(path: str | Path) -> Ontology", "symbol_type": "function"}], "parse_others": [{"docstring": "Parse the results from the other methods.\n\nThe remaining methods are grouped together. Statistics\nfor all three are listed for each of the pairwise\nspecies comparisons, with each method's results on its\nown line.\nThe stats in this section must be handled differently\ndue to the possible presence of NaN values, which won't\nget caught by my typical \"line_floats\" method used above.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_yn00.py", "line_number": 98, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_yn00", "name": "parse_others", "signature": "(lines, results, sequences)", "symbol_type": "function"}], "parse_pairwise": [{"docstring": "Parse results from pairwise comparisons.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_codeml.py", "line_number": 395, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_codeml", "name": "parse_pairwise", "signature": "(lines, results)", "symbol_type": "function"}], "parse_parameter_list": [{"docstring": "Parse the parameters list, which is just an unlabeled list of numeric values.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_baseml.py", "line_number": 66, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_baseml", "name": "parse_parameter_list", "signature": "(lines, parameters, num_params)", "symbol_type": "function"}], "parse_parameters": [{"docstring": "Parse the various parameters from the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_baseml.py", "line_number": 55, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_baseml", "name": "parse_parameters", "signature": "(lines, results, num_params)", "symbol_type": "function"}], "parse_pdb_header": [{"docstring": "Return the header lines of a pdb file as a dictionary.\n\nDictionary keys are: head, deposition_date, release_date, structure_method,\nresolution, structure_reference, journal_reference, author and\ncompound.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/parse_pdb_header.py", "line_number": 155, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.parse_pdb_header", "name": "parse_pdb_header", "signature": "(infile)", "symbol_type": "function"}], "parse_preamble": [{"docstring": "Parse HMMER2 preamble.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HmmerIO/hmmer2_text.py", "line_number": 74, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HmmerIO.hmmer2_text", "name": "parse_preamble", "signature": "(self)", "symbol_type": "function"}], "parse_printed_alignment": [{"docstring": "Infer the sequences and coordinates from a printed alignment.\n\nThis method is primarily employed in Biopython's alignment parsers,\nthough it may be useful for other purposes.\n\nFor an alignment consisting of N sequences, printed as N lines with\nthe same number of columns, where gaps are represented by dashes,\nthis method will calculate the sequence coordinates that define the\nalignment. It returns the tuple (sequences, coordinates), where\nsequences is the list of N sequences after removing the gaps, and\nthe coordinates is a 2D NumPy array of integers. Together, the\nsequences and coordinates can be used to create an Alignment object.\n\nThis is an example for the alignment of three sequences TAGGCATACGTG,\nAACGTACGT, and ACGCATACTTG, with gaps in the second and third sequence.\nNote that the input sequences are bytes objects.\n\n>>> from Bio.Align import Alignment\n>>> from Bio.Seq import Seq\n>>> lines = [b\"TAGGCATACGTG\",\n...          b\"AACG--TACGT-\",\n...          b\"-ACGCATACTTG\",\n...         ]\n>>> sequences, coordinates = Alignment.parse_printed_alignment(lines)\n>>> sequences\n[b'TAGGCATACGTG', b'AACGTACGT', b'ACGCATACTTG']\n>>> print(coordinates)\n[[ 0  1  4  6 11 12]\n [ 0  1  4  4  9  9]\n [ 0  0  3  5 10 11]]\n>>> sequences = [Seq(sequence) for sequence in sequences]\n>>> sequences\n[Seq('TAGGCATACGTG'), Seq('AACGTACGT'), Seq('ACGCATACTTG')]\n>>> alignment = Alignment(sequences, coordinates)\n>>> print(alignment)\n                  0 TAGGCATACGTG 12\n                  0 AACG--TACGT-  9\n                  0 -ACGCATACTTG 11\n<BLANKLINE>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 1017, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "parse_printed_alignment", "signature": "(cls, lines)", "symbol_type": "function"}], "parse_qresult": [{"docstring": "Parse a HMMER2 query block.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HmmerIO/hmmer2_text.py", "line_number": 109, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HmmerIO.hmmer2_text", "name": "parse_qresult", "signature": "(self)", "symbol_type": "function"}], "parse_rates": [{"docstring": "Parse the rate parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_baseml.py", "line_number": 137, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_baseml", "name": "parse_rates", "signature": "(lines, parameters)", "symbol_type": "function"}], "parse_records": [{"docstring": "Parse records, return a SeqRecord object iterator.\n\nEach record (from the ID/LOCUS line to the // line) becomes a SeqRecord\n\nThe SeqRecord objects include SeqFeatures if do_features=True\n\nThis method is intended for use in Bio.SeqIO", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/Scanner.py", "line_number": 500, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.Scanner", "name": "parse_records", "signature": "(self, handle, do_features = True)", "symbol_type": "function"}], "parse_scalar": [{"docstring": "Parse a scalar value (int, string, empty dict/list).\n\nArgs:\n    s: String to parse\n    \nReturns:\n    Parsed value (int, dict, list, or string)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/config.py", "line_number": 312, "module": "src.metainformant.core.config", "name": "parse_scalar", "signature": "(s: str) -> Any", "symbol_type": "function"}], "parse_siteclass_omegas": [{"docstring": "Find omega estimate for each class.\n\nFor models which have multiple site classes, find the omega estimated\nfor each class.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_codeml.py", "line_number": 351, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_codeml", "name": "parse_siteclass_omegas", "signature": "(line, site_classes)", "symbol_type": "function"}], "parse_siteclass_proportions": [{"docstring": "Find proportion of alignment assigned to each class.\n\nFor models which have multiple site classes, find the proportion of the\nalignment assigned to each class.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_codeml.py", "line_number": 338, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_codeml", "name": "parse_siteclass_proportions", "signature": "(line_floats)", "symbol_type": "function"}], "parse_size": [{"docstring": "Parse size string like '468G' or '1.5T' to GB.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/disk.py", "line_number": 52, "module": "src.metainformant.core.disk", "name": "parse_size", "signature": "(s: str) -> float", "symbol_type": "function"}], "parse_stream_start": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 127, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "parse_stream_start", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 127, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "parse_stream_start", "signature": "(self)", "symbol_type": "function"}], "parse_time": [{"docstring": "Parse time string to timestamp.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/analyze_intervention.py", "line_number": 67, "module": "scripts.life_events.analyze_intervention", "name": "parse_time", "signature": "(time_str: str) -> float", "symbol_type": "function"}], "parse_vcf": [{"docstring": "Parse a minimal VCF to extract sample names and variant count.\n\nOnly inspects header for samples and counts non-header lines as variants.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/variants.py", "line_number": 7, "module": "src.metainformant.dna.variants", "name": "parse_vcf", "signature": "(path: str | Path) -> Dict[str, Any]", "symbol_type": "function"}], "parse_vcf_full": [{"docstring": "Parse VCF file and extract full genotype matrix.\n\nExtends dna.variants.parse_vcf to extract genotypes per sample.\n\nArgs:\n    path: Path to VCF file (supports .gz)\n\nReturns:\n    Dictionary with:\n    - samples: List of sample IDs\n    - variants: List of variant records (CHROM, POS, ID, REF, ALT, QUAL, FILTER)\n    - genotypes: 2D array (samples x variants) with genotypes encoded as:\n      0 = homozygous REF (0/0)\n      1 = heterozygous (0/1 or 1/0)\n      2 = homozygous ALT (1/1)\n      -1 = missing (./.)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/quality.py", "line_number": 29, "module": "src.metainformant.gwas.quality", "name": "parse_vcf_full", "signature": "(path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "parse_vulgar_comp": [{"docstring": "Parse the vulgar components present in the hsp dictionary.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/ExonerateIO/exonerate_vulgar.py", "line_number": 38, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.ExonerateIO.exonerate_vulgar", "name": "parse_vulgar_comp", "signature": "(hsp, vulgar_comp)", "symbol_type": "function"}], "parse_xsd": [{"docstring": "Parse an XSD file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 867, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "parse_xsd", "signature": "(self, root)", "symbol_type": "function"}], "parse_yn00": [{"docstring": "Parse the Yang & Nielsen (2000) part of the results.\n\nYang & Nielsen results are organized in a table with\neach row comprising one pairwise species comparison.\nRows are labeled by sequence number rather than by\nsequence name.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_parse_yn00.py", "line_number": 59, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._parse_yn00", "name": "parse_yn00", "signature": "(lines, results, sequences)", "symbol_type": "function"}], "parts": [{"docstring": "Read only list of sections (always one, the SimpleLocation object).\n\nThis is a convenience property allowing you to write code handling\nboth SimpleLocation objects (with one part) and more complex\nCompoundLocation objects (with multiple parts) interchangeably.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 1245, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "parts", "signature": "(self)", "symbol_type": "function"}], "path_to_root": [{"docstring": "Get shortest path from term to root (term with no parents).\n\nReturns a list of term IDs representing the path from the given term\nto a root term, following parent relationships. If multiple paths exist,\nreturns one of the shortest paths.\n\nArgs:\n    onto: Ontology object containing terms\n    term_id: Starting term identifier\n    \nReturns:\n    List of term IDs from term_id to a root, including term_id itself.\n    Returns [term_id] if term has no parents.\n    \nRaises:\n    ValueError: If term_id is empty or not found\n    \nExamples:\n    >>> onto = load_go_obo(\"go.obo\")\n    >>> path = path_to_root(onto, \"GO:0009987\")\n    >>> len(path) >= 1\n    True\n    >>> path[0] == \"GO:0009987\"\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/query.py", "line_number": 282, "module": "src.metainformant.ontology.query", "name": "path_to_root", "signature": "(onto: Ontology, term_id: str) -> List[str]", "symbol_type": "function"}], "pathway_activity_score": [{"docstring": "Calculate activity score for a pathway based on gene expression.\n\nComputes a summary score representing pathway activity from\nindividual gene expression levels.\n\nArgs:\n    pathway_network: PathwayNetwork object\n    pathway_id: Pathway identifier\n    gene_expression: Dictionary mapping gene_id to expression value\n    method: Aggregation method:\n        - \"mean\": Average expression of pathway genes\n        - \"median\": Median expression\n        - \"max\": Maximum expression\n        - \"sum\": Sum of expressions\n        \nReturns:\n    Pathway activity score (float). Higher values indicate higher activity.\n    \nExamples:\n    >>> pn = PathwayNetwork()\n    >>> pn.add_pathway(\"path1\", [\"GENE1\", \"GENE2\", \"GENE3\"])\n    >>> expression = {\"GENE1\": 10.5, \"GENE2\": 8.2, \"GENE3\": 12.1}\n    >>> score = pathway_activity_score(pn, \"path1\", expression)\n    >>> score > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 666, "module": "src.metainformant.networks.pathway", "name": "pathway_activity_score", "signature": "(pathway_network: PathwayNetwork, pathway_id: str, gene_expression: Dict[str, float], method: str = 'mean') -> float", "symbol_type": "function"}], "pathway_enrichment": [{"docstring": "Perform pathway enrichment analysis for a gene list.\n\nIdentifies pathways that are overrepresented in a query gene set compared\nto a background set. Uses hypergeometric-like statistics to assess enrichment.\n\nArgs:\n    gene_list: List of gene identifiers of interest (query set)\n    pathway_network: PathwayNetwork object containing pathways to test\n    background_genes: Optional background gene set. If None, uses all\n        genes present in the pathway network\n    return_dict: If True (default), returns dict keyed by pathway_id.\n        If False, returns list of dicts sorted by fold_enrichment.\n        \nReturns:\n    If return_dict=True: Dictionary mapping pathway_id -> enrichment result dict\n    If return_dict=False: List of dictionaries, one per enriched pathway, sorted by fold enrichment.\n    \n    Each dictionary contains:\n    - pathway_id: Pathway identifier\n    - pathway_size: Number of genes in pathway (in background)\n    - overlap_size: Number of query genes in pathway\n    - query_size: Number of query genes in background\n    - background_size: Total background genes\n    - fold_enrichment: Enrichment ratio (also available as \"enrichment_ratio\" for compatibility)\n    - p_value: Statistical significance (approximate)\n    - overlapping_genes: List of genes in both query and pathway\n    - metadata: Pathway metadata dictionary\n    \nExamples:\n    >>> query_genes = [\"GENE1\", \"GENE2\", \"GENE5\"]\n    >>> enrichment = pathway_enrichment(query_genes, pathway_network)\n    >>> enrichment[\"path:00010\"][\"fold_enrichment\"]\n    3.5\n    \nNote:\n    This uses simplified statistics. For rigorous analysis, consider\n    using Fisher's exact test or hypergeometric test implementations.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 394, "module": "src.metainformant.networks.pathway", "name": "pathway_enrichment", "signature": "(gene_list: List[str], pathway_network: PathwayNetwork, background_genes: Optional[List[str]] = None, return_dict: bool = True) -> Union[List[Dict[str, Any]], Dict[str, Dict[str, Any]]]", "symbol_type": "function"}], "pathway_overlap": [{"docstring": "Calculate gene overlap and similarity between two pathways.\n\nComputes both the set of overlapping genes and the Jaccard similarity\ncoefficient, which measures pathway similarity as the ratio of\nintersection to union.\n\nArgs:\n    pathway1: First pathway identifier\n    pathway2: Second pathway identifier\n\nReturns:\n    Tuple containing:\n    - overlapping_genes: Set of gene IDs present in both pathways\n    - jaccard_index: Jaccard similarity coefficient in [0, 1].\n      Formula: |A \u2229 B| / |A \u222a B|\n      \nExamples:\n    >>> pn = PathwayNetwork()\n    >>> pn.add_pathway(\"path1\", [\"GENE1\", \"GENE2\", \"GENE3\"])\n    >>> pn.add_pathway(\"path2\", [\"GENE2\", \"GENE3\", \"GENE4\"])\n    >>> overlap, jaccard = pn.pathway_overlap(\"path1\", \"path2\")\n    >>> overlap\n    {'GENE2', 'GENE3'}\n    >>> jaccard\n    0.5  # 2 overlapping / 4 total unique genes", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 190, "module": "src.metainformant.networks.pathway", "name": "pathway_overlap", "signature": "(self, pathway1: str, pathway2: str) -> Tuple[Set[str], float]", "symbol_type": "function"}], "pathway_regulation_analysis": [{"docstring": "Analyze regulatory control structure of biological pathways.\n\nExamines how pathways are regulated by transcription factors,\ndistinguishing between internal regulation (within pathway) and\nexternal regulation (from outside pathway).\n\nArgs:\n    grn: Gene regulatory network\n    pathway_genes: Dictionary mapping pathway_id to list of gene IDs\n        in that pathway\n    min_confidence: Minimum confidence threshold for regulatory\n        interactions to include in analysis\n        \nReturns:\n    Dictionary mapping pathway_id to analysis results. Each result\n    contains:\n    - pathway_size: Number of genes in pathway\n    - regulated_genes: Number of genes with regulatory inputs\n    - internal_regulations: Count of regulations within pathway\n    - external_regulators: List of regulators outside pathway\n    - pathway_regulators: List of regulators within pathway\n    - regulation_coverage: Fraction of genes with regulations\n    - internal_regulation_ratio: Ratio of internal to total regulations\n    \nExamples:\n    >>> pathway_genes = {\n    ...     \"pathway1\": [\"GENE1\", \"GENE2\", \"GENE3\"],\n    ...     \"pathway2\": [\"GENE4\", \"GENE5\"]\n    ... }\n    >>> analysis = pathway_regulation_analysis(grn, pathway_genes, min_confidence=0.7)\n    >>> analysis[\"pathway1\"][\"regulation_coverage\"]\n    0.666...", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 832, "module": "src.metainformant.networks.regulatory", "name": "pathway_regulation_analysis", "signature": "(grn: GeneRegulatoryNetwork, pathway_genes: Union[Dict[str, List[str]], List[str]], min_confidence: float = 0.5, calculate_enrichment: bool = False) -> Dict[str, Any]", "symbol_type": "function"}], "pathway_similarity": [{"docstring": "Calculate similarity between two pathways.\n\nComputes various similarity metrics to assess how similar two\npathways are in terms of gene composition.\n\nArgs:\n    pathway1_genes: Set of gene identifiers in first pathway\n    pathway2_genes: Set of gene identifiers in second pathway\n    method: Similarity metric:\n        - \"jaccard\": Jaccard similarity (intersection/union)\n        - \"overlap\": Overlap coefficient (intersection/min)\n        - \"dice\": Dice coefficient (2*intersection/(sum))\n        \nReturns:\n    Similarity score in [0, 1]. Higher values indicate more similar pathways.\n    \nExamples:\n    >>> path1 = {\"GENE1\", \"GENE2\", \"GENE3\"}\n    >>> path2 = {\"GENE2\", \"GENE3\", \"GENE4\"}\n    >>> similarity = pathway_similarity(path1, path2)\n    >>> similarity > 0.0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 624, "module": "src.metainformant.networks.pathway", "name": "pathway_similarity", "signature": "(pathway1_genes: Set[str], pathway2_genes: Set[str], method: str = 'jaccard') -> float", "symbol_type": "function"}, {"docstring": "Calculate similarity between two pathways.\n\nComputes similarity metrics to assess how similar two pathways\nare in terms of gene composition.\n\nArgs:\n    pathway1: First pathway identifier\n    pathway2: Second pathway identifier\n    method: Similarity metric:\n        - \"jaccard\": Jaccard similarity (intersection/union)\n        - \"overlap\": Overlap coefficient (intersection/min)\n        - \"dice\": Dice coefficient (2*intersection/(sum))\n\nReturns:\n    Similarity score in [0, 1]. Higher values indicate more similar pathways.\n\nExamples:\n    >>> pn = PathwayNetwork()\n    >>> pn.add_pathway(\"path1\", [\"GENE1\", \"GENE2\", \"GENE3\"])\n    >>> pn.add_pathway(\"path2\", [\"GENE2\", \"GENE3\", \"GENE4\"])\n    >>> similarity = pn.pathway_similarity(\"path1\", \"path2\")\n    >>> similarity > 0.0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/pathway.py", "line_number": 230, "module": "src.metainformant.networks.pathway", "name": "pathway_similarity", "signature": "(self, pathway1: str, pathway2: str, method: str = 'jaccard') -> float", "symbol_type": "function"}], "pca": [{"docstring": "Perform principal component analysis.\n\nKeyword arguments:\n - data: nrows x ncolumns array containing the data values.\n\nReturn value:\nThis function returns an array containing the mean of each column, the\nprincipal components as an nmin x ncolumns array, as well as the\ncoordinates (an nrows x nmin array) of the data along the principal\ncomponents, and the associated eigenvalues. The principal components, the\ncoordinates, and the eigenvalues are sorted by the magnitude of the\neigenvalue, with the largest eigenvalues appearing first. Here, nmin is\nthe smaller of nrows and ncolumns.\nAdding the column means to the dot product of the coordinates and the\nprincipal components recreates the data matrix:\n\n>>> import numpy as np\n>>> from Bio.Cluster import pca\n>>> matrix = np.array([[ 0.,  0.,  0.],\n...                    [ 1.,  0.,  0.],\n...                    [ 7.,  3.,  0.],\n...                    [ 4.,  2.,  6.]])\n>>> columnmean, coordinates, pc, _ = pca(matrix)\n>>> m = matrix - (columnmean + np.dot(coordinates, pc))\n>>> np.all(abs(m) < 1e-12)\nnp.True_", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 585, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "pca", "signature": "(data)", "symbol_type": "function"}], "pca_loadings_plot": [{"docstring": "Create a PCA loadings plot.\n\nArgs:\n    loadings: Loadings matrix (features x components)\n    pc_x: Principal component for x-axis\n    pc_y: Principal component for y-axis\n    feature_names: Optional feature names\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import pca_loadings_plot\n    >>> import numpy as np\n    >>> loadings = np.random.random((10, 5))\n    >>> ax = pca_loadings_plot(loadings, feature_names=[f'feature{i}' for i in range(10)])", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/dimred.py", "line_number": 285, "module": "src.metainformant.visualization.dimred", "name": "pca_loadings_plot", "signature": "(loadings: pd.DataFrame | np.ndarray, pc_x: int = 0, pc_y: int = 1, **kwargs) -> plt.Axes", "symbol_type": "function"}], "pca_plot": [{"docstring": "Plot PCA results colored by phenotype.\n\nArgs:\n    pca_components: Path to PCA TSV or numpy array\n    output_path: Save path\n    phenotypes: Dict mapping sample_id to phenotype\n    pc1: PC number for x-axis (1-indexed)\n    pc2: PC number for y-axis (1-indexed)\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_enhanced.py", "line_number": 600, "module": "src.metainformant.gwas.visualization_enhanced", "name": "pca_plot", "signature": "(pca_components: Path | np.ndarray, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "2D or 3D PCA plot of population structure.\n\nVisualizes principal components to identify population stratification,\noutliers, and batch effects.\n\nArgs:\n    pca_file: Path to PCA components file (TSV)\n    output_path: Output path\n    pc1: First PC to plot (default 1)\n    pc2: Second PC to plot (default 2)\n    phenotype_file: Optional phenotype file for coloring\n    title: Plot title\n    show_3d: Create 3D plot (PC1, PC2, PC3)\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_population.py", "line_number": 31, "module": "src.metainformant.gwas.visualization_population", "name": "pca_plot", "signature": "(pca_file: Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Create a PCA scatter plot.\n\nArgs:\n    data: DataFrame with PCA coordinates (PC1, PC2, etc.)\n    pc_x: Principal component for x-axis\n    pc_y: Principal component for y-axis\n    hue: Column to color points by\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments for scatter\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import pca_plot\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> data = pd.DataFrame({\n    ...     'PC1': np.random.normal(0, 1, 100),\n    ...     'PC2': np.random.normal(0, 1, 100),\n    ...     'group': ['A'] * 50 + ['B'] * 50\n    ... })\n    >>> ax = pca_plot(data, hue='group')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/dimred.py", "line_number": 28, "module": "src.metainformant.visualization.dimred", "name": "pca_plot", "signature": "(data: pd.DataFrame, **kwargs) -> plt.Axes", "symbol_type": "function"}], "pca_scree_plot": [{"docstring": "Scree plot showing variance explained by each PC.\n\nHelps determine how many PCs to include in GWAS adjustment.\n\nArgs:\n    pca_file: Path to PCA file with variance explained\n    output_path: Output path\n    max_pcs: Maximum number of PCs to show\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_population.py", "line_number": 152, "module": "src.metainformant.gwas.visualization_population", "name": "pca_scree_plot", "signature": "(pca_file: Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Create a PCA scree plot showing variance explained.\n\nArgs:\n    explained_variance: Variance explained by each component\n    n_components: Number of components to show (if None, shows all)\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import pca_scree_plot\n    >>> import numpy as np\n    >>> variance = np.array([0.4, 0.3, 0.2, 0.1])\n    >>> ax = pca_scree_plot(variance)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/dimred.py", "line_number": 241, "module": "src.metainformant.visualization.dimred", "name": "pca_scree_plot", "signature": "(explained_variance: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "pcb_vectors_pymol": [{"docstring": "Write PyMol script for visualization.\n\nWrite a PyMol script that visualizes the pseudo CB-CA directions\nat the CA coordinates.\n\n:param filename: the name of the pymol script file\n:type filename: string", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/HSExposure.py", "line_number": 211, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.HSExposure", "name": "pcb_vectors_pymol", "signature": "(self, filename = 'hs_exp.py')", "symbol_type": "function"}], "pdb_date": [{"docstring": "Convert yyyy-mm-dd date to dd-month-yy.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 921, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "pdb_date", "signature": "(datestr: str) -> str", "symbol_type": "function"}], "pdb_residue_string": [{"docstring": "Generate PDB ATOM records for this residue as string.\n\nConvenience method for functionality not exposed in PDBIO.py.\nIncrements :data:`IC_Residue.atom_sernum` if not None\n\n:param IC_Residue.atom_sernum: Class variable default None.\n    Override and increment atom serial number if not None\n:param IC_Residue.atom_chain: Class variable.\n    Override atom chain id if not None\n\n.. todo::\n    move to PDBIO", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 3311, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "pdb_residue_string", "signature": "(self) -> str", "symbol_type": "function"}], "peak_enrichment_analysis": [{"docstring": "Analyze peak enrichment near genomic features.\n\nArgs:\n    peaks: Peak DataFrame with 'chrom', 'start', 'end' columns\n    gene_annotations: Optional gene annotations with 'chrom', 'start', 'end', 'gene_id' columns\n    window_size: Window size around features for enrichment analysis\n    \nReturns:\n    Dictionary with enrichment statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/chipseq.py", "line_number": 203, "module": "src.metainformant.epigenome.chipseq", "name": "peak_enrichment_analysis", "signature": "(peaks: pd.DataFrame, gene_annotations: pd.DataFrame | None = None, window_size: int = 5000) -> dict[str, Any]", "symbol_type": "function"}], "peek": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/reader.py", "line_number": 87, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.reader", "name": "peek", "signature": "(self, index = 0)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/reader.py", "line_number": 87, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.reader", "name": "peek", "signature": "(self, index = 0)", "symbol_type": "function"}, {"docstring": "Return the first character from the buffer.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 78, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "peek", "signature": "(self)", "symbol_type": "function"}], "peek_event": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 107, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "peek_event", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 107, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "peek_event", "signature": "(self)", "symbol_type": "function"}], "peek_nonwhitespace": [{"docstring": "Return the first character from the buffer, do not include spaces.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 85, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "peek_nonwhitespace", "signature": "(self)", "symbol_type": "function"}], "peek_token": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 125, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "peek_token", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 125, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "peek_token", "signature": "(self)", "symbol_type": "function"}], "peek_word": [{"docstring": "Return a word stored in the buffer.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 129, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "peek_word", "signature": "(self, word)", "symbol_type": "function"}], "per_base_quality": [{"docstring": "Calculate per-base quality statistics.\n\nArgs:\n    reads: List of FASTQ records\n\nReturns:\n    Dictionary with per-base quality statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/fastq.py", "line_number": 129, "module": "src.metainformant.quality.fastq", "name": "per_base_quality", "signature": "(reads: List[FastqRecord]) -> Dict[str, Any]", "symbol_type": "function"}], "per_base_quality_plot": [{"docstring": "Plot quality scores across read positions.\n\nArgs:\n    positions: Read positions\n    quality_scores: Quality scores at each position\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import per_base_quality_plot\n    >>> import numpy as np\n    >>> positions = np.arange(1, 101)\n    >>> quality = 30 - 0.1 * positions + np.random.normal(0, 2, 100)\n    >>> ax = per_base_quality_plot(positions, quality)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/quality.py", "line_number": 132, "module": "src.metainformant.visualization.quality", "name": "per_base_quality_plot", "signature": "(positions: Sequence[int], quality_scores: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "per_sequence_quality": [{"docstring": "Calculate per-sequence quality score distribution.\n\nArgs:\n    reads: List of FASTQ records\n\nReturns:\n    Dictionary with per-sequence quality distribution", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/fastq.py", "line_number": 187, "module": "src.metainformant.quality.fastq", "name": "per_sequence_quality", "signature": "(reads: List[FastqRecord]) -> Dict[str, Any]", "symbol_type": "function"}], "performance_tracker": [{"docstring": "Provide performance tracking for tests.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 310, "module": "tests.conftest", "name": "performance_tracker", "signature": "() -> PerformanceTracker", "symbol_type": "function"}], "permutation_test": [{"docstring": "Perform permutation-based p-value calculation.\n\nArgs:\n    genotypes: Genotype matrix (samples x variants)\n    phenotypes: Phenotype values\n    covariates: Optional covariates\n    n_perm: Number of permutations\n    seed: Random seed\n\nReturns:\n    Dictionary with permutation-based p-values\n\nNote:\n    This is computationally expensive and may take a long time for large datasets.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/correction.py", "line_number": 179, "module": "src.metainformant.gwas.correction", "name": "permutation_test", "signature": "(genotypes: list[list[int]], phenotypes: list[float], covariates: list[list[float]] | None = None, n_perm: int = 1000, seed: int | None = None) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Perform permutation test to compare two groups.\n\nNon-parametric significance test that compares observed difference to\npermuted distribution under null hypothesis of no difference.\n\nArgs:\n    group1: First group of observations\n    group2: Second group of observations\n    statistic_func: Function that computes test statistic from two groups.\n        If None, uses difference of means.\n    n_permutations: Number of permutations to perform\n    alternative: Alternative hypothesis (\"two-sided\", \"greater\", \"less\")\n    random_state: Random seed for reproducibility\n\nReturns:\n    Dictionary with:\n    - statistic: Observed test statistic\n    - p_value: Permutation-based p-value\n    - n_permutations: Number of permutations performed\n    - alternative: Alternative hypothesis used\n    \nExamples:\n    >>> group1 = [1.0, 2.0, 3.0]\n    >>> group2 = [4.0, 5.0, 6.0]\n    >>> result = permutation_test(group1, group2, n_permutations=1000)\n    >>> result[\"p_value\"] < 0.05\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen_stats.py", "line_number": 102, "module": "src.metainformant.math.popgen_stats", "name": "permutation_test", "signature": "(group1: Sequence[float], group2: Sequence[float], statistic_func: Callable[[Sequence[float], Sequence[float]], float] | None = None, n_permutations: int = 10000, alternative: str = 'two-sided', random_state: int | None = None) -> dict[str, float]", "symbol_type": "function"}], "phred_quality_from_solexa": [{"docstring": "Convert a Solexa quality (which can be negative) to a PHRED quality.\n\nPHRED and Solexa quality scores are both log transformations of a\nprobality of error (high score = low probability of error). This function\ntakes a Solexa score, transforms it back to a probability of error, and\nthen re-expresses it as a PHRED score. This assumes the error estimates\nare equivalent.\n\nThe underlying formulas are given in the documentation for the sister\nfunction solexa_quality_from_phred, in this case the operation is::\n\n    phred_quality = 10*log(10**(solexa_quality/10.0) + 1, 10)\n\nThis will return a floating point number, it is up to you to round this to\nthe nearest integer if appropriate.  e.g.\n\n>>> print(\"%0.2f\" % round(phred_quality_from_solexa(80), 2))\n80.00\n>>> print(\"%0.2f\" % round(phred_quality_from_solexa(20), 2))\n20.04\n>>> print(\"%0.2f\" % round(phred_quality_from_solexa(10), 2))\n10.41\n>>> print(\"%0.2f\" % round(phred_quality_from_solexa(0), 2))\n3.01\n>>> print(\"%0.2f\" % round(phred_quality_from_solexa(-5), 2))\n1.19\n\nNote that a solexa_quality less then -5 is not expected, will trigger a\nwarning, but will still be converted as per the logarithmic mapping\n(giving a number between 0 and 1.19 back).\n\nAs a special case where None is used for a \"missing value\", None is\nreturned:\n\n>>> print(phred_quality_from_solexa(None))\nNone", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 493, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "phred_quality_from_solexa", "signature": "(solexa_quality: float) -> float", "symbol_type": "function"}], "phred_to_prob": [{"docstring": "Convert Phred score to error probability.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 349, "module": "tests.test_dna_comprehensive", "name": "phred_to_prob", "signature": "(q)", "symbol_type": "function"}], "phyloxml": [{"docstring": "Convert phyloxml to Etree element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 727, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "phyloxml", "signature": "(self, obj)", "symbol_type": "function"}], "pi": [{"docstring": "Calculate and return the isoelectric point as float.\n\nThis is a recursive function that uses bisection method.\nWiki on bisection: https://en.wikipedia.org/wiki/Bisection_method\n\nArguments:\n - pH: the pH at which the current charge of the protein is computed.\n   This pH lies at the centre of the interval (mean of `min_` and `max_`).\n - min\\_: the minimum of the interval. Initial value defaults to 4.05,\n   which is below the theoretical minimum, when the protein is composed\n   exclusively of aspartate.\n - max\\_: the maximum of the the interval. Initial value defaults to 12,\n   which is above the theoretical maximum, when the protein is composed\n   exclusively of arginine.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/IsoelectricPoint.py", "line_number": 137, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.IsoelectricPoint", "name": "pi", "signature": "(self, pH = 7.775, min_ = 4.05, max_ = 12)", "symbol_type": "function"}], "pick_angle": [{"docstring": "Get Hedron or Dihedron for angle_key.\n\n:param angle_key:\n    - tuple of 3 or 4 AtomKeys\n    - string of atom names ('CA') separated by :'s\n    - string of [-1, 0, 1]<atom name> separated by ':'s. -1 is\n      previous residue, 0 is this residue, 1 is next residue\n    - psi, phi, omg, omega, chi1, chi2, chi3, chi4, chi5\n    - tau (N-CA-C angle) see Richardson1981\n    - tuples of AtomKeys is only access for alternate disordered atoms\n\nObserve that a residue's phi and omega dihedrals, as well as the hedra\ncomprising them (including the N:Ca:C `tau` hedron), are stored in the\nn-1 di/hedra sets; this overlap is handled here, but may be an issue if\naccessing directly.\n\nThe following print commands are equivalent (except for sidechains with\nnon-carbon atoms for chi2)::\n\n    ric = r.internal_coord\n    print(\n        r,\n        ric.get_angle(\"psi\"),\n        ric.get_angle(\"phi\"),\n        ric.get_angle(\"omg\"),\n        ric.get_angle(\"tau\"),\n        ric.get_angle(\"chi2\"),\n    )\n    print(\n        r,\n        ric.get_angle(\"N:CA:C:1N\"),\n        ric.get_angle(\"-1C:N:CA:C\"),\n        ric.get_angle(\"-1CA:-1C:N:CA\"),\n        ric.get_angle(\"N:CA:C\"),\n        ric.get_angle(\"CA:CB:CG:CD\"),\n    )\n\nSee ic_data.py for detail of atoms in the enumerated sidechain angles\nand the backbone angles which do not span the peptide bond. Using 's'\nfor current residue ('self') and 'n' for next residue, the spanning\n(overlapping) angles are::\n\n        (sN, sCA, sC, nN)   # psi\n        (sCA, sC, nN, nCA)  # omega i+1\n        (sC, nN, nCA, nC)   # phi i+1\n        (sCA, sC, nN)\n        (sC, nN, nCA)\n        (nN, nCA, nC)       # tau i+1\n\n:return: Matching Hedron, Dihedron, or None.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 3585, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "pick_angle", "signature": "(self, angle_key: EKT | str) -> Union['Hedron', 'Dihedron'] | None", "symbol_type": "function"}], "pick_length": [{"docstring": "Get list of hedra containing specified atom pair.\n\n:param ak_spec:\n    - tuple of two AtomKeys\n    - string: two atom names separated by ':', e.g. 'N:CA' with\n      optional position specifier relative to self, e.g. '-1C:N' for\n      preceding peptide bond.  Position specifiers are -1, 0, 1.\n\nThe following are equivalent::\n\n    ric = r.internal_coord\n    print(\n        r,\n        ric.get_length(\"0C:1N\"),\n    )\n    print(\n        r,\n        None\n        if not ric.rnext\n        else ric.get_length((ric.rak(\"C\"), ric.rnext[0].rak(\"N\"))),\n    )\n\nIf atom not found on current residue then will look on rprev[0] to\nhandle cases like Gly N:CA.  For finer control please access\n`IC_Chain.hedra` directly.\n\n:return: list of hedra containing specified atom pair as tuples of\n        AtomKeys", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 3784, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "pick_length", "signature": "(self, ak_spec: str | BKT) -> tuple[list['Hedron'] | None, BKT | None]", "symbol_type": "function"}], "pid": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 429, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "pid", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 971, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "pid", "signature": "(self, content)", "symbol_type": "function"}], "pie_chart": [{"docstring": "Create a pie chart.\n\nArgs:\n    sizes: Values for each slice\n    labels: Labels for each slice\n    ax: Matplotlib axes (creates new if None)\n    colors: Colors for slices\n    autopct: Format string for percentage labels\n    title: Plot title\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import pie_chart\n    >>> ax = pie_chart([30, 25, 45], [\"A\", \"B\", \"C\"])", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/basic.py", "line_number": 210, "module": "src.metainformant.visualization.basic", "name": "pie_chart", "signature": "(sizes: Sequence[float], labels: Sequence[str] | None = None) -> plt.Axes", "symbol_type": "function"}], "pielou_evenness": [{"docstring": "Calculate Pielou's evenness index J' = H'/ln(S).\n\nArgs:\n    abundances: Species abundance values\n\nReturns:\n    Pielou's evenness index", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/community.py", "line_number": 66, "module": "src.metainformant.ecology.community", "name": "pielou_evenness", "signature": "(abundances: Sequence[float]) -> float", "symbol_type": "function"}], "pivot": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 353, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "pivot", "signature": "(self, n_sp_cutoff = 0, qualified_only = True, sampled_only = False)", "symbol_type": "function"}], "plan_workflow": [{"docstring": "Return an ordered list of (subcommand, params) representing a full run.\n\nThis does not execute anything; it allows dry inspection and TDD.\n\nNote: integrate runs AFTER getfastq to integrate downloaded FASTQs into metadata.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/workflow.py", "line_number": 165, "module": "src.metainformant.rna.workflow", "name": "plan_workflow", "signature": "(config: AmalgkitWorkflowConfig) -> list[tuple[str, AmalgkitParams]]", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 379, "module": "tests.test_rna_amalgkit_comprehensive", "name": "plan_workflow", "signature": "()", "symbol_type": "function"}], "plan_workflow_with_params": [{"docstring": "Plan workflow while merging per-step params on top of common ones.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/workflow.py", "line_number": 209, "module": "src.metainformant.rna.workflow", "name": "plan_workflow_with_params", "signature": "(config: AmalgkitWorkflowConfig, step_params: dict[str, AmalgkitParams]) -> list[tuple[str, AmalgkitParams]]", "symbol_type": "function"}], "plot_admixture_plot": [{"docstring": "Plot ancestry proportions as stacked bar plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 936, "module": "src.metainformant.dna.population_viz", "name": "plot_admixture_plot", "signature": "(ancestry_proportions: Sequence[Sequence[float]], population_names: Sequence[str] | None = None) -> plt.Figure", "symbol_type": "function"}], "plot_allele_frequency_spectrum": [{"docstring": "Plot allele frequency spectrum (SFS).\n\nArgs:\n    sfs: Site frequency spectrum (counts of sites at each frequency)\n    unfolded: Whether SFS is unfolded (requires ancestral state)\n    output_path: Optional path to save figure\n    title: Plot title\n    figsize: Figure size\n\nReturns:\n    matplotlib Figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 621, "module": "src.metainformant.dna.population_viz", "name": "plot_allele_frequency_spectrum", "signature": "(sfs: Sequence[int]) -> plt.Figure", "symbol_type": "function"}], "plot_attention_heatmap": [{"docstring": "Plot attention weight heatmap for sequence models.\n\nArgs:\n    attention_weights: Attention weight matrix (events x events)\n    event_tokens: List of event tokens for labels\n    output_path: Optional path to save figure\n    figsize: Figure size\n    \nReturns:\n    Matplotlib figure", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 158, "module": "src.metainformant.life_events.visualization", "name": "plot_attention_heatmap", "signature": "(attention_weights: NDArray, event_tokens: List[str], output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (12, 10)) -> 'Figure'", "symbol_type": "function"}], "plot_bootstrap_distribution": [{"docstring": "Plot bootstrap distribution with confidence intervals.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 1259, "module": "src.metainformant.dna.population_viz", "name": "plot_bootstrap_distribution", "signature": "(bootstrap_values: Sequence[float], observed_value: float | None = None) -> plt.Figure", "symbol_type": "function"}], "plot_clusters": [{"docstring": "Plot clusters on dimensionality reduction.\n\nArgs:\n    data: SingleCellData object\n    groupby: Clustering column name\n    basis: Embedding basis\n    size: Point size\n    alpha: Point transparency\n    figsize: Figure size\n    legend: Whether to show legend\n\nReturns:\n    Matplotlib figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/visualization.py", "line_number": 368, "module": "src.metainformant.singlecell.visualization", "name": "plot_clusters", "signature": "(data: SingleCellData, groupby: str, basis: str = 'umap', size: float = 1.0, alpha: float = 0.7, figsize: Tuple[float, float] = (8, 6), legend: bool = True) -> plt.Figure", "symbol_type": "function"}], "plot_demographic_comparison": [{"docstring": "Plot comparison of demographic models.\n\nArgs:\n    demographic_results: Dictionary with demographic model results\n    output_path: Optional path to save figure\n    title: Plot title\n    figsize: Figure size\n\nReturns:\n    matplotlib Figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 438, "module": "src.metainformant.dna.population_viz", "name": "plot_demographic_comparison", "signature": "(demographic_results: dict[str, dict[str, float]]) -> plt.Figure", "symbol_type": "function"}], "plot_dimensionality_reduction": [{"docstring": "Plot dimensionality reduction (UMAP, t-SNE, PCA).\n\nArgs:\n    data: SingleCellData object\n    basis: Embedding to plot ('umap', 'tsne', 'pca', 'diffmap')\n    color: Variable(s) to color by\n    size: Point size\n    alpha: Point transparency\n    ncols: Number of columns for multiple plots\n    figsize: Figure size\n    legend: Whether to show legend\n\nReturns:\n    Matplotlib figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/visualization.py", "line_number": 143, "module": "src.metainformant.singlecell.visualization", "name": "plot_dimensionality_reduction", "signature": "(data: SingleCellData, basis: str = 'umap', color: Optional[Union[str, List[str]]] = None, size: float = 1.0, alpha: float = 0.7, ncols: int = 2, figsize: Optional[Tuple[float, float]] = None, legend: bool = True) -> plt.Figure", "symbol_type": "function"}], "plot_diversity_comparison": [{"docstring": "Plot comparison of nucleotide diversity across scenarios.\n\nArgs:\n    diversity_values: Dictionary mapping scenario names to \u03c0 values\n    output_path: Optional path to save figure\n    title: Plot title\n    figsize: Figure size\n\nReturns:\n    matplotlib Figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 24, "module": "src.metainformant.dna.population_viz", "name": "plot_diversity_comparison", "signature": "(diversity_values: dict[str, float]) -> plt.Figure", "symbol_type": "function"}], "plot_domain_distribution": [{"docstring": "Plot distribution of domains across event sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 249, "module": "src.metainformant.life_events.visualization", "name": "plot_domain_distribution", "signature": "(sequences: List[EventSequence], output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (10, 6), plot_type: str = 'bar') -> 'Figure'", "symbol_type": "function"}], "plot_domain_timeline": [{"docstring": "Plot multi-domain timeline (Gantt-style) for multiple sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 468, "module": "src.metainformant.life_events.visualization", "name": "plot_domain_timeline", "signature": "(sequences: List[EventSequence], output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (14, 8), max_sequences: int = 10) -> 'Figure'", "symbol_type": "function"}], "plot_embedding_clusters": [{"docstring": "Plot clustered embedding visualization.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 697, "module": "src.metainformant.life_events.visualization", "name": "plot_embedding_clusters", "signature": "(embeddings: Dict[str, NDArray], clusters: Optional[Dict[str, int]] = None, method: str = 'umap', output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (10, 8)) -> 'Figure'", "symbol_type": "function"}], "plot_entropy_distribution": [{"docstring": "Plot distribution of entropy values.\n\nArgs:\n    entropies: List of entropy values\n    output_path: Path to save plot (if None, uses output/information/)\n    title: Plot title\n    \nReturns:\n    Dictionary with plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/visualization.py", "line_number": 20, "module": "src.metainformant.information.visualization", "name": "plot_entropy_distribution", "signature": "(entropies: list[float] | np.ndarray, output_path: Path | str | None = None, title: str = 'Entropy Distribution') -> dict[str, Any]", "symbol_type": "function"}], "plot_entropy_landscape": [{"docstring": "Plot 2D/3D visualization of entropy landscape.\n\nArgs:\n    entropy_data: 2D array of entropy values\n    x_labels: Optional labels for x-axis\n    y_labels: Optional labels for y-axis\n    output_path: Path to save plot\n    title: Plot title\n    \nReturns:\n    Dictionary with plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/visualization.py", "line_number": 343, "module": "src.metainformant.information.visualization", "name": "plot_entropy_landscape", "signature": "(entropy_data: np.ndarray, x_labels: list[str] | None = None, y_labels: list[str] | None = None, output_path: Path | str | None = None, title: str = 'Entropy Landscape') -> dict[str, Any]", "symbol_type": "function"}], "plot_event_cooccurrence": [{"docstring": "Plot heatmap of event co-occurrence patterns.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 310, "module": "src.metainformant.life_events.visualization", "name": "plot_event_cooccurrence", "signature": "(sequences: List[EventSequence], output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (12, 10), top_n: int = 20) -> 'Figure'", "symbol_type": "function"}], "plot_event_embeddings": [{"docstring": "Plot 2D/3D visualization of event embeddings.\n\nArgs:\n    embeddings: Dictionary mapping event tokens to embedding vectors\n    method: Dimensionality reduction method (\"pca\", \"umap\", \"tsne\")\n    n_components: Number of components (2 or 3)\n    output_path: Optional path to save figure\n    figsize: Figure size\n    \nReturns:\n    Matplotlib figure", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 85, "module": "src.metainformant.life_events.visualization", "name": "plot_event_embeddings", "signature": "(embeddings: Dict[str, NDArray], method: str = 'umap', n_components: int = 2, output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (10, 8)) -> 'Figure'", "symbol_type": "function"}], "plot_event_frequency_heatmap": [{"docstring": "Plot temporal frequency heatmap of events.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 760, "module": "src.metainformant.life_events.visualization", "name": "plot_event_frequency_heatmap", "signature": "(sequences: List[EventSequence], output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (14, 8), time_bins: int = 10) -> 'Figure'", "symbol_type": "function"}], "plot_event_timeline": [{"docstring": "Plot timeline visualization of individual life course.\n\nArgs:\n    sequence: EventSequence to visualize\n    output_path: Optional path to save figure\n    figsize: Figure size\n    \nReturns:\n    Matplotlib figure", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 26, "module": "src.metainformant.life_events.visualization", "name": "plot_event_timeline", "signature": "(sequence: EventSequence, output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (12, 6)) -> 'Figure'", "symbol_type": "function"}], "plot_fst_comparison": [{"docstring": "Plot comparison of Fst values.\n\nArgs:\n    fst_values: Dictionary mapping comparison names to Fst values\n    output_path: Optional path to save figure\n    title: Plot title\n    figsize: Figure size\n\nReturns:\n    matplotlib Figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 138, "module": "src.metainformant.dna.population_viz", "name": "plot_fst_comparison", "signature": "(fst_values: dict[str, float]) -> plt.Figure", "symbol_type": "function"}], "plot_fst_matrix": [{"docstring": "Plot heatmap of pairwise Fst values.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 898, "module": "src.metainformant.dna.population_viz", "name": "plot_fst_matrix", "signature": "(fst_matrix: Sequence[Sequence[float]] | dict[str, dict[str, float]], population_names: Sequence[str] | None = None) -> plt.Figure", "symbol_type": "function"}], "plot_gene_expression": [{"docstring": "Plot gene expression on dimensionality reduction.\n\nArgs:\n    data: SingleCellData object\n    genes: Gene name(s) to plot\n    basis: Embedding basis\n    ncols: Number of columns\n    size: Point size\n    alpha: Point transparency\n    figsize: Figure size\n    cmap: Colormap name\n\nReturns:\n    Matplotlib figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/visualization.py", "line_number": 265, "module": "src.metainformant.singlecell.visualization", "name": "plot_gene_expression", "signature": "(data: SingleCellData, genes: Union[str, List[str]], basis: str = 'umap', ncols: int = 3, size: float = 1.0, alpha: float = 0.7, figsize: Optional[Tuple[float, float]] = None, cmap: str = 'Reds') -> plt.Figure", "symbol_type": "function"}], "plot_hardy_weinberg_test": [{"docstring": "Plot Hardy-Weinberg test results.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 1226, "module": "src.metainformant.dna.population_viz", "name": "plot_hardy_weinberg_test", "signature": "(hwe_results: dict[str, float] | Sequence[dict[str, float]]) -> plt.Figure", "symbol_type": "function"}], "plot_heterozygosity_distribution": [{"docstring": "Plot distribution of observed heterozygosity across sites.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 690, "module": "src.metainformant.dna.population_viz", "name": "plot_heterozygosity_distribution", "signature": "(heterozygosity_values: Sequence[float]) -> plt.Figure", "symbol_type": "function"}], "plot_information_network": [{"docstring": "Visualize information flow in a network using MI matrix.\n\nArgs:\n    network: NetworkX graph or network object\n    mi_matrix: Optional mutual information matrix\n    node_labels: Optional node labels\n    output_path: Path to save plot\n    title: Plot title\n    \nReturns:\n    Dictionary with plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/visualization.py", "line_number": 253, "module": "src.metainformant.information.visualization", "name": "plot_information_network", "signature": "(network: Any, mi_matrix: np.ndarray | None = None, node_labels: list[str] | None = None, output_path: Path | str | None = None, title: str = 'Information Network') -> dict[str, Any]", "symbol_type": "function"}], "plot_information_profile": [{"docstring": "Plot information profile visualization.\n\nArgs:\n    profile: Information profile dictionary from information_profile()\n    output_path: Path to save plot\n    title: Plot title\n    \nReturns:\n    Dictionary with plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/visualization.py", "line_number": 117, "module": "src.metainformant.information.visualization", "name": "plot_information_profile", "signature": "(profile: dict[str, Any], output_path: Path | str | None = None, title: str = 'Information Profile') -> dict[str, Any]", "symbol_type": "function"}], "plot_intervention_effects": [{"docstring": "Plot before/after intervention visualization.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 644, "module": "src.metainformant.life_events.visualization", "name": "plot_intervention_effects", "signature": "(pre_sequences: List[EventSequence], post_sequences: List[EventSequence], pre_outcomes: Optional[NDArray] = None, post_outcomes: Optional[NDArray] = None, output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (14, 6)) -> 'Figure'", "symbol_type": "function"}], "plot_isolation_by_distance": [{"docstring": "Plot Fst vs geographic distance with Mantel test visualization.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 1008, "module": "src.metainformant.dna.population_viz", "name": "plot_isolation_by_distance", "signature": "(fst_values: Sequence[float], geographic_distances: Sequence[float]) -> plt.Figure", "symbol_type": "function"}], "plot_kinship_heatmap": [{"docstring": "Create a heatmap visualization of the kinship matrix.\n\nArgs:\n    kinship_matrix: NxN kinship/relatedness matrix\n    output_path: Path to save the plot\n    sample_ids: Optional sample IDs for axis labels\n    title: Plot title\n\nReturns:\n    Dictionary with status and statistics", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/enhanced_visualizations.py", "line_number": 17, "module": "scripts.gwas.enhanced_visualizations", "name": "plot_kinship_heatmap", "signature": "(kinship_matrix: np.ndarray, output_path: Path, sample_ids: list[str] | None = None, title: str = 'Kinship Matrix') -> dict[str, Any]", "symbol_type": "function"}], "plot_kinship_matrix": [{"docstring": "Plot kinship matrix as heatmap.\n\nArgs:\n    kinship_result: Dictionary with kinship results (from compute_kinship_matrix)\n    output_path: Optional path to save figure\n    max_samples: Maximum number of samples to plot (for large matrices)\n    title: Plot title\n    figsize: Figure size\n\nReturns:\n    matplotlib Figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 266, "module": "src.metainformant.dna.population_viz", "name": "plot_kinship_matrix", "signature": "(kinship_result: dict[str, Any]) -> plt.Figure", "symbol_type": "function"}], "plot_linkage_disequilibrium_decay": [{"docstring": "Plot linkage disequilibrium decay with distance.\n\nArgs:\n    ld_values: r\u00b2 values at different distances\n    distances: Optional distances (if None, uses indices)\n    output_path: Optional path to save figure\n    title: Plot title\n    figsize: Figure size\n\nReturns:\n    matplotlib Figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 583, "module": "src.metainformant.dna.population_viz", "name": "plot_linkage_disequilibrium_decay", "signature": "(ld_values: Sequence[float], distances: Sequence[float] | None = None) -> plt.Figure", "symbol_type": "function"}], "plot_marker_genes_heatmap": [{"docstring": "Plot heatmap of marker genes.\n\nArgs:\n    data: SingleCellData object\n    markers_df: DataFrame from find_marker_genes()\n    groupby: Clustering column\n    n_genes: Number of top genes per cluster\n    figsize: Figure size\n    cmap: Colormap\n\nReturns:\n    Matplotlib figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/visualization.py", "line_number": 433, "module": "src.metainformant.singlecell.visualization", "name": "plot_marker_genes_heatmap", "signature": "(data: SingleCellData, markers_df: pd.DataFrame, groupby: str, n_genes: int = 5, figsize: Optional[Tuple[float, float]] = None, cmap: str = 'RdBu_r') -> plt.Figure", "symbol_type": "function"}], "plot_mi_network": [{"docstring": "Plot network visualization colored by mutual information.\n\nArgs:\n    mi_matrix: Mutual information matrix\n    labels: Optional node labels\n    threshold: Minimum MI threshold for edges\n    output_path: Path to save plot\n    title: Plot title\n    \nReturns:\n    Dictionary with plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/visualization.py", "line_number": 401, "module": "src.metainformant.information.visualization", "name": "plot_mi_network", "signature": "(mi_matrix: np.ndarray, labels: list[str] | None = None, threshold: float = 0.1, output_path: Path | str | None = None, title: str = 'Mutual Information Network') -> dict[str, Any]", "symbol_type": "function"}], "plot_mutual_information_matrix": [{"docstring": "Plot mutual information matrix as heatmap.\n\nArgs:\n    mi_matrix: Square matrix of mutual information values\n    labels: Optional labels for rows/columns\n    output_path: Path to save plot\n    title: Plot title\n    \nReturns:\n    Dictionary with plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/visualization.py", "line_number": 65, "module": "src.metainformant.information.visualization", "name": "plot_mutual_information_matrix", "signature": "(mi_matrix: np.ndarray, labels: list[str] | None = None, output_path: Path | str | None = None, title: str = 'Mutual Information Matrix') -> dict[str, Any]", "symbol_type": "function"}], "plot_neutrality_test_suite": [{"docstring": "Plot comprehensive panel of all neutrality tests.\n\nArgs:\n    test_results: Dictionary mapping scenario names to neutrality test results.\n        Each result dict should contain test statistics like 'tajimas_d',\n        'fu_and_li_d_star', 'fay_wu_h', etc.\n    output_path: Optional path to save figure\n    title: Plot title\n    figsize: Figure size\n\nReturns:\n    matplotlib Figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 1064, "module": "src.metainformant.dna.population_viz", "name": "plot_neutrality_test_suite", "signature": "(test_results: dict[str, dict[str, float]]) -> plt.Figure", "symbol_type": "function"}], "plot_neutrality_test_summary": [{"docstring": "Plot summary of neutrality tests across scenarios.\n\nArgs:\n    neutrality_results: Dictionary mapping scenario names to neutrality test results\n    output_path: Optional path to save figure\n    title: Plot title\n    figsize: Figure size\n\nReturns:\n    matplotlib Figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 363, "module": "src.metainformant.dna.population_viz", "name": "plot_neutrality_test_summary", "signature": "(neutrality_results: dict[str, dict[str, Any]]) -> plt.Figure", "symbol_type": "function"}], "plot_outcome_distribution": [{"docstring": "Plot distribution of outcomes.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 356, "module": "src.metainformant.life_events.visualization", "name": "plot_outcome_distribution", "signature": "(outcomes: NDArray, output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (10, 6), plot_type: str = 'histogram') -> 'Figure'", "symbol_type": "function"}], "plot_outlier_detection": [{"docstring": "Plot Manhattan plot of statistics with outliers highlighted.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 1316, "module": "src.metainformant.dna.population_viz", "name": "plot_outlier_detection", "signature": "(statistic_values: Sequence[float], outlier_indices: Sequence[int] | None = None) -> plt.Figure", "symbol_type": "function"}], "plot_pairwise_distance_distribution": [{"docstring": "Plot distribution of pairwise nucleotide differences.\n\nArgs:\n    pairwise_distances: Pairwise distance values\n    output_path: Optional path to save figure\n    title: Plot title\n    figsize: Figure size\n    bins: Number of histogram bins\n\nReturns:\n    matplotlib Figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 658, "module": "src.metainformant.dna.population_viz", "name": "plot_pairwise_distance_distribution", "signature": "(pairwise_distances: Sequence[float]) -> plt.Figure", "symbol_type": "function"}], "plot_pca_loadings": [{"docstring": "Plot top variant loadings for a specific PC.\n\nArgs:\n    loadings: Variant loadings matrix (variants x PCs)\n    output_path: Path to save the plot\n    pc_index: Which PC to plot (0-based)\n    top_n: Number of top loadings to show\n    title: Optional plot title\n\nReturns:\n    Dictionary with status", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/enhanced_visualizations.py", "line_number": 294, "module": "scripts.gwas.enhanced_visualizations", "name": "plot_pca_loadings", "signature": "(loadings: np.ndarray, output_path: Path, pc_index: int = 0, top_n: int = 20, title: str | None = None) -> dict[str, Any]", "symbol_type": "function"}], "plot_pca_results": [{"docstring": "Plot PCA results.\n\nArgs:\n    pca_result: Dictionary with PCA results (from compute_pca)\n    output_path: Optional path to save figure\n    n_components: Number of components to plot\n    title: Plot title\n    figsize: Figure size\n\nReturns:\n    matplotlib Figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 197, "module": "src.metainformant.dna.population_viz", "name": "plot_pca_results", "signature": "(pca_result: dict[str, Any]) -> plt.Figure", "symbol_type": "function"}], "plot_pca_scatter": [{"docstring": "Create PCA scatter plot.\n\nArgs:\n    pca_components: PC matrix (samples x components)\n    variance_explained: Variance explained by each PC\n    output_path: Path to save the plot\n    pc_x: PC index for X-axis (0-based)\n    pc_y: PC index for Y-axis (0-based)\n    phenotypes: Optional phenotype data for coloring\n    color_by: Phenotype name to color points by\n    title: Optional plot title\n\nReturns:\n    Dictionary with status", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/enhanced_visualizations.py", "line_number": 117, "module": "scripts.gwas.enhanced_visualizations", "name": "plot_pca_scatter", "signature": "(pca_components: np.ndarray, variance_explained: np.ndarray, output_path: Path, pc_x: int = 0, pc_y: int = 1, phenotypes: dict[str, list] | None = None, color_by: str | None = None, title: str | None = None) -> dict[str, Any]", "symbol_type": "function"}], "plot_pca_scree": [{"docstring": "Create scree plot showing variance explained by each PC.\n\nArgs:\n    variance_explained: Variance explained by each PC (as proportions)\n    output_path: Path to save the plot\n    title: Plot title\n\nReturns:\n    Dictionary with status", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/enhanced_visualizations.py", "line_number": 221, "module": "scripts.gwas.enhanced_visualizations", "name": "plot_pca_scree", "signature": "(variance_explained: np.ndarray, output_path: Path, title: str = 'PCA Scree Plot') -> dict[str, Any]", "symbol_type": "function"}], "plot_pca_variance": [{"docstring": "Plot PCA variance explained.\n\nArgs:\n    data: SingleCellData object with PCA results\n    n_components: Number of components to show\n    figsize: Figure size\n\nReturns:\n    Matplotlib figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/visualization.py", "line_number": 500, "module": "src.metainformant.singlecell.visualization", "name": "plot_pca_variance", "signature": "(data: SingleCellData, n_components: int = 50, figsize: Tuple[float, float] = (10, 4)) -> plt.Figure", "symbol_type": "function"}], "plot_permutation_test": [{"docstring": "Plot permuted vs observed distribution.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 1289, "module": "src.metainformant.dna.population_viz", "name": "plot_permutation_test", "signature": "(permuted_values: Sequence[float], observed_value: float) -> plt.Figure", "symbol_type": "function"}], "plot_phylo_tree": [{"docstring": "Plot a Biopython Phylo tree to matplotlib Axes.\n\nAccepts any object compatible with Bio.Phylo.draw().\n\nArgs:\n    tree: Biopython Phylo tree object\n    ax: Matplotlib axes (creates new if None)\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import plot_phylo_tree\n    >>> from Bio import Phylo\n    >>> tree = Phylo.read(\"tree.nwk\", \"newick\")\n    >>> ax = plot_phylo_tree(tree)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/trees.py", "line_number": 25, "module": "src.metainformant.visualization.trees", "name": "plot_phylo_tree", "signature": "(tree: Any) -> plt.Axes", "symbol_type": "function"}], "plot_pi_vs_theta": [{"docstring": "Plot scatter of \u03c0 vs \u03b8_W with expected 1:1 line.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 748, "module": "src.metainformant.dna.population_viz", "name": "plot_pi_vs_theta", "signature": "(pi_values: Sequence[float], theta_values: Sequence[float]) -> plt.Figure", "symbol_type": "function"}], "plot_population_comparison": [{"docstring": "Plot side-by-side comparison of two population groups.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 595, "module": "src.metainformant.life_events.visualization", "name": "plot_population_comparison", "signature": "(sequences_group1: List[EventSequence], sequences_group2: List[EventSequence], group1_label: str = 'Group 1', group2_label: str = 'Group 2', output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (14, 6)) -> 'Figure'", "symbol_type": "function"}], "plot_population_structure_tree": [{"docstring": "Plot neighbor-joining tree based on Fst or genetic distances.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 967, "module": "src.metainformant.dna.population_viz", "name": "plot_population_structure_tree", "signature": "(fst_matrix: Sequence[Sequence[float]] | dict[str, dict[str, float]], population_names: Sequence[str] | None = None) -> plt.Figure", "symbol_type": "function"}], "plot_prediction_accuracy": [{"docstring": "Plot prediction accuracy metrics.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 506, "module": "src.metainformant.life_events.visualization", "name": "plot_prediction_accuracy", "signature": "(y_true: NDArray, y_pred: NDArray, task_type: str = 'classification', output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (12, 5)) -> 'Figure'", "symbol_type": "function"}], "plot_prediction_importance": [{"docstring": "Plot event importance for predictions.\n\nArgs:\n    event_importance: Dictionary mapping event tokens to importance scores\n    top_n: Number of top events to display\n    output_path: Optional path to save figure\n    figsize: Figure size\n    \nReturns:\n    Matplotlib figure", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 204, "module": "src.metainformant.life_events.visualization", "name": "plot_prediction_importance", "signature": "(event_importance: Dict[str, float], top_n: int = 20, output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (10, 8)) -> 'Figure'", "symbol_type": "function"}], "plot_progress_dashboard": [{"docstring": "Generate multi-panel bar chart visualization of amalgkit progress.\n\nCreates a dashboard showing sample counts in each category (need_download,\nongoing_download, failed_download, needs_quant, needs_delete, completed)\nfor each species, plus an overall summary panel.\n\nArgs:\n    progress_state: Either a dictionary of progress state data, or path to\n        progress_state.json file\n    output_path: Path to save PNG file (if None, returns figure without saving)\n    figsize: Figure size tuple (auto-calculated if None)\n    dpi: Resolution for saved figure\n    \nReturns:\n    Path to saved file (if output_path provided), or None\n    \nExample:\n    >>> from metainformant.visualization.amalgkit_visualization import plot_progress_dashboard\n    >>> path = plot_progress_dashboard(\"output/amalgkit/progress_state.json\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/amalgkit_visualization.py", "line_number": 86, "module": "src.metainformant.visualization.amalgkit_visualization", "name": "plot_progress_dashboard", "signature": "(progress_state: dict[str, Any] | Path | str) -> Path", "symbol_type": "function"}], "plot_qc_metrics": [{"docstring": "Plot quality control metrics.\n\nArgs:\n    data: SingleCellData object with QC metrics\n    metrics: List of metrics to plot (default: standard QC metrics)\n    ncols: Number of columns in subplot grid\n    figsize: Figure size tuple\n\nReturns:\n    Matplotlib figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/visualization.py", "line_number": 29, "module": "src.metainformant.singlecell.visualization", "name": "plot_qc_metrics", "signature": "(data: SingleCellData, metrics: Optional[List[str]] = None, ncols: int = 3, figsize: Optional[Tuple[float, float]] = None) -> plt.Figure", "symbol_type": "function"}], "plot_qc_scatter": [{"docstring": "Create scatter plot of QC metrics.\n\nArgs:\n    data: SingleCellData object\n    x: X-axis metric\n    y: Y-axis metric\n    color: Color-coding metric (optional)\n    figsize: Figure size\n\nReturns:\n    Matplotlib figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/visualization.py", "line_number": 98, "module": "src.metainformant.singlecell.visualization", "name": "plot_qc_scatter", "signature": "(data: SingleCellData, x: str = 'total_counts', y: str = 'n_genes', color: Optional[str] = 'pct_mt', figsize: Tuple[float, float] = (8, 6)) -> plt.Figure", "symbol_type": "function"}], "plot_regression_analysis": [{"docstring": "Plot regression analysis with confidence bands.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 820, "module": "src.metainformant.dna.population_viz", "name": "plot_regression_analysis", "signature": "(x_values: Sequence[float], y_values: Sequence[float]) -> plt.Figure", "symbol_type": "function"}], "plot_renyi_spectrum": [{"docstring": "Plot R\u00e9nyi entropy as a function of order \u03b1.\n\nArgs:\n    probs: Probability distribution\n    alpha_range: Range of \u03b1 values to plot (default: [0.1, 0.5, 1.0, 1.5, 2.0, 3.0, 5.0, 10.0])\n    output_path: Path to save plot\n    title: Plot title\n    \nReturns:\n    Dictionary with plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/visualization.py", "line_number": 191, "module": "src.metainformant.information.visualization", "name": "plot_renyi_spectrum", "signature": "(probs: list[float], alpha_range: list[float] | None = None, output_path: Path | str | None = None, title: str = 'R\u00e9nyi Entropy Spectrum') -> dict[str, Any]", "symbol_type": "function"}], "plot_semantic_similarity_network": [{"docstring": "Plot hierarchical network visualization of semantic similarity.\n\nArgs:\n    similarity_matrix: Semantic similarity matrix\n    terms: List of terms\n    output_path: Path to save plot\n    title: Plot title\n    \nReturns:\n    Dictionary with plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/visualization.py", "line_number": 488, "module": "src.metainformant.information.visualization", "name": "plot_semantic_similarity_network", "signature": "(similarity_matrix: np.ndarray, terms: list[str], output_path: Path | str | None = None, title: str = 'Semantic Similarity Network') -> dict[str, Any]", "symbol_type": "function"}], "plot_sequence_length_distribution": [{"docstring": "Plot histogram of sequence lengths.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 739, "module": "src.metainformant.life_events.visualization", "name": "plot_sequence_length_distribution", "signature": "(sequences: List[EventSequence], output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (10, 6)) -> 'Figure'", "symbol_type": "function"}], "plot_sequence_similarity": [{"docstring": "Plot heatmap of sequence similarity matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 382, "module": "src.metainformant.life_events.visualization", "name": "plot_sequence_similarity", "signature": "(sequences: List[EventSequence], embeddings: Optional[Dict[str, NDArray]] = None, output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (12, 10)) -> 'Figure'", "symbol_type": "function"}], "plot_site_frequency_spectrum": [{"docstring": "Plot site frequency spectrum.\n\nArgs:\n    sfs: Site frequency spectrum (list of counts per frequency bin)\n    output_path: Optional path to save figure\n    title: Plot title\n    figsize: Figure size\n\nReturns:\n    matplotlib Figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 312, "module": "src.metainformant.dna.population_viz", "name": "plot_site_frequency_spectrum", "signature": "(sfs: Sequence[int]) -> plt.Figure", "symbol_type": "function"}], "plot_statistic_correlation_matrix": [{"docstring": "Plot correlation heatmap between statistics.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 781, "module": "src.metainformant.dna.population_viz", "name": "plot_statistic_correlation_matrix", "signature": "(statistics: dict[str, Sequence[float]]) -> plt.Figure", "symbol_type": "function"}], "plot_statistic_distribution": [{"docstring": "Plot distribution of statistics across scenarios.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 711, "module": "src.metainformant.dna.population_viz", "name": "plot_statistic_distribution", "signature": "(statistic_values: dict[str, Sequence[float]]) -> plt.Figure", "symbol_type": "function"}], "plot_statistic_relationships": [{"docstring": "Plot multi-panel relationship plots between statistics.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 860, "module": "src.metainformant.dna.population_viz", "name": "plot_statistic_relationships", "signature": "(statistics: dict[str, Sequence[float]]) -> plt.Figure", "symbol_type": "function"}], "plot_summary_statistics_grid": [{"docstring": "Plot grid of summary statistics across scenarios.\n\nArgs:\n    summary_stats: Dictionary mapping scenario names to summary statistics\n    output_path: Optional path to save figure\n    title: Plot title\n    figsize: Figure size\n\nReturns:\n    matplotlib Figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 489, "module": "src.metainformant.dna.population_viz", "name": "plot_summary_statistics_grid", "signature": "(summary_stats: dict[str, dict[str, Any]]) -> plt.Figure", "symbol_type": "function"}], "plot_tajimas_d_comparison": [{"docstring": "Plot comparison of Tajima's D across scenarios.\n\nArgs:\n    tajimas_d_values: Dictionary mapping scenario names to Tajima's D values\n    output_path: Optional path to save figure\n    title: Plot title\n    figsize: Figure size\n\nReturns:\n    matplotlib Figure object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 77, "module": "src.metainformant.dna.population_viz", "name": "plot_tajimas_d_comparison", "signature": "(tajimas_d_values: dict[str, float]) -> plt.Figure", "symbol_type": "function"}], "plot_temporal_density": [{"docstring": "Plot temporal density of events over time.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 282, "module": "src.metainformant.life_events.visualization", "name": "plot_temporal_density", "signature": "(sequences: List[EventSequence], output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (12, 6), bins: int = 50) -> 'Figure'", "symbol_type": "function"}], "plot_temporal_patterns": [{"docstring": "Plot time-based importance visualization.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 565, "module": "src.metainformant.life_events.visualization", "name": "plot_temporal_patterns", "signature": "(sequences: List[EventSequence], importance_scores: Optional[Dict[int, float]] = None, output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (12, 6)) -> 'Figure'", "symbol_type": "function"}], "plot_three_population_f3": [{"docstring": "Plot F3-statistic for admixture testing.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population_viz.py", "line_number": 1039, "module": "src.metainformant.dna.population_viz", "name": "plot_three_population_f3", "signature": "(f3_values: dict[str, float]) -> plt.Figure", "symbol_type": "function"}], "plot_transition_network": [{"docstring": "Plot network graph of event transitions.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/visualization.py", "line_number": 419, "module": "src.metainformant.life_events.visualization", "name": "plot_transition_network", "signature": "(sequences: List[EventSequence], output_path: Optional[str | Path] = None, figsize: tuple[int, int] = (14, 10), top_n: int = 15) -> 'Figure'", "symbol_type": "function"}], "point": [{"docstring": "Create point object, coordinates of a point.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 601, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "point", "signature": "(self, elem)", "symbol_type": "function"}], "polygon": [{"docstring": "Create polygon object, list of points.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 611, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "polygon", "signature": "(self, elem)", "symbol_type": "function"}], "pool": [{"docstring": "Create thread pool on first request\navoids instantiating unused threadpool for blocking clients.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 96, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "pool", "signature": "(self)", "symbol_type": "function"}], "pop": [{"docstring": "Remove a subsequence of a single letter at given index.\n\n>>> my_seq = MutableSeq('ACTCGACGTCG')\n>>> my_seq.pop()\n'G'\n>>> my_seq\nMutableSeq('ACTCGACGTC')\n>>> my_seq.pop()\n'C'\n>>> my_seq\nMutableSeq('ACTCGACGT')\n\nReturns the last character of the sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2283, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "pop", "signature": "(self, i = -1)", "symbol_type": "function"}, {"docstring": "Remove and returns the HSP object at the specified index.\n\n:param index: index of HSP object to pop\n:type index: int", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/hit.py", "line_number": 426, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.hit", "name": "pop", "signature": "(self, index = -1)", "symbol_type": "function"}, {"docstring": "Remove the specified hit key and return the Hit object.\n\n:param hit_key: key of the Hit object to return\n:type hit_key: int or string\n:param default: return value if no Hit exists with the given key\n:type default: object\n\nBy default, ``pop`` will remove and return the last Hit object in the\nQueryResult object. To remove specific Hit objects, you can use its\ninteger index or hit key.\n\n    >>> from Bio import SearchIO\n    >>> qresult = next(SearchIO.parse('Blast/mirna.xml', 'blast-xml'))\n    >>> len(qresult)\n    100\n    >>> for hit in qresult[:5]:\n    ...     print(hit.id)\n    ...\n    gi|262205317|ref|NR_030195.1|\n    gi|301171311|ref|NR_035856.1|\n    gi|270133242|ref|NR_032573.1|\n    gi|301171322|ref|NR_035857.1|\n    gi|301171267|ref|NR_035851.1|\n\n    # remove the last hit\n    >>> qresult.pop()\n    Hit(id='gi|397513516|ref|XM_003827011.1|', query_id='33211', 1 hsps)\n\n    # remove the first hit\n    >>> qresult.pop(0)\n    Hit(id='gi|262205317|ref|NR_030195.1|', query_id='33211', 1 hsps)\n\n    # remove hit with the given ID\n    >>> qresult.pop('gi|301171322|ref|NR_035857.1|')\n    Hit(id='gi|301171322|ref|NR_035857.1|', query_id='33211', 2 hsps)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 602, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "pop", "signature": "(self, hit_key = -1, default = __marker)", "symbol_type": "function"}], "population_tree": [{"docstring": "Phylogenetic tree from kinship matrix.\n\nHierarchical clustering of samples based on genetic similarity.\n\nArgs:\n    kinship_file: Path to kinship matrix\n    output_path: Output path\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_population.py", "line_number": 347, "module": "src.metainformant.gwas.visualization_population", "name": "population_tree", "signature": "(kinship_file: Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "positions": [{"docstring": "Get current positions of all agents.\n\nReturns:\n    List of (x, y) tuples for each agent", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/agents.py", "line_number": 79, "module": "src.metainformant.simulation.agents", "name": "positions", "signature": "(self) -> List[Tuple[int, int]]", "symbol_type": "function"}], "power_plot": [{"docstring": "Statistical power curves for GWAS.\n\nShows expected power to detect associations at different sample sizes\nand effect sizes. Useful for study design and interpretation.\n\nArgs:\n    sample_sizes: List of sample sizes to evaluate\n    output_path: Output path\n    effect_sizes: Effect sizes (OR or \u03b2) to plot\n    alpha: Significance threshold\n    maf: Minor allele frequency\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_statistical.py", "line_number": 529, "module": "src.metainformant.gwas.visualization_statistical", "name": "power_plot", "signature": "(sample_sizes: list[int], output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "precision_recall_curve": [{"docstring": "Create a precision-recall curve plot.\n\nArgs:\n    y_true: True binary labels\n    y_scores: Predicted scores/probabilities\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments for plot\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import precision_recall_curve\n    >>> import numpy as np\n    >>> y_true = [0, 1, 0, 1, 1]\n    >>> y_scores = [0.1, 0.9, 0.2, 0.8, 0.7]\n    >>> ax = precision_recall_curve(y_true, y_scores)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/statistical.py", "line_number": 444, "module": "src.metainformant.visualization.statistical", "name": "precision_recall_curve", "signature": "(y_true: Sequence[int], y_scores: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "predict": [{"docstring": "Predict outcomes for event sequences.\n\nArgs:\n    sequences: List of event sequences\n    \nReturns:\n    Array of predictions", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 237, "module": "src.metainformant.life_events.models", "name": "predict", "signature": "(self, sequences: Sequence[Sequence[str]]) -> NDArray", "symbol_type": "function"}, {"docstring": "Predict using LSTM model.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 726, "module": "src.metainformant.life_events.models", "name": "predict", "signature": "(self, sequences: Sequence[Sequence[str]]) -> NDArray", "symbol_type": "function"}, {"docstring": "Predict using GRU model.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 894, "module": "src.metainformant.life_events.models", "name": "predict", "signature": "(self, sequences: Sequence[Sequence[str]]) -> NDArray", "symbol_type": "function"}, {"docstring": "Predict using ensemble of models.\n\nArgs:\n    sequences: List of event sequences\n    \nReturns:\n    Array of ensemble predictions", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 952, "module": "src.metainformant.life_events.models", "name": "predict", "signature": "(self, sequences: Sequence[Sequence[str]]) -> NDArray", "symbol_type": "function"}, {"docstring": "Predict time until event.\n\nArgs:\n    sequences: List of event sequences\n    \nReturns:\n    Array of predicted event times", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 1054, "module": "src.metainformant.life_events.models", "name": "predict", "signature": "(self, sequences: Sequence[Sequence[str]]) -> NDArray", "symbol_type": "function"}, {"docstring": "Predict outcomes for all tasks or specific task.\n\nArgs:\n    sequences: List of event sequences\n    task_name: Optional specific task name (if None, returns all tasks)\n    \nReturns:\n    Dictionary of predictions (if task_name is None) or array for specific task", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 1171, "module": "src.metainformant.life_events.models", "name": "predict", "signature": "(self, sequences: Sequence[Sequence[str]], task_name: Optional[str] = None) -> Union[Dict[str, NDArray], NDArray]", "symbol_type": "function"}, {"docstring": "Predict class labels for samples.\n\nArgs:\n    X: Test feature matrix\n\nReturns:\n    Predicted class labels", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/classification.py", "line_number": 96, "module": "src.metainformant.ml.classification", "name": "predict", "signature": "(self, X: np.ndarray) -> np.ndarray", "symbol_type": "function"}, {"docstring": "Predict continuous values for samples.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/regression.py", "line_number": 53, "module": "src.metainformant.ml.regression", "name": "predict", "signature": "(self, X: np.ndarray) -> np.ndarray", "symbol_type": "function"}], "predictNOE": [{"docstring": "Predict the i->j NOE position based on self peak (diagonal) assignments.\n\nParameters\n----------\npeaklist : xprtools.Peaklist\n    List of peaks from which to derive predictions\noriginNuc : str\n    Name of originating nucleus.\noriginResNum : int\n    Index of originating residue.\ndetectedNuc : str\n    Name of detected nucleus.\n\ntoResNum : int\n    Index of detected residue.\n\nReturns\n-------\nreturnLine : str\n    The .xpk file entry for the predicted crosspeak.\n\nExamples\n--------\nUsing predictNOE(peaklist,\"N15\",\"H1\",10,12)\nwhere peaklist is of the type xpktools.peaklist\nwould generate a .xpk file entry for a crosspeak\nthat originated on N15 of residue 10 and ended up\nas magnetization detected on the H1 nucleus of\nresidue 12\n\n\nNotes\n=====\nThe initial peaklist is assumed to be diagonal (self peaks only)\nand currently there is no checking done to insure that this\nassumption holds true.  Check your peaklist for errors and\noff diagonal peaks before attempting to use predictNOE.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/NMR/NOEtools.py", "line_number": 16, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.NMR.NOEtools", "name": "predictNOE", "signature": "(peaklist, originNuc, detectedNuc, originResNum, toResNum)", "symbol_type": "function"}], "predict_interactions": [{"docstring": "Predict protein-protein interactions from feature data.\n\nUses correlation or coexpression patterns to predict likely protein\ninteractions based on shared feature profiles (e.g., expression levels,\nsequence features, localization signals).\n\nArgs:\n    protein_features: Feature matrix of shape (n_proteins, n_features).\n        Each row represents one protein's feature vector.\n    protein_ids: List of protein identifiers corresponding to rows\n        in protein_features. Must have length equal to protein_features.shape[0]\n    method: Prediction method:\n        - \"correlation\": Pearson correlation between feature vectors\n        - \"coexpression\": Cosine similarity between feature vectors\n    threshold: Minimum correlation/similarity for predicted interaction.\n        Interactions with |correlation| >= threshold are included.\n        \nReturns:\n    ProteinNetwork object with predicted interactions. Confidence scores\n    are set to the absolute correlation/similarity values.\n    \nRaises:\n    ValueError: If number of protein_ids doesn't match feature matrix rows\n    \nExamples:\n    >>> features = np.random.randn(100, 50)  # 100 proteins, 50 features\n    >>> protein_ids = [f\"P{i:05d}\" for i in range(100)]\n    >>> ppi = predict_interactions(\n    ...     features, protein_ids,\n    ...     method=\"correlation\",\n    ...     threshold=0.8\n    ... )\n    >>> ppi.network_statistics()[\"total_interactions\"]\n    245\n    \nNote:\n    These predictions are based on feature similarity and should be\n    validated with experimental evidence for biological interpretation.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 487, "module": "src.metainformant.networks.ppi", "name": "predict_interactions", "signature": "(protein_features: np.ndarray = None, protein_ids: List[str] = None, method: str = 'correlation', threshold: float = 0.7, target_proteins: List[str] = None, known_network: ProteinNetwork = None, confidence_threshold: float = None) -> ProteinNetwork", "symbol_type": "function"}], "predict_proba": [{"docstring": "Predict class probabilities for event sequences.\n\nArgs:\n    sequences: List of event sequences\n    \nReturns:\n    Array of class probabilities (only for classification tasks)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 297, "module": "src.metainformant.life_events.models", "name": "predict_proba", "signature": "(self, sequences: Sequence[Sequence[str]]) -> NDArray", "symbol_type": "function"}, {"docstring": "Predict class probabilities for samples.\n\nArgs:\n    X: Test feature matrix\n\nReturns:\n    Class probability matrix (samples x classes)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/classification.py", "line_number": 120, "module": "src.metainformant.ml.classification", "name": "predict_proba", "signature": "(self, X: np.ndarray) -> np.ndarray", "symbol_type": "function"}], "predict_protein_abundance_from_rna": [{"docstring": "Predict protein abundance from RNA expression levels.\n\nUses a trained model (if provided) or simple linear relationship to predict\nprotein levels from mRNA expression.\n\nArgs:\n    rna_expression: RNA expression data to predict from (samples x genes)\n    training_rna: Optional training RNA data for model fitting\n    training_protein: Optional training protein data for model fitting\n    method: Prediction method ('linear', 'log_linear', 'power_law')\n    \nReturns:\n    DataFrame with predicted protein abundance (samples x proteins)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/protein_integration.py", "line_number": 105, "module": "src.metainformant.rna.protein_integration", "name": "predict_protein_abundance_from_rna", "signature": "(rna_expression: pd.DataFrame, training_rna: pd.DataFrame | None = None, training_protein: pd.DataFrame | None = None, method: str = 'linear') -> pd.DataFrame", "symbol_type": "function"}], "predict_protein_family": [{"docstring": "Predict protein family from sequence.\n\nUses sequence similarity or pattern matching to identify protein families.\n\nArgs:\n    sequence: Protein sequence\n    family_database: Optional dictionary mapping family names to representative sequences\n    \nReturns:\n    List of (family_name, similarity_score) tuples, sorted by score", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/structure_analysis.py", "line_number": 154, "module": "src.metainformant.protein.structure_analysis", "name": "predict_protein_family", "signature": "(sequence: str, family_database: Dict[str, List[str]] | None = None) -> List[Tuple[str, float]]", "symbol_type": "function"}], "predict_secondary_structure": [{"docstring": "Predict secondary structure from protein sequence.\n\nArgs:\n    sequence: Protein sequence\n    method: Prediction method ('simple', 'chou_fasman')\n    \nReturns:\n    Dictionary with:\n    - 'sequence': Input sequence\n    - 'helix': List of helix probabilities per residue\n    - 'sheet': List of sheet probabilities per residue\n    - 'coil': List of coil probabilities per residue\n    - 'predicted_structure': String of predicted structure (H/E/C)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/structure_analysis.py", "line_number": 15, "module": "src.metainformant.protein.structure_analysis", "name": "predict_secondary_structure", "signature": "(sequence: str, method: str = 'simple') -> Dict[str, Any]", "symbol_type": "function"}], "predict_survival_function": [{"docstring": "Predict survival probabilities at specified times.\n\nArgs:\n    sequences: List of event sequences\n    times: Time points at which to evaluate survival function\n    \nReturns:\n    Array of survival probabilities (shape: n_sequences x n_times)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 1071, "module": "src.metainformant.life_events.models", "name": "predict_survival_function", "signature": "(self, sequences: Sequence[Sequence[str]], times: NDArray) -> NDArray", "symbol_type": "function"}], "predict_variant_effect_on_expression": [{"docstring": "Predict effect of variant on transcript expression.\n\nSimplified prediction based on variant location (promoter, coding, UTR, etc.).\nMore sophisticated predictions would require additional tools.\n\nArgs:\n    variant: Dictionary with variant information ('chrom', 'pos', 'ref', 'alt')\n    transcript_sequence: Transcript sequence (for coding variants)\n    variant_position_in_transcript: Position of variant within transcript (if known)\n    \nReturns:\n    Dictionary with predicted effects:\n    - 'effect_type': Type of predicted effect (promoter, coding, UTR, intergenic)\n    - 'severity': Predicted severity (high, medium, low, none)\n    - 'notes': Additional notes about prediction", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/rna_integration.py", "line_number": 83, "module": "src.metainformant.dna.rna_integration", "name": "predict_variant_effect_on_expression", "signature": "(variant: Dict[str, Any], transcript_sequence: str, variant_position_in_transcript: int | None = None) -> Dict[str, Any]", "symbol_type": "function"}], "prefix": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/reader.py", "line_number": 94, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.reader", "name": "prefix", "signature": "(self, length = 1)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/reader.py", "line_number": 94, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.reader", "name": "prefix", "signature": "(self, length = 1)", "symbol_type": "function"}], "prepare_anchor": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 616, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "prepare_anchor", "signature": "(self, anchor)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 616, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "prepare_anchor", "signature": "(self, anchor)", "symbol_type": "function"}], "prepare_file_path": [{"docstring": "Ensure parent directories exist for a file path.\n\nArgs:\n    file_path: File path to prepare", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 31, "module": "src.metainformant.core.paths", "name": "prepare_file_path", "signature": "(file_path: Path) -> None", "symbol_type": "function"}], "prepare_genome_for_quantification": [{"docstring": "Complete genome preparation for quantification.\n\nThis function orchestrates the full process:\n1. Extract transcriptome FASTA from genome package\n2. Prepare FASTA in expected location\n3. Build kallisto index (if requested)\n\nArgs:\n    genome_dir: Directory containing extracted genome package\n    species_name: Species name (with underscores)\n    work_dir: Work directory for amalgkit workflow\n    accession: Optional NCBI assembly accession\n    build_index: If True, build kallisto index after preparing FASTA\n    kmer_size: k-mer size for kallisto index\n    \nReturns:\n    Dictionary with preparation results:\n    - success: bool\n    - fasta_path: Path | None\n    - index_path: Path | None\n    - error: str | None", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/genome_prep.py", "line_number": 641, "module": "src.metainformant.rna.genome_prep", "name": "prepare_genome_for_quantification", "signature": "(genome_dir: Path, species_name: str, work_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "prepare_tag": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 580, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "prepare_tag", "signature": "(self, tag)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 580, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "prepare_tag", "signature": "(self, tag)", "symbol_type": "function"}], "prepare_tag_handle": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 545, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "prepare_tag_handle", "signature": "(self, handle)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 545, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "prepare_tag_handle", "signature": "(self, handle)", "symbol_type": "function"}], "prepare_tag_prefix": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 557, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "prepare_tag_prefix", "signature": "(self, prefix)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 557, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "prepare_tag_prefix", "signature": "(self, prefix)", "symbol_type": "function"}], "prepare_transcriptome_for_kallisto": [{"docstring": "Prepare transcriptome FASTA file for kallisto indexing.\n\nFinds the RNA FASTA file in the extracted genome directory and\ncopies it to the expected location for amalgkit/kallisto.\nIf RNA FASTA is not found and use_cds_fallback is True, uses CDS sequences as fallback.\nIf still not found, attempts to download from FTP or extract from GFF.\n\nExpected output: work_dir/fasta/{Species_Name}_rna.fasta\n\nArgs:\n    genome_dir: Directory containing extracted genome package\n    species_name: Species name (with underscores, e.g., \"Camponotus_floridanus\")\n    work_dir: Work directory for amalgkit workflow\n    accession: Optional NCBI assembly accession (for searching)\n    use_cds_fallback: If True, use CDS sequences when RNA FASTA is not available\n    ftp_url: Optional FTP URL for direct file download\n    assembly_name: Optional assembly name (for FTP filename construction)\n    config: Optional config dict (may contain genome.files.transcriptome_fasta, etc.)\n    \nReturns:\n    Path to prepared FASTA file if successful, None otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/genome_prep.py", "line_number": 346, "module": "src.metainformant.rna.genome_prep", "name": "prepare_transcriptome_for_kallisto", "signature": "(genome_dir: Path, species_name: str, work_dir: Path) -> Path | None", "symbol_type": "function"}], "prepare_version": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 539, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "prepare_version", "signature": "(self, version)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 539, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "prepare_version", "signature": "(self, version)", "symbol_type": "function"}], "pretty_str": [{"docstring": "Nice string for residue ID.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 2681, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "pretty_str", "signature": "(self) -> str", "symbol_type": "function"}], "price_equation": [{"docstring": "Compute Price equation decomposition of evolutionary change.\n\nThe Price equation decomposes change in mean trait into selection (covariance)\nand transmission components: \u0394z\u0304 = Cov(w, z) + E(w\u0394z)\n\nArgs:\n    fitness: Sequence of fitness values (w)\n    trait_parent: Sequence of parental trait values (z)\n    trait_offspring: Optional sequence of offspring trait values (z').\n        If None, transmission term is set to 0.\n        \nReturns:\n    Tuple of (covariance_term, transmission_term, total_change):\n    - covariance_term: Selection component Cov(w_rel, z)\n    - transmission_term: Transmission bias E(w_rel * (z' - z))\n    - total_change: Total change in mean trait\n    \nExamples:\n    >>> fitness = [1.0, 1.2, 0.9]\n    >>> parent = [0.2, 0.4, 0.1]\n    >>> offspring = [0.25, 0.35, 0.15]\n    >>> cov, trans, total = price_equation(fitness, parent, offspring)\n    >>> abs(total - (cov + trans)) < 1e-10\n    True\n    \nReferences:\n    Price, G. R. (1970). Selection and covariance. Nature, 227(5257), 520-521.\n    Frank, S. A. (2012). Natural selection. IV. The Price equation.\n    Journal of Evolutionary Biology, 25(5), 1002-1019.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 253, "module": "src.metainformant.math.price", "name": "price_equation", "signature": "(fitness: Sequence[float], trait_parent: Sequence[float], trait_offspring: Sequence[float] | None = None) -> Tuple[float, float, float]", "symbol_type": "function"}], "primary": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1054, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "primary", "signature": "(self, content)", "symbol_type": "function"}], "primary_ref_line": [{"docstring": "Save reference data for the PRIMARY line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1050, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "primary_ref_line", "signature": "(self, content)", "symbol_type": "function"}], "print_as": [{"docstring": "Print the results as specified.\n\nValid format are:\n    'list'      -> alphabetical order\n    'number'    -> number of sites in the sequence\n    'map'       -> a map representation of the sequence with the sites.\n\nIf you want more flexibility over-ride the virtual method make_format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/PrintFormat.py", "line_number": 96, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.PrintFormat", "name": "print_as", "signature": "(self, what = 'list')", "symbol_type": "function"}], "print_assembly_metadata_by_fields": [{"docstring": "Reports selected fields for a V1AssemblyMatch object to stdout\n\nWarning/Error code will be printed if the supplied assembly object does not contain a assembly field.\n\nArgs:\n    assembly_match: A single assembly metadata record returned by the API\n    fields: A list of top-level field names to display.  If set to None, print the entire object.\n\nReturns:\n    None\n\nSide Effects:\n    Prints report to stdout.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/metadata/genome.py", "line_number": 48, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.metadata.genome", "name": "print_assembly_metadata_by_fields", "signature": "(assembly_match: V1AssemblyMatch, fields = List[str])", "symbol_type": "function"}], "print_assembly_warning_or_error": [{"docstring": "Reports assembly warnings and/or errors per query term\n\nArgs:\n    assembly_match: A single assembly metadata record returned by the API\n\nReturns:\n    None\n\nSide Effects:\n    Prints report to stdout.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/metadata/genome.py", "line_number": 12, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.metadata.genome", "name": "print_assembly_warning_or_error", "signature": "(assembly_match: V1AssemblyMatch)", "symbol_type": "function"}], "print_banner": [{"docstring": "Print a formatted banner.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/run_pbarbatus_gwas.py", "line_number": 51, "module": "scripts.gwas.run_pbarbatus_gwas", "name": "print_banner", "signature": "(text: str, char: str = '=', width: int = 80)", "symbol_type": "function"}], "print_gene_metadata_by_fields": [{"docstring": "Reports selected fields for a V1GeneMatch object to stdout\n\nWarning/Error code will be printed if the supplied gene object does not contain a gene field.\n\nArgs:\n    gene: A single gene metadata record returned by the API\n    fields: A list of field names to display.  If set to None, print the entire object.\n\nReturns:\n    None\n\nSide Effects:\n    Prints report to stdout.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/metadata/gene.py", "line_number": 47, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.metadata.gene", "name": "print_gene_metadata_by_fields", "signature": "(gene: V1GeneMatch, fields = List[str])", "symbol_type": "function"}], "print_gene_warning_or_error": [{"docstring": "Reports gene warnings and/or errors per query term\n\nArgs:\n    gene: A single gene metadata record returned by the API\n\nReturns:\n    None\n\nSide Effects:\n    Prints report to stdout.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/metadata/gene.py", "line_number": 7, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.metadata.gene", "name": "print_gene_warning_or_error", "signature": "(gene: V1GeneMatch)", "symbol_type": "function"}], "print_matrix": [{"docstring": "Print out a matrix for debugging purposes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/pairwise2.py", "line_number": 1333, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.pairwise2", "name": "print_matrix", "signature": "(matrix)", "symbol_type": "function"}], "print_options": [{"docstring": "Print out all of the options and their current settings.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_paml.py", "line_number": 43, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._paml", "name": "print_options", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Print out all of the options and their current settings.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/codeml.py", "line_number": 159, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.codeml", "name": "print_options", "signature": "(self)", "symbol_type": "function"}], "print_read_stats": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 484, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "print_read_stats", "signature": "(args, metadata, g, sra_stat = None, individual = False)", "symbol_type": "function"}], "print_section": [{"docstring": "Print formatted section header.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/download_real_honeybee_variants.py", "line_number": 50, "module": "scripts.gwas.download_real_honeybee_variants", "name": "print_section", "signature": "(title: str) -> None", "symbol_type": "function"}], "print_step": [{"docstring": "Print a step header.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/run_pbarbatus_gwas.py", "line_number": 57, "module": "scripts.gwas.run_pbarbatus_gwas", "name": "print_step", "signature": "(step_num: int, total_steps: int, description: str)", "symbol_type": "function"}], "print_that": [{"docstring": "Print the output of the format_output method (OBSOLETE).\n\nArguments:\n - dct is a dictionary as returned by a RestrictionBatch.search()\n - title is the title of the map.\n   It must be a formatted string, i.e. you must include the line break.\n - s1 is the title separating the list of enzymes that have sites from\n   those without sites.\n - s1 must be a formatted string as well.\n\nThis method prints the output of A.format_output() and it is here\nfor backwards compatibility.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/PrintFormat.py", "line_number": 136, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.PrintFormat", "name": "print_that", "signature": "(self, dct, title = '', s1 = '')", "symbol_type": "function"}, {"docstring": "Print the output of the analysis.\n\nIf dct is not given the full dictionary is used.\ns1: Title for non-cutting enzymes\nThis method prints the output of A.format_output() and it is here\nfor backwards compatibility.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2335, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "print_that", "signature": "(self, dct = None, title = '', s1 = '')", "symbol_type": "function"}], "print_tree": [{"docstring": "Recursively serialize sub-elements.\n\nThis closes over textlines and modifies it in-place.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 987, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "print_tree", "signature": "(obj, indent)", "symbol_type": "function"}], "process_anchor": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 459, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "process_anchor", "signature": "(self, indicator)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 459, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "process_anchor", "signature": "(self, indicator)", "symbol_type": "function"}], "process_asa_data": [{"docstring": "Process the .asa output file: atomic level SASA data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/NACCESS.py", "line_number": 116, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.NACCESS", "name": "process_asa_data", "signature": "(rsa_data)", "symbol_type": "function"}], "process_batch": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 567, "module": "tests.test_core_comprehensive", "name": "process_batch", "signature": "(batch)", "symbol_type": "function"}], "process_clade": [{"docstring": "Recursively generate triples describing a tree of clades.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 334, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "process_clade", "signature": "(self, clade, parent = None, root = False)", "symbol_type": "function"}, {"docstring": "Remove node's parent and return it. Final processing of parsed clade.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NewickIO.py", "line_number": 231, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NewickIO", "name": "process_clade", "signature": "(self, clade)", "symbol_type": "function"}], "process_dihedron": [{"docstring": "Create Dihedron on current Chain.internal_coord.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 281, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "process_dihedron", "signature": "(a1: str, a2: str, a3: str, a4: str, dangle: str, ric: IC_Residue) -> set", "symbol_type": "function"}], "process_directives": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 217, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "process_directives", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 217, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "process_directives", "signature": "(self)", "symbol_type": "function"}], "process_empty_scalar": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/parser.py", "line_number": 587, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.parser", "name": "process_empty_scalar", "signature": "(self, mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/parser.py", "line_number": 587, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.parser", "name": "process_empty_scalar", "signature": "(self, mark)", "symbol_type": "function"}], "process_hedron": [{"docstring": "Create Hedron on current (sbcic) Chain.internal_coord.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 188, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "process_hedron", "signature": "(a1: str, a2: str, a3: str, l12: str, ang: str, l23: str, ric: IC_Residue) -> tuple", "symbol_type": "function"}], "process_line": [{"docstring": "Process a line from the handle, decoding byte stream.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/InfernalIO/infernal_tab.py", "line_number": 223, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.InfernalIO.infernal_tab", "name": "process_line", "signature": "(handle, is_byte)", "symbol_type": "function"}], "process_rsa_data": [{"docstring": "Process the .rsa output file: residue level SASA data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/NACCESS.py", "line_number": 90, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.NACCESS", "name": "process_rsa_data", "signature": "(rsa_data)", "symbol_type": "function"}], "process_scalar": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 515, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "process_scalar", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 515, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "process_scalar", "signature": "(self)", "symbol_type": "function"}], "process_tag": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 469, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "process_tag", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 469, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "process_tag", "signature": "(self)", "symbol_type": "function"}], "products": [{"docstring": "Return list of product Entry elements.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 743, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "products", "signature": "(self)", "symbol_type": "function"}], "progress_bar": [{"docstring": "Create a progress bar for iterating over items.\n\nArgs:\n    iterable: Iterable to wrap with progress bar\n    total: Total number of items (if not inferrable from iterable)\n    desc: Description text for progress bar\n    **kwargs: Additional arguments for tqdm\n\nReturns:\n    Progress bar object (tqdm-like interface)\n\nExample:\n    for item in progress_bar(items, desc=\"Processing\"):\n        process(item)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/progress.py", "line_number": 52, "module": "src.metainformant.core.progress", "name": "progress_bar", "signature": "(iterable: Iterator[Any] | None = None, total: int | None = None, desc: str | None = None, **kwargs: Any) -> tqdm", "symbol_type": "function"}], "project": [{"docstring": "Handle the information from the PROJECT line as a list of projects.\n\ne.g.::\n\n    PROJECT     GenomeProject:28471\n\nor::\n\n    PROJECT     GenomeProject:13543  GenomeProject:99999\n\nThis is stored as dbxrefs in the SeqRecord to be consistent with the\nprojected switch of this line to DBLINK in future GenBank versions.\nNote the NCBI plan to replace \"GenomeProject:28471\" with the shorter\n\"Project:28471\" as part of this transition.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 445, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "project", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 986, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "project", "signature": "(self, content)", "symbol_type": "function"}], "propagate_changes": [{"docstring": "Track through di/hedra to invalidate dependent atoms.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 1502, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "propagate_changes", "signature": "(self) -> None", "symbol_type": "function"}], "property": [{"docstring": "Create properties from external resources.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 615, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "property", "signature": "(self, elem)", "symbol_type": "function"}], "protein_scale": [{"docstring": "Compute a profile by any amino acid scale.\n\nAn amino acid scale is defined by a numerical value assigned to each\ntype of amino acid. The most frequently used scales are the\nhydrophobicity or hydrophilicity scales and the secondary structure\nconformational parameters scales, but many other scales exist which\nare based on different chemical and physical properties of the\namino acids.  You can set several parameters that control the\ncomputation of a scale profile, such as the window size and the window\nedge relative weight value.\n\nWindowSize: The window size is the length of the interval to use for\nthe profile computation. For a window size n, we use the i-(n-1)/2\nneighboring residues on each side to compute the score for residue i.\nThe score for residue i is the sum of the scaled values for these\namino acids, optionally weighted according to their position in the\nwindow.\n\nEdge: The central amino acid of the window always has a weight of 1.\nBy default, the amino acids at the remaining window positions have the\nsame weight, but you can make the residue at the center of the window\nhave a larger weight than the others by setting the edge value for the\nresidues at the beginning and end of the interval to a value between\n0 and 1. For instance, for Edge=0.4 and a window size of 5 the weights\nwill be: 0.4, 0.7, 1.0, 0.7, 0.4.\n\nThe method returns a list of values which can be plotted to view the\nchange along a protein sequence.  Many scales exist. Just add your\nfavorites to the ProtParamData modules.\n\nSimilar to expasy's ProtScale:\nhttp://www.expasy.org/cgi-bin/protscale.pl", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/ProtParam.py", "line_number": 236, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.ProtParam", "name": "protein_scale", "signature": "(self, param_dict, window, edge = 1.0)", "symbol_type": "function"}], "protein_similarity": [{"docstring": "Calculate similarity between two proteins based on network structure.\n\nComputes various similarity measures including Jaccard similarity of\ninteraction partners, common neighbors, and network-based distance.\n\nArgs:\n    ppi_network: ProteinNetwork object\n    protein1: First protein identifier\n    protein2: Second protein identifier\n    min_confidence: Minimum interaction confidence to consider\n    \nReturns:\n    Dictionary containing similarity metrics:\n    - jaccard_similarity: Jaccard similarity of interaction partners\n    - common_neighbors: Number of shared interaction partners\n    - total_neighbors: Total unique neighbors\n    - network_distance: Shortest path distance in network (inf if disconnected)\n    \nExamples:\n    >>> ppi = ProteinNetwork()\n    >>> ppi.add_interaction(\"P1\", \"P2\")\n    >>> ppi.add_interaction(\"P1\", \"P3\")\n    >>> ppi.add_interaction(\"P2\", \"P3\")\n    >>> sim = protein_similarity(ppi, \"P1\", \"P2\")\n    >>> sim[\"common_neighbors\"]\n    1  # P3 is common neighbor", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 794, "module": "src.metainformant.networks.ppi", "name": "protein_similarity", "signature": "(ppi_network: ProteinNetwork, protein1: str, protein2: str, min_confidence: float = 0.0) -> Dict[str, float]", "symbol_type": "function"}], "proxy_factory": [{"docstring": "Given a filename returns proxy object, else boolean if format OK.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/__init__.py", "line_number": 566, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.__init__", "name": "proxy_factory", "signature": "(format, filename = None)", "symbol_type": "function"}, {"docstring": "Given a filename returns proxy object, else boolean if format OK.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/__init__.py", "line_number": 1039, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.__init__", "name": "proxy_factory", "signature": "(format, filename = None)", "symbol_type": "function"}], "prune": [{"docstring": "Prune a terminal taxon from the tree.\n\nid_of_previous_node = prune(self,taxon)\nIf taxon is from a bifurcation, the connectiong node will be collapsed\nand its branchlength added to remaining terminal node. This might be no\nlonger a meaningful value'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 272, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "prune", "signature": "(self, taxon)", "symbol_type": "function"}, {"docstring": "Prunes a terminal clade from the tree.\n\nIf the taxon is from a bifurcation, the connecting node will be collapsed\nand its branch length added to remaining terminal node. This might no\nlonger be a meaningful value.\n\n:returns: parent clade of the pruned target", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 660, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "prune", "signature": "(self, target = None, **kwargs)", "symbol_type": "function"}], "psea": [{"docstring": "Parse PSEA output file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PSEA.py", "line_number": 52, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PSEA", "name": "psea", "signature": "(pname)", "symbol_type": "function"}], "psea2HEC": [{"docstring": "Translate PSEA secondary structure string into HEC.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PSEA.py", "line_number": 70, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PSEA", "name": "psea2HEC", "signature": "(pseq)", "symbol_type": "function"}], "pssm": [{"docstring": "Calculate and return the position specific scoring matrix for this motif.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/__init__.py", "line_number": 342, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.__init__", "name": "pssm", "signature": "(self)", "symbol_type": "function"}], "pubmed_id": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 661, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "pubmed_id", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1038, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "pubmed_id", "signature": "(self, content)", "symbol_type": "function"}], "push_back": [{"docstring": "Un-read a line that should not be parsed yet.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HmmerIO/hmmer2_text.py", "line_number": 65, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HmmerIO.hmmer2_text", "name": "push_back", "signature": "(self, line)", "symbol_type": "function"}], "pwm": [{"docstring": "Calculate and return the position weight matrix for this motif.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/__init__.py", "line_number": 337, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.__init__", "name": "pwm", "signature": "(self)", "symbol_type": "function"}], "pytest_addoption": [{"docstring": "Add custom command-line options for pytest.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 223, "module": "tests.conftest", "name": "pytest_addoption", "signature": "(parser)", "symbol_type": "function"}], "pytest_collection_modifyitems": [{"docstring": "Modify test collection to add automatic markers.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 187, "module": "tests.conftest", "name": "pytest_collection_modifyitems", "signature": "(config, items)", "symbol_type": "function"}], "pytest_configure": [{"docstring": "Configure pytest with custom settings.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 180, "module": "tests.conftest", "name": "pytest_configure", "signature": "(config)", "symbol_type": "function"}], "pytest_runtest_setup": [{"docstring": "Setup function to handle test skipping based on environment.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 210, "module": "tests.conftest", "name": "pytest_runtest_setup", "signature": "(item)", "symbol_type": "function"}], "pytest_terminal_summary": [{"docstring": "Provide custom terminal summary after test run.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 316, "module": "tests.conftest", "name": "pytest_terminal_summary", "signature": "(terminalreporter, exitstatus, config)", "symbol_type": "function"}], "qUri": [{"docstring": "Resolve URI for librdf.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 59, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "qUri", "signature": "(x)", "symbol_type": "function"}, {"docstring": "Given a prefixed URI, return the full URI.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NeXMLIO.py", "line_number": 43, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NeXMLIO", "name": "qUri", "signature": "(s)", "symbol_type": "function"}], "q_key": [{"docstring": "Key name (string) of the quality values in record.letter_annotations.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1016, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "q_key", "signature": "(self)", "symbol_type": "function"}], "q_mapping": [{"docstring": "Dictionary that maps letters in the quality string to quality values.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1010, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "q_mapping", "signature": "(self)", "symbol_type": "function"}], "qblast": [{"docstring": "BLAST search using NCBI's QBLAST server.\n\nSupports all parameters of the old qblast API for Put and Get.\n\nPlease note that NCBI uses the new Common URL API for BLAST searches\non the internet (https://blast.ncbi.nlm.nih.gov/doc/blast-help/urlapi.html).\nThus, some of the parameters used by this function are not (or are no longer)\nofficially supported by NCBI. Although they are still functioning, this\nmay change in the future.\n\nSome useful parameters:\n\n - program        blastn, blastp, blastx, tblastn, or tblastx (lower case)\n - database       Which database to search against (e.g. \"nr\").\n - sequence       The sequence to search.\n - ncbi_gi        TRUE/FALSE whether to give 'gi' identifier.\n - descriptions   Number of descriptions to show.  Def 500.\n - alignments     Number of alignments to show.  Def 500.\n - expect         An expect value cutoff.  Def 10.0.\n - matrix_name    Specify an alt. matrix (PAM30, PAM70, BLOSUM80, BLOSUM45).\n - filter         \"none\" turns off filtering.  Default no filtering\n - format_type    \"HTML\", \"Text\", \"ASN.1\", or \"XML\".  Def. \"XML\".\n - entrez_query   Entrez query to limit Blast search - only applies when searching nucleotide BLASTDBs\n - hitlist_size   Number of hits to return. Default 50\n - megablast      TRUE/FALSE whether to use MEga BLAST algorithm (blastn only)\n - short_query    TRUE/FALSE whether to adjust the search parameters for a\n                  short query sequence. Note that this will override\n                  manually set parameters like word size and e value. Turns\n                  off when sequence length is > 30 residues. Default: None.\n - service        plain, psi, phi, rpsblast, megablast (lower case)\n\nThis function does no checking of the validity of the parameters\nand passes the values to the server as is.  More help is available at:\nhttps://blast.ncbi.nlm.nih.gov/doc/blast-help/urlapi.html", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIWWW.py", "line_number": 45, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIWWW", "name": "qblast", "signature": "(program, database, sequence, url_base = NCBI_BLAST_URL, auto_format = None, composition_based_statistics = None, db_genetic_code = None, endpoints = None, entrez_query = '(none)', expect = 10.0, filter = None, gapcosts = None, genetic_code = None, hitlist_size = 50, i_thresh = None, layout = None, lcase_mask = None, matrix_name = None, nucl_penalty = None, nucl_reward = None, other_advanced = None, perc_ident = None, phi_pattern = None, query_file = None, query_believe_defline = None, query_from = None, query_to = None, searchsp_eff = None, service = None, threshold = None, ungapped_alignment = None, word_size = None, short_query = None, alignments = 500, alignment_view = None, descriptions = 500, entrez_links_new_window = None, expect_low = None, expect_high = None, format_entrez_query = None, format_object = None, format_type = 'XML', ncbi_gi = None, results_file = None, show_overview = None, megablast = None, template_type = None, template_length = None, username = 'blast', password = None)", "symbol_type": "function"}, {"docstring": "BLAST search using NCBI's QBLAST server.\n\nSupports all parameters of the old qblast API for Put and Get.\n\nPlease note that NCBI uses the new Common URL API for BLAST searches on\nthe internet (https://blast.ncbi.nlm.nih.gov/doc/blast-help/urlapi.html).\nThus, some of the parameters used by this function are not (or are no\nlonger) officially supported by NCBI. Although they are still functioning,\nthis may change in the future.\n\nSome useful parameters:\n\n - program        blastn, blastp, blastx, tblastn, or tblastx (lower case)\n - database       Which database to search against (e.g. \"nr\").\n - sequence       The sequence to search.\n - ncbi_gi        TRUE/FALSE whether to give 'gi' identifier.\n - descriptions   Number of descriptions to show.  Def 500.\n - alignments     Number of alignments to show.  Def 500.\n - expect         An expect value cutoff.  Def 10.0.\n - matrix_name    Specify an alt. matrix (PAM30, PAM70, BLOSUM80, BLOSUM45).\n - filter         \"none\" turns off filtering.  Default no filtering\n - format_type    \"XML\" (default), \"HTML\", \"Text\", \"XML2\", \"JSON2\",\n                  or \"Tabular\".\n - entrez_query   Entrez query to limit Blast search - only applies when searching nucleotide BLASTDBs\n - hitlist_size   Number of hits to return. Default 50\n - megablast      TRUE/FALSE whether to use MEga BLAST algorithm (blastn only)\n - short_query    TRUE/FALSE whether to adjust the search parameters for a\n                  short query sequence. Note that this will override\n                  manually set parameters like word size and e value. Turns\n                  off when sequence length is > 30 residues. Default: None.\n - service        plain, psi, phi, rpsblast, megablast (lower case)\n\nThis function does no checking of the validity of the parameters\nand passes the values to the server as is.  More help is available at:\nhttps://blast.ncbi.nlm.nih.gov/doc/blast-help/urlapi.html\n\nThe http.client.HTTPResponse object returned by this function has the\nadditional attributes rid and rtoe with the Request ID and Request Time Of\nExecution for this BLAST search.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/__init__.py", "line_number": 1012, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.__init__", "name": "qblast", "signature": "(program, database, sequence, url_base = NCBI_BLAST_URL, auto_format = None, composition_based_statistics = None, db_genetic_code = None, endpoints = None, entrez_query = '(none)', expect = 10.0, filter = None, gapcosts = None, genetic_code = None, hitlist_size = 50, i_thresh = None, layout = None, lcase_mask = None, matrix_name = None, nucl_penalty = None, nucl_reward = None, other_advanced = None, perc_ident = None, phi_pattern = None, query_file = None, query_believe_defline = None, query_from = None, query_to = None, searchsp_eff = None, service = None, threshold = None, ungapped_alignment = None, word_size = None, short_query = None, alignments = 500, alignment_view = None, descriptions = 500, entrez_links_new_window = None, expect_low = None, expect_high = None, format_entrez_query = None, format_object = None, format_type = 'XML', ncbi_gi = None, results_file = None, show_overview = None, megablast = None, template_type = None, template_length = None, username = 'blast', password = None)", "symbol_type": "function"}], "qc_metrics_plot": [{"docstring": "Plot multiple quality control metrics.\n\nArgs:\n    metrics: Dictionary mapping metric names to values\n    ncols: Number of columns in subplot grid\n    figsize: Figure size tuple\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib Figure object\n\nExample:\n    >>> from metainformant.visualization import qc_metrics_plot\n    >>> import numpy as np\n    >>> metrics = {\n    ...     'total_counts': np.random.poisson(1000, 100),\n    ...     'n_genes': np.random.poisson(2000, 100),\n    ...     'pct_mt': np.random.uniform(0, 10, 100)\n    ... }\n    >>> fig = qc_metrics_plot(metrics)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/quality.py", "line_number": 21, "module": "src.metainformant.visualization.quality", "name": "qc_metrics_plot", "signature": "(metrics: dict[str, Sequence[float]], **kwargs) -> plt.Figure", "symbol_type": "function"}], "qcp": [{"docstring": "Implement the QCP code in Python.\n\nInput coordinate arrays must be centered at the origin and have\nshape Nx3.\n\nVariable names match (as much as possible) the C implementation.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/qcprot.py", "line_number": 29, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.qcprot", "name": "qcp", "signature": "(coords1, coords2, natoms)", "symbol_type": "function"}], "qq_plot": [{"docstring": "Generate Q-Q plot for p-value distribution.\n\nArgs:\n    pvalues: List of p-values or path to results file with p_value column\n    output_path: Path to save plot\n    title: Plot title\n\nReturns:\n    Dictionary with plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization.py", "line_number": 198, "module": "src.metainformant.gwas.visualization", "name": "qq_plot", "signature": "(pvalues: list[float] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Generate Q-Q plot for p-value distribution (genome-scale optimized).\n\nArgs:\n    pvalues: List of p-values or path to results file\n    output_path: Path to save plot\n    title: Plot title\n    show_ci: Show 95% confidence interval\n\nReturns:\n    Dictionary with plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_enhanced.py", "line_number": 233, "module": "src.metainformant.gwas.visualization_enhanced", "name": "qq_plot", "signature": "(pvalues: list[float] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Q-Q plot with 95% confidence intervals and lambda GC.\n\nQuantile-quantile plot comparing observed vs expected p-values.\nDeviations indicate systematic bias or true associations.\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    title: Plot title\n    show_ci: Show 95% confidence intervals\n    show_lambda_gc: Show genomic inflation factor\n\nReturns:\n    Plot metadata with lambda_GC", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_statistical.py", "line_number": 33, "module": "src.metainformant.gwas.visualization_statistical", "name": "qq_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Create a Q-Q plot for p-value distribution analysis.\n\nArgs:\n    p_values: List of p-values to plot\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments for scatter\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import qq_plot\n    >>> import numpy as np\n    >>> pvals = np.random.uniform(0, 1, 1000)\n    >>> ax = qq_plot(pvals.tolist())", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/statistical.py", "line_number": 182, "module": "src.metainformant.visualization.statistical", "name": "qq_plot", "signature": "(p_values: list[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "qq_plot_stratified": [{"docstring": "QQ plot stratified by MAF bins.\n\nChecks if genomic inflation varies by allele frequency,\nwhich can indicate technical artifacts or population stratification.\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    maf_bins: MAF bins [(min, max), ...], default [(0, 0.05), (0.05, 0.5)]\n    title: Plot title\n\nReturns:\n    Plot metadata with lambda_GC per bin", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_statistical.py", "line_number": 169, "module": "src.metainformant.gwas.visualization_statistical", "name": "qq_plot_stratified", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "quality_score_distribution": [{"docstring": "Analyze quality score distribution.\n\nArgs:\n    reads: List of FASTQ records\n\nReturns:\n    Dictionary with quality score distribution", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/fastq.py", "line_number": 457, "module": "src.metainformant.quality.fastq", "name": "quality_score_distribution", "signature": "(reads: List[FastqRecord]) -> Dict[str, Any]", "symbol_type": "function"}], "quality_score_plot": [{"docstring": "Plot distribution of quality scores.\n\nArgs:\n    quality_scores: Quality scores\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import quality_score_plot\n    >>> import numpy as np\n    >>> scores = np.random.uniform(0, 40, 1000)\n    >>> ax = quality_score_plot(scores)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/quality.py", "line_number": 88, "module": "src.metainformant.visualization.quality", "name": "quality_score_plot", "signature": "(quality_scores: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "quant": [{"docstring": "Run `amalgkit quant` (quantify transcript abundances).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 571, "module": "src.metainformant.rna.amalgkit", "name": "quant", "signature": "(params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}], "quant_dir": [{"docstring": "Path to quantification results directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/configs.py", "line_number": 39, "module": "src.metainformant.rna.configs", "name": "quant_dir", "signature": "(self) -> Path", "symbol_type": "function"}], "quant_main": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/quant.py", "line_number": 184, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.quant", "name": "quant_main", "signature": "(args)", "symbol_type": "function"}], "quant_output_exists": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/quant.py", "line_number": 8, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.quant", "name": "quant_output_exists", "signature": "(sra_id, output_dir)", "symbol_type": "function"}], "quantify_sample": [{"docstring": "Quantify a single sample using amalgkit quant.\n\nCreates a temporary metadata file with just this sample and runs quantification.\n\nArgs:\n    sample_id: SRA accession ID (e.g., \"SRR1234567\")\n    metadata_rows: List of metadata rows (dicts) for this sample\n    quant_params: Parameters for amalgkit quant step\n    log_dir: Optional directory for log files\n    step_name: Optional step name for logging\n    \nReturns:\n    Tuple of (success: bool, message: str, abundance_file: Path | None)\n    abundance_file is the path to abundance.tsv if successful, None otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/quant.py", "line_number": 28, "module": "src.metainformant.rna.steps.quant", "name": "quantify_sample", "signature": "(sample_id: str, metadata_rows: list[dict[str, Any]], quant_params: Mapping[str, Any]) -> tuple[bool, str, Path | None]", "symbol_type": "function"}], "quartiles": [{"docstring": "Return (minimum, lowerQ, medianQ, upperQ, maximum) values as tuple.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Graph.py", "line_number": 111, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Graph", "name": "quartiles", "signature": "(self)", "symbol_type": "function"}], "query": [{"docstring": "Return self.sequences[1] for a pairwise alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 1580, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "query", "signature": "(self)", "symbol_type": "function"}, {"docstring": "For a pairwise alignment, set self.sequences[1].", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 1591, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "query", "signature": "(self, value)", "symbol_type": "function"}], "query_coverage": [{"docstring": "Return the length of the query covered in the alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Compass/__init__.py", "line_number": 123, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Compass.__init__", "name": "query_coverage", "signature": "(self)", "symbol_type": "function"}], "query_ncbi_esearch": [{"docstring": "Query NCBI using esearch.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/query_bioproject_metadata.py", "line_number": 17, "module": "scripts.gwas.query_bioproject_metadata", "name": "query_ncbi_esearch", "signature": "(db: str, query: str, retmax: int = 100)", "symbol_type": "function"}], "query_sra_metadata": [{"docstring": "Query SRA metadata for a BioProject.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/query_bioproject_metadata.py", "line_number": 40, "module": "scripts.gwas.query_bioproject_metadata", "name": "query_sra_metadata", "signature": "(bioproject: str)", "symbol_type": "function"}], "query_with_curl": [{"docstring": "Query SRA Run Selector via curl.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/gwas/query_bioproject_metadata.py", "line_number": 63, "module": "scripts.gwas.query_bioproject_metadata", "name": "query_with_curl", "signature": "(bioproject: str)", "symbol_type": "function"}], "quotestrip": [{"docstring": "Remove quotes and/or double quotes around identifiers.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 274, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "quotestrip", "signature": "(word)", "symbol_type": "function"}], "rTreeFromChromRangeArray": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1925, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "rTreeFromChromRangeArray", "signature": "(self, blockSize, items, endFileOffset)", "symbol_type": "function"}], "rWriteIndexLevel": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 2036, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "rWriteIndexLevel", "signature": "(self, parent, blockSize, childNodeSize, curLevel, destLevel, offset, output)", "symbol_type": "function"}], "rWriteLeaves": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 2008, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "rWriteLeaves", "signature": "(self, itemsPerSlot, lNodeSize, tree, curLevel, leafLevel, output)", "symbol_type": "function"}], "r_squared": [{"docstring": "Calculate r\u00b2, the squared correlation coefficient between two biallelic loci.\n\nr\u00b2 is a widely used measure of linkage disequilibrium that ranges from 0\n(no LD, alleles are independent) to 1 (complete LD, alleles are perfectly\ncorrelated). It is the square of the correlation between allele presence\nat the two loci.\n\nArgs:\n    pA: Frequency of allele A at first locus\n    pa: Frequency of allele a at first locus\n    pB: Frequency of allele B at second locus\n    pb: Frequency of allele b at second locus\n    haplotype_pAB: Observed frequency of AB haplotype\n    \nReturns:\n    r\u00b2 value in [0, 1]. Returns 0.0 if denominator is zero or inputs invalid.\n    Formula: r\u00b2 = D\u00b2 / (pA \u00d7 pa \u00d7 pB \u00d7 pb)\n    \nExamples:\n    >>> r_squared(pA=0.6, pa=0.4, pB=0.7, pb=0.3, haplotype_pAB=0.5)\n    0.095...\n    >>> r_squared(pA=0.5, pa=0.5, pB=0.5, pb=0.5, haplotype_pAB=0.25)\n    0.0  # No LD\n    \nReferences:\n    Hill, W. G., & Robertson, A. (1968). Linkage disequilibrium in finite\n    populations. Theoretical and Applied Genetics, 38(6), 226-231.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/ld.py", "line_number": 52, "module": "src.metainformant.math.ld", "name": "r_squared", "signature": "(pA: float, pa: float, pB: float, pb: float, haplotype_pAB: float) -> float", "symbol_type": "function"}], "radar_chart": [{"docstring": "Create a radar chart (spider chart).\n\nArgs:\n    categories: Category names\n    values: Values for each category\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import radar_chart\n    >>> categories = ['A', 'B', 'C', 'D', 'E']\n    >>> values = [0.8, 0.6, 0.9, 0.7, 0.5]\n    >>> ax = radar_chart(categories, values)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/multidim.py", "line_number": 154, "module": "src.metainformant.visualization.multidim", "name": "radar_chart", "signature": "(categories: Sequence[str], values: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "raiseBadHeader": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Affy/CelFile.py", "line_number": 210, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Affy.CelFile", "name": "raiseBadHeader", "signature": "(field, expected)", "symbol_type": "function"}], "rak": [{"docstring": "Cache calls to AtomKey for this residue.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 2637, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "rak", "signature": "(self, atm: str | Atom) -> 'AtomKey'", "symbol_type": "function"}], "random_point_mutations": [{"docstring": "Introduce a given number of random point mutations into the sequence.\n\nOnly A/C/G/T are used as replacement bases when possible. Positions are\nunique; if num_mutations exceeds length, it is clamped.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/mutations.py", "line_number": 29, "module": "src.metainformant.dna.mutations", "name": "random_point_mutations", "signature": "(seq: str) -> str", "symbol_type": "function"}], "randomize": [{"docstring": "Generate a random tree with ntax taxa and/or taxa from taxlabels.\n\nnew_tree = randomize(self,ntax=None,taxon_list=None,branchlength=1.0,branchlength_sd=None,bifurcate=True)\nTrees are bifurcating by default. (Polytomies not yet supported).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 567, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "randomize", "signature": "(self, ntax = None, taxon_list = None, branchlength = 1.0, branchlength_sd = None, bifurcate = True)", "symbol_type": "function"}], "randomized": [{"docstring": "Create a randomized bifurcating tree given a list of taxa.\n\n:param taxa: Either an integer specifying the number of taxa to create\n    (automatically named taxon#), or an iterable of taxon names, as\n    strings.\n\n:returns: a tree of the same type as this class.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 756, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "randomized", "signature": "(cls, taxa, branch_length = 1.0, branch_stdev = None)", "symbol_type": "function"}], "range": [{"docstring": "Return lowest and highest base numbers from track features.\n\nReturned type is a tuple.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Diagram.py", "line_number": 388, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Diagram", "name": "range", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the lowest and highest base (or mark) numbers as a tuple.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_FeatureSet.py", "line_number": 166, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._FeatureSet", "name": "range", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return range of data as (start, end) tuple.\n\nReturns the range of the data, i.e. its start and end points on\nthe genome as a (start, end) tuple.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Graph.py", "line_number": 123, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Graph", "name": "range", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the lowest and highest base (or mark) numbers as a tuple.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_GraphSet.py", "line_number": 117, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._GraphSet", "name": "range", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the lowest and highest base (or mark) numbers as a tuple.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Track.py", "line_number": 238, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Track", "name": "range", "signature": "(self)", "symbol_type": "function"}], "rank_abundance_distribution": [{"docstring": "Generate rank-abundance distribution (Whittaker plot data).\n\nArgs:\n    abundances: Species abundance values\n\nReturns:\n    List of (rank, abundance) tuples, sorted by decreasing abundance", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/community.py", "line_number": 258, "module": "src.metainformant.ecology.community", "name": "rank_abundance_distribution", "signature": "(abundances: Sequence[float]) -> List[Tuple[int, float]]", "symbol_type": "function"}], "rarefaction_curve": [{"docstring": "Generate rarefaction curve for species richness.\n\nArgs:\n    abundances: Species abundance counts\n    max_samples: Maximum number of samples to rarify to (default: total abundance)\n\nReturns:\n    List of (sample_size, expected_species_richness) tuples", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/community.py", "line_number": 193, "module": "src.metainformant.ecology.community", "name": "rarefaction_curve", "signature": "(abundances: Sequence[int], max_samples: int | None = None) -> List[Tuple[int, float]]", "symbol_type": "function"}], "raw": [{"docstring": "Return the full coding as a python list.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/StandardData.py", "line_number": 103, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.StandardData", "name": "raw", "signature": "(self)", "symbol_type": "function"}], "reactant_ids": [{"docstring": "Return a list of substrate and product reactant IDs.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 753, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "reactant_ids", "signature": "(self)", "symbol_type": "function"}], "reaction_entries": [{"docstring": "List of entries corresponding to each reaction in the pathway.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 212, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "reaction_entries", "signature": "(self)", "symbol_type": "function"}], "reactions": [{"docstring": "Get a list of reactions in the pathway.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 207, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "reactions", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a list of the reactions in this system.\n\nNote the order is arbitrary!", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 188, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "reactions", "signature": "(self)", "symbol_type": "function"}], "read": [{"docstring": "Read method for the BGZF module.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 699, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "read", "signature": "(self, size = -1)", "symbol_type": "function"}, {"docstring": "Read Affymetrix CEL file and return Record object.\n\nCEL files format versions 3 and 4 are supported.\nPlease specify the CEL file format as 3 or 4 if known for the version\nargument. If the version number is not specified, the parser will attempt\nto detect the version from the file contents.\n\nThe Record object returned by this function stores the intensities from\nthe CEL file in record.intensities.\nCurrently, record.mask and record.outliers are not set in when parsing\nversion 4 CEL files.\n\nExample Usage:\n\n>>> from Bio.Affy import CelFile\n>>> with open(\"Affy/affy_v3_example.CEL\") as handle:\n...     record = CelFile.read(handle)\n...\n>>> record.version == 3\nTrue\n>>> print(\"%i by %i array\" % record.intensities.shape)\n5 by 5 array\n\n>>> with open(\"Affy/affy_v4_example.CEL\", \"rb\") as handle:\n...     record = CelFile.read(handle, version=4)\n...\n>>> record.version == 4\nTrue\n>>> print(\"%i by %i array\" % record.intensities.shape)\n5 by 5 array", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Affy/CelFile.py", "line_number": 85, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Affy.CelFile", "name": "read", "signature": "(handle, version = None)", "symbol_type": "function"}, {"docstring": "Parse a file containing one alignment, and return it.\n\nArguments:\n - source - File or file-like object to read from, or filename as string.\n - fmt    - String describing the file format (case-insensitive).\n\nThis function is for use parsing alignment files containing exactly one\nalignment.  For example, reading a Clustal file:\n\n>>> from Bio import Align\n>>> alignment = Align.read(\"Clustalw/opuntia.aln\", \"clustal\")\n>>> print(\"Alignment shape:\", alignment.shape)\nAlignment shape: (7, 156)\n>>> for sequence in alignment.sequences:\n...     print(sequence.id, len(sequence))\ngi|6273285|gb|AF191659.1|AF191 146\ngi|6273284|gb|AF191658.1|AF191 148\ngi|6273287|gb|AF191661.1|AF191 146\ngi|6273286|gb|AF191660.1|AF191 146\ngi|6273290|gb|AF191664.1|AF191 150\ngi|6273289|gb|AF191663.1|AF191 150\ngi|6273291|gb|AF191665.1|AF191 156\n\nIf the file contains no records, or more than one record, an exception is\nraised.  For example:\n\n>>> from Bio import Align\n>>> filename = \"Exonerate/exn_22_m_ner_cigar.exn\"\n>>> alignment = Align.read(filename, \"exonerate\")\nTraceback (most recent call last):\n    ...\nValueError: More than one alignment found in file\n\nUse the Bio.Align.parse function if you want to read a file containing\nmore than one alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 4915, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "read", "signature": "(handle, fmt)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1316, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "read", "signature": "(self, stream)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1339, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "read", "signature": "(self, stream)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1810, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "read", "signature": "(self, stream)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 2135, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "read", "signature": "(self, stream)", "symbol_type": "function"}, {"docstring": "Parse the file and return an Array object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/substitution_matrices/__init__.py", "line_number": 449, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.substitution_matrices.__init__", "name": "read", "signature": "(handle, dtype = float)", "symbol_type": "function"}, {"docstring": "Turn an alignment file into a single MultipleSeqAlignment object.\n\nArguments:\n - handle    - handle to the file, or the filename as a string\n   (note older versions of Biopython only took a handle).\n - format    - string describing the file format.\n - seq_count - Optional integer, number of sequences expected in each\n   alignment.  Recommended for fasta format files.\n\nIf the handle contains no alignments, or more than one alignment,\nan exception is raised.  For example, using a PFAM/Stockholm file\ncontaining one alignment:\n\n>>> from Bio import AlignIO\n>>> filename = \"Clustalw/protein.aln\"\n>>> format = \"clustal\"\n>>> alignment = AlignIO.read(filename, format)\n>>> print(\"Alignment of length %i\" % alignment.get_alignment_length())\nAlignment of length 411\n\nIf however you want the first alignment from a file containing\nmultiple alignments this function would raise an exception.\n\n>>> from Bio import AlignIO\n>>> filename = \"Emboss/needle.txt\"\n>>> format = \"emboss\"\n>>> alignment = AlignIO.read(filename, format)\nTraceback (most recent call last):\n    ...\nValueError: More than one record found in handle\n\nInstead use:\n\n>>> from Bio import AlignIO\n>>> filename = \"Emboss/needle.txt\"\n>>> format = \"emboss\"\n>>> alignment = next(AlignIO.parse(filename, format))\n>>> print(\"First alignment has length %i\" % alignment.get_alignment_length())\nFirst alignment has length 124\n\nYou must use the Bio.AlignIO.parse() function if you want to read multiple\nrecords from the handle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/__init__.py", "line_number": 338, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.__init__", "name": "read", "signature": "(handle, format, seq_count = None)", "symbol_type": "function"}, {"docstring": "Return a single Blast record (assumes just one query).\n\nUses the BlastParser internally.\n\nThis function is for use when there is one and only one BLAST\nresult in your XML file.\n\nUse the Bio.Blast.NCBIXML.parse() function if you expect more than\none BLAST record (i.e. if you have more than one query sequence).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIXML.py", "line_number": 1193, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIXML", "name": "read", "signature": "(handle, debug = 0)", "symbol_type": "function"}, {"docstring": "Parse an XML file containing BLAST output for a single query and return it.\n\nInternally, this function uses Bio.Blast.parse to obtain an iterator over\nBLAST records.  The function then reads one record from the iterator,\nensures that there are no further records, and returns the record it found\nas a Bio.Blast.Record object. An exception is raised if no records are\nfound, or more than one record is found.\n\nThe source can be a file stream or the path to an XML file containing the\nBLAST output. If a file stream, source  must be in binary mode. This allows\nthe parser to detect the encoding from the XML file,and to use it to convert\nany text in the XML to the correct Unicode string. The qblast function in\nBio.Blast returns a file stream in binary mode. For files, please use mode\n\"rb\" when opening the file, as in\n\n>>> from Bio import Blast\n>>> stream = open(\"Blast/xml_21500_blastn_001.xml\", \"rb\")  # opened in binary mode\n>>> record = Blast.read(stream)\n>>> record.query.id\n'Query_78041'\n>>> record.query.description\n'G26684.1 human STS STS_D11570, sequence tagged site'\n>>> len(record)\n11\n>>> stream.close()\n\nUse the Bio.Blast.parse function if you want to read a file containing\nBLAST output for more than one query.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/__init__.py", "line_number": 917, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.__init__", "name": "read", "signature": "(source)", "symbol_type": "function"}, {"docstring": "Read gene expression data from the file handle and return a Record.\n\nThe file should be in the file format defined for Michael Eisen's\nCluster/TreeView program.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 1193, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read a COMPASS file containing one COMPASS record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Compass/__init__.py", "line_number": 22, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Compass.__init__", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse primer3 output into a Bio.Emboss.Primer3.Record object.\n\nThis is for when there is one and only one target sequence. If\ndesigning primers for multiple sequences, use the parse function.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Emboss/Primer3.py", "line_number": 167, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Emboss.Primer3", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Get output from primersearch into a PrimerSearchOutputRecord.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Emboss/PrimerSearch.py", "line_number": 55, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Emboss.PrimerSearch", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Set up the parser and let it read the XML results.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 390, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "read", "signature": "(self, source)", "symbol_type": "function"}, {"docstring": "Parse an XML file from the NCBI Entrez Utilities into python objects.\n\nThis function parses an XML file created by NCBI's Entrez Utilities,\nreturning a multilevel data structure of Python lists and dictionaries.\nMost XML files returned by NCBI's Entrez Utilities can be parsed by\nthis function, provided its DTD is available. Biopython includes the\nDTDs for most commonly used Entrez Utilities.\n\nThe argument ``source`` must be a file or file-like object opened in binary\nmode, or a filename. The parser detects the encoding from the XML file, and\nuses it to convert all text in the XML to the correct Unicode string. The\nfunctions in Bio.Entrez to access NCBI Entrez will automatically return XML\ndata in binary mode. For files, use mode \"rb\" when opening the file, as in\n\n    >>> from Bio import Entrez\n    >>> path = \"Entrez/esearch1.xml\"\n    >>> stream = open(path, \"rb\")  # opened in binary mode\n    >>> record = Entrez.read(stream)\n    >>> print(record['QueryTranslation'])\n    biopython[All Fields]\n    >>> stream.close()\n\nAlternatively, you can use the filename directly, as in\n\n    >>> record = Entrez.read(path)\n    >>> print(record['QueryTranslation'])\n    biopython[All Fields]\n\nwhich is safer, as the file stream will automatically be closed after the\nrecord has been read, or if an error occurs.\n\nIf validate is True (default), the parser will validate the XML file\nagainst the DTD, and raise an error if the XML file contains tags that\nare not represented in the DTD. If validate is False, the parser will\nsimply skip such tags.\n\nIf escape is True, all characters that are not valid HTML are replaced\nby HTML escape characters to guarantee that the returned strings are\nvalid HTML fragments. For example, a less-than sign (<) is replaced by\n&lt;. If escape is False (default), the string is returned as is.\n\nIf ignore_errors is False (default), any error messages in the XML file\nwill raise a RuntimeError. If ignore_errors is True, error messages will\nbe stored as ErrorElement items, without raising an exception.\n\nWhereas the data structure seems to consist of generic Python lists,\ndictionaries, strings, and so on, each of these is actually a class\nderived from the base type. This allows us to store the attributes\n(if any) of each element in a dictionary my_element.attributes, and\nthe tag name in my_element.tag.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/__init__.py", "line_number": 474, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.__init__", "name": "read", "signature": "(source, validate = True, escape = False, ignore_errors = False)", "symbol_type": "function"}, {"docstring": "Read one ENZYME record.\n\nThis function is for parsing ENZYME files containing\nexactly one record.\n\nArguments:\n - handle   - handle to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/Enzyme.py", "line_number": 40, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.Enzyme", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read in a record from a file with exactly one Prodoc record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/Prodoc.py", "line_number": 27, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.Prodoc", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read one Prosite record.\n\nThis function is for parsing Prosite files containing\nexactly one record.\n\nArguments:\n - handle   - handle to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/Prosite.py", "line_number": 43, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.Prosite", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse search results returned by ScanProsite into a Python object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/ScanProsite.py", "line_number": 65, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.ScanProsite", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read one cell line record.\n\nThis function is for parsing cell line files containing\nexactly one record.\n\nArguments:\n - handle   - handle to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/cellosaurus.py", "line_number": 67, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.cellosaurus", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read a handle containing a single GenBank entry as a Record object.\n\n>>> from Bio import GenBank\n>>> with open(\"GenBank/NC_000932.gb\") as handle:\n...     record = GenBank.read(handle)\n...     print(record.accession)\n['NC_000932']\n\nTo get a SeqRecord object use Bio.SeqIO.read(..., format=\"gb\")\ninstead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1178, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse a KEGG Enzyme file with exactly one entry.\n\nIf the handle contains no records, or more than one record,\nan exception is raised.  For example:\n\n>>> with open(\"KEGG/enzyme.new\") as handle:\n...     record = read(handle)\n...     print(\"%s %s\" % (record.entry, record.name[0]))\n...\n6.2.1.25 benzoate---CoA ligase", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/Enzyme/__init__.py", "line_number": 311, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.Enzyme.__init__", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse a single KEGG Pathway from given file handle.\n\nReturns a single Pathway object.  There should be one and only\none pathway in each file, but there may well be pathological\nexamples out there.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_parser.py", "line_number": 32, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_parser", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read a single Medline record from the handle.\n\nThe handle is either is a Medline file, a file-like object, or a list\nof lines describing a Medline record.\n\nTypical usage:\n\n    >>> from Bio import Medline\n    >>> with open(\"Medline/pubmed_result1.txt\") as handle:\n    ...     record = Medline.read(handle)\n    ...     print(record['TI'])\n    ...\n    The Bio* toolkits--a brief overview.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Medline/__init__.py", "line_number": 202, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Medline.__init__", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read and parse NEXUS input (a filename, file-handle, or string).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 664, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "read", "signature": "(self, input)", "symbol_type": "function"}, {"docstring": "Parse a phyloXML file or stream and build a tree of Biopython objects.\n\nThe children of the root node are phylogenies and possibly other arbitrary\n(non-phyloXML) objects.\n\n:returns: a single ``Bio.Phylo.PhyloXML.Phyloxml`` object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 52, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "read", "signature": "(file)", "symbol_type": "function"}, {"docstring": "Parse the phyloXML file and create a single Phyloxml object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 282, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "read", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Parse a file in the given format and return a single tree.\n\nRaises a ``ValueError`` if there are zero or multiple trees -- if this\noccurs, use ``parse`` instead to get the complete sequence of trees.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_io.py", "line_number": 55, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._io", "name": "read", "signature": "(file, format, **kwargs)", "symbol_type": "function"}, {"docstring": "Parse a BASEML results file.\n\nParse the file and return the results. Raise an exception if\nthe results file does not exist, is empty, or is invalid.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/baseml.py", "line_number": 192, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.baseml", "name": "read", "signature": "(results_file)", "symbol_type": "function"}, {"docstring": "Parse a CODEML results file.\n\nReturn the results if there are any. Raise an exception if\nthe results file does not exist, is empty, or is invalid.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/codeml.py", "line_number": 203, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.codeml", "name": "read", "signature": "(results_file)", "symbol_type": "function"}, {"docstring": "Parse a YN00 results file.\n\nReturn the results if there are any. Raise an exception if\nthe results file does not exist, is empty, or is invalid.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/yn00.py", "line_number": 123, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.yn00", "name": "read", "signature": "(results_file)", "symbol_type": "function"}, {"docstring": "Parse a file containing a GenePop file.\n\nfname is a file name that contains a GenePop record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/FileParser.py", "line_number": 29, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.FileParser", "name": "read", "signature": "(fname)", "symbol_type": "function"}, {"docstring": "Parse a handle containing a GenePop file.\n\nArguments:\n- handle is a file-like object that contains a GenePop record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/LargeFileParser.py", "line_number": 40, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.LargeFileParser", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse a handle containing a GenePop file.\n\nhandle is a file-like object that contains a GenePop record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/__init__.py", "line_number": 53, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.__init__", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Turn a search output file containing one query into a single QueryResult.\n\n - handle - Handle to the file, or the filename as a string.\n - format - Lower case string denoting one of the supported formats.\n - kwargs - Format-specific keyword arguments.\n\n``read`` is used for parsing search output files containing exactly one query:\n\n>>> from Bio import SearchIO\n>>> qresult = SearchIO.read('Blast/xml_2226_blastp_004.xml', 'blast-xml')\n>>> print(\"%s %s\" % (qresult.id, qresult.description))\n...\ngi|11464971:4-101 pleckstrin [Mus musculus]\n\nIf the given handle has no results, an exception will be raised:\n\n>>> from Bio import SearchIO\n>>> qresult = SearchIO.read('Blast/tab_2226_tblastn_002.txt', 'blast-tab')\nTraceback (most recent call last):\n...\nValueError: No query results found in handle\n\nSimilarly, if the given handle has more than one result, an exception will\nbe raised:\n\n>>> from Bio import SearchIO\n>>> qresult = SearchIO.read('Blast/tab_2226_tblastn_001.txt', 'blast-tab')\nTraceback (most recent call last):\n...\nValueError: More than one query result found in handle\n\nLike ``parse``, ``read`` may also accept keyword argument(s) depending on the\nsearch output file format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/__init__.py", "line_number": 314, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.__init__", "name": "read", "signature": "(handle, format = None, **kwargs)", "symbol_type": "function"}, {"docstring": "Turn a sequence file into a single SeqRecord.\n\nArguments:\n - handle   - handle to the file, or the filename as a string\n   (note older versions of Biopython only took a handle).\n - format   - string describing the file format.\n - alphabet - no longer used, should be None.\n\nThis function is for use parsing sequence files containing\nexactly one record.  For example, reading a GenBank file:\n\n>>> from Bio import SeqIO\n>>> record = SeqIO.read(\"GenBank/arab1.gb\", \"genbank\")\n>>> print(\"ID %s\" % record.id)\nID AC007323.5\n>>> print(\"Sequence length %i\" % len(record))\nSequence length 86436\n\nIf the handle contains no records, or more than one record,\nan exception is raised.  For example:\n\n>>> from Bio import SeqIO\n>>> record = SeqIO.read(\"GenBank/cor6_6.gb\", \"genbank\")\nTraceback (most recent call last):\n    ...\nValueError: More than one record found in handle\n\nIf however you want the first record from a file containing\nmultiple records this function would raise an exception (as\nshown in the example above).  Instead use:\n\n>>> from Bio import SeqIO\n>>> record = next(SeqIO.parse(\"GenBank/cor6_6.gb\", \"genbank\"))\n>>> print(\"First record's ID %s\" % record.id)\nFirst record's ID X55053.1\n\nUse the Bio.SeqIO.parse(handle, format) function if you want\nto read multiple records from the handle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/__init__.py", "line_number": 679, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.__init__", "name": "read", "signature": "(handle, format, alphabet = None)", "symbol_type": "function"}, {"docstring": "Parse a full ACE file into a list of contigs.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Sequencing/Ace.py", "line_number": 577, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Sequencing.Ace", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read one PHD record from the file and return it as a Record object.\n\nArgument source is a file-like object opened in text mode, or a path\nto a file.\n\nThis function reads PHD file data line by line from the source, and\nreturns a single Record object. A ValueError is raised if more than\none record is found in the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Sequencing/Phd.py", "line_number": 51, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Sequencing.Phd", "name": "read", "signature": "(source)", "symbol_type": "function"}, {"docstring": "Read one SwissProt record from file.\n\nArgument source is a file-like object or a path to a file.\n\nReturns a Record() object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SwissProt/__init__.py", "line_number": 243, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SwissProt.__init__", "name": "read", "signature": "(source)", "symbol_type": "function"}, {"docstring": "Read and load a UniGene record, one record per file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/UniGene/__init__.py", "line_number": 265, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.UniGene.__init__", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read a motif from a handle using the specified file-format.\n\nThis supports the same formats as Bio.motifs.parse(), but\nonly for files containing exactly one motif.  For example,\nreading a JASPAR-style pfm file:\n\n>>> from Bio import motifs\n>>> with open(\"motifs/SRF.pfm\") as handle:\n...     m = motifs.read(handle, \"pfm\")\n>>> m.consensus\nSeq('GCCCATATATGG')\n\nOr a single-motif MEME file,\n\n>>> from Bio import motifs\n>>> with open(\"motifs/meme.psp_test.classic.zoops.xml\") as handle:\n...     m = motifs.read(handle, \"meme\")\n>>> m.consensus\nSeq('GCTTATGTAA')\n\nIf the handle contains no records, or more than one record,\nan exception is raised:\n\n>>> from Bio import motifs\n>>> with open(\"motifs/alignace.out\") as handle:\n...     motif = motifs.read(handle, \"AlignAce\")\nTraceback (most recent call last):\n    ...\nValueError: More than one motif found in handle\n\nIf however you want the first motif from a file containing\nmultiple motifs this function would raise an exception (as\nshown in the example above).  Instead use:\n\n>>> from Bio import motifs\n>>> with open(\"motifs/alignace.out\") as handle:\n...     record = motifs.parse(handle, \"alignace\")\n>>> motif = record[0]\n>>> motif.consensus\nSeq('TCTACGATTGAG')\n\nUse the Bio.motifs.parse(handle, fmt) function if you want\nto read multiple records from the handle.\n\nIf strict is True (default), the parser will raise a ValueError if the\nfile contents does not strictly comply with the specified file format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/__init__.py", "line_number": 130, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.__init__", "name": "read", "signature": "(handle, fmt, strict = True)", "symbol_type": "function"}, {"docstring": "Parse an AlignACE format handle as a Record object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/alignace.py", "line_number": 23, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.alignace", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read motifs in Cluster Buster position frequency matrix format from a file handle.\n\nCluster Buster motif format: https://bu.wenglab.org/cluster-buster/help/cis-format.html", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/clusterbuster.py", "line_number": 23, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.clusterbuster", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse a MAST XML format handle as a Record object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/mast.py", "line_number": 53, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.mast", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse the text output of the MEME program into a meme.Record object.\n\nExamples\n--------\n>>> from Bio.motifs import meme\n>>> with open(\"motifs/meme.INO_up800.classic.oops.xml\") as f:\n...     record = meme.read(f)\n>>> for motif in record:\n...     for sequence in motif.alignment.sequences:\n...         print(sequence.motif_name, sequence.sequence_name, sequence.sequence_id, sequence.strand, sequence.pvalue)\nGSKGCATGTGAAA INO1 sequence_5 + 1.21e-08\nGSKGCATGTGAAA FAS1 sequence_2 - 1.87e-08\nGSKGCATGTGAAA ACC1 sequence_4 - 6.62e-08\nGSKGCATGTGAAA CHO2 sequence_1 - 1.05e-07\nGSKGCATGTGAAA CHO1 sequence_0 - 1.69e-07\nGSKGCATGTGAAA FAS2 sequence_3 - 5.62e-07\nGSKGCATGTGAAA OPI3 sequence_6 + 1.08e-06\nTTGACWCYTGCYCWG CHO2 sequence_1 + 7.2e-10\nTTGACWCYTGCYCWG OPI3 sequence_6 - 2.56e-08\nTTGACWCYTGCYCWG ACC1 sequence_4 - 1.59e-07\nTTGACWCYTGCYCWG CHO1 sequence_0 + 2.05e-07\nTTGACWCYTGCYCWG FAS1 sequence_2 + 3.85e-07\nTTGACWCYTGCYCWG FAS2 sequence_3 - 5.11e-07\nTTGACWCYTGCYCWG INO1 sequence_5 + 8.01e-07", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/meme.py", "line_number": 20, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.meme", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Parse the text output of the MEME program into a meme.Record object.\n\nExamples\n--------\n>>> from Bio.motifs import minimal\n>>> with open(\"motifs/meme.out\") as f:\n...     record = minimal.read(f)\n...\n>>> for motif in record:\n...     print(motif.name, motif.evalue)\n...\n1 1.1e-22\n\nYou can access individual motifs in the record by their index or find a motif\nby its name:\n\n>>> from Bio import motifs\n>>> with open(\"motifs/minimal_test.meme\") as f:\n...     record = motifs.parse(f, 'minimal')\n...\n>>> motif = record[0]\n>>> print(motif.name)\nKRP\n>>> motif = record['IFXA']\n>>> print(motif.name)\nIFXA\n\nThis function won't retrieve instances, as there are none in minimal meme format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/minimal.py", "line_number": 13, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.minimal", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read motif(s) from a file in various position frequency matrix formats.\n\nReturn the record of PFM(s).\nCall the appropriate routine based on the format passed.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/pfm.py", "line_number": 25, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.pfm", "name": "read", "signature": "(handle, pfm_format)", "symbol_type": "function"}, {"docstring": "Parse a transfac format handle into a Record object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/transfac.py", "line_number": 98, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.transfac", "name": "read", "signature": "(handle, strict = True)", "symbol_type": "function"}, {"docstring": "Read motifs in XMS matrix format from a file handle.\n\nXMS is an XML format for describing regulatory motifs and PSSMs.\nThis format was defined by Thomas Down, and used in the NestedMICA and MotifExplorer programs.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/xms.py", "line_number": 97, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.xms", "name": "read", "signature": "(handle)", "symbol_type": "function"}, {"docstring": "Read motif(s) from a file in one of several different JASPAR formats.\n\nReturn the record of PFM(s).\nCall the appropriate routine based on the format passed.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/jaspar/__init__.py", "line_number": 152, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.jaspar.__init__", "name": "read", "signature": "(handle, format)", "symbol_type": "function"}, {"docstring": "Turn a phenotype file into a single PlateRecord.\n\n - handle   - handle to the file, or the filename as a string\n              (note older versions of Biopython only took a handle).\n - format   - string describing the file format.\n\nThis function is for use parsing phenotype files containing\nexactly one record.  For example, reading a PM JSON file:\n\n>>> from Bio import phenotype\n>>> record = phenotype.read(\"phenotype/Plate.json\", \"pm-json\")\n>>> print(\"ID %s\" % record.id)\nID PM01\n>>> print(\"Number of wells %i\" % len(record))\nNumber of wells 96\n\nIf the handle contains no records, or more than one record,\nan exception is raised.  For example::\n\n    from Bio import phenotype\n    record = phenotype.read(\"plates.csv\", \"pm-csv\")\n    Traceback (most recent call last):\n    ...\n    ValueError: More than one record found in handle\n\nIf however you want the first record from a file containing\nmultiple records this function would raise an exception (as\nshown in the example above).  Instead use:\n\n>>> from Bio import phenotype\n>>> record = next(phenotype.parse(\"phenotype/Plates.csv\", \"pm-csv\"))\n>>> print(\"First record's ID %s\" % record.id)\nFirst record's ID PM01\n\nUse the Bio.phenotype.parse(handle, format) function if you want\nto read multiple records from the handle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/__init__.py", "line_number": 187, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.__init__", "name": "read", "signature": "(handle, format)", "symbol_type": "function"}], "read_PIC": [{"docstring": "Load Protein Internal Coordinate (.pic) data from file.\n\nPIC file format:\n    - comment lines start with #\n    - (optional) PDB HEADER record\n       - idcode and deposition date recommended but optional\n       - deposition date in PDB format or as changed by Biopython\n    - (optional) PDB TITLE record\n    - repeat:\n       - Biopython Residue Full ID - sets residue IDs of returned structure\n       - (optional) PDB N, CA, C ATOM records for chain start\n       - (optional) PIC Hedra records for residue\n       - (optional) PIC Dihedra records for residue\n       - (optional) BFAC records listing AtomKeys and b-factors\n\nAn improvement would define relative positions for HOH (water) entries.\n\nDefaults will be supplied for any value if defaults=True.  Default values\nare supplied in ic_data.py, but structures degrade quickly with any\ndeviation from true coordinates.  Experiment with\n:data:`Bio.PDB.internal_coords.IC_Residue.pic_flags` options to\n:func:`write_PIC` to verify this.\n\nN.B. dihedron (i-1)C-N-CA-CB is ignored in assembly if O exists.\n\nC-beta is by default placed using O-C-CA-CB, but O is missing\nin some PDB file residues, which means the sidechain cannot be\nplaced.  The alternate CB path (i-1)C-N-CA-CB is provided to\ncircumvent this, but if this is needed then it must be adjusted in\nconjunction with PHI ((i-1)C-N-CA-C) as they overlap (see :meth:`.bond_set`\nand :meth:`.bond_rotate` to handle this automatically).\n\n:param Bio.File file: :func:`.as_handle` file name or handle\n:param bool verbose: complain when lines not as expected\n:param bool quick: don't check residues for all dihedra (no default values)\n:param bool defaults: create di/hedra as needed from reference database.\n    Amide proton created if 'H' is in IC_Residue.accept_atoms\n:returns: Biopython Structure object, Residues with .internal_coord\n    attributes but no coordinates except for chain start N, CA, C atoms if\n    supplied, **OR** None on parse fail (silent unless verbose=True)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 41, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "read_PIC", "signature": "(file: TextIO, verbose: bool = False, quick: bool = False, defaults: bool = False) -> Structure", "symbol_type": "function"}], "read_PIC_seq": [{"docstring": "Read :class:`.SeqRecord` into Structure with default internal coords.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 818, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "read_PIC_seq", "signature": "(seqRec: 'SeqIO.SeqRecord', pdbid: str = None, title: str = None, chain: str = None) -> Structure", "symbol_type": "function"}], "read_bedgraph": [{"docstring": "Read a simple bedGraph file into a DataFrame with columns chrom,start,end,value.\n\n- Supports plain text or gzip-compressed input (\".gz\").\n- Ignores header/comment lines starting with '#'.\n- start/end are returned as int; value as float.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/tracks.py", "line_number": 11, "module": "src.metainformant.epigenome.tracks", "name": "read_bedgraph", "signature": "(path: str | Path) -> pd.DataFrame", "symbol_type": "function"}], "read_colorscheme": [{"docstring": "Load colour scheme from file.\n\nReads information from a file containing color information and stores\nit internally.\n\nArgument filename is the location of a file defining colors in\ntab-separated format plaintext as::\n\n    INT \\t RED \\t GREEN \\t BLUE \\t Comment\n\nWhere RED, GREEN and BLUE are intensities in the range 0 -> 255, e.g.::\n\n    2 \\t 255 \\t 0 \\t 0 \\t Red: Information transfer", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Colors.py", "line_number": 122, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Colors", "name": "read_colorscheme", "signature": "(self, filename)", "symbol_type": "function"}], "read_config_file": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 371, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "read_config_file", "signature": "(file_name, dir_path)", "symbol_type": "function"}], "read_csv": [{"docstring": "Read CSV file using pandas if available, fallback to native implementation.\n\nArgs:\n    path: Path to CSV file (supports gzip compression automatically)\n    **kwargs: Additional arguments passed to pandas.read_csv if pandas available\n    \nReturns:\n    pandas DataFrame if pandas available, otherwise dict of lists", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 260, "module": "src.metainformant.core.io", "name": "read_csv", "signature": "(path: str | Path, **kwargs) -> Any", "symbol_type": "function"}], "read_ctl_file": [{"docstring": "Read control file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_paml.py", "line_number": 40, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._paml", "name": "read_ctl_file", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Parse a control file and load the options into the Baseml instance.\n\nUpdate each BASEML option to the new option if supplied or None if\nnot supplied. Raise an exception if the control file does not exist,\na line is malformed, or an option is invalid.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/baseml.py", "line_number": 102, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.baseml", "name": "read_ctl_file", "signature": "(self, ctl_file)", "symbol_type": "function"}, {"docstring": "Parse a control file and load the options into the Codeml instance.\n\nUpdate each CODEML option to the new option if supplied or None if\nnot supplied. Raise an exception if the control file does not exist,\na line is malformed, or an option is invalid.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/codeml.py", "line_number": 100, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.codeml", "name": "read_ctl_file", "signature": "(self, ctl_file)", "symbol_type": "function"}, {"docstring": "Parse a control file and load the options into the Yn00 instance.\n\nUpdate each YN00 option to the new option if supplied or None if\nnot supplied. Raise an exception if the control file does not exist,\na line is malformed, or an option is invalid.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/yn00.py", "line_number": 63, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.yn00", "name": "read_ctl_file", "signature": "(self, ctl_file)", "symbol_type": "function"}], "read_delimited": [{"docstring": "Read delimited text file (CSV/TSV) as dictionaries.\n\nArgs:\n    path: Path to delimited file (supports gzip compression automatically)\n    delimiter: Field delimiter (default: comma for CSV, use \"\\t\" for TSV)\n    \nYields:\n    Dictionary for each row with column names as keys\n\nRaises:\n    FileNotFoundError: If file does not exist\n    IOError: If file read fails", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 177, "module": "src.metainformant.core.io", "name": "read_delimited", "signature": "(path: str | Path) -> Iterator[dict[str, str]]", "symbol_type": "function"}], "read_fasta": [{"docstring": "Read a FASTA file into a dictionary of id -> sequence string.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 9, "module": "src.metainformant.dna.sequences", "name": "read_fasta", "signature": "(path: str) -> Dict[str, str]", "symbol_type": "function"}], "read_forward": [{"docstring": "Read through whitespaces, return the first non-whitespace line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 25, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "read_forward", "signature": "(handle)", "symbol_type": "function"}], "read_jsonl": [{"docstring": "Read JSON Lines format (one JSON object per line).\n\nArgs:\n    path: Path to JSONL file (supports gzip compression automatically)\n    \nYields:\n    Dictionary for each line in the file", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 126, "module": "src.metainformant.core.io", "name": "read_jsonl", "signature": "(path: str | Path) -> Iterator[dict[str, Any]]", "symbol_type": "function"}], "read_next": [{"docstring": "Return the next non-empty line, trailing whitespace removed.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HmmerIO/hmmer2_text.py", "line_number": 53, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HmmerIO.hmmer2_text", "name": "read_next", "signature": "(self, rstrip = True)", "symbol_type": "function"}], "read_parquet": [{"docstring": "Read Parquet file with pandas.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 106, "module": "src.metainformant.core.io", "name": "read_parquet", "signature": "(path: str | Path, **kwargs) -> Any", "symbol_type": "function"}], "read_pdb_ca_coordinates": [{"docstring": "Parse a PDB file and return list of CA atom coordinates as (x,y,z).\n\nMinimal PDB parser sufficient for unit tests; ignores altloc/occupancy.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/structure_io.py", "line_number": 7, "module": "src.metainformant.protein.structure_io", "name": "read_pdb_ca_coordinates", "signature": "(pdb_path: Path) -> List[tuple[float, float, float]]", "symbol_type": "function"}], "read_taxon_ids": [{"docstring": "Read NCBI taxonomy IDs from a text file (one per line).\n\nArgs:\n    taxon_id_file: Path to file containing taxonomy IDs\n    \nReturns:\n    List of taxonomy IDs (integers), skipping empty lines and comments", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/proteomes.py", "line_number": 6, "module": "src.metainformant.protein.proteomes", "name": "read_taxon_ids", "signature": "(taxon_id_file: Path) -> list[int]", "symbol_type": "function"}], "read_tsv": [{"docstring": "Read TSV file.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 331, "module": "src.metainformant.core.io", "name": "read_tsv", "signature": "(path: str | Path) -> list[list[str]]", "symbol_type": "function"}], "read_until": [{"docstring": "Read the file handle until the given bool function returns True.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/ExonerateIO/_base.py", "line_number": 379, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.ExonerateIO._base", "name": "read_until", "signature": "(self, bool_func)", "symbol_type": "function"}], "readline": [{"docstring": "Read a single line for the BGZF file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 725, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "readline", "signature": "(self)", "symbol_type": "function"}], "realized_heritability": [{"docstring": "h^2_realized = R / S (guarding S=0).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/quantgen.py", "line_number": 104, "module": "src.metainformant.math.quantgen", "name": "realized_heritability", "signature": "(response: float, selection_differential: float) -> float", "symbol_type": "function"}], "recombination_rate_plot": [{"docstring": "Association with recombination hotspots.\n\nOverlays recombination rates with association signal.\nRecombination hotspots can affect LD and fine-mapping.\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    recomb_map_path: Path to recombination map\n    chrom: Chromosome\n    start: Region start\n    end: Region end\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_regional.py", "line_number": 291, "module": "src.metainformant.gwas.visualization_regional", "name": "recombination_rate_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "record_end": [{"docstring": "Clean up when we've finished the record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 815, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "record_end", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": "Signal the end of the record and do any necessary clean-up.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1154, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "record_end", "signature": "(self, content)", "symbol_type": "function"}], "record_has": [{"docstring": "Accept a record, and a dictionary of field values.\n\nThe format is {'field_name': set([val1, val2])}.\nIf any field in the record has  a matching value, the function returns\nTrue. Otherwise, returns False.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/UniProt/GOA.py", "line_number": 487, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.UniProt.GOA", "name": "record_has", "signature": "(inrec, fieldvals)", "symbol_type": "function"}], "reduce": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1364, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "reduce", "signature": "(self, summaries, initialReduction, buffer, blockSize, itemsPerSlot)", "symbol_type": "function"}], "reduce_dimensions_pca": [{"docstring": "Principal Component Analysis for dimensionality reduction.\n\nArgs:\n    X: Data matrix (samples x features)\n    n_components: Number of components to keep\n    standardize: Whether to standardize features\n\nReturns:\n    Tuple of (transformed_data, components, explained_variance)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/dimensionality.py", "line_number": 11, "module": "src.metainformant.ml.dimensionality", "name": "reduce_dimensions_pca", "signature": "(X: np.ndarray, n_components: int = 50, standardize: bool = True) -> Tuple[np.ndarray, np.ndarray, np.ndarray]", "symbol_type": "function"}], "reduce_dimensions_tsne": [{"docstring": "Simplified t-SNE dimensionality reduction.\n\nArgs:\n    X: Data matrix\n    n_components: Number of output dimensions\n    perplexity: t-SNE perplexity parameter\n    random_state: Random seed\n\nReturns:\n    Low-dimensional embedding", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/dimensionality.py", "line_number": 121, "module": "src.metainformant.ml.dimensionality", "name": "reduce_dimensions_tsne", "signature": "(X: np.ndarray, n_components: int = 2, perplexity: float = 30.0, random_state: Optional[int] = None) -> np.ndarray", "symbol_type": "function"}], "reduce_dimensions_umap": [{"docstring": "Simplified UMAP-like dimensionality reduction.\n\nArgs:\n    X: Data matrix\n    n_components: Number of output dimensions\n    n_neighbors: Number of neighbors for local structure\n    min_dist: Minimum distance between points in low-dim space\n    random_state: Random seed\n\nReturns:\n    Low-dimensional embedding", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/dimensionality.py", "line_number": 56, "module": "src.metainformant.ml.dimensionality", "name": "reduce_dimensions_umap", "signature": "(X: np.ndarray, n_components: int = 2, n_neighbors: int = 15, min_dist: float = 0.1, random_state: Optional[int] = None) -> np.ndarray", "symbol_type": "function"}], "ref": [{"docstring": "Not present in CompoundLocation, dummy method for API compatibility.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 1677, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "ref", "signature": "(self)", "symbol_type": "function"}], "ref_db": [{"docstring": "Not present in CompoundLocation, dummy method for API compatibility.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 1682, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "ref_db", "signature": "(self)", "symbol_type": "function"}], "reference": [{"docstring": "Create literature reference object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 626, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "reference", "signature": "(self, elem)", "symbol_type": "function"}], "reference_bases": [{"docstring": "Attempt to determine the sequence region the reference entails.\n\nPossible types of information we may have to deal with:\n\n(bases 1 to 86436)\n(sites)\n(bases 1 to 105654; 110423 to 111122)\n1  (residues 1 to 182)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 567, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "reference_bases", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1015, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "reference_bases", "signature": "(self, content)", "symbol_type": "function"}], "reference_num": [{"docstring": "Signal the beginning of a new reference object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 556, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "reference_num", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": "Grab the reference number and signal the start of a new reference.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1004, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "reference_num", "signature": "(self, content)", "symbol_type": "function"}], "refmat": [{"docstring": "Return a (left multiplying) matrix that mirrors p onto q.\n\n:type p,q: L{Vector}\n:return: The mirror operation, a 3x3 NumPy array.\n\nExamples\n--------\n>>> from Bio.PDB.vectors import refmat\n>>> p, q = Vector(1, 2, 3), Vector(2, 3, 5)\n>>> mirror = refmat(p, q)\n>>> qq = p.left_multiply(mirror)\n>>> print(q)\n<Vector 2.00, 3.00, 5.00>\n>>> print(qq)\n<Vector 1.21, 1.82, 3.03>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 149, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "refmat", "signature": "(p, q)", "symbol_type": "function"}], "regional_ld_plot": [{"docstring": "LD structure around lead SNP.\n\nShows linkage disequilibrium (r\u00b2) between lead SNP and surrounding variants.\nUseful for identifying LD blocks and tagging variants.\n\nArgs:\n    vcf_path: Path to VCF file\n    output_path: Output path\n    chrom: Chromosome\n    start: Region start\n    end: Region end\n    lead_snp_pos: Lead SNP position\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_regional.py", "line_number": 141, "module": "src.metainformant.gwas.visualization_regional", "name": "regional_ld_plot", "signature": "(vcf_path: Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "regional_plot": [{"docstring": "Generate regional association plot for a specific genomic region.\n\nArgs:\n    results: List of result dictionaries or path to results file\n    region: Genomic region (format: \"chr:start-end\" or \"chr:center\")\n    output_path: Path to save plot\n    window: Window size around center if single position given (in bp)\n    title: Plot title\n\nReturns:\n    Dictionary with plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization.py", "line_number": 311, "module": "src.metainformant.gwas.visualization", "name": "regional_plot", "signature": "(results: list[dict[str, Any]] | Path, region: str, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Generate regional association plot with optional gene annotations.\n\nArgs:\n    results: Results or path to file\n    region: Format \"chr:start-end\" or \"chr:center\"\n    output_path: Save path\n    window: Window size if single position (bp)\n    title: Plot title\n    genes: Optional gene annotations [{\"name\": str, \"start\": int, \"end\": int}]\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_enhanced.py", "line_number": 339, "module": "src.metainformant.gwas.visualization_enhanced", "name": "regional_plot", "signature": "(results: list[dict[str, Any]] | Path, region: str, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Regional association plot around a locus.\n\nShows association signal in a genomic window, useful for\nfine-mapping and identifying candidate causal variants.\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    chrom: Chromosome\n    start: Region start position\n    end: Region end position\n    lead_snp_pos: Position of lead SNP to highlight\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_regional.py", "line_number": 32, "module": "src.metainformant.gwas.visualization_regional", "name": "regional_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Create a regional plot for a specific genomic region.\n\nArgs:\n    data: DataFrame with genomic positions and p-values\n    chromosome: Chromosome name\n    start: Start position\n    end: End position\n    x_col: Column name for x-axis (genomic position)\n    y_col: Column name for y-axis (usually -log10(p-value))\n    p_threshold: P-value threshold for significance\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments for scatter\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import regional_plot\n    >>> import pandas as pd\n    >>> data = pd.DataFrame({\n    ...     'position': range(1000000, 1001000, 100),\n    ...     'neg_log10_p': np.random.uniform(0, 5, 10)\n    ... })\n    >>> ax = regional_plot(data, 'chr1', 1000000, 1001000)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/genomics.py", "line_number": 196, "module": "src.metainformant.visualization.genomics", "name": "regional_plot", "signature": "(data: pd.DataFrame, chromosome: str, start: int, end: int, x_col: str = 'position', y_col: str = 'neg_log10_p', **kwargs) -> plt.Axes", "symbol_type": "function"}], "register_ncbi_table": [{"docstring": "Turn codon table data into objects (PRIVATE).\n\nThe data is stored in the dictionaries.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Data/CodonTable.py", "line_number": 493, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Data.CodonTable", "name": "register_ncbi_table", "signature": "(name, alt_name, id, table, start_codons, stop_codons)", "symbol_type": "function"}], "register_thread": [{"docstring": "Register a new download thread for tracking.\n\nArgs:\n    thread_id: Unique thread identifier\n    run_id: SRA run ID being downloaded\n    sample_dir: Optional specific directory; if None, uses out_dir/getfastq/run_id", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/download_progress.py", "line_number": 261, "module": "src.metainformant.rna.steps.download_progress", "name": "register_thread", "signature": "(self, thread_id: int, run_id: str, sample_dir: Path | None = None) -> None", "symbol_type": "function"}], "regulatory_motifs": [{"docstring": "Identify regulatory network motifs (small recurring patterns).\n\nRegulatory motifs are small subnetworks that occur frequently and\noften have specific biological functions. Common motifs include\nfeed-forward loops and feedback loops.\n\nArgs:\n    grn: Gene regulatory network to analyze\n    motif_types: List of motif types to search for. If None, searches\n        for all supported types. Supported types:\n        - \"feed_forward_loop\": A -> B -> C, A -> C (common in GRNs)\n        - \"feedback_loop\": A -> B -> A (two-gene feedback)\n        - \"bifan\": Two regulators both target two common targets\n        \nReturns:\n    Dictionary mapping motif_type to list of motif instances.\n    Each motif instance is a dictionary with relevant node identifiers.\n    \nExamples:\n    >>> grn = GeneRegulatoryNetwork()\n    >>> grn.add_regulation(\"TF1\", \"TF2\", regulation_type=\"activation\")\n    >>> grn.add_regulation(\"TF2\", \"GENE1\", regulation_type=\"activation\")\n    >>> grn.add_regulation(\"TF1\", \"GENE1\", regulation_type=\"activation\")\n    >>> motifs = regulatory_motifs(grn, motif_types=[\"feed_forward_loop\"])\n    >>> len(motifs[\"feed_forward_loop\"])\n    1\n    \nReferences:\n    Alon, U. (2007). Network motifs: theory and experimental approaches.\n    Nature Reviews Genetics, 8(6), 450-461.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 693, "module": "src.metainformant.networks.regulatory", "name": "regulatory_motifs", "signature": "(grn: GeneRegulatoryNetwork, motif_types: Optional[List[str]] = None, min_confidence: float = 0.0, return_list: bool = True) -> Union[Dict[str, List[Dict[str, Any]]], List[Dict[str, Any]]]", "symbol_type": "function"}], "regulatory_statistics": [{"docstring": "Calculate comprehensive regulatory network statistics.\n\nComputes network topology, regulatory type counts, and identifies\nmaster regulators (genes with high out-degree).\n\nReturns:\n    Dictionary containing:\n    - total_genes: Number of unique genes in network\n    - total_tfs: Number of transcription factors\n    - total_regulations: Number of regulatory interactions\n    - activation_regulations: Count of activation interactions\n    - repression_regulations: Count of repression interactions\n    - master_regulators: List of top 10 regulators by out-degree\n    - network_metrics: Basic network topology metrics\n    - avg_out_degree: Average number of targets per regulator\n    \nExamples:\n    >>> stats = grn.regulatory_statistics()\n    >>> stats[\"total_tfs\"]\n    50\n    >>> stats[\"master_regulators\"]\n    ['TF1', 'TF2', 'TF3']", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 426, "module": "src.metainformant.networks.regulatory", "name": "regulatory_statistics", "signature": "(self) -> Dict[str, Any]", "symbol_type": "function"}], "relations": [{"docstring": "Get a list of relations in the pathway.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 217, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "relations", "signature": "(self)", "symbol_type": "function"}], "relative_entropy": [{"docstring": "Return an array with the relative entropy for each column of the motif.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/__init__.py", "line_number": 437, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.__init__", "name": "relative_entropy", "signature": "(self)", "symbol_type": "function"}], "relative_fitness": [{"docstring": "Normalize fitness values by their mean to obtain relative fitness.\n\nRelative fitness is used in evolutionary analysis where the mean fitness\ndefines the baseline. After normalization, mean relative fitness is 1.0.\n\nArgs:\n    fitness: Sequence of absolute fitness values\n    \nReturns:\n    List of relative fitness values (fitness / mean(fitness)). \n    Returns zeros if mean fitness is 0 or input is empty.\n    The mean of returned values is 1.0 when mean(fitness) > 0.\n    \nExamples:\n    >>> relative_fitness([1.0, 2.0, 3.0])\n    [0.5, 1.0, 1.5]\n    >>> sum(relative_fitness([1.0, 2.0, 3.0])) / 3\n    1.0", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 135, "module": "src.metainformant.math.price", "name": "relative_fitness", "signature": "(fitness: Sequence[float]) -> list[float]", "symbol_type": "function"}], "remark": [{"docstring": "Deal with a reference comment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 664, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "remark", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1041, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "remark", "signature": "(self, content)", "symbol_type": "function"}], "remove": [{"docstring": "Remove a subsequence of a single letter from mutable sequence.\n\n>>> my_seq = MutableSeq('ACTCGACGTCG')\n>>> my_seq.remove('C')\n>>> my_seq\nMutableSeq('ATCGACGTCG')\n>>> my_seq.remove('A')\n>>> my_seq\nMutableSeq('TCGACGTCG')\n\nNo return value.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2302, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "remove", "signature": "(self, item)", "symbol_type": "function"}, {"docstring": "Remove the specified component from the subcomponents.\n\nRaises a ValueError if the component is not registered as a\nsub_component.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/BasicChromosome.py", "line_number": 79, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.BasicChromosome", "name": "remove", "signature": "(self, component)", "symbol_type": "function"}, {"docstring": "Remove enzyme from restriction batch.\n\nSafe set.remove method. Verify that other is a RestrictionType or can\nbe evaluated to a RestrictionType.\nRaise a ValueError if other can not be evaluated to a RestrictionType.\nRaise a KeyError if other is not in B.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2110, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "remove", "signature": "(self, other)", "symbol_type": "function"}, {"docstring": "Remove everything related to the given database id.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/Loader.py", "line_number": 1255, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.Loader", "name": "remove", "signature": "(self)", "symbol_type": "function"}], "remove_component": [{"docstring": "Remove the entry with the passed ID from the group.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 320, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "remove_component", "signature": "(self, value)", "symbol_type": "function"}], "remove_control_chars": [{"docstring": "Remove control characters from text.\n\nArgs:\n    text: Text to clean\n\nReturns:\n    Text without control characters", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/text.py", "line_number": 43, "module": "src.metainformant.core.text", "name": "remove_control_chars", "signature": "(text: str) -> str", "symbol_type": "function"}], "remove_edge": [{"docstring": "Remove an edge from the network.\n\nArgs:\n    network: Biological network to modify\n    node1: First node of edge\n    node2: Second node of edge\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\"])\n    >>> network.add_edge(\"A\", \"B\")\n    >>> network.add_edge(\"B\", \"C\")\n    >>> remove_edge(network, \"A\", \"B\")\n    >>> network.num_edges()\n    1", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 1178, "module": "src.metainformant.networks.graph", "name": "remove_edge", "signature": "(network: BiologicalNetwork, node1: str, node2: str) -> None", "symbol_type": "function"}, {"docstring": "Remove edge (NOT IMPLEMENTED).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/Graph.py", "line_number": 146, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.Graph", "name": "remove_edge", "signature": "(self, parent, child, label)", "symbol_type": "function"}, {"docstring": "Remove edge (NOT IMPLEMENTED).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/MultiGraph.py", "line_number": 136, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.MultiGraph", "name": "remove_edge", "signature": "(self, parent, child, label)", "symbol_type": "function"}], "remove_entry": [{"docstring": "Remove an Entry element from the pathway.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 102, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "remove_entry", "signature": "(self, entry)", "symbol_type": "function"}], "remove_experiment_without_run": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 583, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "remove_experiment_without_run", "signature": "(metadata)", "symbol_type": "function"}], "remove_graphics": [{"docstring": "Remove the Graphics entry with the passed ID from the group.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 328, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "remove_graphics", "signature": "(self, entry)", "symbol_type": "function"}], "remove_intermediate_files": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 170, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "remove_intermediate_files", "signature": "(sra_stat, ext, work_dir)", "symbol_type": "function"}], "remove_loci_by_name": [{"docstring": "Remove a loci list (by name).\n\nArguments:\n - names - names\n - fname - file to be created with loci removed", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/FileParser.py", "line_number": 336, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.FileParser", "name": "remove_loci_by_name", "signature": "(self, names, fname)", "symbol_type": "function"}], "remove_loci_by_position": [{"docstring": "Remove a set of loci by position.\n\nArguments:\n - positions - positions\n - fname - file to be created with locus removed", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/FileParser.py", "line_number": 275, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.FileParser", "name": "remove_loci_by_position", "signature": "(self, positions, fname)", "symbol_type": "function"}], "remove_locus_by_name": [{"docstring": "Remove a locus by name.\n\nArguments:\n - name - name\n - fname - file to be created with locus removed", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/FileParser.py", "line_number": 321, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.FileParser", "name": "remove_locus_by_name", "signature": "(self, name, fname)", "symbol_type": "function"}, {"docstring": "Remove a locus by name.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/__init__.py", "line_number": 217, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.__init__", "name": "remove_locus_by_name", "signature": "(self, name)", "symbol_type": "function"}], "remove_locus_by_position": [{"docstring": "Remove a locus by position.\n\nArguments:\n - pos - position\n - fname - file to be created with locus removed", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/FileParser.py", "line_number": 234, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.FileParser", "name": "remove_locus_by_position", "signature": "(self, pos, fname)", "symbol_type": "function"}, {"docstring": "Remove a locus by position.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/__init__.py", "line_number": 209, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.__init__", "name": "remove_locus_by_position", "signature": "(self, pos)", "symbol_type": "function"}], "remove_node": [{"docstring": "Remove a node and all its edges from the network.\n\nArgs:\n    network: Biological network to modify\n    node: Node identifier to remove\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\"])\n    >>> network.add_edge(\"A\", \"B\")\n    >>> remove_node(network, \"B\")\n    >>> network.num_nodes()\n    2\n    >>> network.num_edges()\n    0", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 1144, "module": "src.metainformant.networks.graph", "name": "remove_node", "signature": "(network: BiologicalNetwork, node: str) -> None", "symbol_type": "function"}, {"docstring": "Remove node and all edges connected to it.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/Graph.py", "line_number": 122, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.Graph", "name": "remove_node", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": "Remove node and all edges connected to it.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/Rep/MultiGraph.py", "line_number": 114, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.Rep.MultiGraph", "name": "remove_node", "signature": "(self, node)", "symbol_type": "function"}], "remove_old_intermediate_files": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 160, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "remove_old_intermediate_files", "signature": "(sra_id, work_dir)", "symbol_type": "function"}], "remove_population": [{"docstring": "Remove a population (by position).\n\nArguments:\n - pos - position\n - fname - file to be created with population removed", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/FileParser.py", "line_number": 191, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.FileParser", "name": "remove_population", "signature": "(self, pos, fname)", "symbol_type": "function"}, {"docstring": "Remove a population (by position).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/__init__.py", "line_number": 205, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.__init__", "name": "remove_population", "signature": "(self, pos)", "symbol_type": "function"}], "remove_possible_simple_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 312, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "remove_possible_simple_key", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 312, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "remove_possible_simple_key", "signature": "(self)", "symbol_type": "function"}], "remove_reaction": [{"docstring": "Remove a Reaction element from the pathway.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 125, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "remove_reaction", "signature": "(self, reaction)", "symbol_type": "function"}, {"docstring": "Remove reaction from self.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 184, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "remove_reaction", "signature": "(self, reaction)", "symbol_type": "function"}], "remove_relation": [{"docstring": "Remove a Relation element from the pathway.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 141, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "remove_relation", "signature": "(self, relation)", "symbol_type": "function"}], "remove_specialchars": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 344, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "remove_specialchars", "signature": "(self)", "symbol_type": "function"}], "remove_sra_files": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 137, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "remove_sra_files", "signature": "(metadata, amalgkit_out_dir)", "symbol_type": "function"}], "remove_succ": [{"docstring": "Remove a node id from the node's successors.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 160, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "remove_succ", "signature": "(self, id)", "symbol_type": "function"}], "remove_uncoercible": [{"docstring": "Only keeps the type conversions that are possible\n\nArgs:\n    required_types_classes (tuple): tuple of classes that are required\n                      these should be ordered by COERCION_INDEX_BY_TYPE\n    spec_property_naming (bool): True if the variable names in the input\n        data are serialized names as specified in the OpenAPI document.\n        False if the variables names in the input data are python\n        variable names in PEP-8 snake case.\n    current_item (any): the current item (input data) to be converted\n\nKeyword Args:\n    must_convert (bool): if True the item to convert is of the wrong\n                      type and we want a big list of coercibles\n                      if False, we want a limited list of coercibles\n\nReturns:\n    (list): the remaining coercible required types, classes only", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1079, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "remove_uncoercible", "signature": "(required_types_classes, current_item, spec_property_naming, must_convert = True)", "symbol_type": "function"}], "remove_unpaired_files": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 331, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "remove_unpaired_files", "signature": "(sra_stat)", "symbol_type": "function"}], "removeprefix": [{"docstring": "Remove the prefix if present.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 279, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "removeprefix", "signature": "(self, prefix)", "symbol_type": "function"}, {"docstring": "Return a new Seq object with prefix (left) removed.\n\nThis behaves like the python string method of the same name.\n\ne.g. Removing a start Codon:\n\n>>> from Bio.Seq import Seq\n>>> my_seq = Seq(\"ATGGTGTGTGT\")\n>>> my_seq\nSeq('ATGGTGTGTGT')\n>>> my_seq.removeprefix('ATG')\nSeq('GTGTGTGT')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if\n``removeprefix`` is called on a ``Seq`` object with ``inplace=True``.\n\nSee also the removesuffix method.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1320, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "removeprefix", "signature": "(self, prefix, inplace = False)", "symbol_type": "function"}], "removesuffix": [{"docstring": "Remove the suffix if present.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 292, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "removesuffix", "signature": "(self, suffix)", "symbol_type": "function"}, {"docstring": "Return a new Seq object with suffix (right) removed.\n\nThis behaves like the python string method of the same name.\n\ne.g. Removing a stop codon:\n\n>>> from Bio.Seq import Seq\n>>> my_seq = Seq(\"GTGTGTGTTAG\")\n>>> my_seq\nSeq('GTGTGTGTTAG')\n>>> stop_codon = Seq(\"TAG\")\n>>> my_seq.removesuffix(stop_codon)\nSeq('GTGTGTGT')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if\n``removesuffix`` is called on a ``Seq`` object with ``inplace=True``.\n\nSee also the removeprefix method.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1362, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "removesuffix", "signature": "(self, suffix, inplace = False)", "symbol_type": "function"}, {"docstring": "Remove the suffix from the string, if it exists.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 172, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "removesuffix", "signature": "(string, suffix)", "symbol_type": "function"}], "rename_fastq": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 436, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "rename_fastq", "signature": "(sra_stat, output_dir, inext, outext)", "symbol_type": "function"}], "rename_reads": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 391, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "rename_reads", "signature": "(sra_stat, args, output_dir)", "symbol_type": "function"}], "render_path": [{"docstring": "Returns a string representation of a path", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/exceptions.py", "line_number": 151, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.exceptions", "name": "render_path", "signature": "(path_to_item)", "symbol_type": "function"}], "renumber_tracks": [{"docstring": "Renumber all tracks consecutively.\n\nOptionally from a passed lowest number.\n\nArguments:\n - low     - an integer. The track number to start from.\n - step    - an integer. The track interval for separation of\n   tracks.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Diagram.py", "line_number": 356, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Diagram", "name": "renumber_tracks", "signature": "(self, low = 1, step = 1)", "symbol_type": "function"}], "renyi_entropy": [{"docstring": "Calculate R\u00e9nyi entropy of order \u03b1.\n\nR\u00e9nyi entropy is a generalization of Shannon entropy. When \u03b1=1, it equals\nShannon entropy. When \u03b1=2, it's called collision entropy.\n\nArgs:\n    probs: Probability distribution\n    alpha: Order parameter (\u03b1 > 0, \u03b1 \u2260 1). \u03b1=1 uses Shannon entropy.\n    base: Logarithm base\n    \nReturns:\n    R\u00e9nyi entropy. Formula: H_\u03b1(X) = (1/(1-\u03b1)) \u00d7 log(\u03a3 p_i^\u03b1)\n    \nExamples:\n    >>> probs = [0.5, 0.5]\n    >>> renyi_entropy(probs, alpha=2.0)  # Collision entropy\n    1.0\n    >>> abs(renyi_entropy(probs, alpha=1.0) - shannon_entropy(probs)) < 1e-10\n    True  # \u03b1=1 equals Shannon entropy\n    \nReferences:\n    R\u00e9nyi, A. (1961). On measures of entropy and information.\n    Proceedings of the Fourth Berkeley Symposium on Mathematical Statistics\n    and Probability, 1, 547-561.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 553, "module": "src.metainformant.information.syntactic", "name": "renyi_entropy", "signature": "(probs: Sequence[float], alpha: float = 2.0, base: float = 2.0) -> float", "symbol_type": "function"}], "renyi_spectrum_plot": [{"docstring": "Plot R\u00e9nyi entropy as a function of order \u03b1.\n\nArgs:\n    alpha_range: Range of \u03b1 values\n    entropies: R\u00e9nyi entropy values for each \u03b1\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import renyi_spectrum_plot\n    >>> import numpy as np\n    >>> alpha = [0.1, 0.5, 1.0, 1.5, 2.0, 3.0, 5.0, 10.0]\n    >>> entropies = [2.0, 1.8, 1.5, 1.3, 1.2, 1.0, 0.8, 0.6]\n    >>> ax = renyi_spectrum_plot(alpha, entropies)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/information.py", "line_number": 180, "module": "src.metainformant.visualization.information", "name": "renyi_spectrum_plot", "signature": "(alpha_range: Sequence[float], entropies: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "reorder": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 43, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "reorder", "signature": "(self, omit_misc = False, column_names = column_names)", "symbol_type": "function"}], "replace": [{"docstring": "Return a copy with all occurrences of substring old replaced by new.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 327, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "replace", "signature": "(self, old, new)", "symbol_type": "function"}, {"docstring": "Return a copy with all occurrences of subsequence old replaced by new.\n\n>>> s = Seq(\"ACGTAACCGGTT\")\n>>> t = s.replace(\"AC\", \"XYZ\")\n>>> s\nSeq('ACGTAACCGGTT')\n>>> t\nSeq('XYZGTAXYZCGGTT')\n\nFor mutable sequences, passing inplace=True will modify the sequence in place:\n\n>>> m = MutableSeq(\"ACGTAACCGGTT\")\n>>> t = m.replace(\"AC\", \"XYZ\")\n>>> m\nMutableSeq('ACGTAACCGGTT')\n>>> t\nMutableSeq('XYZGTAXYZCGGTT')\n\n>>> m = MutableSeq(\"ACGTAACCGGTT\")\n>>> t = m.replace(\"AC\", \"XYZ\", inplace=True)\n>>> m\nMutableSeq('XYZGTAXYZCGGTT')\n>>> t\nMutableSeq('XYZGTAXYZCGGTT')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if\n``replace`` is called on a ``Seq`` object with ``inplace=True``.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1954, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "replace", "signature": "(self, old, new, inplace = False)", "symbol_type": "function"}, {"docstring": "Return a copy with all occurrences of substring old replaced by new.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2439, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "replace", "signature": "(self, old, new)", "symbol_type": "function"}, {"docstring": "Return a copy with all occurrences of substring old replaced by new.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2658, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "replace", "signature": "(self, old, new)", "symbol_type": "function"}], "replace_entry": [{"docstring": "Replace an entry in a string by the field number.\n\nNo padding is implemented currently.  Spacing will change if\nthe original field entry and the new field entry are of\ndifferent lengths.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/NMR/xpktools.py", "line_number": 184, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.NMR.xpktools", "name": "replace_entry", "signature": "(line, fieldn, newentry)", "symbol_type": "function"}], "replicator_derivative": [{"docstring": "Calculate continuous-time replicator equation derivative.\n\nReturns the rate of change for each strategy frequency under continuous-time\nreplicator dynamics. Used for continuous-time simulations and stability analysis.\n\nArgs:\n    frequencies: Current strategy frequencies\n    payoff_matrix: Payoff matrix A where A[i][j] is payoff to strategy i\n        when playing against strategy j\n        \nReturns:\n    List of derivatives dx_i/dt for each strategy. Formula:\n    dx_i/dt = x_i \u00d7 [(Ax)_i - x^T A x]\n    \nExamples:\n    >>> freqs = [0.5, 0.3, 0.2]\n    >>> payoff = [[1.0, 0.5], [0.5, 1.0]]\n    >>> derivatives = replicator_derivative(freqs[:2], payoff)\n    >>> len(derivatives)\n    2\n    \nReferences:\n    Hofbauer, J., & Sigmund, K. (1998). Evolutionary games and population\n    dynamics. Cambridge University Press.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/egt.py", "line_number": 50, "module": "src.metainformant.math.egt", "name": "replicator_derivative", "signature": "(frequencies: Iterable[float], payoff_matrix: Iterable[Iterable[float]]) -> list[float]", "symbol_type": "function"}], "replicator_step": [{"docstring": "Perform one discrete-time step of the replicator equation.\n\nThe replicator equation models frequency-dependent selection in evolutionary\ngame theory. Strategies with above-average payoffs increase in frequency.\n\nArgs:\n    frequencies: Current strategy frequencies (must sum to 1)\n    payoff_matrix: Payoff matrix A where A[i][j] is payoff to strategy i\n        when playing against strategy j\n        \nReturns:\n    Updated frequencies after one generation, renormalized to sum to 1.\n    Formula: x_i' = x_i \u00d7 (Ax)_i / (x^T A x)\n    \nExamples:\n    >>> freqs = [0.5, 0.3, 0.2]\n    >>> payoff = [[1.0, 0.5, 0.3], [0.5, 1.0, 0.7], [0.3, 0.7, 1.0]]\n    >>> new_freqs = replicator_step(freqs, payoff)\n    >>> abs(sum(new_freqs) - 1.0) < 1e-10\n    True\n    \nReferences:\n    Hofbauer, J., & Sigmund, K. (1998). Evolutionary games and population\n    dynamics. Cambridge University Press.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/egt.py", "line_number": 6, "module": "src.metainformant.math.egt", "name": "replicator_step", "signature": "(frequencies: Iterable[float], payoff_matrix: Iterable[Iterable[float]]) -> list[float]", "symbol_type": "function"}], "report_IC": [{"docstring": "Generate dict with counts of ic data elements for each entity level.\n\nreportDict entries are:\n    - idcode : PDB ID\n    - hdr : PDB header lines\n    - mdl : models\n    - chn : chains\n    - res : residue objects\n    - res_e : residues with dihedra and/or hedra\n    - dih : dihedra\n    - hed : hedra\n\n:param Entity entity: Biopython PDB Entity object: S, M, C or R\n:raises PDBException: if entity level not S, M, C, or R\n:raises Exception: if entity does not have .level attribute\n:returns: dict with counts of IC data elements", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/ic_rebuild.py", "line_number": 72, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.ic_rebuild", "name": "report_IC", "signature": "(entity: Structure | Model | Chain | Residue, reportDict: dict[str, Any] = None, verbose: bool = False) -> dict[str, Any]", "symbol_type": "function"}], "represent": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 26, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 26, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent", "signature": "(self, data)", "symbol_type": "function"}], "represent_binary": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 150, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_binary", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 150, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_binary", "signature": "(self, data)", "symbol_type": "function"}], "represent_bool": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 157, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_bool", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 157, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_bool", "signature": "(self, data)", "symbol_type": "function"}], "represent_complex": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 274, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_complex", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 274, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_complex", "signature": "(self, data)", "symbol_type": "function"}], "represent_data": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 33, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_data", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 33, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_data", "signature": "(self, data)", "symbol_type": "function"}], "represent_date": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 215, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_date", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 215, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_date", "signature": "(self, data)", "symbol_type": "function"}], "represent_datetime": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 219, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_datetime", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 219, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_datetime", "signature": "(self, data)", "symbol_type": "function"}], "represent_dict": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 206, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_dict", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 206, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_dict", "signature": "(self, data)", "symbol_type": "function"}], "represent_float": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 171, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_float", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 171, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_float", "signature": "(self, data)", "symbol_type": "function"}], "represent_int": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 164, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_int", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 164, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_int", "signature": "(self, data)", "symbol_type": "function"}], "represent_list": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 191, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_list", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 191, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_list", "signature": "(self, data)", "symbol_type": "function"}], "represent_mapping": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 103, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_mapping", "signature": "(self, tag, mapping, flow_style = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 103, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_mapping", "signature": "(self, tag, mapping, flow_style = None)", "symbol_type": "function"}], "represent_module": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 292, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_module", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 292, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_module", "signature": "(self, data)", "symbol_type": "function"}], "represent_name": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 288, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_name", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 288, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_name", "signature": "(self, data)", "symbol_type": "function"}], "represent_none": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 144, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_none", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 144, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_none", "signature": "(self, data)", "symbol_type": "function"}], "represent_object": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 296, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_object", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 296, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_object", "signature": "(self, data)", "symbol_type": "function"}], "represent_ordered_dict": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 358, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_ordered_dict", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 358, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_ordered_dict", "signature": "(self, data)", "symbol_type": "function"}], "represent_scalar": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 77, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_scalar", "signature": "(self, tag, value, style = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 77, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_scalar", "signature": "(self, tag, value, style = None)", "symbol_type": "function"}], "represent_sequence": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 85, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_sequence", "signature": "(self, tag, sequence, flow_style = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 85, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_sequence", "signature": "(self, tag, sequence, flow_style = None)", "symbol_type": "function"}], "represent_set": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 209, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_set", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 209, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_set", "signature": "(self, data)", "symbol_type": "function"}], "represent_str": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 147, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_str", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 147, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_str", "signature": "(self, data)", "symbol_type": "function"}], "represent_tuple": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 285, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_tuple", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 285, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_tuple", "signature": "(self, data)", "symbol_type": "function"}], "represent_undefined": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 230, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_undefined", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 230, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_undefined", "signature": "(self, data)", "symbol_type": "function"}], "represent_yaml_object": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/representer.py", "line_number": 223, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.representer", "name": "represent_yaml_object", "signature": "(self, tag, data, cls, flow_style = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/representer.py", "line_number": 223, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.representer", "name": "represent_yaml_object", "signature": "(self, tag, data, cls, flow_style = None)", "symbol_type": "function"}], "request": [{"docstring": "Makes the HTTP request using RESTClient.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 429, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "request", "signature": "(self, method, url, query_params = None, headers = None, post_params = None, body = None, _preload_content = True, _request_timeout = None)", "symbol_type": "function"}, {"docstring": "Perform requests.\n\n:param method: http request method\n:param url: http request url\n:param query_params: query parameters in the url\n:param headers: http request headers\n:param body: request json body, for `application/json`\n:param post_params: request post parameters,\n                    `application/x-www-form-urlencoded`\n                    and `multipart/form-data`\n:param _preload_content: if False, the urllib3.HTTPResponse object will\n                         be returned without reading/decoding response\n                         data. Default is True.\n:param _request_timeout: timeout setting for this request. If one\n                         number provided, it will be total request\n                         timeout. It can also be a pair (tuple) of\n                         (connection, read) timeouts.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/rest.py", "line_number": 98, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.rest", "name": "request", "signature": "(self, method, url, query_params = None, headers = None, body = None, post_params = None, _preload_content = True, _request_timeout = None)", "symbol_type": "function"}], "reset": [{"docstring": "Reset all the data allowing reuse of the BlastParser() object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIXML.py", "line_number": 618, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIXML", "name": "reset", "signature": "(self)", "symbol_type": "function"}], "reset_style": [{"docstring": "Reset matplotlib style to default.\n\nExample:\n    >>> from metainformant.visualization.style import reset_style\n    >>> reset_style()", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/style.py", "line_number": 138, "module": "src.metainformant.visualization.style", "name": "reset_style", "signature": "() -> None", "symbol_type": "function"}], "reshape": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Affy/CelFile.py", "line_number": 266, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Affy.CelFile", "name": "reshape", "signature": "(array)", "symbol_type": "function"}], "resid2code": [{"docstring": "Serialize a residue's resseq and icode for easy comparison.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/DSSP.py", "line_number": 409, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.DSSP", "name": "resid2code", "signature": "(res_id)", "symbol_type": "function"}], "residual_plot": [{"docstring": "Create a residual plot for regression diagnostics.\n\nArgs:\n    y_true: True values\n    y_pred: Predicted values\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments for scatter\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import residual_plot\n    >>> import numpy as np\n    >>> y_true = np.array([1, 2, 3, 4, 5])\n    >>> y_pred = np.array([1.1, 1.9, 3.2, 3.8, 5.1])\n    >>> ax = residual_plot(y_true, y_pred)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/statistical.py", "line_number": 490, "module": "src.metainformant.visualization.statistical", "name": "residual_plot", "signature": "(y_true: Sequence[float], y_pred: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "residue_depth": [{"docstring": "Residue depth as average depth of all its atoms.\n\nReturn average distance to surface for all atoms in a residue,\nie. the residue depth.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/ResidueDepth.py", "line_number": 563, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.ResidueDepth", "name": "residue_depth", "signature": "(residue, surface)", "symbol_type": "function"}], "residue_dict": [{"docstring": "Return a dict of lines in 'data' indexed by residue number or a nucleus.\n\nThe nucleus should be given as the input argument in the same form as\nit appears in the xpk label line (H1, 15N for example)\n\nParameters\n----------\nindex : str\n    The nucleus to index data by.\n\nReturns\n-------\nresdict : dict\n    Mappings of index nucleus to data line.\n\nExamples\n--------\n>>> from Bio.NMR.xpktools import Peaklist\n>>> peaklist = Peaklist('../Doc/examples/nmr/noed.xpk')\n>>> residue_d = peaklist.residue_dict('H1')\n>>> sorted(residue_d.keys())\n['10', '3', '4', '5', '6', '7', '8', '9', 'maxres', 'minres']\n>>> residue_d['10']\n['8  10.hn   7.663   0.021   0.010   ++   0.000   10.n   118.341   0.324   0.010   +E   0.000   10.n   118.476   0.324   0.010   +E   0.000  0.49840 0.49840 0']", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/NMR/xpktools.py", "line_number": 108, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.NMR.xpktools", "name": "residue_dict", "signature": "(self, index)", "symbol_type": "function"}], "residue_type": [{"docstring": "Record the sequence type (SEMI-OBSOLETE).\n\nThis reflects the fact that the topology (linear/circular) and\nmolecule type (e.g. DNA vs RNA) were a single field in early\nfiles. Current GenBank/EMBL files have two fields.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 332, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "residue_type", "signature": "(self, type)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 912, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "residue_type", "signature": "(self, content)", "symbol_type": "function"}], "resolve": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/resolver.py", "line_number": 143, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.resolver", "name": "resolve", "signature": "(self, kind, value, implicit)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/resolver.py", "line_number": 143, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.resolver", "name": "resolve", "signature": "(self, kind, value, implicit)", "symbol_type": "function"}], "resolve_link_path": [{"docstring": "Resolve a relative link path.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/triple_check_rna.py", "line_number": 168, "module": "scripts.triple_check_rna", "name": "resolve_link_path", "signature": "(base_file: Path, link_path: str) -> Path", "symbol_type": "function"}], "resolve_uri": [{"docstring": "Convert prefixed URIs to full URIs.\n\nOptionally, converts CDAO named identifiers to OBO numeric identifiers.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_cdao_owl.py", "line_number": 18, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._cdao_owl", "name": "resolve_uri", "signature": "(s, namespaces = cdao_namespaces, cdao_to_obo = True, xml_style = False)", "symbol_type": "function"}], "rest": [{"docstring": "Return the rest of the string without parsing.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 171, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "rest", "signature": "(self)", "symbol_type": "function"}], "restructure": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1596, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "restructure", "signature": "(self, x, y, z)", "symbol_type": "function"}], "retrieve_assembly_file": [{"docstring": "Fetch one or more assembly structures associated with a PDB entry.\n\nUnless noted below, parameters are described in ``retrieve_pdb_file``.\n\n:type  assembly_num: str\n:param assembly_num: assembly number to download.\n\n:rtype : str\n:return: file name of the downloaded assembly file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 505, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "retrieve_assembly_file", "signature": "(self, pdb_code, assembly_num, pdir = None, file_format = None, overwrite = False)", "symbol_type": "function"}], "retrieve_pdb_file": [{"docstring": "Fetch PDB structure file from PDB server, and store it locally.\n\nThe PDB structure's file name is returned as a single string.\nIf obsolete ``==`` True, the file will be saved in a special file tree.\n\nNOTE. The default download format has changed from PDB to PDBx/mmCif\n\n:param pdb_code: 4-symbols structure Id from PDB (e.g. 3J92).\n:type pdb_code: string\n\n:param file_format:\n    File format. Available options:\n\n    * \"mmCif\" (default, PDBx/mmCif file),\n    * \"pdb\" (format PDB),\n    * \"xml\" (PDBML/XML format),\n    * \"mmtf\" (highly compressed),\n    * \"bundle\" (PDB formatted archive for large structure)\n\n:type file_format: string\n\n:param overwrite: if set to True, existing structure files will be overwritten. Default: False\n:type overwrite: bool\n\n:param obsolete:\n    Has a meaning only for obsolete structures. If True, download the obsolete structure\n    to 'obsolete' folder, otherwise download won't be performed.\n    This option doesn't work for mmtf format as obsoleted structures aren't stored in mmtf.\n    Also doesn't have meaning when parameter pdir is specified.\n    Note: make sure that you are about to download the really obsolete structure.\n    Trying to download non-obsolete structure into obsolete folder will not work\n    and you face the \"structure doesn't exists\" error.\n    Default: False\n\n:type obsolete: bool\n\n:param pdir: put the file in this directory (default: create a PDB-style directory tree)\n:type pdir: string\n\n:return: filename\n:rtype: string", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 222, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "retrieve_pdb_file", "signature": "(self, pdb_code, obsolete = False, pdir = None, file_format = None, overwrite = False)", "symbol_type": "function"}], "retry_with_backoff": [{"docstring": "Decorator for retrying functions with exponential backoff.\n\nArgs:\n    max_attempts: Maximum number of retry attempts\n    initial_delay: Initial delay in seconds before first retry\n    backoff_factor: Multiplier for delay between retries\n    max_delay: Maximum delay in seconds between retries\n    exceptions: Tuple of exception types to catch and retry on\n\nReturns:\n    Decorated function that retries on specified exceptions\n\nExample:\n    @retry_with_backoff(max_attempts=5, initial_delay=2.0)\n    def download_file(url):\n        # This will retry up to 5 times with exponential backoff\n        return requests.get(url)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/errors.py", "line_number": 102, "module": "src.metainformant.core.errors", "name": "retry_with_backoff", "signature": "(max_attempts: int = 3, initial_delay: float = 1.0, backoff_factor: float = 2.0, max_delay: float = 60.0, exceptions: tuple[type[Exception], ...] = (Exception,))", "symbol_type": "function"}], "reverse": [{"docstring": "Modify the mutable sequence to reverse itself.\n\nNo return value.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2321, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "reverse", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a new Reaction that is the reverse of self.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 139, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "reverse", "signature": "(self)", "symbol_type": "function"}], "reverse_complement": [{"docstring": "Compute reverse complement of a DNA sequence.\n\nArgs:\n    seq: DNA sequence string\n    \nReturns:\n    Reverse complement sequence", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 18, "module": "src.metainformant.dna.sequences", "name": "reverse_complement", "signature": "(seq: str) -> str", "symbol_type": "function"}, {"docstring": "Return the reverse complement as a DNA sequence.\n\nIf given a string, returns a new string object.\nGiven a Seq object, returns a new Seq object.\nGiven a MutableSeq, returns a new MutableSeq object.\nGiven a SeqRecord object, returns a new SeqRecord object.\n\n>>> my_seq = \"CGA\"\n>>> reverse_complement(my_seq)\n'TCG'\n>>> my_seq = Seq(\"CGA\")\n>>> reverse_complement(my_seq)\nSeq('TCG')\n>>> my_seq = MutableSeq(\"CGA\")\n>>> reverse_complement(my_seq)\nMutableSeq('TCG')\n>>> my_seq\nMutableSeq('CGA')\n\nAny U in the sequence is treated as a T:\n\n>>> reverse_complement(Seq(\"CGAUT\"))\nSeq('AATCG')\n\nIn contrast, ``reverse_complement_rna`` returns an RNA sequence:\n\n>>> reverse_complement_rna(Seq(\"CGAUT\"))\nSeq('AAUCG')\n\nSupports and lower- and upper-case characters, and unambiguous and\nambiguous nucleotides. All other characters are not converted:\n\n>>> reverse_complement(\"ACGTUacgtuXYZxyz\")\n'zrxZRXaacgtAACGT'\n\nThe sequence is modified in-place and returned if inplace is True:\n\n>>> my_seq = MutableSeq(\"CGA\")\n>>> reverse_complement(my_seq, inplace=True)\nMutableSeq('TCG')\n>>> my_seq\nMutableSeq('TCG')\n\nAs strings and ``Seq`` objects are immutable, a ``TypeError`` is\nraised if ``reverse_complement`` is called on a ``Seq`` object with\n``inplace=True``.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 3019, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "reverse_complement", "signature": "(sequence, inplace = False)", "symbol_type": "function"}, {"docstring": "Return the reverse complement as a DNA sequence.\n\n>>> Seq(\"CGA\").reverse_complement()\nSeq('TCG')\n\nAny U in the sequence is treated as a T:\n\n>>> Seq(\"CGAUT\").reverse_complement()\nSeq('AATCG')\n\nIn contrast, ``reverse_complement_rna`` returns an RNA sequence:\n\n>>> Seq(\"CGA\").reverse_complement_rna()\nSeq('UCG')\n\nThe sequence is modified in-place and returned if inplace is True:\n\n>>> my_seq = MutableSeq(\"CGA\")\n>>> my_seq\nMutableSeq('CGA')\n>>> my_seq.reverse_complement()\nMutableSeq('TCG')\n>>> my_seq\nMutableSeq('CGA')\n\n>>> my_seq.reverse_complement(inplace=True)\nMutableSeq('TCG')\n>>> my_seq\nMutableSeq('TCG')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if\n``reverse_complement`` is called on a ``Seq`` object with\n``inplace=True``.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1718, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "reverse_complement", "signature": "(self, inplace = False)", "symbol_type": "function"}, {"docstring": "Return new SeqRecord with reverse complement sequence.\n\nBy default the new record does NOT preserve the sequence identifier,\nname, description, general annotation or database cross-references -\nthese are unlikely to apply to the reversed sequence.\n\nYou can specify the returned record's id, name and description as\nstrings, or True to keep that of the parent, or False for a default.\n\nYou can specify the returned record's features with a list of\nSeqFeature objects, or True to keep that of the parent, or False to\nomit them. The default is to keep the original features (with the\nstrand and locations adjusted).\n\nYou can also specify both the returned record's annotations and\nletter_annotations as dictionaries, True to keep that of the parent,\nor False to omit them. The default is to keep the original\nannotations (with the letter annotations reversed).\n\nTo show what happens to the pre-letter annotations, consider an\nexample Solexa variant FASTQ file with a single entry, which we'll\nread in as a SeqRecord:\n\n>>> from Bio import SeqIO\n>>> record = SeqIO.read(\"Quality/solexa_faked.fastq\", \"fastq-solexa\")\n>>> print(\"%s %s\" % (record.id, record.seq))\nslxa_0001_1_0001_01 ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTNNNNNN\n>>> print(list(record.letter_annotations))\n['solexa_quality']\n>>> print(record.letter_annotations[\"solexa_quality\"])\n[40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5]\n\nNow take the reverse complement, here we explicitly give a new\nidentifier (the old identifier with a suffix):\n\n>>> rc_record = record.reverse_complement(id=record.id + \"_rc\")\n>>> print(\"%s %s\" % (rc_record.id, rc_record.seq))\nslxa_0001_1_0001_01_rc NNNNNNACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT\n\nNotice that the per-letter-annotations have also been reversed,\nalthough this may not be appropriate for all cases.\n\n>>> print(rc_record.letter_annotations[\"solexa_quality\"])\n[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]\n\nNow for the features, we need a different example. Parsing a GenBank\nfile is probably the easiest way to get an nice example with features\nin it...\n\n>>> from Bio import SeqIO\n>>> with open(\"GenBank/pBAD30.gb\") as handle:\n...     plasmid = SeqIO.read(handle, \"gb\")\n>>> print(\"%s %i\" % (plasmid.id, len(plasmid)))\npBAD30 4923\n>>> plasmid.seq\nSeq('GCTAGCGGAGTGTATACTGGCTTACTATGTTGGCACTGATGAGGGTGTCAGTGA...ATG')\n>>> len(plasmid.features)\n13\n\nNow, let's take the reverse complement of this whole plasmid:\n\n>>> rc_plasmid = plasmid.reverse_complement(id=plasmid.id+\"_rc\")\n>>> print(\"%s %i\" % (rc_plasmid.id, len(rc_plasmid)))\npBAD30_rc 4923\n>>> rc_plasmid.seq\nSeq('CATGGGCAAATATTATACGCAAGGCGACAAGGTGCTGATGCCGCTGGCGATTCA...AGC')\n>>> len(rc_plasmid.features)\n13\n\nLet's compare the first CDS feature - it has gone from being the\nsecond feature (index 1) to the second last feature (index -2), its\nstrand has changed, and the location switched round.\n\n>>> print(plasmid.features[1])\ntype: CDS\nlocation: [1081:1960](-)\nqualifiers:\n    Key: label, Value: ['araC']\n    Key: note, Value: ['araC regulator of the arabinose BAD promoter']\n    Key: vntifkey, Value: ['4']\n<BLANKLINE>\n>>> print(rc_plasmid.features[-2])\ntype: CDS\nlocation: [2963:3842](+)\nqualifiers:\n    Key: label, Value: ['araC']\n    Key: note, Value: ['araC regulator of the arabinose BAD promoter']\n    Key: vntifkey, Value: ['4']\n<BLANKLINE>\n\nYou can check this new location, based on the length of the plasmid:\n\n>>> len(plasmid) - 1081\n3842\n>>> len(plasmid) - 1960\n2963\n\nNote that if the SeqFeature annotation includes any strand specific\ninformation (e.g. base changes for a SNP), this information is not\namended, and would need correction after the reverse complement.\n\nNote trying to reverse complement a protein SeqRecord raises an\nexception:\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqRecord import SeqRecord\n>>> protein_rec = SeqRecord(Seq(\"MAIVMGR\"), id=\"Test\",\n...                         annotations={\"molecule_type\": \"protein\"})\n>>> protein_rec.reverse_complement()\nTraceback (most recent call last):\n   ...\nValueError: Proteins do not have complements!\n\nIf you have RNA without any U bases, it must be annotated as RNA\notherwise it will be treated as DNA by default with A mapped to T:\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqRecord import SeqRecord\n>>> rna1 = SeqRecord(Seq(\"ACG\"), id=\"Test\")\n>>> rna2 = SeqRecord(Seq(\"ACG\"), id=\"Test\", annotations={\"molecule_type\": \"RNA\"})\n>>> print(rna1.reverse_complement(id=\"RC\", description=\"unk\").format(\"fasta\"))\n>RC unk\nCGT\n<BLANKLINE>\n>>> print(rna2.reverse_complement(id=\"RC\", description=\"RNA\").format(\"fasta\"))\n>RC RNA\nCGU\n<BLANKLINE>\n\nAlso note you can reverse complement a SeqRecord using a MutableSeq:\n\n>>> from Bio.Seq import MutableSeq\n>>> from Bio.SeqRecord import SeqRecord\n>>> rec = SeqRecord(MutableSeq(\"ACGT\"), id=\"Test\")\n>>> rec.seq[0] = \"T\"\n>>> print(\"%s %s\" % (rec.id, rec.seq))\nTest TCGT\n>>> rc = rec.reverse_complement(id=True)\n>>> print(\"%s %s\" % (rc.id, rc.seq))\nTest ACGA", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 1202, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "reverse_complement", "signature": "(self, id: bool = False, name: bool = False, description: bool = False, features: bool = True, annotations: bool = False, letter_annotations: bool = True, dbxrefs: bool = False) -> 'SeqRecord'", "symbol_type": "function"}, {"docstring": "Reverse-complement the alignment and return it.\n\n>>> sequences = [\"ATCG\", \"AAG\", \"ATC\"]\n>>> coordinates = np.array([[0, 2, 3, 4], [0, 2, 2, 3], [0, 2, 3, 3]])\n>>> alignment = Alignment(sequences, coordinates)\n>>> print(alignment)\n                  0 ATCG 4\n                  0 AA-G 3\n                  0 ATC- 3\n<BLANKLINE>\n>>> rc_alignment = alignment.reverse_complement()\n>>> print(rc_alignment)\n                  0 CGAT 4\n                  0 C-TT 3\n                  0 -GAT 3\n<BLANKLINE>\n\nThe attribute `column_annotations`, if present, is associated with the\nreverse-complemented alignment, with its values in reverse order.\n\n>>> alignment.column_annotations = {\"score\": [3, 2, 2, 2]}\n>>> rc_alignment = alignment.reverse_complement()\n>>> print(rc_alignment.column_annotations)\n{'score': [2, 2, 2, 3]}", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 3977, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "reverse_complement", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the reverse complement of the motif as a new motif.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/__init__.py", "line_number": 377, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.__init__", "name": "reverse_complement", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Compute reverse complement.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 301, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "reverse_complement", "signature": "(self)", "symbol_type": "function"}], "reverse_complement_rna": [{"docstring": "Return the reverse complement as an RNA sequence.\n\nIf given a string, returns a new string object.\nGiven a Seq object, returns a new Seq object.\nGiven a MutableSeq, returns a new MutableSeq object.\nGiven a SeqRecord object, returns a new SeqRecord object.\n\n>>> my_seq = \"CGA\"\n>>> reverse_complement_rna(my_seq)\n'UCG'\n>>> my_seq = Seq(\"CGA\")\n>>> reverse_complement_rna(my_seq)\nSeq('UCG')\n>>> my_seq = MutableSeq(\"CGA\")\n>>> reverse_complement_rna(my_seq)\nMutableSeq('UCG')\n>>> my_seq\nMutableSeq('CGA')\n\nAny T in the sequence is treated as a U:\n\n>>> reverse_complement_rna(Seq(\"CGAUT\"))\nSeq('AAUCG')\n\nIn contrast, ``reverse_complement`` returns a DNA sequence:\n\n>>> reverse_complement(Seq(\"CGAUT\"), inplace=False)\nSeq('AATCG')\n\nSupports and lower- and upper-case characters, and unambiguous and\nambiguous nucleotides. All other characters are not converted:\n\n>>> reverse_complement_rna(\"ACGTUacgtuXYZxyz\")\n'zrxZRXaacguAACGU'\n\nThe sequence is modified in-place and returned if inplace is True:\n\n>>> my_seq = MutableSeq(\"CGA\")\n>>> reverse_complement_rna(my_seq, inplace=True)\nMutableSeq('UCG')\n>>> my_seq\nMutableSeq('UCG')\n\nAs strings and ``Seq`` objects are immutable, a ``TypeError`` is\nraised if ``reverse_complement`` is called on a ``Seq`` object with\n``inplace=True``.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 3084, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "reverse_complement_rna", "signature": "(sequence, inplace = False)", "symbol_type": "function"}, {"docstring": "Return the reverse complement as an RNA sequence.\n\n>>> Seq(\"CGA\").reverse_complement_rna()\nSeq('UCG')\n\nAny T in the sequence is treated as a U:\n\n>>> Seq(\"CGAUT\").reverse_complement_rna()\nSeq('AAUCG')\n\nIn contrast, ``reverse_complement`` returns a DNA sequence:\n\n>>> Seq(\"CGA\").reverse_complement()\nSeq('TCG')\n\nThe sequence is modified in-place and returned if inplace is True:\n\n>>> my_seq = MutableSeq(\"CGA\")\n>>> my_seq\nMutableSeq('CGA')\n>>> my_seq.reverse_complement_rna()\nMutableSeq('UCG')\n>>> my_seq\nMutableSeq('CGA')\n\n>>> my_seq.reverse_complement_rna(inplace=True)\nMutableSeq('UCG')\n>>> my_seq\nMutableSeq('UCG')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if\n``reverse_complement_rna`` is called on a ``Seq`` object with\n``inplace=True``.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1766, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "reverse_complement_rna", "signature": "(self, inplace = False)", "symbol_type": "function"}], "reverse_transcribe_rna_to_dna": [{"docstring": "Reverse transcribe RNA to DNA (U->T). Preserves case; non-AUGC characters pass through.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/transcription.py", "line_number": 35, "module": "src.metainformant.dna.transcription", "name": "reverse_transcribe_rna_to_dna", "signature": "(seq: str) -> str", "symbol_type": "function"}], "rewind": [{"docstring": "Rewind the iterator to let it loop over the alignments from the beginning.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 4049, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "rewind", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 4071, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "rewind", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 4155, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "rewind", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/interfaces.py", "line_number": 191, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.interfaces", "name": "rewind", "signature": "(self)", "symbol_type": "function"}], "rfind": [{"docstring": "Return the highest index in data where subsection sub is found.\n\nReturn the highest index in data where subsection sub is found,\nsuch that sub is contained within data[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 179, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "rfind", "signature": "(self, sub, start = None, end = None)", "symbol_type": "function"}, {"docstring": "Return the highest index in the sequence where subsequence sub is found.\n\nWith optional arguments start and end, return the highest index in the\nsequence such that the subsequence sub is contained within the sequence\nregion [start:end].\n\nArguments:\n - sub - a string or another Seq or MutableSeq object to search for\n - start - optional integer, slice start\n - end - optional integer, slice end\n\nReturns -1 if the subsequence is NOT found.\n\ne.g. Locating the last typical start codon, AUG, in an RNA sequence:\n\n>>> from Bio.Seq import Seq\n>>> my_rna = Seq(\"GUCAUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAGUUG\")\n>>> my_rna.rfind(\"AUG\")\n15\n\nThe location of the typical start codon before that can be found by\nending the search at position 15:\n\n>>> my_rna.rfind(\"AUG\", end=15)\n3\n\nSee the ``search`` method to find the locations of multiple subsequences\nat the same time.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 818, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "rfind", "signature": "(self, sub, start = None, end = None)", "symbol_type": "function"}], "ribosome_profiling_integration": [{"docstring": "Integrate ribosome profiling data with RNA expression.\n\nRibosome profiling (Ribo-seq) measures actively translated mRNAs.\nThis function integrates Ribo-seq data with RNA-seq to identify\ntranslationally regulated genes.\n\nArgs:\n    rna_expression: RNA-seq expression data (samples x genes)\n    ribo_profiling: Ribo-seq profiling data (samples x genes)\n    gene_annotations: Optional gene annotations with 'gene_id', 'cds_length' columns\n    \nReturns:\n    DataFrame with integrated metrics:\n    - 'gene_id': Gene identifier\n    - 'rna_level': RNA expression level\n    - 'ribo_level': Ribosome profiling level\n    - 'translation_rate': Ribo/RNA ratio\n    - 'translationally_regulated': Boolean indicating translational regulation", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/protein_integration.py", "line_number": 195, "module": "src.metainformant.rna.protein_integration", "name": "ribosome_profiling_integration", "signature": "(rna_expression: pd.DataFrame, ribo_profiling: pd.DataFrame, gene_annotations: pd.DataFrame | None = None) -> pd.DataFrame", "symbol_type": "function"}], "richards": [{"docstring": "Richards growth model (equivalent to Stannard).\n\nProposed in Zwietering et al., 1990 (PMID: 16348228)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/pm_fitting.py", "line_number": 57, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.pm_fitting", "name": "richards", "signature": "(x, A, u, d, v, y0)", "symbol_type": "function"}], "ridge_plot": [{"docstring": "Create a ridge plot (overlapping density plots).\n\nArgs:\n    data: List of data arrays\n    labels: Labels for each distribution\n    ax: Matplotlib axes (creates new if None)\n    overlap: Overlap factor between plots (0-1)\n    **kwargs: Additional arguments for density plots\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import ridge_plot\n    >>> import numpy as np\n    >>> data = [np.random.normal(i, 1, 100) for i in range(3)]\n    >>> ax = ridge_plot(data, labels=[\"A\", \"B\", \"C\"])", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/statistical.py", "line_number": 344, "module": "src.metainformant.visualization.statistical", "name": "ridge_plot", "signature": "(data: list[Sequence[float]], labels: list[str] | None = None, **kwargs) -> plt.Axes", "symbol_type": "function"}], "right_multiply": [{"docstring": "Return Vector=Vector x Matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 373, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "right_multiply", "signature": "(self, matrix)", "symbol_type": "function"}], "rindex": [{"docstring": "Return the highest index in data where subsection sub is found.\n\nReturn the highest index in data where subsection sub is found,\nsuch that sub is contained within data[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaise ValueError when the subsection is not found.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 201, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "rindex", "signature": "(self, sub, start = None, end = None)", "symbol_type": "function"}, {"docstring": "Return the highest index in the sequence where subsequence sub is found.\n\nWith optional arguments start and end, return the highest index in the\nsequence such that the subsequence sub is contained within the sequence\nregion [start:end].\n\nArguments:\n - sub - a string or another Seq or MutableSeq object to search for\n - start - optional integer, slice start\n - end - optional integer, slice end\n\nReturns -1 if the subsequence is NOT found.\n\ne.g. Locating the last typical start codon, AUG, in an RNA sequence:\n\n>>> from Bio.Seq import Seq\n>>> my_rna = Seq(\"GUCAUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAGUUG\")\n>>> my_rna.rindex(\"AUG\")\n15\n\nThe location of the typical start codon before that can be found by\nending the search at position 15:\n\n>>> my_rna.rindex(\"AUG\", end=15)\n3\n\nThis method performs the same search as the ``rfind`` method.  However,\nif the subsequence is not found, ``rfind`` returns -1 which ``rindex``\nraises a ValueError:\n\n>>> my_rna.rindex(\"T\")\nTraceback (most recent call last):\n           ...\nValueError: ...\n>>> my_rna.rfind(\"T\")\n-1\n\nSee the ``search`` method to find the locations of multiple subsequences\nat the same time.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 913, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "rindex", "signature": "(self, sub, start = None, end = None)", "symbol_type": "function"}], "rint": [{"docstring": "Print number with declared precision.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/pairwise2.py", "line_number": 1251, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.pairwise2", "name": "rint", "signature": "(x, precision = _PRECISION)", "symbol_type": "function"}], "rna_integration": [{"docstring": "Information-theoretic analysis of RNA expression data.\n\nArgs:\n    expression_data: Expression matrix (samples x genes)\n    gene_names: Optional list of gene names\n    method: Analysis method (\"entropy\", \"mutual_information\")\n    \nReturns:\n    Analysis results dictionary\n    \nExamples:\n    >>> import numpy as np\n    >>> expression = np.random.randn(100, 50)  # 100 samples, 50 genes\n    >>> results = rna_integration(expression, method=\"entropy\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/integration.py", "line_number": 167, "module": "src.metainformant.information.integration", "name": "rna_integration", "signature": "(expression_data: np.ndarray, gene_names: list[str] | None = None, method: str = 'entropy') -> dict[str, Any]", "symbol_type": "function"}], "roc_curve": [{"docstring": "Create a ROC curve plot.\n\nArgs:\n    y_true: True binary labels\n    y_scores: Predicted scores/probabilities\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments for plot\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import roc_curve\n    >>> import numpy as np\n    >>> y_true = [0, 1, 0, 1, 1]\n    >>> y_scores = [0.1, 0.9, 0.2, 0.8, 0.7]\n    >>> ax = roc_curve(y_true, y_scores)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/statistical.py", "line_number": 397, "module": "src.metainformant.visualization.statistical", "name": "roc_curve", "signature": "(y_true: Sequence[int], y_scores: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "rollback": [{"docstring": "Roll-back the current transaction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 288, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "rollback", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Roll-back the current transaction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 371, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "rollback", "signature": "(self)", "symbol_type": "function"}], "root": [{"docstring": "Allow TreeMixin methods to traverse clades properly.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 1049, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "root", "signature": "(self)", "symbol_type": "function"}], "root_at_midpoint": [{"docstring": "Root the tree at the midpoint of the two most distant taxa.\n\nThis operates in-place, leaving a bifurcating root. The topology of the\ntree is otherwise retained, though no guarantees are made about the\nstability of clade/node/taxon ordering.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 902, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "root_at_midpoint", "signature": "(self)", "symbol_type": "function"}], "root_with_outgroup": [{"docstring": "Define a tree's root with a reference group outgroup.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 799, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "root_with_outgroup", "signature": "(self, outgroup = None)", "symbol_type": "function"}, {"docstring": "Reroot this tree with the outgroup clade containing outgroup_targets.\n\nOperates in-place.\n\nEdge cases:\n - If ``outgroup == self.root``, no change\n - If outgroup is terminal, create new bifurcating root node with a\n   0-length branch to the outgroup\n - If outgroup is internal, use the given outgroup node as the new\n   trifurcating root, keeping branches the same\n - If the original root was bifurcating, drop it from the tree,\n   preserving total branch lengths\n\n:param outgroup_branch_length: length of the branch leading to the\n    outgroup after rerooting. If not specified (None), then:\n\n    - If the outgroup is an internal node (not a single terminal taxon),\n      then use that node as the new root.\n    - Otherwise, create a new root node as the parent of the outgroup.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 807, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "root_with_outgroup", "signature": "(self, outgroup_targets, *more_targets)", "symbol_type": "function"}], "rotaxis2m": [{"docstring": "Calculate left multiplying rotation matrix.\n\nCalculate a left multiplying rotation matrix that rotates\ntheta rad around vector.\n\n:type theta: float\n:param theta: the rotation angle\n\n:type vector: L{Vector}\n:param vector: the rotation axis\n\n:return: The rotation matrix, a 3x3 NumPy array.\n\nExamples\n--------\n>>> from numpy import pi\n>>> from Bio.PDB.vectors import rotaxis2m\n>>> from Bio.PDB.vectors import Vector\n>>> m = rotaxis2m(pi, Vector(1, 0, 0))\n>>> Vector(1, 2, 3).left_multiply(m)\n<Vector 1.00, -2.00, -3.00>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 101, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "rotaxis2m", "signature": "(theta, vector)", "symbol_type": "function"}], "rotmat": [{"docstring": "Return a (left multiplying) matrix that rotates p onto q.\n\n:param p: moving vector\n:type p: L{Vector}\n\n:param q: fixed vector\n:type q: L{Vector}\n\n:return: rotation matrix that rotates p onto q\n:rtype: 3x3 NumPy array\n\nExamples\n--------\n>>> from Bio.PDB.vectors import rotmat\n>>> p, q = Vector(1, 2, 3), Vector(2, 3, 5)\n>>> r = rotmat(p, q)\n>>> print(q)\n<Vector 2.00, 3.00, 5.00>\n>>> print(p)\n<Vector 1.00, 2.00, 3.00>\n>>> p.left_multiply(r)\n<Vector 1.21, 1.82, 3.03>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 180, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "rotmat", "signature": "(p, q)", "symbol_type": "function"}], "rsplit": [{"docstring": "Return a list of the sections in the data, using sep as the delimiter.\n\nsep\n  The delimiter according which to split the data.\n  None (the default value) means split on ASCII whitespace characters\n  (space, tab, return, newline, formfeed, vertical tab).\nmaxsplit\n  Maximum number of splits to do.\n  -1 (the default value) means no limit.\n\nSplitting is done starting at the end of the data and working to the front.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 243, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "rsplit", "signature": "(self, sep = None, maxsplit = -1)", "symbol_type": "function"}, {"docstring": "Return a list of subsequences by splitting the sequence from the right.\n\nReturn a list of the subsequences in the sequence (as Seq objects),\nusing sep as the delimiter string.  If maxsplit is given, at\nmost maxsplit splits are done.  If maxsplit is omitted, all\nsplits are made.\n\nFor consistency with the ``rsplit`` method of Python strings, any\nwhitespace (tabs, spaces, newlines) is a separator if sep is None, the\ndefault value\n\ne.g.\n\n>>> from Bio.Seq import Seq\n>>> my_rna = Seq(\"GUCAUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAGUUG\")\n>>> my_aa = my_rna.translate()\n>>> my_aa\nSeq('VMAIVMGR*KGAR*L')\n>>> for pep in my_aa.rsplit(\"*\"):\n...     pep\nSeq('VMAIVMGR')\nSeq('KGAR')\nSeq('L')\n>>> for pep in my_aa.rsplit(\"*\", 1):\n...     pep\nSeq('VMAIVMGR*KGAR')\nSeq('L')\n\nSee also the split method, which splits the sequence starting from the\nbeginning:\n\n>>> for pep in my_aa.split(\"*\", 1):\n...     pep\nSeq('VMAIVMGR')\nSeq('KGAR*L')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1113, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "rsplit", "signature": "(self, sep = None, maxsplit = -1)", "symbol_type": "function"}], "rstrip": [{"docstring": "Strip trailing characters contained in the argument.\n\nIf the argument is omitted or None, strip trailing ASCII whitespace.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 272, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "rstrip", "signature": "(self, chars = None)", "symbol_type": "function"}, {"docstring": "Return a sequence object with trailing ends stripped.\n\nWith default arguments, trailing whitespace is removed:\n\n>>> seq = Seq(\" ACGT \")\n>>> seq.rstrip()\nSeq(' ACGT')\n>>> seq\nSeq(' ACGT ')\n\nIf ``chars`` is given and not ``None``, remove characters in ``chars``\nfrom the trailing end instead.  The order of the characters to be\nremoved is not important:\n\n>>> Seq(\"ACGACGTTACG\").rstrip(\"GCA\")\nSeq('ACGACGTT')\n\nA copy of the sequence is returned if ``inplace`` is ``False`` (the\ndefault value).  If ``inplace`` is ``True``, the sequence is stripped\nin-place and returned.\n\n>>> seq = MutableSeq(\" ACGT \")\n>>> seq.rstrip()\nMutableSeq(' ACGT')\n>>> seq\nMutableSeq(' ACGT ')\n>>> seq.rstrip(inplace=True)\nMutableSeq(' ACGT')\n>>> seq\nMutableSeq(' ACGT')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if\n``rstrip`` is called on a ``Seq`` object with ``inplace=True``.\n\nSee also the strip and lstrip methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1265, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "rstrip", "signature": "(self, chars = None, inplace = False)", "symbol_type": "function"}], "run": [{"docstring": "Run `amalgkit config` (generate configuration files for downstream tools).\n\nGenerates configuration files (.config) for downstream analysis tools based\non metadata. These configs define quality criteria for sample selection.\n\nArgs:\n    params: Parameters for amalgkit config step. Common parameters:\n        - out_dir: Output directory for .config files\n    work_dir: Working directory for amalgkit commands\n    log_dir: Directory for step logs\n    check: If True, raise CalledProcessError on non-zero exit\n    \nReturns:\n    subprocess.CompletedProcess with return code and output\n    \nRaises:\n    subprocess.CalledProcessError: If check=True and step fails\n    \nNote:\n    This step typically runs after metadata retrieval and before sample selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/config.py", "line_number": 16, "module": "src.metainformant.rna.steps.config", "name": "run", "signature": "(params: Mapping[str, Any] | None = None) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}, {"docstring": "Run `amalgkit csca` (cross-species correlation analysis and plots).\n\nPerforms correlation analysis across multiple species to assess expression\nconservation and generate comparative plots.\n\nArgs:\n    params: Parameters for amalgkit csca step. Common parameters:\n        - metadata: Path to metadata TSV file\n        - curate_dir: Directory containing curated expression matrices\n        - out_dir: Output directory for correlation results and plots\n    work_dir: Working directory for amalgkit commands\n    log_dir: Directory for step logs\n    check: If True, raise CalledProcessError on non-zero exit\n    \nReturns:\n    subprocess.CompletedProcess with return code and output\n    \nRaises:\n    subprocess.CalledProcessError: If check=True and step fails\n    \nNote:\n    This step requires R (Rscript) for statistical analysis and plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/csca.py", "line_number": 13, "module": "src.metainformant.rna.steps.csca", "name": "run", "signature": "(params: Mapping[str, Any] | None = None) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}, {"docstring": "Run `amalgkit cstmm` (cross-species TMM normalization).\n\nPerforms Trimmed Mean of M-values (TMM) normalization across multiple\nspecies to enable cross-species expression comparisons.\n\nArgs:\n    params: Parameters for amalgkit cstmm step. Common parameters:\n        - metadata: Path to metadata TSV file\n        - merge_dir: Directory containing merged expression matrices\n        - out_dir: Output directory for normalized matrices\n    work_dir: Working directory for amalgkit commands\n    log_dir: Directory for step logs\n    check: If True, raise CalledProcessError on non-zero exit\n    \nReturns:\n    subprocess.CompletedProcess with return code and output\n    \nRaises:\n    subprocess.CalledProcessError: If check=True and step fails\n    \nNote:\n    This step requires merged expression matrices from multiple species.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/cstmm.py", "line_number": 13, "module": "src.metainformant.rna.steps.cstmm", "name": "run", "signature": "(params: Mapping[str, Any] | None = None) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}, {"docstring": "Run `amalgkit curate` (outlier removal and bias correction).\n\nPerforms quality control, outlier detection, and batch effect correction\non expression matrices. Generates QC plots and corrected expression data.\n\nArgs:\n    params: Parameters for amalgkit curate step. Common parameters:\n        - metadata: Path to metadata TSV file\n        - merge_dir: Directory containing merged expression matrix\n        - out_dir: Output directory for curated matrices and QC plots\n    work_dir: Working directory for amalgkit commands\n    log_dir: Directory for step logs\n    check: If True, raise CalledProcessError on non-zero exit\n    \nReturns:\n    subprocess.CompletedProcess with return code and output\n    \nRaises:\n    subprocess.CalledProcessError: If check=True and step fails\n    \nNote:\n    This step requires R (Rscript) for statistical analysis and plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/curate.py", "line_number": 13, "module": "src.metainformant.rna.steps.curate", "name": "run", "signature": "(params: Mapping[str, Any] | None = None) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}, {"docstring": "Run `amalgkit getfastq` with robust defaults, verification, and targeted retries.\n\nStrategy:\n- Bulk attempt (metadata or id) via `amalgkit getfastq` using robust sra-tools path.\n- Verify per-SRR outputs under out_dir/getfastq/<SRR>.\n- Targeted retries for missing SRRs: first via `amalgkit getfastq --id <SRR>`,\n  then fall back to direct sra-tools: prefetch + fasterq-dump (+ gzip/pigz).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/getfastq.py", "line_number": 83, "module": "src.metainformant.rna.steps.getfastq", "name": "run", "signature": "(params: Mapping[str, Any] | None = None)", "symbol_type": "function"}, {"docstring": "Run `amalgkit integrate` (augment metadata with local FASTQ paths).\n\nIntegrates local FASTQ file paths into metadata tables. This step discovers\nFASTQ files in the filesystem and adds their paths to the metadata.\n\nArgs:\n    params: Parameters for amalgkit integrate step. Common parameters:\n        - metadata: Path to input metadata TSV file\n        - fastq_dir: Directory containing FASTQ files to discover\n        - out_dir: Output directory for updated metadata\n    work_dir: Working directory for amalgkit commands\n    log_dir: Directory for step logs\n    check: If True, raise CalledProcessError on non-zero exit\n    \nReturns:\n    subprocess.CompletedProcess with return code and output\n    \nRaises:\n    subprocess.CalledProcessError: If check=True and step fails\n    \nNote:\n    This step gracefully skips if no FASTQ files are found yet (expected\n    before getfastq step completes).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/integrate.py", "line_number": 13, "module": "src.metainformant.rna.steps.integrate", "name": "run", "signature": "(params: Mapping[str, Any] | None = None) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}, {"docstring": "Run `amalgkit merge` (combine per-sample quantifications into expression matrix).\n\nMerges per-sample abundance files (abundance.tsv) into a single expression\nmatrix with samples as columns and transcripts as rows.\n\nArgs:\n    params: Parameters for amalgkit merge step. Common parameters:\n        - metadata: Path to metadata TSV file with sample list\n        - quant_dir: Directory containing per-sample quantification results\n        - out: Output file path for merged expression matrix (TSV format)\n    work_dir: Working directory for amalgkit commands\n    log_dir: Directory for step logs\n    check: If True, raise CalledProcessError on non-zero exit\n    \nReturns:\n    subprocess.CompletedProcess with return code and output\n    \nRaises:\n    subprocess.CalledProcessError: If check=True and step fails", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/merge.py", "line_number": 13, "module": "src.metainformant.rna.steps.merge", "name": "run", "signature": "(params: Mapping[str, Any] | None = None) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}, {"docstring": "Run `amalgkit metadata` (fetch SRA/ENA metadata).\n\nRetrieves RNA-seq sample metadata from NCBI SRA/ENA databases based on\nsearch criteria. This is typically the first step in an RNA-seq workflow.\n\nArgs:\n    params: Parameters for amalgkit metadata step. Common parameters:\n        - search_string: NCBI Entrez search query (e.g., \"species[Organism] AND RNA-Seq[Strategy]\")\n        - out_dir: Output directory for metadata files\n        - entrez_email: Email for NCBI Entrez API (or set NCBI_EMAIL env var)\n    work_dir: Working directory for amalgkit commands\n    log_dir: Directory for step logs\n    check: If True, raise CalledProcessError on non-zero exit\n    \nReturns:\n    subprocess.CompletedProcess with return code and output\n    \nRaises:\n    subprocess.CalledProcessError: If check=True and step fails\n    \nExamples:\n    >>> from metainformant.rna.steps import run_metadata\n    >>> result = run_metadata({\n    ...     \"search_string\": \"Pogonomyrmex barbatus[Organism] AND RNA-Seq[Strategy]\",\n    ...     \"out_dir\": \"output/amalgkit/pbarbatus/work\"\n    ... })", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/metadata.py", "line_number": 13, "module": "src.metainformant.rna.steps.metadata", "name": "run", "signature": "(params: Mapping[str, Any] | None = None) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}, {"docstring": "Run `amalgkit quant` (quantification, e.g., Salmon).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/quant.py", "line_number": 16, "module": "src.metainformant.rna.steps.quant", "name": "run", "signature": "(params: Mapping[str, Any] | None = None)", "symbol_type": "function"}, {"docstring": "Run `amalgkit sanity` (final integrity checks and validation).\n\nPerforms final validation checks on workflow outputs to ensure data integrity\nand completeness. This is typically the last step in a workflow.\n\nArgs:\n    params: Parameters for amalgkit sanity step. Common parameters:\n        - out_dir: Directory containing workflow outputs to validate\n        - all: If True, check all output types (default: False)\n    work_dir: Working directory for amalgkit commands\n    log_dir: Directory for step logs\n    check: If True, raise CalledProcessError on non-zero exit\n    \nReturns:\n    subprocess.CompletedProcess with return code and output\n    \nRaises:\n    subprocess.CalledProcessError: If check=True and step fails", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/sanity.py", "line_number": 13, "module": "src.metainformant.rna.steps.sanity", "name": "run", "signature": "(params: Mapping[str, Any] | None = None) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}, {"docstring": "Run `amalgkit select` (filter samples based on quality criteria).\n\nFilters RNA-seq samples based on quality criteria defined in configuration\nfiles. This step produces a qualified sample list for downstream processing.\n\nArgs:\n    params: Parameters for amalgkit select step. Common parameters:\n        - metadata: Path to input metadata TSV file\n        - config_dir: Directory containing .config files with quality criteria\n        - out_dir: Output directory for qualified sample list\n    work_dir: Working directory for amalgkit commands\n    log_dir: Directory for step logs\n    check: If True, raise CalledProcessError on non-zero exit\n    \nReturns:\n    subprocess.CompletedProcess with return code and output\n    \nRaises:\n    subprocess.CalledProcessError: If check=True and step fails", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/select.py", "line_number": 13, "module": "src.metainformant.rna.steps.select", "name": "run", "signature": "(params: Mapping[str, Any] | None = None) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}, {"docstring": "Superimpose the coordinate sets.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/qcprot.py", "line_number": 313, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.qcprot", "name": "run", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Run a PAML program using the current configuration.\n\nCheck that the class attributes exist and raise an error\nif not. Then run the command and check if it succeeds with\na return code of 0, otherwise raise an error.\n\nThe arguments may be passed as either absolute or relative\npaths, despite the fact that PAML requires relative paths.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_paml.py", "line_number": 85, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._paml", "name": "run", "signature": "(self, ctl_file, verbose, command)", "symbol_type": "function"}, {"docstring": "Run ``baseml`` using the current configuration.\n\nCheck that the tree file is specified and exists, and then\nrun ``baseml``. If parse is True then read and return the results,\notherwise return None. An exception is raised if the return code\nof the ``baseml`` command is non-zero.\n\nThe arguments may be passed as either absolute or relative paths,\ndespite the fact that ``baseml`` requires relative paths.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/baseml.py", "line_number": 171, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.baseml", "name": "run", "signature": "(self, ctl_file = None, verbose = False, command = 'baseml', parse = True)", "symbol_type": "function"}, {"docstring": "Run ``codeml`` using the current configuration.\n\nCheck that the tree file is specified and exists, and then\nrun ``codeml``. If parse is True then read and return the results,\notherwise return None. An exception is raised if the return code\nof the ``codeml`` command is non-zero.\n\nThe arguments may be passed as either absolute or relative\npaths, despite the fact that ``codeml`` requires relative paths.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/codeml.py", "line_number": 182, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.codeml", "name": "run", "signature": "(self, ctl_file = None, verbose = False, command = 'codeml', parse = True)", "symbol_type": "function"}, {"docstring": "Run ``yn00`` using the current configuration.\n\nIf parse is True then read and return the result, otherwise\nreturn None. An exception is raised if the return code of\nthe ``yn00`` command is non-zero.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/yn00.py", "line_number": 110, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.yn00", "name": "run", "signature": "(self, ctl_file = None, verbose = False, command = 'yn00', parse = True)", "symbol_type": "function"}, {"docstring": "Superimpose the coordinate sets.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SVDSuperimposer/__init__.py", "line_number": 147, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SVDSuperimposer.__init__", "name": "run", "signature": "(self)", "symbol_type": "function"}], "run_agent_simulation": [{"docstring": "Run agent-based model simulation.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/run_simulation.py", "line_number": 124, "module": "scripts.simulation.run_simulation", "name": "run_agent_simulation", "signature": "(args, output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "run_agent_simulation_workflow": [{"docstring": "Run end-to-end agent-based simulation workflow.\n\nArgs:\n    output_dir: Directory for output files\n    width: Grid width\n    height: Grid height\n    num_agents: Number of agents\n    num_steps: Number of simulation steps\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with workflow results and metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/workflow.py", "line_number": 80, "module": "src.metainformant.simulation.workflow", "name": "run_agent_simulation_workflow", "signature": "(output_dir: Path | str) -> dict[str, Any]", "symbol_type": "function"}], "run_all_tests": [{"docstring": "Run the repository's pytest suite programmatically.\n\nEnsures the metainformant package is importable by adding src to Python path\nif not already available. This allows tests to run whether the package is\ninstalled in editable mode or not.\n\nReturns the pytest exit code (0 = success).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/tests/runner.py", "line_number": 7, "module": "src.metainformant.tests.runner", "name": "run_all_tests", "signature": "(pytest_args: list[str] | None = None) -> int", "symbol_type": "function"}], "run_amalgkit": [{"docstring": "Execute an `amalgkit` subcommand with optional logging.\n\nParameters\n- subcommand: e.g., \"metadata\", \"integrate\", \"quant\", ...\n- params: mapping of flags/values following `build_cli_args` rules\n- work_dir: working directory to run in (created if missing)\n- env: additional environment variables to merge with current env\n- check: if True, raise CalledProcessError on non-zero exit\n- capture_output: capture stdout/stderr as text\n- log_dir: if provided, write timestamped stdout/stderr logs per step\n- step_name: optional label to prefix log filenames", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 206, "module": "src.metainformant.rna.amalgkit", "name": "run_amalgkit", "signature": "(subcommand: str, params: AmalgkitParams | None = None) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}], "run_analysis": [{"docstring": "Run complete life course analysis workflow.\n\nArgs:\n    sequences: List of event sequences\n    outcomes: Optional outcome labels/values\n    config_path: Optional configuration file path\n    output_dir: Output directory\n    embedding_dim: Optional embedding dimension override\n    window_size: Optional window size override\n    epochs: Optional epochs override\n    model_type: Optional model type override\n    \nReturns:\n    Analysis results dictionary", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/life_events/run_life_events_analysis.py", "line_number": 208, "module": "scripts.life_events.run_life_events_analysis", "name": "run_analysis", "signature": "(sequences: list, outcomes: Optional[Any], config_path: Optional[Path], output_dir: Path, embedding_dim: Optional[int], window_size: Optional[int], epochs: Optional[int], model_type: Optional[str]) -> dict[str, Any]", "symbol_type": "function"}], "run_atacseq_workflow": [{"docstring": "Run ATAC-seq accessibility analysis workflow.\n\nArgs:\n    signal_file: Path to bedGraph signal file\n    output_dir: Output directory for results\n    chrom: Chromosome to analyze\n    threshold: Optional signal threshold\n    \nReturns:\n    Dictionary with workflow results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/workflow.py", "line_number": 131, "module": "src.metainformant.epigenome.workflow", "name": "run_atacseq_workflow", "signature": "(signal_file: Path, output_dir: Path, chrom: str, threshold: float | None = None) -> Dict[str, Any]", "symbol_type": "function"}], "run_chipseq_workflow": [{"docstring": "Run ChIP-seq peak calling workflow.\n\nArgs:\n    signal_file: Path to bedGraph signal file\n    output_dir: Output directory for results\n    chrom: Chromosome to analyze\n    threshold: Optional signal threshold for peak calling\n    \nReturns:\n    Dictionary with workflow results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/workflow.py", "line_number": 83, "module": "src.metainformant.epigenome.workflow", "name": "run_chipseq_workflow", "signature": "(signal_file: Path, output_dir: Path, chrom: str, threshold: float | None = None) -> Dict[str, Any]", "symbol_type": "function"}], "run_community_analysis_workflow": [{"docstring": "Run complete community ecology analysis workflow.\n\nArgs:\n    abundance_file: Path to species abundance table (sites x species)\n    output_dir: Output directory for results\n    calculate_diversity: If True, calculate alpha diversity metrics\n    calculate_beta: If True, calculate beta diversity metrics\n    environmental_file: Optional environmental variables file\n    \nReturns:\n    Dictionary with workflow results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/workflow.py", "line_number": 16, "module": "src.metainformant.ecology.workflow", "name": "run_community_analysis_workflow", "signature": "(abundance_file: Path, output_dir: Path, calculate_diversity: bool = True, calculate_beta: bool = True, environmental_file: Path | None = None) -> Dict[str, Any]", "symbol_type": "function"}], "run_config_based_workflow": [{"docstring": "Run a complete workflow based on a configuration file.\n\nThis is the main entry point for config-based processing.\n\nArgs:\n    config_path: Path to configuration file\n    **kwargs: Additional arguments for download_and_process_data\n    \nReturns:\n    Processing results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/workflow.py", "line_number": 230, "module": "src.metainformant.core.workflow", "name": "run_config_based_workflow", "signature": "(config_path: str | Path, **kwargs) -> dict[str, Any]", "symbol_type": "function"}], "run_create_abstract": [{"docstring": "Create a composite graphical abstract by running all experiments and combining results.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/cli.py", "line_number": 83, "module": "src.metainformant.math.selection_experiments.cli", "name": "run_create_abstract", "signature": "(dest_dir: Path) -> None", "symbol_type": "function"}], "run_curate_r_script": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/curate.py", "line_number": 27, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.curate", "name": "run_curate_r_script", "signature": "(args, metadata, sp, input_dir)", "symbol_type": "function"}], "run_doctest": [{"docstring": "Run doctest for the importing module.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/_utils.py", "line_number": 71, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio._utils", "name": "run_doctest", "signature": "(target_dir: str | None = None, *args: Any, **kwargs: Any) -> None", "symbol_type": "function"}], "run_download_quant_workflow": [{"docstring": "Process samples: download \u2192 quantify \u2192 delete FASTQ.\n\nUnified function that handles both sequential and parallel processing modes.\n\nProcessing Modes:\n- Sequential (num_workers=1): Process one sample at a time\n  - Download \u2192 Quantify \u2192 Delete FASTQ \u2192 Next sample\n  - Maximum disk efficiency: only one sample's FASTQs exist at a time\n  \n- Parallel (num_workers>1): Multiple downloads, sequential quantification\n  - N download workers fetch FASTQ files in parallel\n  - 1 quantification worker processes them sequentially\n  - FASTQ files deleted immediately after quantification\n  - Maximizes throughput while preventing disk exhaustion\n\nArgs:\n    metadata_path: Path to metadata TSV with sample list\n    getfastq_params: Parameters for amalgkit getfastq step\n    quant_params: Parameters for amalgkit quant step\n    work_dir: Working directory for amalgkit commands\n    log_dir: Directory for step logs\n    num_workers: Number of parallel download workers (default: 1 for sequential)\n    max_samples: Optional limit on number of samples to process\n    skip_completed: If True, skip samples that are already quantified (sequential mode only)\n    progress_monitor: Optional progress monitor (if None, will be created if enabled in params)\n    \nReturns:\n    Dictionary with processing statistics:\n    - total_samples: Total number of samples\n    - processed: Number of samples successfully processed\n    - skipped: Number of samples skipped (already done)\n    - failed: Number of samples that failed\n    - failed_runs: List of run IDs that failed\n    \nRaises:\n    FileNotFoundError: If metadata file not found\n    ValueError: If metadata file missing 'run' column", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/process_samples.py", "line_number": 504, "module": "src.metainformant.rna.steps.process_samples", "name": "run_download_quant_workflow", "signature": "(metadata_path: str | Path, getfastq_params: Mapping[str, Any] | None = None, quant_params: Mapping[str, Any] | None = None) -> dict[str, Any]", "symbol_type": "function"}], "run_expression_simulation": [{"docstring": "Run expression count simulation.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/run_simulation.py", "line_number": 158, "module": "scripts.simulation.run_simulation", "name": "run_expression_simulation", "signature": "(args, output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "run_fastp": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 341, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "run_fastp", "signature": "(sra_stat, args, output_dir, metadata)", "symbol_type": "function"}], "run_gwas": [{"docstring": "Run association tests for all variants in VCF.\n\nArgs:\n    vcf_path: Path to VCF file\n    phenotype_path: Path to phenotype file (TSV with sample_id, trait columns)\n    config: Association configuration\n    output_dir: Optional directory for results\n\nReturns:\n    Dictionary with association test results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/association.py", "line_number": 298, "module": "src.metainformant.gwas.association", "name": "run_gwas", "signature": "(vcf_path: str | Path, phenotype_path: str | Path, config: dict[str, Any], output_dir: str | Path | None = None) -> dict[str, Any]", "symbol_type": "function"}], "run_logistic_model": [{"docstring": "Run logistic growth model.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/math/run_math_modeling.py", "line_number": 130, "module": "scripts.math.run_math_modeling", "name": "run_logistic_model", "signature": "(args, output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "run_lotka_volterra": [{"docstring": "Run Lotka-Volterra predator-prey model.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/math/run_math_modeling.py", "line_number": 207, "module": "scripts.math.run_math_modeling", "name": "run_lotka_volterra", "signature": "(args, output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "run_methylation_workflow": [{"docstring": "Run complete DNA methylation analysis workflow.\n\nArgs:\n    methylation_file: Path to CpG methylation table\n    output_dir: Output directory for results\n    compute_beta: If True, compute beta values\n    differential_analysis: If True, perform differential methylation analysis\n    condition2_file: Optional second condition file for differential analysis\n    \nReturns:\n    Dictionary with workflow results and output paths", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/workflow.py", "line_number": 16, "module": "src.metainformant.epigenome.workflow", "name": "run_methylation_workflow", "signature": "(methylation_file: Path, output_dir: Path, compute_beta: bool = True, differential_analysis: bool = False, condition2_file: Path | None = None) -> Dict[str, Any]", "symbol_type": "function"}], "run_naccess": [{"docstring": "Run naccess for a pdb file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/NACCESS.py", "line_number": 33, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.NACCESS", "name": "run_naccess", "signature": "(model, pdb_file, probe_size = None, z_slice = None, naccess = 'naccess', temp_path = '/tmp/')", "symbol_type": "function"}], "run_pfd": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 294, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "run_pfd", "signature": "(sra_stat, args, metadata, start, end)", "symbol_type": "function"}], "run_popgen_simulation_workflow": [{"docstring": "Run end-to-end population genetics simulation workflow.\n\nArgs:\n    output_dir: Directory for output files\n    n_sequences: Number of sequences\n    sequence_length: Length of each sequence\n    nucleotide_diversity: Target nucleotide diversity\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with workflow results and metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/workflow.py", "line_number": 155, "module": "src.metainformant.simulation.workflow", "name": "run_popgen_simulation_workflow", "signature": "(output_dir: Path | str) -> dict[str, Any]", "symbol_type": "function"}], "run_price_equation": [{"docstring": "Run Price equation analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/math/run_math_modeling.py", "line_number": 178, "module": "scripts.math.run_math_modeling", "name": "run_price_equation", "signature": "(args, output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "run_psea": [{"docstring": "Run PSEA and return output filename.\n\nNote that this assumes the P-SEA binary is called \"psea\" and that it is\non the path.\n\nNote that P-SEA will write an output file in the current directory using\nthe input filename with extension \".sea\".\n\nNote that P-SEA will not write output to the terminal while run unless\n verbose is set to True.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PSEA.py", "line_number": 25, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PSEA", "name": "run_psea", "signature": "(fname, verbose = False)", "symbol_type": "function"}], "run_quant": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/quant.py", "line_number": 89, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.quant", "name": "run_quant", "signature": "(args, metadata, sra_id, index)", "symbol_type": "function"}], "run_replay": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/cli.py", "line_number": 15, "module": "src.metainformant.math.selection_experiments.cli", "name": "run_replay", "signature": "(dest_dir: Path) -> None", "symbol_type": "function"}], "run_selection_model": [{"docstring": "Run selection experiment simulation.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/math/run_math_modeling.py", "line_number": 151, "module": "scripts.math.run_math_modeling", "name": "run_selection_model", "signature": "(args, output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "run_sequence_simulation": [{"docstring": "Run sequence generation simulation.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/run_simulation.py", "line_number": 95, "module": "scripts.simulation.run_simulation", "name": "run_sequence_simulation", "signature": "(args, output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "run_sequence_simulation_workflow": [{"docstring": "Run end-to-end sequence simulation workflow.\n\nArgs:\n    output_dir: Directory for output files\n    n_sequences: Number of sequences to generate\n    sequence_length: Length of each sequence\n    gc_content: GC content for sequences\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with workflow results and metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/workflow.py", "line_number": 17, "module": "src.metainformant.simulation.workflow", "name": "run_sequence_simulation_workflow", "signature": "(output_dir: Path | str) -> dict[str, Any]", "symbol_type": "function"}], "run_sir_model": [{"docstring": "Run SIR epidemiology model.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/math/run_math_modeling.py", "line_number": 96, "module": "scripts.math.run_math_modeling", "name": "run_sir_model", "signature": "(args, output_dir: Path) -> dict[str, Any]", "symbol_type": "function"}], "run_workflow": [{"docstring": "Execute DNA analysis workflow.\n\nArgs:\n    args: Parsed command-line arguments", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/dna/run_dna_analysis.py", "line_number": 253, "module": "scripts.dna.run_dna_analysis", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}, {"docstring": "Execute ecology analysis workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/ecology/run_ecology_analysis.py", "line_number": 86, "module": "scripts.ecology.run_ecology_analysis", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}, {"docstring": "Execute epigenome analysis workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/epigenome/run_epigenome_analysis.py", "line_number": 85, "module": "scripts.epigenome.run_epigenome_analysis", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}, {"docstring": "Execute mathematical modeling workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/math/run_math_modeling.py", "line_number": 237, "module": "scripts.math.run_math_modeling", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}, {"docstring": "Execute machine learning workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/ml/run_ml_pipeline.py", "line_number": 126, "module": "scripts.ml.run_ml_pipeline", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}, {"docstring": "Execute multi-omics integration workflow.\n\nArgs:\n    args: Parsed command-line arguments", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/multiomics/run_multiomics_integration.py", "line_number": 106, "module": "scripts.multiomics.run_multiomics_integration", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}, {"docstring": "Execute network analysis workflow.\n\nArgs:\n    args: Parsed command-line arguments", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/networks/run_network_analysis.py", "line_number": 235, "module": "scripts.networks.run_network_analysis", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}, {"docstring": "Execute ontology analysis workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/ontology/run_ontology_analysis.py", "line_number": 95, "module": "scripts.ontology.run_ontology_analysis", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}, {"docstring": "Execute phenotype analysis workflow.\n\nArgs:\n    args: Parsed command-line arguments", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/phenotype/run_phenotype_analysis.py", "line_number": 265, "module": "scripts.phenotype.run_phenotype_analysis", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}, {"docstring": "Execute protein analysis workflow.\n\nArgs:\n    args: Parsed command-line arguments", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/protein/run_protein_analysis.py", "line_number": 281, "module": "scripts.protein.run_protein_analysis", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}, {"docstring": "Execute quality control workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/quality/run_quality_control.py", "line_number": 90, "module": "scripts.quality.run_quality_control", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}, {"docstring": "Execute biological simulation workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/run_simulation.py", "line_number": 191, "module": "scripts.simulation.run_simulation", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}, {"docstring": "Execute single-cell analysis workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/singlecell/run_singlecell_analysis.py", "line_number": 113, "module": "scripts.singlecell.run_singlecell_analysis", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}, {"docstring": "Execute visualization workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/visualization/run_visualization.py", "line_number": 101, "module": "scripts.visualization.run_visualization", "name": "run_workflow", "signature": "(args)", "symbol_type": "function"}], "run_workflow_for_species": [{"docstring": "Run workflow steps for a single species.\n\nArgs:\n    config_path: Path to species workflow config file\n    steps: List of steps to run (default: all steps)\n    check: If True, stop on first failure\n\nReturns:\n    Dictionary with 'success', 'completed', 'failed' keys", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/orchestration.py", "line_number": 94, "module": "src.metainformant.rna.orchestration", "name": "run_workflow_for_species", "signature": "(config_path: Path, steps: Sequence[str] | None = None) -> dict[str, Any]", "symbol_type": "function"}], "safe_dump": [{"docstring": "Serialize a Python object into a YAML stream.\nProduce only basic YAML tags.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 263, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "safe_dump", "signature": "(data, stream = None, **kwds)", "symbol_type": "function"}, {"docstring": "Serialize a Python object into a YAML stream.\nProduce only basic YAML tags.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 263, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "safe_dump", "signature": "(data, stream = None, **kwds)", "symbol_type": "function"}], "safe_dump_all": [{"docstring": "Serialize a sequence of Python objects into a YAML stream.\nProduce only basic YAML tags.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 255, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "safe_dump_all", "signature": "(documents, stream = None, **kwds)", "symbol_type": "function"}, {"docstring": "Serialize a sequence of Python objects into a YAML stream.\nProduce only basic YAML tags.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 255, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "safe_dump_all", "signature": "(documents, stream = None, **kwds)", "symbol_type": "function"}], "safe_execute": [{"docstring": "Execute a function safely, returning default on error.\n\nArgs:\n    func: Function to execute\n    *args: Positional arguments for function\n    default: Default value to return on error\n    **kwargs: Keyword arguments for function\n\nReturns:\n    Function result or default value on error\n\nExample:\n    result = safe_execute(risky_function, arg1, arg2, default=\"fallback\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/errors.py", "line_number": 178, "module": "src.metainformant.core.errors", "name": "safe_execute", "signature": "(func: Callable[..., T], *args: Any, **kwargs: Any) -> T | None", "symbol_type": "function"}], "safe_filename": [{"docstring": "Make a safe filename, preserving extension when present.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/text.py", "line_number": 23, "module": "src.metainformant.core.text", "name": "safe_filename", "signature": "(name: str) -> str", "symbol_type": "function"}], "safe_load": [{"docstring": "Parse the first YAML document in a stream\nand produce the corresponding Python object.\n\nResolve only basic YAML tags. This is known\nto be safe for untrusted input.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 117, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "safe_load", "signature": "(stream)", "symbol_type": "function"}, {"docstring": "Parse the first YAML document in a stream\nand produce the corresponding Python object.\n\nResolve only basic YAML tags. This is known\nto be safe for untrusted input.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 117, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "safe_load", "signature": "(stream)", "symbol_type": "function"}], "safe_load_all": [{"docstring": "Parse all YAML documents in a stream\nand produce corresponding Python objects.\n\nResolve only basic YAML tags. This is known\nto be safe for untrusted input.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 127, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "safe_load_all", "signature": "(stream)", "symbol_type": "function"}, {"docstring": "Parse all YAML documents in a stream\nand produce corresponding Python objects.\n\nResolve only basic YAML tags. This is known\nto be safe for untrusted input.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 127, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "safe_load_all", "signature": "(stream)", "symbol_type": "function"}], "safename": [{"docstring": "Return a taxon identifier according to NEXUS standard.\n\nWrap quotes around names with punctuation or whitespace, and double\nsingle quotes.\n\nmrbayes=True: write names without quotes, whitespace or punctuation\nfor the mrbayes software package.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 255, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "safename", "signature": "(name, mrbayes = False)", "symbol_type": "function"}], "salt_correction": [{"docstring": "Calculate a term to correct Tm for salt ions.\n\nDepending on the Tm calculation, the term will correct Tm or entropy. To\ncalculate corrected Tm values, different operations need to be applied:\n\n - methods 1-4: Tm(new) = Tm(old) + corr\n - method 5: deltaS(new) = deltaS(old) + corr\n - methods 6+7: Tm(new) = 1/(1/Tm(old) + corr)\n\nArguments:\n - Na, K, Tris, Mg, dNTPS: Millimolar concentration of respective ion. To\n   have a simple 'salt correction', just pass Na. If any of K, Tris, Mg and\n   dNTPS is non-zero, a 'sodium-equivalent' concentration is calculated\n   according to von Ahsen et al. (2001, Clin Chem 47: 1956-1961):\n   [Na_eq] = [Na+] + [K+] + [Tris]/2 + 120*([Mg2+] - [dNTPs])^0.5\n   If [dNTPs] >= [Mg2+]: [Na_eq] = [Na+] + [K+] + [Tris]/2\n - method: Which method to be applied. Methods 1-4 correct Tm, method 5\n   corrects deltaS, methods 6 and 7 correct 1/Tm. The methods are:\n\n   1. 16.6 x log[Na+]\n      (Schildkraut & Lifson (1965), Biopolymers 3: 195-208)\n   2. 16.6 x log([Na+]/(1.0 + 0.7*[Na+]))\n      (Wetmur (1991), Crit Rev Biochem Mol Biol 126: 227-259)\n   3. 12.5 x log(Na+]\n      (SantaLucia et al. (1996), Biochemistry 35: 3555-3562\n   4. 11.7 x log[Na+]\n      (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465\n   5. Correction for deltaS: 0.368 x (N-1) x ln[Na+]\n      (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465)\n   6. (4.29(%GC)-3.95)x1e-5 x ln[Na+] + 9.40e-6 x ln[Na+]^2\n      (Owczarzy et al. (2004), Biochemistry 43: 3537-3554)\n   7. Complex formula with decision tree and 7 empirical constants.\n      Mg2+ is corrected for dNTPs binding (if present)\n      (Owczarzy et al. (2008), Biochemistry 47: 5336-5353)\n\nExamples\n--------\n>>> from Bio.SeqUtils.MeltingTemp import salt_correction\n>>> print('%0.2f' % salt_correction(Na=50, method=1))\n-21.60\n>>> print('%0.2f' % salt_correction(Na=50, method=2))\n-21.85\n>>> print('%0.2f' % salt_correction(Na=100, Tris=20, method=2))\n-16.45\n>>> print('%0.2f' % salt_correction(Na=100, Tris=20, Mg=1.5, method=2))\n-10.99", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/MeltingTemp.py", "line_number": 475, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.MeltingTemp", "name": "salt_correction", "signature": "(Na = 0, K = 0, Tris = 0, Mg = 0, dNTPs = 0, method = 1, seq = None)", "symbol_type": "function"}], "sample_dna_sequences": [{"docstring": "Provide sample DNA sequences for testing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 59, "module": "tests.conftest", "name": "sample_dna_sequences", "signature": "() -> dict[str, str]", "symbol_type": "function"}], "sample_fasta_content": [{"docstring": "Sample FASTA content for testing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 236, "module": "tests.conftest", "name": "sample_fasta_content", "signature": "() -> str", "symbol_type": "function"}], "sample_fastq_content": [{"docstring": "Sample FASTQ content for testing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 248, "module": "tests.conftest", "name": "sample_fastq_content", "signature": "() -> str", "symbol_type": "function"}], "sample_pdb_content": [{"docstring": "Sample PDB content for testing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 278, "module": "tests.conftest", "name": "sample_pdb_content", "signature": "() -> str", "symbol_type": "function"}], "sample_protein_sequences": [{"docstring": "Provide sample protein sequences for testing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 73, "module": "tests.conftest", "name": "sample_protein_sequences", "signature": "() -> dict[str, str]", "symbol_type": "function"}], "sample_sequences": [{"docstring": "Create sample event sequences for testing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 32, "module": "tests.test_life_events_visualization_extended", "name": "sample_sequences", "signature": "()", "symbol_type": "function"}], "sample_vcf_content": [{"docstring": "Sample VCF content for testing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 266, "module": "tests.conftest", "name": "sample_vcf_content", "signature": "() -> str", "symbol_type": "function"}], "samples": [{"docstring": "Get list of aligned samples across all omics layers.\n\nReturns:\n    List of sample identifiers (index values) that are present\n    in all provided omics layers. Samples are sorted alphabetically.\n    \nExamples:\n    >>> data = MultiOmicsData(genomics=genomics_df, transcriptomics=transcriptomics_df)\n    >>> len(data.samples)\n    10\n    >>> data.samples[0]\n    'S0'", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 100, "module": "src.metainformant.multiomics.integration", "name": "samples", "signature": "(self) -> List[str]", "symbol_type": "function"}], "sanitize_connection_params": [{"docstring": "Sanitize database connection parameters for security.\n\nArgs:\n    params: Raw connection parameters\n\nReturns:\n    Sanitized connection parameters", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/db.py", "line_number": 57, "module": "src.metainformant.core.db", "name": "sanitize_connection_params", "signature": "(params: dict) -> dict", "symbol_type": "function"}], "sanitize_filename": [{"docstring": "Sanitize filename for safe filesystem use.\n\nArgs:\n    filename: Original filename\n\nReturns:\n    Sanitized filename safe for filesystem", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/paths.py", "line_number": 149, "module": "src.metainformant.core.paths", "name": "sanitize_filename", "signature": "(filename: str) -> str", "symbol_type": "function"}], "sanitize_for_serialization": [{"docstring": "Prepares data for transmission before it is sent with the rest client\nIf obj is None, return None.\nIf obj is str, int, long, float, bool, return directly.\nIf obj is datetime.datetime, datetime.date\n    convert to string in iso8601 format.\nIf obj is list, sanitize each element in the list.\nIf obj is dict, return the dict.\nIf obj is OpenAPI model, return the properties dict.\nIf obj is io.IOBase, return the bytes\n:param obj: The data to serialize.\n:return: The serialized form of data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 258, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "sanitize_for_serialization", "signature": "(cls, obj)", "symbol_type": "function"}], "sanitize_name": [{"docstring": "Sanitise sequence identifier for output.\n\nRemoves the banned characters \"[]()\" and replaces the characters \":;\"\nwith \"|\". The name is truncated to \"width\" characters if specified.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/PhylipIO.py", "line_number": 441, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.PhylipIO", "name": "sanitize_name", "signature": "(name, width = None)", "symbol_type": "function"}], "sanity": [{"docstring": "Run `amalgkit sanity` (final integrity checks).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 596, "module": "src.metainformant.rna.amalgkit", "name": "sanity", "signature": "(params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}], "sanity_main": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/sanity.py", "line_number": 201, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.sanity", "name": "sanity_main", "signature": "(args)", "symbol_type": "function"}], "sars2_protein_download": [{"docstring": "Download SARS-CoV-2 protein and CDS datasets by protein name  # noqa: E501\n\nDownload SARS-CoV-2 protein datasets  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.sars2_protein_download(proteins, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    proteins ([str]): Which proteins to retrieve in the data package\n\nKeyword Args:\n    refseq_only (bool): If true, limit results to RefSeq genomes.. [optional] if omitted the server will use the default value of False\n    annotated_only (bool): If true, limit results to annotated genomes.. [optional] if omitted the server will use the default value of False\n    released_since (datetime): If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'. [optional]\n    updated_since (datetime): [optional]\n    host (str): If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default. [optional]\n    geo_location (str): Assemblies from this location (country and state, or continent). [optional]\n    complete_only (bool): only include complete genomes.. [optional] if omitted the server will use the default value of False\n    include_annotation_type ([V1AnnotationForVirusType]): Select additional types of annotation to include in the data package.  If unset, no annotation is provided.. [optional]\n    filename (str): Output file name.. [optional] if omitted the server will use the default value of \"ncbi_dataset.zip\"\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    file_type\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 1358, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "sars2_protein_download", "signature": "(self, proteins, **kwargs)", "symbol_type": "function"}], "sars2_protein_summary": [{"docstring": "Summary of SARS-CoV-2 protein and CDS datasets by protein name  # noqa: E501\n\nDownload a summary of available SARS-CoV-2 protein datasets  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.sars2_protein_summary(proteins, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    proteins ([str]): Which proteins to retrieve in the data package\n\nKeyword Args:\n    refseq_only (bool): If true, limit results to RefSeq genomes.. [optional] if omitted the server will use the default value of False\n    annotated_only (bool): If true, limit results to annotated genomes.. [optional] if omitted the server will use the default value of False\n    released_since (datetime): If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'. [optional]\n    updated_since (datetime): [optional]\n    host (str): If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default. [optional]\n    geo_location (str): Assemblies from this location (country and state, or continent). [optional]\n    complete_only (bool): only include complete genomes.. [optional] if omitted the server will use the default value of False\n    include_annotation_type ([V1AnnotationForVirusType]): Select additional types of annotation to include in the data package.  If unset, no annotation is provided.. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1DownloadSummary\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 1442, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "sars2_protein_summary", "signature": "(self, proteins, **kwargs)", "symbol_type": "function"}], "sars2_protein_table": [{"docstring": "Get SARS-CoV-2 protein metadata in a tabular format.  # noqa: E501\n\nGet protein metadata in tabular format for SARS-CoV-2 genomes.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.sars2_protein_table(proteins, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    proteins ([str]): Which proteins to retrieve in the data package\n\nKeyword Args:\n    refseq_only (bool): If true, limit results to RefSeq genomes.. [optional] if omitted the server will use the default value of False\n    annotated_only (bool): If true, limit results to annotated genomes.. [optional] if omitted the server will use the default value of False\n    released_since (datetime): If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'. [optional]\n    updated_since (datetime): [optional]\n    host (str): If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default. [optional]\n    geo_location (str): Assemblies from this location (country and state, or continent). [optional]\n    complete_only (bool): only include complete genomes.. [optional] if omitted the server will use the default value of False\n    table_fields ([V1VirusTableField]): Specify which fields to include in the tabular report. [optional]\n    format (V1TableFormat): Choose download format (tsv, csv or jsonl). [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1TabularOutput\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 1525, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "sars2_protein_table", "signature": "(self, proteins, **kwargs)", "symbol_type": "function"}], "save": [{"docstring": "Save the clustering results.\n\nThe saved files follow the convention for the Java TreeView program,\nwhich can therefore be used to view the clustering result.\n\nKeyword arguments:\n - jobname: The base name of the files to be saved. The filenames\n   are jobname.cdt, jobname.gtr, and jobname.atr for hierarchical\n   clustering, and jobname-K*.cdt, jobname-K*.kgg, jobname-K*.kag\n   for k-means clustering results.\n - geneclusters: For hierarchical clustering results, geneclusters\n   is a Tree object as returned by the treecluster method. For k-means\n   clustering results, geneclusters is a vector containing ngenes\n   integers, describing to which cluster a given gene belongs. This\n   vector can be calculated by kcluster.\n - expclusters: For hierarchical clustering results, expclusters\n   is a Tree object as returned by the treecluster method. For k-means\n   clustering results, expclusters is a vector containing nexps\n   integers, describing to which cluster a given sample belongs. This\n   vector can be calculated by kcluster.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 1006, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "save", "signature": "(self, jobname, geneclusters = None, expclusters = None)", "symbol_type": "function"}, {"docstring": "Save structure to a file.\n\n:param file: output file\n:type file: string or filehandle\n\n:param select: selects which entities will be written.\n:type select: object\n\nTypically select is a subclass of L{Select}, it should\nhave the following methods:\n\n - accept_model(model)\n - accept_chain(chain)\n - accept_residue(residue)\n - accept_atom(atom)\n\nThese methods should return 1 if the entity is to be\nwritten out, 0 otherwise.\n\nTypically select is a subclass of L{Select}.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBIO.py", "line_number": 355, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBIO", "name": "save", "signature": "(self, file, select = _select, write_end = True, preserve_atom_numbering = False)", "symbol_type": "function"}, {"docstring": "Save the structure to a file.\n\n:param filepath: output file\n:type filepath: string or filehandle\n\n:param select: selects which entities will be written.\n:type select: object\n\nTypically select is a subclass of L{Select}, it should\nhave the following methods:\n\n - accept_model(model)\n - accept_chain(chain)\n - accept_residue(residue)\n - accept_atom(atom)\n\nThese methods should return 1 if the entity is to be\nwritten out, 0 otherwise.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmcifio.py", "line_number": 79, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmcifio", "name": "save", "signature": "(self, filepath, select = _select, preserve_atom_numbering = False)", "symbol_type": "function"}, {"docstring": "Save the structure to a file.\n\n:param filepath: output file\n:type filepath: string\n\n:param select: selects which entities will be written.\n:type select: object\n\nTypically select is a subclass of L{Select}, it should\nhave the following methods:\n\n - accept_model(model)\n - accept_chain(chain)\n - accept_residue(residue)\n - accept_atom(atom)\n\nThese methods should return 1 if the entity is to be\nwritten out, 0 otherwise.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/mmtfio.py", "line_number": 45, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.mmtfio", "name": "save", "signature": "(self, filepath, select = _select)", "symbol_type": "function"}], "save_dtd_file": [{"docstring": "Save DTD file to cache.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 1069, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "save_dtd_file", "signature": "(self, filename, text)", "symbol_type": "function"}], "save_figure": [{"docstring": "Save a figure with high-resolution settings.\n\nArgs:\n    fig: Matplotlib figure\n    path: Output path\n    dpi: Resolution in dots per inch\n    bbox_inches: Bounding box mode ('tight', 'standard', etc.)\n    format: Output format (if None, inferred from extension)\n    **kwargs: Additional arguments for savefig\n\nReturns:\n    Path to saved file\n\nExample:\n    >>> from metainformant.visualization.export import save_figure\n    >>> import matplotlib.pyplot as plt\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [4, 5, 6])\n    >>> path = save_figure(fig, 'output/plot.png', dpi=300)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/export.py", "line_number": 15, "module": "src.metainformant.visualization.export", "name": "save_figure", "signature": "(fig: plt.Figure, path: str | Path, **kwargs) -> Path", "symbol_type": "function"}], "save_figure_multiformat": [{"docstring": "Save a figure in multiple formats.\n\nArgs:\n    fig: Matplotlib figure\n    base_path: Base output path (without extension)\n    formats: List of formats to save\n    dpi: Resolution for raster formats\n    **kwargs: Additional arguments for savefig\n\nReturns:\n    List of saved file paths\n\nExample:\n    >>> from metainformant.visualization.export import save_figure_multiformat\n    >>> import matplotlib.pyplot as plt\n    >>> fig, ax = plt.subplots()\n    >>> paths = save_figure_multiformat(fig, 'output/plot', formats=['png', 'pdf'])", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/export.py", "line_number": 62, "module": "src.metainformant.visualization.export", "name": "save_figure_multiformat", "signature": "(fig: plt.Figure, base_path: str | Path, **kwargs) -> list[Path]", "symbol_type": "function"}], "save_model": [{"docstring": "Save trained model to disk.\n\nSaves model hyperparameters, embeddings, vocabulary, and classifier/regressor\nstate to a JSON file. The model can be reconstructed using load_model().\n\nArgs:\n    path: Path to save model file (JSON format)\n    \nRaises:\n    ValueError: If model is not fitted\n    IOError: If file cannot be written\n    \nExamples:\n    >>> predictor = EventSequencePredictor(random_state=42)\n    >>> predictor.fit(sequences, outcomes)\n    >>> predictor.save_model(\"output/model.json\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/models.py", "line_number": 336, "module": "src.metainformant.life_events.models", "name": "save_model", "signature": "(self, path: str | Path) -> None", "symbol_type": "function"}], "save_ontology": [{"docstring": "Save ontology to JSON file.\n\nSerializes an Ontology object to JSON format, preserving all term\nattributes including relationships, synonyms, xrefs, and subsets.\n\nArgs:\n    onto: Ontology object to serialize\n    dest: Destination path for JSON file\n    \nReturns:\n    Path to the created JSON file\n    \nRaises:\n    IOError: If file cannot be written\n    \nExamples:\n    >>> onto = load_go_obo(\"go.obo\")\n    >>> path = save_ontology(onto, \"go_saved.json\")\n    >>> path.exists()\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/serialize.py", "line_number": 22, "module": "src.metainformant.ontology.serialize", "name": "save_ontology", "signature": "(onto: Ontology, dest: str | Path) -> Path", "symbol_type": "function"}], "save_possible_simple_key": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 295, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "save_possible_simple_key", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 295, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "save_possible_simple_key", "signature": "(self)", "symbol_type": "function"}], "save_xsd_file": [{"docstring": "Save XSD file to cache.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 1082, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "save_xsd_file", "signature": "(self, filename, text)", "symbol_type": "function"}], "scale_data": [{"docstring": "Scale expression data (z-score normalization).\n\nArgs:\n    data: SingleCellData object (should be log-transformed)\n    zero_center: Whether to center data around zero\n    max_value: Maximum value after scaling (clips outliers)\n\nReturns:\n    Scaled SingleCellData object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/preprocessing.py", "line_number": 471, "module": "src.metainformant.singlecell.preprocessing", "name": "scale_data", "signature": "(data: SingleCellData, zero_center: bool = True, max_value: Optional[float] = None) -> SingleCellData", "symbol_type": "function"}], "scale_segment_value": [{"docstring": "Divide the counts for a segment by some kind of scale value.\n\nThis is useful if segments aren't represented by raw counts, but\nare instead counts divided by some number.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/DisplayRepresentation.py", "line_number": 82, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.DisplayRepresentation", "name": "scale_segment_value", "signature": "(self, segment_name, scale_value = None)", "symbol_type": "function"}], "scan": [{"docstring": "Scan a YAML stream and produce scanning tokens.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 29, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "scan", "signature": "(stream, Loader = Loader)", "symbol_type": "function"}, {"docstring": "Scan a YAML stream and produce scanning tokens.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 29, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "scan", "signature": "(stream, Loader = Loader)", "symbol_type": "function"}, {"docstring": "Execute a ScanProsite search.\n\nArguments:\n - mirror:   The ScanProsite mirror to be used\n             (default: https://prosite.expasy.org).\n - seq:      The query sequence, or UniProtKB (Swiss-Prot,\n             TrEMBL) accession\n - output:   Format of the search results\n             (default: xml)\n\nFurther search parameters can be passed as keywords; see the\ndocumentation for programmatic access to ScanProsite at\nhttps://prosite.expasy.org/scanprosite/scanprosite_doc.html\nfor a description of such parameters.\n\nThis function returns a handle to the search results returned by\nScanProsite. Search results in the XML format can be parsed into a\nPython object, by using the Bio.ExPASy.ScanProsite.read function.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/ScanProsite.py", "line_number": 34, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.ScanProsite", "name": "scan", "signature": "(seq = '', mirror = 'https://prosite.expasy.org', output = 'xml', **keywords)", "symbol_type": "function"}], "scan_anchor": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 899, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_anchor", "signature": "(self, TokenClass)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 899, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_anchor", "signature": "(self, TokenClass)", "symbol_type": "function"}], "scan_block_scalar": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 976, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_block_scalar", "signature": "(self, style)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 976, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_block_scalar", "signature": "(self, style)", "symbol_type": "function"}], "scan_block_scalar_breaks": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1121, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_block_scalar_breaks", "signature": "(self, indent)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1121, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_block_scalar_breaks", "signature": "(self, indent)", "symbol_type": "function"}], "scan_block_scalar_ignored_line": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1092, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_block_scalar_ignored_line", "signature": "(self, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1092, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_block_scalar_ignored_line", "signature": "(self, start_mark)", "symbol_type": "function"}], "scan_block_scalar_indentation": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1106, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_block_scalar_indentation", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1106, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_block_scalar_indentation", "signature": "(self)", "symbol_type": "function"}], "scan_block_scalar_indicators": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1052, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_block_scalar_indicators", "signature": "(self, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1052, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_block_scalar_indicators", "signature": "(self, start_mark)", "symbol_type": "function"}], "scan_directive": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 787, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_directive", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 787, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_directive", "signature": "(self)", "symbol_type": "function"}], "scan_directive_ignored_line": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 885, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_directive_ignored_line", "signature": "(self, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 885, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_directive_ignored_line", "signature": "(self, start_mark)", "symbol_type": "function"}], "scan_directive_name": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 806, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_directive_name", "signature": "(self, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 806, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_directive_name", "signature": "(self, start_mark)", "symbol_type": "function"}], "scan_flow_scalar": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1134, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_flow_scalar", "signature": "(self, style)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1134, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_flow_scalar", "signature": "(self, style)", "symbol_type": "function"}], "scan_flow_scalar_breaks": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1252, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_flow_scalar_breaks", "signature": "(self, double, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1252, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_flow_scalar_breaks", "signature": "(self, double, start_mark)", "symbol_type": "function"}], "scan_flow_scalar_non_spaces": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1185, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_flow_scalar_non_spaces", "signature": "(self, double, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1185, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_flow_scalar_non_spaces", "signature": "(self, double, start_mark)", "symbol_type": "function"}], "scan_flow_scalar_spaces": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1228, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_flow_scalar_spaces", "signature": "(self, double, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1228, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_flow_scalar_spaces", "signature": "(self, double, start_mark)", "symbol_type": "function"}], "scan_line_break": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1416, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_line_break", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1416, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_line_break", "signature": "(self)", "symbol_type": "function"}], "scan_plain": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1270, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_plain", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1270, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_plain", "signature": "(self)", "symbol_type": "function"}], "scan_plain_spaces": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1311, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_plain_spaces", "signature": "(self, indent, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1311, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_plain_spaces", "signature": "(self, indent, start_mark)", "symbol_type": "function"}], "scan_tag": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 935, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_tag", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 935, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_tag", "signature": "(self)", "symbol_type": "function"}], "scan_tag_directive_handle": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 867, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_tag_directive_handle", "signature": "(self, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 867, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_tag_directive_handle", "signature": "(self, start_mark)", "symbol_type": "function"}], "scan_tag_directive_prefix": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 876, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_tag_directive_prefix", "signature": "(self, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 876, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_tag_directive_prefix", "signature": "(self, start_mark)", "symbol_type": "function"}], "scan_tag_directive_value": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 857, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_tag_directive_value", "signature": "(self, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 857, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_tag_directive_value", "signature": "(self, start_mark)", "symbol_type": "function"}], "scan_tag_handle": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1348, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_tag_handle", "signature": "(self, name, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1348, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_tag_handle", "signature": "(self, name, start_mark)", "symbol_type": "function"}], "scan_tag_uri": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1372, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_tag_uri", "signature": "(self, name, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1372, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_tag_uri", "signature": "(self, name, start_mark)", "symbol_type": "function"}], "scan_to_next_token": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 752, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_to_next_token", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 752, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_to_next_token", "signature": "(self)", "symbol_type": "function"}], "scan_uri_escapes": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 1397, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_uri_escapes", "signature": "(self, name, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 1397, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_uri_escapes", "signature": "(self, name, start_mark)", "symbol_type": "function"}], "scan_yaml_directive_number": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 844, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_yaml_directive_number", "signature": "(self, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 844, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_yaml_directive_number", "signature": "(self, start_mark)", "symbol_type": "function"}], "scan_yaml_directive_value": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 827, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "scan_yaml_directive_value", "signature": "(self, start_mark)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 827, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "scan_yaml_directive_value", "signature": "(self, start_mark)", "symbol_type": "function"}], "scatter_3d": [{"docstring": "Create a 3D scatter plot.\n\nArgs:\n    x: X-axis values\n    y: Y-axis values\n    z: Z-axis values\n    color: Optional color values\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object (3D)\n\nExample:\n    >>> from metainformant.visualization import scatter_3d\n    >>> import numpy as np\n    >>> x = np.random.random(100)\n    >>> y = np.random.random(100)\n    >>> z = np.random.random(100)\n    >>> ax = scatter_3d(x, y, z)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/multidim.py", "line_number": 280, "module": "src.metainformant.visualization.multidim", "name": "scatter_3d", "signature": "(x: Sequence[float], y: Sequence[float], z: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "scatter_plot": [{"docstring": "Create a scatter plot.\n\nArgs:\n    x: X-axis values\n    y: Y-axis values\n    ax: Matplotlib axes (creates new if None)\n    color: Point colors\n    size: Point sizes\n    alpha: Point transparency\n    xlabel: X-axis label\n    ylabel: Y-axis label\n    title: Plot title\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import scatter_plot\n    >>> ax = scatter_plot([1, 2, 3], [4, 5, 6], xlabel=\"X\", ylabel=\"Y\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/basic.py", "line_number": 67, "module": "src.metainformant.visualization.basic", "name": "scatter_plot", "signature": "(x: Sequence[float], y: Sequence[float]) -> plt.Axes", "symbol_type": "function"}], "schemaHandler": [{"docstring": "Process the XML schema (before processing the element).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 577, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "schemaHandler", "signature": "(self, name, attrs)", "symbol_type": "function"}], "scheme_color": [{"docstring": "Map a user-defined color integer to a ReportLab Color object.\n\n- value: An int representing a single color in the user-defined\n  color scheme\n\nTakes an int representing a user-defined color and returns the\nappropriate colors.Color object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Colors.py", "line_number": 190, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Colors", "name": "scheme_color", "signature": "(self, value)", "symbol_type": "function"}], "score": [{"docstring": "Return the alignment score of two sequences using PairwiseAligner.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 4507, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "score", "signature": "(self, seqA, seqB, strand = '+')", "symbol_type": "function"}, {"docstring": "Return the alignment score of a protein sequence and nucleotide sequence.\n\nArguments:\n - seqA  - the protein sequence of amino acids (plain string, Seq,\n   MutableSeq, or SeqRecord).\n - seqB  - the nucleotide sequence (plain string, Seq, MutableSeq, or\n   SeqRecord); both DNA and RNA sequences are accepted.\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqRecord import SeqRecord\n>>> aligner = CodonAligner()\n>>> dna = SeqRecord(Seq('ATGTCTCGT'), id='dna')\n>>> pro = SeqRecord(Seq('MSR'), id='pro')\n>>> score = aligner.score(pro, dna)\n>>> print(score)\n3.0\n>>> rna = SeqRecord(Seq('AUGUCUCGU'), id='rna')\n>>> score = aligner.score(pro, rna)\n>>> print(score)\n3.0\n\nThis is an example with a frame shift in the DNA sequence:\n\n>>> dna = \"ATGCTGGGCTCGAACGAGTCCGTGTATGCCCTAAGCTGAGCCCGTCG\"\n>>> pro = \"MLGSNESRVCPKLSPS\"\n>>> len(pro)\n16\n>>> aligner.frameshift_score = -3.0\n>>> score = aligner.score(pro, dna)\n>>> print(score)\n13.0\n\nIn the following example, the position of the frame shift is ambiguous:\n\n>>> dna = 'TTTAAAAAAAAAAATTT'\n>>> pro = 'FKKKKF'\n>>> len(pro)\n6\n>>> aligner.frameshift_score = -1.0\n>>> alignments = aligner.align(pro, dna)\n>>> print(alignments.score)\n5.0\n>>> len(alignments)\n3\n>>> print(next(alignments))\ntarget            0 F  K  K  K   4\nquery             0 TTTAAAAAAAAA 12\n<BLANKLINE>\ntarget            4 K  F    6\nquery            11 AAATTT 17\n<BLANKLINE>\n>>> print(next(alignments))\ntarget            0 F  K  K   3\nquery             0 TTTAAAAAA 9\n<BLANKLINE>\ntarget            3 K  K  F    6\nquery             8 AAAAAATTT 17\n<BLANKLINE>\n>>> print(next(alignments))\ntarget            0 F  K   2\nquery             0 TTTAAA 6\n<BLANKLINE>\ntarget            2 K  K  K  F    6\nquery             5 AAAAAAAAATTT 17\n<BLANKLINE>\n>>> print(next(alignments))\nTraceback (most recent call last):\n...\nStopIteration", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 4628, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "score", "signature": "(self, seqA, seqB)", "symbol_type": "function"}], "search": [{"docstring": "Search the substrings subs in self and yield the index and substring found.\n\nArguments:\n - subs - a list of strings, Seq, MutableSeq, bytes, or bytearray\n   objects containing the substrings to search for.\n\n>>> from Bio.Seq import Seq\n>>> dna = Seq(\"GTCATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAGTTG\")\n>>> matches = dna.search([\"CC\", Seq(\"ATTG\"), \"ATTG\", Seq(\"CCC\")])\n>>> for index, substring in matches:\n...     print(index, substring)\n...\n7 CC\n9 ATTG\n20 CC\n34 CC\n34 CCC\n35 CC", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 967, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "search", "signature": "(self, subs)", "symbol_type": "function"}, {"docstring": "Iterate over alignments overlapping the specified chromosome region..\n\nThis method searches the index to find alignments to the specified\nchromosome that fully or partially overlap the chromosome region\nbetween start and end.\n\nArguments:\n - chromosome - chromosome name. If None (default value), include all\n   alignments.\n - start      - starting position on the chromosome. If None (default\n   value), use 0 as the starting position.\n - end        - end position on the chromosome. If None (default value),\n   use the length of the chromosome as the end position.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1044, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "search", "signature": "(self, chromosome = None, start = None, end = None)", "symbol_type": "function"}, {"docstring": "Search index database for MAF records overlapping ranges provided.\n\nReturns *MultipleSeqAlignment* results in order by start, then end, then\ninternal offset field.\n\n*starts* should be a list of 0-based start coordinates of segments in the reference.\n*ends* should be the list of the corresponding segment ends\n(in the half-open UCSC convention:\nhttp://genome.ucsc.edu/blog/the-ucsc-genome-browser-coordinate-counting-systems/).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/MafIO.py", "line_number": 566, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.MafIO", "name": "search", "signature": "(self, starts, ends)", "symbol_type": "function"}, {"docstring": "Neighbor search.\n\nReturn all atoms/residues/chains/models/structures\nthat have at least one atom within radius of center.\nWhat entity level is returned (e.g. atoms or residues)\nis determined by level (A=atoms, R=residues, C=chains,\nM=models, S=structures).\n\nArguments:\n - center - NumPy array\n - radius - float\n - level - char (A, R, C, M, S)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/NeighborSearch.py", "line_number": 75, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.NeighborSearch", "name": "search", "signature": "(self, center, radius, level = 'A')", "symbol_type": "function"}, {"docstring": "Caller to search the best tree with a starting tree.\n\nThis should be implemented in subclass.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/TreeConstruction.py", "line_number": 897, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.TreeConstruction", "name": "search", "signature": "(self, starting_tree, alignment)", "symbol_type": "function"}, {"docstring": "Implement the TreeSearcher.search method.\n\n:Parameters:\n   starting_tree : Tree\n       starting tree of NNI method.\n   alignment : Alignment or MultipleSeqAlignment object\n       multiple sequence alignment used to calculate parsimony\n       score of different NNI trees.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/TreeConstruction.py", "line_number": 922, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.TreeConstruction", "name": "search", "signature": "(self, starting_tree, alignment)", "symbol_type": "function"}, {"docstring": "Return a list of cutting sites of the enzyme in the sequence.\n\nCompensate for circular sequences and so on.\n\ndna must be a Bio.Seq.Seq instance or a Bio.Seq.MutableSeq instance.\n\nIf linear is False, the restriction sites that span over the boundaries\nwill be included.\n\nThe positions are the first base of the 3' fragment,\ni.e. the first base after the position the enzyme will cut.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 514, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "search", "signature": "(cls, dna, linear = True)", "symbol_type": "function"}, {"docstring": "Return a dic of cutting sites in the seq for the batch enzymes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2213, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "search", "signature": "(self, dna, linear = True)", "symbol_type": "function"}, {"docstring": "Call TogoWS search.\n\nThis is a low level wrapper for the TogoWS search function, which\ncan return results in a several formats. In general, the search_iter\nfunction is more suitable for end users.\n\nArguments:\n - db - database (string), see http://togows.dbcls.jp/search/\n - query - search term (string)\n - offset, limit - optional integers specifying which result to start from\n   (1 based) and the number of results to return.\n - format - return data file format (string), e.g. \"json\", \"ttl\" (RDF)\n   By default plain text is returned, one result per line.\n\nAt the time of writing, TogoWS applies a default count limit of 100\nsearch results, and this is an upper bound. To access more results,\nuse the offset argument or the search_iter(...) function.\n\nTogoWS supports a long list of databases, including many from the NCBI\n(e.g. \"ncbi-pubmed\" or \"pubmed\", \"ncbi-genbank\" or \"genbank\", and\n\"ncbi-taxonomy\"), EBI (e.g. \"ebi-ebml\" or \"embl\", \"ebi-uniprot\" or\n\"uniprot, \"ebi-go\"), and KEGG (e.g. \"kegg-compound\" or \"compound\").\nFor the current list, see http://togows.dbcls.jp/search/\n\nThe NCBI provide the Entrez Search service (ESearch) which is similar,\navailable in Biopython as the Bio.Entrez.esearch() function.\n\nSee also the function Bio.TogoWS.search_count() which returns the number\nof matches found, and the Bio.TogoWS.search_iter() function which allows\nyou to iterate over the search results (taking care of batching for you).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/TogoWS/__init__.py", "line_number": 235, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.TogoWS.__init__", "name": "search", "signature": "(db, query, offset = None, limit = None, format = None)", "symbol_type": "function"}, {"docstring": "Search the UniProt database.\n\nConsider using `query syntax <https://www.uniprot.org/help/text-search>`_ and\n`query fields <https://www.uniprot.org/help/query-fields>`_ to refine your search.\n\nSee the API details `here <https://www.uniprot.org/help/api_queries>`_.\n\n>>> from Bio import UniProt\n>>> from itertools import islice\n>>> # Get the first 10 results\n>>> results = UniProt.search(\"(organism_id:2697049) AND (reviewed:true)\")[:10]\n\n:param query: The query string to search UniProt with\n:type query: str\n:param fields: The columns to retrieve in the results, defaults to all fields\n:type fields: List[str], optional\n:param batch_size: The number of results to retrieve in each batch, defaults to 500\n:type batch_size: int\n:return: An iterator over the search results\n:rtype: _UniProtSearchResults", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/UniProt/__init__.py", "line_number": 117, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.UniProt.__init__", "name": "search", "signature": "(query: str, fields: list[str] | None = None, batch_size: int = 500) -> _UniProtSearchResults", "symbol_type": "function"}, {"docstring": "Find hits with PWM score above given threshold.\n\nA generator function, returning found hits in the given sequence\nwith the pwm score higher than the threshold.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 455, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "search", "signature": "(self, sequence, threshold = 0.0, both = True, chunksize = 10 ** 6)", "symbol_type": "function"}], "search_all": [{"docstring": "All neighbor search.\n\nSearch all entities that have atoms pairs within\nradius.\n\nArguments:\n - radius - float\n - level - char (A, R, C, M, S)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/NeighborSearch.py", "line_number": 102, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.NeighborSearch", "name": "search_all", "signature": "(self, radius, level = 'A')", "symbol_type": "function"}], "search_count": [{"docstring": "Call TogoWS search count to see how many matches a search gives.\n\nArguments:\n - db - database (string), see http://togows.dbcls.jp/search\n - query - search term (string)\n\nYou could then use the count to download a large set of search results in\nbatches using the offset and limit options to Bio.TogoWS.search(). In\ngeneral however the Bio.TogoWS.search_iter() function is simpler to use.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/TogoWS/__init__.py", "line_number": 153, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.TogoWS.__init__", "name": "search_count", "signature": "(db, query)", "symbol_type": "function"}], "search_iter": [{"docstring": "Call TogoWS search iterating over the results (generator function).\n\nArguments:\n - db - database (string), see http://togows.dbcls.jp/search\n - query - search term (string)\n - limit - optional upper bound on number of search results\n - batch - number of search results to pull back each time talk to\n   TogoWS (currently limited to 100).\n\nYou would use this function within a for loop, e.g.\n\n>>> from Bio import TogoWS\n>>> for id in TogoWS.search_iter(\"pubmed\", \"diabetes+human\", limit=10):\n...     print(\"PubMed ID: %s\" %id) # maybe fetch data with entry?\nPubMed ID: ...\n\nInternally this first calls the Bio.TogoWS.search_count() and then\nuses Bio.TogoWS.search() to get the results in batches.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/TogoWS/__init__.py", "line_number": 188, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.TogoWS.__init__", "name": "search_iter", "signature": "(db, query, limit = None, batch = 100)", "symbol_type": "function"}], "search_species_with_rnaseq": [{"docstring": "Search NCBI SRA for species with RNA-seq data.\n\nArgs:\n    search_query: NCBI Entrez search query\n    max_records: Maximum number of records to retrieve\n\nReturns:\n    Dictionary mapping species names to metadata\n\nRaises:\n    ImportError: If Biopython is not available", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/discovery.py", "line_number": 37, "module": "src.metainformant.rna.discovery", "name": "search_species_with_rnaseq", "signature": "(search_query: str) -> dict[str, dict[str, Any]]", "symbol_type": "function"}], "search_sra_for_organism": [{"docstring": "Search NCBI SRA for sequencing runs of a specific organism.\n\nArgs:\n    organism: Scientific name (e.g., \"Apis mellifera\")\n    strategy: Sequencing strategy (WGS, RNA-Seq, etc.)\n    max_results: Maximum number of results to return\n\nReturns:\n    Dictionary with search results and SRA accessions\n\nNote:\n    Requires esearch and efetch from NCBI E-utilities, or uses web scraping.\n    For programmatic access, users should use NCBI E-utilities directly.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/sra_download.py", "line_number": 134, "module": "src.metainformant.gwas.sra_download", "name": "search_sra_for_organism", "signature": "(organism: str, strategy: str = 'WGS', max_results: int = 100) -> dict[str, Any]", "symbol_type": "function"}], "search_taxon": [{"docstring": "Return the first matching taxon in self.data.taxon. Not restricted to terminal nodes.\n\nnode_id = search_taxon(self,taxon)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 261, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "search_taxon", "signature": "(self, taxon)", "symbol_type": "function"}], "seasonal_decomposition_plot": [{"docstring": "Create a seasonal decomposition plot.\n\nArgs:\n    data: Time series data\n    period: Seasonal period\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import seasonal_decomposition_plot\n    >>> import numpy as np\n    >>> t = np.arange(0, 100)\n    >>> data = np.sin(2 * np.pi * t / 12) + 0.1 * t + np.random.normal(0, 0.1, 100)\n    >>> ax = seasonal_decomposition_plot(data, period=12)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/timeseries.py", "line_number": 123, "module": "src.metainformant.visualization.timeseries", "name": "seasonal_decomposition_plot", "signature": "(data: Sequence[float], period: int, **kwargs) -> plt.Axes", "symbol_type": "function"}], "secondary_structure_fraction": [{"docstring": "Calculate fraction of helix, turn and sheet.\n\nReturns a list of the fraction of amino acids which tend\nto be in Helix, Turn or Sheet, according to Haimov and Srebnik, 2016;\nHutchinson and Thornton, 1994; and Kim and Berg, 1993, respectively.\n\nAmino acids in helix: E, M, A, L, K.\nAmino acids in turn: N, P, G, S, D.\nAmino acids in sheet: V, I, Y, F, W, L, T.\n\nNote that, prior to v1.82, this method wrongly returned\n(Sheet, Turn, Helix) while claiming to return (Helix, Turn, Sheet).\n\nReturns a tuple of three floats (Helix, Turn, Sheet).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/ProtParam.py", "line_number": 326, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.ProtParam", "name": "secondary_structure_fraction", "signature": "(self)", "symbol_type": "function"}], "seeded_random": [{"docstring": "Provide a seeded random number generator for reproducible tests.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 52, "module": "tests.conftest", "name": "seeded_random", "signature": "() -> Iterator[random.Random]", "symbol_type": "function"}], "seek": [{"docstring": "Seek to a 64-bit unsigned BGZF virtual offset.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 673, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "seek", "signature": "(self, virtual_offset)", "symbol_type": "function"}], "seek_position": [{"docstring": "Seek a certain position in the file.\n\nArguments:\n - pop - pop position (0 is first)\n - indiv - individual in pop", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/FileParser.py", "line_number": 141, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.FileParser", "name": "seek_position", "signature": "(self, pop, indiv)", "symbol_type": "function"}], "seekable": [{"docstring": "Return True indicating the BGZF supports random access.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 773, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "seekable", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return True indicating the BGZF supports random access.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 907, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "seekable", "signature": "(self)", "symbol_type": "function"}], "segment": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 531, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "segment", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 992, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "segment", "signature": "(self, content)", "symbol_type": "function"}], "segregating_sites": [{"docstring": "Count the number of sites with more than one allele among sequences.\n\nA segregating (polymorphic) site is a position where at least two\ndifferent nucleotides are observed across the sequences.\n\nArgs:\n    seqs: Sequence of DNA sequences (strings)\n\nReturns:\n    Integer count of segregating sites. Returns 0 if:\n    - Less than 2 sequences provided\n    - Sequences have zero length\n    - All sequences are identical\n\nExamples:\n    >>> seqs = [\"AAAA\", \"AAAT\", \"AATT\"]\n    >>> segregating_sites(seqs)\n    2  # Sites at positions 2 and 3 are polymorphic\n    >>> seqs = [\"AAAA\", \"AAAA\"]\n    >>> segregating_sites(seqs)\n    0  # No variation", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population.py", "line_number": 477, "module": "src.metainformant.dna.population", "name": "segregating_sites", "signature": "(seqs: Sequence[str]) -> int", "symbol_type": "function"}], "seguid": [{"docstring": "Return the SEGUID (string) for a sequence (string or Seq object).\n\nGiven a nucleotide or amino-acid sequence (or any string),\nreturns the SEGUID string (A SEquence Globally Unique IDentifier).\nseq type = str.\n\nNote that the case is not important:\n\n>>> seguid(\"ACGTACGTACGT\")\n'If6HIvcnRSQDVNiAoefAzySc6i4'\n>>> seguid(\"acgtACGTacgt\")\n'If6HIvcnRSQDVNiAoefAzySc6i4'\n\nFor more information about SEGUID, see:\nhttp://bioinformatics.anl.gov/seguid/\nhttps://doi.org/10.1002/pmic.200600032", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/CheckSum.py", "line_number": 108, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.CheckSum", "name": "seguid", "signature": "(seq)", "symbol_type": "function"}], "seir_step": [{"docstring": "Single Euler step of the SEIR model.\n\ndS/dt = -beta S I, dE/dt = beta S I - sigma E, dI/dt = sigma E - gamma I, dR/dt = gamma I", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/epidemiology.py", "line_number": 79, "module": "src.metainformant.math.epidemiology", "name": "seir_step", "signature": "(S: float, E: float, I: float, R: float, beta: float, sigma: float, gamma: float, dt: float = 0.01) -> tuple[float, float, float, float]", "symbol_type": "function"}], "select": [{"docstring": "Run `amalgkit select` (filter samples based on criteria).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/amalgkit.py", "line_number": 561, "module": "src.metainformant.rna.amalgkit", "name": "select", "signature": "(params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]", "symbol_type": "function"}, {"docstring": "Subset the array by selecting the letters from the specified alphabet.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/substitution_matrices/__init__.py", "line_number": 325, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.substitution_matrices.__init__", "name": "select", "signature": "(self, alphabet)", "symbol_type": "function"}], "select_features_recursive": [{"docstring": "Recursive feature elimination with cross-validation.\n\nArgs:\n    X: Feature matrix\n    y: Target vector\n    estimator_type: Base estimator (\"random_forest\", \"linear\", \"svm\")\n    n_features: Number of features to select\n    step: Fraction of features to eliminate each step\n    cv_folds: Cross-validation folds\n    random_state: Random seed\n\nReturns:\n    Tuple of (selected_features_matrix, selected_indices)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/features.py", "line_number": 57, "module": "src.metainformant.ml.features", "name": "select_features_recursive", "signature": "(X: np.ndarray, y: np.ndarray, estimator_type: str = 'random_forest', n_features: int = 50, step: float = 0.1, cv_folds: int = 5, random_state: Optional[int] = None) -> Tuple[np.ndarray, List[int]]", "symbol_type": "function"}], "select_features_stability": [{"docstring": "Select features based on stability across bootstrap samples.\n\nArgs:\n    X: Feature matrix\n    y: Target vector\n    method: Feature selection method\n    n_bootstrap: Number of bootstrap samples\n    subsample_ratio: Fraction of samples in each bootstrap\n    stability_threshold: Minimum selection frequency\n    random_state: Random seed\n\nReturns:\n    Tuple of (selected_features_matrix, selected_indices)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/features.py", "line_number": 108, "module": "src.metainformant.ml.features", "name": "select_features_stability", "signature": "(X: np.ndarray, y: np.ndarray, method: str = 'random_forest', n_bootstrap: int = 100, subsample_ratio: float = 0.8, stability_threshold: float = 0.6, random_state: Optional[int] = None) -> Tuple[np.ndarray, List[int]]", "symbol_type": "function"}], "select_features_univariate": [{"docstring": "Select features using univariate statistical tests.\n\nArgs:\n    X: Feature matrix (samples x features)\n    y: Target vector\n    method: Statistical test (\"f_score\", \"chi2\", \"mutual_info\")\n    k: Number of features to select\n    p_threshold: P-value threshold for significance\n\nReturns:\n    Tuple of (selected_features_matrix, selected_indices)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/features.py", "line_number": 12, "module": "src.metainformant.ml.features", "name": "select_features_univariate", "signature": "(X: np.ndarray, y: np.ndarray, method: str = 'f_score', k: int = 100, p_threshold: float = 0.05) -> Tuple[np.ndarray, List[int]]", "symbol_type": "function"}], "select_header_accept": [{"docstring": "Returns `Accept` based on an array of accepts provided.\n\n:param accepts: List of headers.\n:return: Accept (e.g. application/json).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 559, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "select_header_accept", "signature": "(self, accepts)", "symbol_type": "function"}], "select_header_content_type": [{"docstring": "Returns `Content-Type` based on an array of content_types provided.\n\n:param content_types: List of content-types.\n:return: Content-Type (e.g. application/json).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 575, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "select_header_content_type", "signature": "(self, content_types)", "symbol_type": "function"}], "select_hvgs": [{"docstring": "Select highly variable genes (HVGs).\n\nArgs:\n    data: SingleCellData object (should be normalized and log-transformed)\n    n_top_genes: Number of top variable genes to select\n    method: Method for HVG selection ('seurat', 'cell_ranger', 'variance')\n    min_mean: Minimum mean expression for Seurat method\n    max_mean: Maximum mean expression for Seurat method\n    min_disp: Minimum dispersion for Seurat method\n\nReturns:\n    SingleCellData with HVG information in var", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/dimensionality.py", "line_number": 45, "module": "src.metainformant.singlecell.dimensionality", "name": "select_hvgs", "signature": "(data: SingleCellData, n_top_genes: int = 2000, method: str = 'seurat', min_mean: float = 0.0125, max_mean: float = 3, min_disp: float = 0.5) -> SingleCellData", "symbol_type": "function"}], "select_main": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/select.py", "line_number": 18, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.select", "name": "select_main", "signature": "(args)", "symbol_type": "function"}], "selection_differential": [{"docstring": "Calculate selection differential S = Cov(w_rel, z).\n\nThe selection differential measures the change in mean trait due to selection\nand is the covariance between relative fitness and trait values.\n\nArgs:\n    fitness: Sequence of fitness values\n    trait: Sequence of trait values (must match length of fitness)\n    normalize_by_mean_fitness: If True (default), normalize fitness by mean.\n        If False, use raw fitness values (assumes they are already relative).\n        \nReturns:\n    Selection differential. Returns 0.0 if inputs are empty or mismatched.\n    \nExamples:\n    >>> selection_differential([1.0, 1.2, 0.9], [0.2, 0.4, 0.1])\n    0.0333...\n    \nReferences:\n    Lande, R., & Arnold, S. J. (1983). The measurement of selection on\n    correlated characters. Evolution, 37(6), 1210-1226.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 163, "module": "src.metainformant.math.price", "name": "selection_differential", "signature": "(fitness: Sequence[float], trait: Sequence[float], normalize_by_mean_fitness: bool = True) -> float", "symbol_type": "function"}], "selection_gradient": [{"docstring": "Calculate Lande\u2013Arnold directional selection gradient \u03b2 = Cov(w_rel, z) / Var(z).\n\nThe selection gradient measures the strength of directional selection per unit\nof phenotypic variance. Standardized by trait variance to remove scale dependence.\n\nArgs:\n    fitness: Sequence of fitness values\n    trait: Sequence of trait values (must match length of fitness)\n    normalize_by_mean_fitness: If True (default), normalize fitness by mean.\n        \nReturns:\n    Selection gradient. Returns 0.0 if variance is 0 or inputs are invalid.\n    \nExamples:\n    >>> selection_gradient([1.0, 1.2, 0.9], [0.2, 0.4, 0.1])\n    0.25...\n    \nReferences:\n    Lande, R., & Arnold, S. J. (1983). The measurement of selection on\n    correlated characters. Evolution, 37(6), 1210-1226.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 204, "module": "src.metainformant.math.price", "name": "selection_gradient", "signature": "(fitness: Sequence[float], trait: Sequence[float], normalize_by_mean_fitness: bool = True) -> float", "symbol_type": "function"}], "selection_intensity": [{"docstring": "Standardized selection differential i = S / sd(z).\n\nReturns 0.0 if sd(z) == 0.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 237, "module": "src.metainformant.math.price", "name": "selection_intensity", "signature": "(fitness: Sequence[float], trait: Sequence[float], normalize_by_mean_fitness: bool = True) -> float", "symbol_type": "function"}], "selection_update": [{"docstring": "Calculate allele frequency after one generation of viability selection.\n\nImplements deterministic selection in a diploid population with viability\nselection. Genotype fitnesses determine the change in allele frequency\naccording to the standard Wright\u2013Fisher selection model.\n\nArgs:\n    allele_a_frequency: Current frequency of allele A (p)\n    fitness_AA: Fitness of AA homozygote\n    fitness_Aa: Fitness of Aa heterozygote\n    fitness_aa: Fitness of aa homozygote\n    \nReturns:\n    New allele A frequency after selection. Returns original frequency\n    if input is invalid or mean fitness is zero.\n    \nExamples:\n    >>> # Directional selection favoring A\n    >>> selection_update(0.5, fitness_AA=1.0, fitness_Aa=1.0, fitness_aa=0.8)\n    0.526...\n    \n    >>> # Overdominance (heterozygote advantage)\n    >>> selection_update(0.5, fitness_AA=0.8, fitness_Aa=1.0, fitness_aa=0.8)\n    0.5\n    \nReferences:\n    Crow, J. F., & Kimura, M. (1970). An introduction to population\n    genetics theory. Harper & Row.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen.py", "line_number": 40, "module": "src.metainformant.math.popgen", "name": "selection_update", "signature": "(allele_a_frequency: float, fitness_AA: float, fitness_Aa: float, fitness_aa: float) -> float", "symbol_type": "function"}], "semantic_entropy": [{"docstring": "Calculate semantic entropy of a set of annotated entities.\n\nMeasures the information content considering the semantic structure\nof annotations (e.g., GO terms, pathways).\n\nArgs:\n    term_annotations: Dictionary mapping entity IDs to sets of terms\n    base: Logarithm base\n    \nReturns:\n    Semantic entropy in bits (or nats/dits depending on base)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/semantic.py", "line_number": 59, "module": "src.metainformant.information.semantic", "name": "semantic_entropy", "signature": "(term_annotations: dict[str, set[str]], base: float = 2.0) -> float", "symbol_type": "function"}], "semantic_similarity": [{"docstring": "Calculate semantic similarity between two terms.\n\nUses information content to measure similarity. Common approaches:\n- Resnik similarity: IC of most informative common ancestor\n- Lin similarity: 2 * IC(MICA) / (IC(term1) + IC(term2))\n\nArgs:\n    term1: First term\n    term2: Second term\n    term_ic: Dictionary mapping terms to information content\n    term_hierarchy: Optional dictionary mapping terms to parent terms\n        (for finding common ancestors)\n    \nReturns:\n    Semantic similarity score (0 to 1, or based on IC scale)\n    \nExamples:\n    >>> ic = {\"A\": 2.0, \"B\": 2.0, \"C\": 1.0}  # C is parent of A and B\n    >>> hierarchy = {\"A\": {\"C\"}, \"B\": {\"C\"}}\n    >>> sim = semantic_similarity(\"A\", \"B\", ic, hierarchy)\n    >>> sim > 0  # Should have some similarity\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/semantic.py", "line_number": 96, "module": "src.metainformant.information.semantic", "name": "semantic_similarity", "signature": "(term1: str, term2: str, term_ic: dict[str, float], term_hierarchy: dict[str, set[str]] | None = None) -> float", "symbol_type": "function"}, {"docstring": "Calculate semantic similarity between two GO terms.\n\n**Note**: This function requires the `scipy` package and gene annotation data.\nInstall with: `pip install scipy`\n\nImplements semantic similarity measures such as Resnik, Lin, or Jiang-Conrath.\nRequires information content calculations from gene annotation frequencies.\n\nArgs:\n    onto: Ontology object containing GO terms\n    term1: First GO term identifier\n    term2: Second GO term identifier\n    method: Similarity method: \"resnik\", \"lin\", or \"jiang_conrath\"\n    gene_to_terms: Optional dictionary mapping gene_id -> set of GO term IDs.\n        If None, information content cannot be calculated and returns 0.0.\n        \nReturns:\n    Similarity score between 0.0 and 1.0 (or -inf to inf for Resnik)\n    \nRaises:\n    ImportError: If scipy is not installed\n    ValueError: If term1 or term2 not found, or invalid method\n    \nExamples:\n    >>> onto = load_go_obo(\"go.obo\")\n    >>> # Requires scipy and gene annotations\n    >>> # similarity = semantic_similarity(onto, \"GO:0008150\", \"GO:0009987\")\n\nNote:\n    This function is a placeholder. Full implementation requires:\n    - scipy for mathematical operations\n    - Information content calculation from gene annotation frequencies\n    - Lowest common ancestor (LCA) finding\n    - Gene annotation data (GAF/GPAD format)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/go.py", "line_number": 404, "module": "src.metainformant.ontology.go", "name": "semantic_similarity", "signature": "(onto: Ontology, term1: str, term2: str, method: str = 'resnik', gene_to_terms: dict[str, Set[str]] | None = None) -> float", "symbol_type": "function"}], "semantic_similarity_matrix": [{"docstring": "Calculate pairwise semantic similarity matrix.\n\nArgs:\n    terms: List of terms to compare\n    term_ic: Dictionary mapping terms to information content\n    term_hierarchy: Optional dictionary mapping terms to parent terms\n    \nReturns:\n    Symmetric similarity matrix of shape (len(terms), len(terms))", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/semantic.py", "line_number": 169, "module": "src.metainformant.information.semantic", "name": "semantic_similarity_matrix", "signature": "(terms: list[str], term_ic: dict[str, float], term_hierarchy: dict[str, set[str]] | None = None) -> np.ndarray", "symbol_type": "function"}], "seq": [{"docstring": "The sequence itself, as a Seq or MutableSeq object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 337, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "seq", "signature": "(self) -> Union['Seq', 'MutableSeq'] | None", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 342, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "seq", "signature": "(self, value: Union['Seq', 'MutableSeq']) -> None", "symbol_type": "function"}], "seq1": [{"docstring": "Convert protein sequence from three-letter to one-letter code.\n\nThe single required input argument 'seq' should be a protein sequence\nusing three-letter codes, either as a Python string or as a Seq or\nMutableSeq object.\n\nThis function returns the amino acid sequence as a string using the one\nletter amino acid codes. Output follows the IUPAC standard (including\nambiguous characters \"B\" for \"Asx\", \"J\" for \"Xle\", \"X\" for \"Xaa\", \"U\" for\n\"Sel\", and \"O\" for \"Pyl\") plus \"*\" for a terminator given the \"Ter\" code.\nAny unknown character (including possible gap characters), is changed\ninto '-' by default.\n\ne.g.\n\n>>> from Bio.SeqUtils import seq1\n>>> seq1(\"MetAlaIleValMetGlyArgTrpLysGlyAlaArgTer\")\n'MAIVMGRWKGAR*'\n\nThe input is case insensitive, e.g.\n\n>>> from Bio.SeqUtils import seq1\n>>> seq1(\"METalaIlEValMetGLYArgtRplysGlyAlaARGTer\")\n'MAIVMGRWKGAR*'\n\nYou can set a custom translation of the codon termination code using the\ndictionary \"custom_map\" argument (defaulting to {'Ter': '*'}), e.g.\n\n>>> seq1(\"MetAlaIleValMetGlyArgTrpLysGlyAla***\", custom_map={\"***\": \"*\"})\n'MAIVMGRWKGA*'\n\nYou can also set a custom translation for non-amino acid characters, such\nas '-', using the \"undef_code\" argument, e.g.\n\n>>> seq1(\"MetAlaIleValMetGlyArgTrpLysGlyAla------ArgTer\", undef_code='?')\n'MAIVMGRWKGA??R*'\n\nIf not given, \"undef_code\" defaults to \"X\", e.g.\n\n>>> seq1(\"MetAlaIleValMetGlyArgTrpLysGlyAla------ArgTer\")\n'MAIVMGRWKGAXXR*'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/__init__.py", "line_number": 360, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.__init__", "name": "seq1", "signature": "(seq, custom_map = None, undef_code = 'X')", "symbol_type": "function"}], "seq3": [{"docstring": "Convert protein sequence from one-letter to three-letter code.\n\nThe single required input argument 'seq' should be a protein sequence using\nsingle letter codes, either as a Python string or as a Seq or MutableSeq\nobject.\n\nThis function returns the amino acid sequence as a string using the three\nletter amino acid codes. Output follows the IUPAC standard (including\nambiguous characters B for \"Asx\", J for \"Xle\" and X for \"Xaa\", and also U\nfor \"Sel\" and O for \"Pyl\") plus \"Ter\" for a terminator given as an\nasterisk. Any unknown character (including possible gap characters),\nis changed into 'Xaa' by default.\n\ne.g.\n\n>>> from Bio.SeqUtils import seq3\n>>> seq3(\"MAIVMGRWKGAR*\")\n'MetAlaIleValMetGlyArgTrpLysGlyAlaArgTer'\n\nYou can set a custom translation of the codon termination code using the\ndictionary \"custom_map\" argument (which defaults to {'*': 'Ter'}), e.g.\n\n>>> seq3(\"MAIVMGRWKGAR*\", custom_map={\"*\": \"***\"})\n'MetAlaIleValMetGlyArgTrpLysGlyAlaArg***'\n\nYou can also set a custom translation for non-amino acid characters, such\nas '-', using the \"undef_code\" argument, e.g.\n\n>>> seq3(\"MAIVMGRWKGA--R*\", undef_code='---')\n'MetAlaIleValMetGlyArgTrpLysGlyAla------ArgTer'\n\nIf not given, \"undef_code\" defaults to \"Xaa\", e.g.\n\n>>> seq3(\"MAIVMGRWKGA--R*\")\n'MetAlaIleValMetGlyArgTrpLysGlyAlaXaaXaaArgTer'\n\nThis function was inspired by BioPerl's seq3.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/__init__.py", "line_number": 309, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.__init__", "name": "seq3", "signature": "(seq, custom_map = None, undef_code = 'Xaa')", "symbol_type": "function"}], "sequence": [{"docstring": "Add up sequence information as we get it.\n\nTo try and make things speedier, this puts all of the strings\ninto a list of strings, and then uses string.join later to put\nthem together. Supposedly, this is a big time savings", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 805, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "sequence", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": "Add sequence information to a list of sequence strings.\n\nThis removes spaces in the data and uppercases the sequence, and\nthen adds it to a list of sequences. Later on we'll join this\nlist together to make the final sequence. This is faster than\nadding on the new string every time.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1143, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "sequence", "signature": "(self, content)", "symbol_type": "function"}], "sequence_embeddings": [{"docstring": "Aggregate event sequences into fixed-size vector representations.\n\nArgs:\n    sequences: List of event sequences (each sequence is list of event tokens)\n    event_embeddings: Dictionary mapping event tokens to embedding vectors\n    method: Aggregation method (\"mean\", \"sum\", \"max\", \"attention\")\n    temporal_weighting: If True, apply temporal weighting (more recent events weighted higher)\n    \nReturns:\n    Array of shape (n_sequences, embedding_dim) with sequence embeddings\n    \nExamples:\n    >>> event_embeddings = {\n    ...     \"health:diagnosis\": np.array([0.1, 0.2]),\n    ...     \"occupation:job_change\": np.array([0.3, 0.4]),\n    ... }\n    >>> sequences = [\n    ...     [\"health:diagnosis\", \"occupation:job_change\"],\n    ...     [\"health:diagnosis\"],\n    ... ]\n    >>> seq_embeddings = sequence_embeddings(sequences, event_embeddings, method=\"mean\")\n    >>> seq_embeddings.shape\n    (2, 2)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/embeddings.py", "line_number": 176, "module": "src.metainformant.life_events.embeddings", "name": "sequence_embeddings", "signature": "(sequences: List[List[str]], event_embeddings: Dict[str, NDArray[np.float64]], method: str = 'mean', temporal_weighting: bool = False) -> NDArray[np.float64]", "symbol_type": "function"}], "sequence_extraction": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 615, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "sequence_extraction", "signature": "(args, sra_stat, metadata, g, start, end)", "symbol_type": "function"}], "sequence_extraction_1st_round": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 645, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "sequence_extraction_1st_round", "signature": "(args, sra_stat, metadata, g)", "symbol_type": "function"}], "sequence_extraction_2nd_round": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 669, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "sequence_extraction_2nd_round", "signature": "(args, sra_stat, metadata, g)", "symbol_type": "function"}], "sequence_extraction_private": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/getfastq.py", "line_number": 710, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.getfastq", "name": "sequence_extraction_private", "signature": "(i, metadata, sra_stat, args)", "symbol_type": "function"}], "sequence_identity_matrix": [{"docstring": "Compute sequence identity matrix (1 - p_distance).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/distances.py", "line_number": 162, "module": "src.metainformant.dna.distances", "name": "sequence_identity_matrix", "signature": "(sequences: Sequence[str]) -> List[List[float]]", "symbol_type": "function"}], "sequence_length": [{"docstring": "Get the length of a DNA sequence, ignoring case and non-standard characters.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 80, "module": "src.metainformant.dna.sequences", "name": "sequence_length", "signature": "(seq: str) -> int", "symbol_type": "function"}], "sequence_length_distribution": [{"docstring": "Analyze sequence length distribution.\n\nArgs:\n    reads: List of FASTQ records\n\nReturns:\n    Dictionary with length distribution data", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/quality/fastq.py", "line_number": 219, "module": "src.metainformant.quality.fastq", "name": "sequence_length_distribution", "signature": "(reads: List[FastqRecord]) -> Dict[str, Any]", "symbol_type": "function"}, {"docstring": "Plot distribution of sequence lengths.\n\nArgs:\n    lengths: Sequence lengths\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import sequence_length_distribution\n    >>> import numpy as np\n    >>> lengths = np.random.normal(100, 10, 1000).astype(int)\n    >>> ax = sequence_length_distribution(lengths)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/quality.py", "line_number": 232, "module": "src.metainformant.visualization.quality", "name": "sequence_length_distribution", "signature": "(lengths: Sequence[int], **kwargs) -> plt.Axes", "symbol_type": "function"}], "sequence_relation": [{"docstring": "Create sequence relationship object, relationship between two sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 630, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "sequence_relation", "signature": "(self, elem)", "symbol_type": "function"}], "serialize": [{"docstring": "Serialize a representation tree into a YAML stream.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 208, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "serialize", "signature": "(node, stream = None, Dumper = Dumper, **kwds)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/serializer.py", "line_number": 46, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.serializer", "name": "serialize", "signature": "(self, node)", "symbol_type": "function"}, {"docstring": "Serialize a representation tree into a YAML stream.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 208, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "serialize", "signature": "(node, stream = None, Dumper = Dumper, **kwds)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/serializer.py", "line_number": 46, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.serializer", "name": "serialize", "signature": "(self, node)", "symbol_type": "function"}], "serialize_all": [{"docstring": "Serialize a sequence of representation trees into a YAML stream.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 178, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "serialize_all", "signature": "(nodes, stream = None, Dumper = Dumper, canonical = None, indent = None, width = None, allow_unicode = None, line_break = None, encoding = None, explicit_start = None, explicit_end = None, version = None, tags = None)", "symbol_type": "function"}, {"docstring": "Serialize a sequence of representation trees into a YAML stream.\nIf stream is None, return the produced string instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 178, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "serialize_all", "signature": "(nodes, stream = None, Dumper = Dumper, canonical = None, indent = None, width = None, allow_unicode = None, line_break = None, encoding = None, explicit_start = None, explicit_end = None, version = None, tags = None)", "symbol_type": "function"}], "serialize_node": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/serializer.py", "line_number": 78, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.serializer", "name": "serialize_node", "signature": "(self, node, parent, index)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/serializer.py", "line_number": 78, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.serializer", "name": "serialize_node", "signature": "(self, node, parent, index)", "symbol_type": "function"}], "set": [{"docstring": "Set item in cache.\n\nArgs:\n    key: Cache key\n    value: Value to cache", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/cache.py", "line_number": 212, "module": "src.metainformant.core.cache", "name": "set", "signature": "(self, key: str, value: Any) -> None", "symbol_type": "function"}, {"docstring": "Set a given value in the matrix's position.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 194, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "set", "signature": "(self, x, y, value)", "symbol_type": "function"}, {"docstring": "Set the coordinates to be superimposed.\n\ncoords will be put on top of reference_coords.\n\n- reference_coords: an NxDIM array\n- coords: an NxDIM array\n\nDIM is the dimension of the points, N is the number\nof points to be superimposed.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/qcprot.py", "line_number": 290, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.qcprot", "name": "set", "signature": "(self, reference_coords, coords)", "symbol_type": "function"}, {"docstring": "Set the coordinates to be superimposed.\n\ncoords will be put on top of reference_coords.\n\n- reference_coords: an NxDIM array\n- coords: an NxDIM array\n\nDIM is the dimension of the points, N is the number\nof points to be superimposed.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SVDSuperimposer/__init__.py", "line_number": 125, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SVDSuperimposer.__init__", "name": "set", "signature": "(self, reference_coords, coords)", "symbol_type": "function"}], "setAtom": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 797, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "setAtom", "signature": "(res, atm)", "symbol_type": "function"}], "setAtomVw": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 541, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "setAtomVw", "signature": "(res, atm)", "symbol_type": "function"}], "setResAtmVws": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 548, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "setResAtmVws", "signature": "(res)", "symbol_type": "function"}], "setResAtms": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 808, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "setResAtms", "signature": "(res)", "symbol_type": "function"}], "set_X_homog_rot_mtx": [{"docstring": "Update existing X rotation matrix to new angle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 452, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "set_X_homog_rot_mtx", "signature": "(angle_rads: float, mtx: np.ndarray)", "symbol_type": "function"}], "set_Y_homog_rot_mtx": [{"docstring": "Update existing Y rotation matrix to new angle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 442, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "set_Y_homog_rot_mtx", "signature": "(angle_rads: float, mtx: np.ndarray)", "symbol_type": "function"}], "set_Z_homog_rot_mtx": [{"docstring": "Update existing Z rotation matrix to new angle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 432, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "set_Z_homog_rot_mtx", "signature": "(angle_rads: float, mtx: np.ndarray)", "symbol_type": "function"}], "set_accuracy_95": [{"docstring": "Reduce floating point accuracy to 9.5 (xxxx.xxxxx).\n\nUsed by :class:`IC_Residue` class writing PIC and SCAD\nfiles.\n\n:param float num: input number\n:returns: float with specified accuracy", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4924, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "set_accuracy_95", "signature": "(num: float) -> float", "symbol_type": "function"}], "set_all_features": [{"docstring": "Set an attribute of all the features.\n\nArguments:\n - attr: An attribute of the Feature class\n - value: The value to set that attribute to\n\nSet the passed attribute of all features in the set to the\npassed value.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_FeatureSet.py", "line_number": 86, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._FeatureSet", "name": "set_all_features", "signature": "(self, attr, value)", "symbol_type": "function"}], "set_all_tracks": [{"docstring": "Set the passed attribute of all tracks in the set to the passed value.\n\nArguments:\n - attr    - An attribute of the Track class.\n - value   - The value to set that attribute.\n\nset_all_tracks(self, attr, value)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Diagram.py", "line_number": 142, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Diagram", "name": "set_all_tracks", "signature": "(self, attr, value)", "symbol_type": "function"}], "set_altloc": [{"docstring": "Set alternative location specifier.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 315, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "set_altloc", "signature": "(self, altloc: str)", "symbol_type": "function"}], "set_angle": [{"docstring": "Set dihedron or hedron angle for specified key.\n\nIf angle is a `Dihedron` and `overlap` is True (default), overlapping\ndihedra are also changed as appropriate.  The overlap is a result of\nprotein chain definitions in :mod:`.ic_data` and :meth:`_create_edra`\n(e.g. psi overlaps N-CA-C-O).\n\nThe default overlap=True is probably what you want for:\n`set_angle(\"chi1\", val)`\n\nThe default is probably NOT what you want when processing all dihedrals\nin a chain or residue (such as copying from another structure), as the\noverlapping dihedra will likely be in the set as well.\n\nN.B. setting e.g. PRO chi2 is permitted without error or warning!\n\nSee :meth:`.pick_angle` for angle_key specifications.\nSee :meth:`.bond_rotate` to change a dihedral by a number of degrees\n\n:param angle_key: angle identifier.\n:param float v: new angle in degrees (result adjusted to +/-180).\n:param bool overlap: default True.\n    Modify overlapping dihedra as needed", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 3704, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "set_angle", "signature": "(self, angle_key: EKT | str, v: float, overlap = True)", "symbol_type": "function"}], "set_anisou": [{"docstring": "Set anisotropic B factor.\n\n:param anisou_array: anisotropic B factor.\n:type anisou_array: NumPy array (length 6)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 343, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "set_anisou", "signature": "(self, anisou_array: np.ndarray | None)", "symbol_type": "function"}, {"docstring": "Set anisotropic B factor of current Atom.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureBuilder.py", "line_number": 300, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureBuilder", "name": "set_anisou", "signature": "(self, anisou_array)", "symbol_type": "function"}], "set_atom_info": [{"docstring": "Create an atom object an set the information.\n\n:param atom_name: the atom name, e.g. CA for this atom\n:param serial_number: the serial id of the atom (e.g. 1)\n:param alternative_location_id: the alternative location id for the atom, if present\n:param x: the x coordinate of the atom\n:param y: the y coordinate of the atom\n:param z: the z coordinate of the atom\n:param occupancy: the occupancy of the atom\n:param temperature_factor: the temperature factor of the atom\n:param element: the element of the atom, e.g. C for carbon. According to IUPAC. Calcium  is Ca\n:param charge: the formal atomic charge of the atom", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/DefaultParser.py", "line_number": 47, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.DefaultParser", "name": "set_atom_info", "signature": "(self, atom_name, serial_number, alternative_location_id, x, y, z, occupancy, temperature_factor, element, charge)", "symbol_type": "function"}], "set_atoms": [{"docstring": "Prepare translation/rotation to minimize RMSD between atoms.\n\nPut (translate/rotate) the atoms in fixed on the atoms in\nmoving, in such a way that the RMSD is minimized.\n\n:param fixed: list of (fixed) atoms\n:param moving: list of (moving) atoms\n:type fixed,moving: [L{Atom}, L{Atom},...]", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Superimposer.py", "line_number": 24, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Superimposer", "name": "set_atoms", "signature": "(self, fixed, moving)", "symbol_type": "function"}, {"docstring": "Prepare alignment between two atom lists.\n\nPut (translate/rotate) the atoms in fixed on the atoms in\nmoving, in such a way that the RMSD is minimized.\n\n:param fixed: list of (fixed) atoms\n:param moving: list of (moving) atoms\n:type fixed,moving: [L{Atom}, L{Atom},...]", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/qcprot.py", "line_number": 258, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.qcprot", "name": "set_atoms", "signature": "(self, fixed, moving)", "symbol_type": "function"}], "set_attribute": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 122, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "set_attribute", "signature": "(self, name, value)", "symbol_type": "function"}], "set_bfactor": [{"docstring": "Set isotroptic B factor.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 307, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "set_bfactor", "signature": "(self, bfactor: float | None)", "symbol_type": "function"}], "set_bio_assembly_trans": [{"docstring": "Set the Bioassembly transformation information. A single bioassembly can have multiple transforms.\n\n:param bio_assembly_index: the integer index of the bioassembly\n:param input_chain_indices: the list of integer indices for the chains of this bioassembly\n:param input_transform: the list of doubles for  the transform of this bioassmbly transform.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/DefaultParser.py", "line_number": 201, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.DefaultParser", "name": "set_bio_assembly_trans", "signature": "(self, bio_assembly_index, input_chain_indices, input_transform)", "symbol_type": "function"}], "set_bounds": [{"docstring": "Set start and end points for the drawing as a whole.\n\nArguments:\n - start - The first base (or feature mark) to draw from\n - end - The last base (or feature mark) to draw to", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_AbstractDrawer.py", "line_number": 519, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._AbstractDrawer", "name": "set_bounds", "signature": "(self, start, end)", "symbol_type": "function"}], "set_cache_enabled": [{"docstring": "Enable or disable caching for traversal operations.\n\nArgs:\n    enabled: If True, enable caching; if False, disable and clear cache", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/query.py", "line_number": 57, "module": "src.metainformant.ontology.query", "name": "set_cache_enabled", "signature": "(enabled: bool) -> None", "symbol_type": "function"}], "set_cache_ttl": [{"docstring": "Set cache time-to-live in seconds.\n\nArgs:\n    seconds: TTL in seconds (0 or negative to disable TTL)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/query.py", "line_number": 69, "module": "src.metainformant.ontology.query", "name": "set_cache_ttl", "signature": "(seconds: float) -> None", "symbol_type": "function"}], "set_chain_info": [{"docstring": "Set the chain information.\n\n:param chain_id: the asym chain id from mmCIF\n:param chain_name: the auth chain id from mmCIF\n:param num_groups: the number of groups this chain has", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/DefaultParser.py", "line_number": 91, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.DefaultParser", "name": "set_chain_info", "signature": "(self, chain_id, chain_name, num_groups)", "symbol_type": "function"}], "set_charge": [{"docstring": "Set charge.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 351, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "set_charge", "signature": "(self, pqr_charge: float | None)", "symbol_type": "function"}], "set_color": [{"docstring": "Set the color in which the feature will be drawn.\n\nArguments:\n - color    The color to draw the feature - either a colors.Color\n   object, an RGB tuple of floats, or an integer corresponding a\n   colors in colors.txt", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Feature.py", "line_number": 169, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Feature", "name": "set_color", "signature": "(self, color)", "symbol_type": "function"}], "set_colour": [{"docstring": "Backwards compatible variant of set_color(self, color) using UK spelling.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Feature.py", "line_number": 164, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Feature", "name": "set_colour", "signature": "(self, colour)", "symbol_type": "function"}], "set_coord": [{"docstring": "Set coordinates.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 311, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "set_coord", "signature": "(self, coord: np.ndarray)", "symbol_type": "function"}], "set_data": [{"docstring": "Add data as a list of (position, value) tuples.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Graph.py", "line_number": 92, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Graph", "name": "set_data", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": "Set a node's data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 178, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "set_data", "signature": "(self, data)", "symbol_type": "function"}], "set_default": [{"docstring": "Set default instance of configuration.\n\nIt stores default configuration, which can be\nreturned by get_default_copy method.\n\n:param default: object of Configuration", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 242, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "set_default", "signature": "(cls, default)", "symbol_type": "function"}], "set_default_header": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 114, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "set_default_header", "signature": "(self, header_name, header_value)", "symbol_type": "function"}], "set_description": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/progress.py", "line_number": 106, "module": "src.metainformant.core.progress", "name": "set_description", "signature": "(self, desc: str)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/progress.py", "line_number": 48, "module": "src.metainformant.core.progress", "name": "set_description", "signature": "(self, desc)", "symbol_type": "function"}], "set_dict": [{"docstring": "Set the mmCIF dictionary to be written out.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmcifio.py", "line_number": 72, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmcifio", "name": "set_dict", "signature": "(self, dic)", "symbol_type": "function"}], "set_entity_info": [{"docstring": "Set the entity level information for the structure.\n\n:param chain_indices: the indices of the chains for this entity\n:param sequence: the one letter code sequence for this entity\n:param description: the description for this entity\n:param entity_type: the entity type (polymer,non-polymer,water)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/DefaultParser.py", "line_number": 110, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.DefaultParser", "name": "set_entity_info", "signature": "(self, chain_indices, sequence, description, entity_type)", "symbol_type": "function"}], "set_feature": [{"docstring": "Define the Bio.SeqFeature object to be wrapped.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Feature.py", "line_number": 123, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Feature", "name": "set_feature", "signature": "(self, feature)", "symbol_type": "function"}], "set_flexible": [{"docstring": "For OpenSCAD, mark N-CA and CA-C bonds to be flexible joints.\n\nSee :func:`.SCADIO.write_SCAD`", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 2713, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "set_flexible", "signature": "(self) -> None", "symbol_type": "function"}], "set_font_family": [{"docstring": "Set the default font family.\n\nArgs:\n    family: Font family ('serif', 'sans-serif', 'monospace')\n\nExample:\n    >>> from metainformant.visualization.style import set_font_family\n    >>> set_font_family('serif')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/style.py", "line_number": 112, "module": "src.metainformant.visualization.style", "name": "set_font_family", "signature": "(family: str = 'sans-serif') -> None", "symbol_type": "function"}], "set_font_size": [{"docstring": "Set the default font size.\n\nArgs:\n    size: Font size in points\n\nExample:\n    >>> from metainformant.visualization.style import set_font_size\n    >>> set_font_size(12)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/style.py", "line_number": 125, "module": "src.metainformant.visualization.style", "name": "set_font_size", "signature": "(size: float = 10) -> None", "symbol_type": "function"}], "set_group_bond": [{"docstring": "Add bonds within a group.\n\n:param atom_index_one: the integer atom index (in the group) of the first partner in the bond\n:param atom_index_two: the integer atom index (in the group) of the second partner in the bond\n:param bond_order: the integer bond order", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/DefaultParser.py", "line_number": 215, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.DefaultParser", "name": "set_group_bond", "signature": "(self, atom_index_one, atom_index_two, bond_order)", "symbol_type": "function"}], "set_group_info": [{"docstring": "Set the information for a group.\n\n:param group_name: the name of this group, e.g. LYS\n:param group_number: the residue number of this group\n:param insertion_code: the insertion code for this group\n:param group_type: a string indicating the type of group (as found in the chemcomp dictionary.\n    Empty string if none available.\n:param atom_count: the number of atoms in the group\n:param bond_count: the number of unique bonds in the group\n:param single_letter_code: the single letter code of the group\n:param sequence_index: the index of this group in the sequence defined by the entity\n:param secondary_structure_type: the type of secondary structure used\n    (types are according to DSSP and number to type mappings are defined in the specification)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/DefaultParser.py", "line_number": 124, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.DefaultParser", "name": "set_group_info", "signature": "(self, group_name, group_number, insertion_code, group_type, atom_count, bond_count, single_letter_code, sequence_index, secondary_structure_type)", "symbol_type": "function"}], "set_handle": [{"docstring": "Set the handle attribute.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/Scanner.py", "line_number": 71, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.Scanner", "name": "set_handle", "signature": "(self, handle)", "symbol_type": "function"}], "set_hbond": [{"docstring": "For OpenSCAD, mark H-N and C-O bonds to be hbonds (magnets).\n\nSee :func:`.SCADIO.write_SCAD`", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 2729, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "set_hbond", "signature": "(self) -> None", "symbol_type": "function"}], "set_header": [{"docstring": "Set header.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureBuilder.py", "line_number": 61, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureBuilder", "name": "set_header", "signature": "(self, header)", "symbol_type": "function"}], "set_header_info": [{"docstring": "Set the header information.\n\n:param r_free: the measured R-Free for the structure\n:param r_work: the measure R-Work for the structure\n:param resolution: the resolution of the structure\n:param title: the title of the structure\n:param deposition_date: the deposition date of the structure\n:param release_date: the release date of the structure\n:param experimnetal_methods: the list of experimental methods in the structure", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/DefaultParser.py", "line_number": 179, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.DefaultParser", "name": "set_header_info", "signature": "(self, r_free, r_work, resolution, title, deposition_date, release_date, experimnetal_methods)", "symbol_type": "function"}], "set_hit_accession": [{"docstring": "Record the accession value of the database sequence (PRIVATE).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIXML.py", "line_number": 994, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIXML", "name": "set_hit_accession", "signature": "(self)", "symbol_type": "function"}], "set_hit_def": [{"docstring": "Record the definition line of the database sequence (PRIVATE).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIXML.py", "line_number": 988, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIXML", "name": "set_hit_def", "signature": "(self)", "symbol_type": "function"}], "set_hit_id": [{"docstring": "Record the identifier of the database sequence (PRIVATE).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIXML.py", "line_number": 983, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIXML", "name": "set_hit_id", "signature": "(self)", "symbol_type": "function"}], "set_hit_len": [{"docstring": "Record the length of the hit.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIXML.py", "line_number": 999, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIXML", "name": "set_hit_len", "signature": "(self)", "symbol_type": "function"}], "set_homog_trans_mtx": [{"docstring": "Update existing translation matrix to new values.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 473, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "set_homog_trans_mtx", "signature": "(x: float, y: float, z: float, mtx: np.ndarray)", "symbol_type": "function"}], "set_id": [{"docstring": "Set the id of a node, if not set yet.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 135, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "set_id", "signature": "(self, id)", "symbol_type": "function"}], "set_inter_group_bond": [{"docstring": "Add bonds between groups.\n\n:param atom_index_one: the integer atom index (in the structure) of the first partner in the bond\n:param atom_index_two: the integer atom index (in the structure) of the second partner in the bond\n:param bond_order: the bond order", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/DefaultParser.py", "line_number": 224, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.DefaultParser", "name": "set_inter_group_bond", "signature": "(self, atom_index_one, atom_index_two, bond_order)", "symbol_type": "function"}], "set_json_cache": [{"docstring": "Set data in JSON cache file.\n\nArgs:\n    cache_file: Path to cache file\n    data: Data to cache", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/cache.py", "line_number": 101, "module": "src.metainformant.core.cache", "name": "set_json_cache", "signature": "(cache_file: Path, data: Any) -> None", "symbol_type": "function"}], "set_length": [{"docstring": "Set bond length for specified atom pair.\n\nSee :meth:`.pick_length` for ak_spec.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 3847, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "set_length", "signature": "(self, ak_spec: str | BKT, val: float) -> None", "symbol_type": "function"}, {"docstring": "Set bond length for specified atom pair; sets needs_update.\n\n:param tuple .ak_tpl: tuple of AtomKeys\n    Pair of atoms in this Hedron", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 4234, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "set_length", "signature": "(self, ak_tpl: BKT, newLength: float)", "symbol_type": "function"}], "set_line_counter": [{"docstring": "Tracks line in the PDB file that is being parsed.\n\nArguments:\n - line_counter - int", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureBuilder.py", "line_number": 65, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureBuilder", "name": "set_line_counter", "signature": "(self, line_counter: int)", "symbol_type": "function"}], "set_margins": [{"docstring": "Set page margins.\n\nArguments:\n - x         Float(0->1), Absolute X margin as % of page\n - y         Float(0->1), Absolute Y margin as % of page\n - xl        Float(0->1), Left X margin as % of page\n - xr        Float(0->1), Right X margin as % of page\n - yt        Float(0->1), Top Y margin as % of page\n - yb        Float(0->1), Bottom Y margin as % of page\n\nSet the page margins as proportions of the page 0->1, and also\nset the page limits x0, y0 and xlim, ylim, and page center\nxorigin, yorigin, as well as overall page width and height", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_AbstractDrawer.py", "line_number": 485, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._AbstractDrawer", "name": "set_margins", "signature": "(self, x, y, xl, xr, yt, yb)", "symbol_type": "function"}], "set_model_info": [{"docstring": "Set the information for a model.\n\n:param model_id: the index for the model\n:param chain_count: the number of chains in the model", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/DefaultParser.py", "line_number": 161, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.DefaultParser", "name": "set_model_info", "signature": "(self, model_id, chain_count)", "symbol_type": "function"}], "set_occupancy": [{"docstring": "Set occupancy.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 319, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "set_occupancy", "signature": "(self, occupancy: float | None)", "symbol_type": "function"}], "set_options": [{"docstring": "Set the value of an option.\n\nThis function abstracts the options dict to prevent the user from\nadding options that do not exist or misspelling options.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_paml.py", "line_number": 48, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._paml", "name": "set_options", "signature": "(self, **kwargs)", "symbol_type": "function"}], "set_page_size": [{"docstring": "Set page size of the drawing..\n\nArguments:\n - pagesize      Size of the output image, a tuple of pixels (width,\n   height, or a string in the reportlab.lib.pagesizes\n   set of ISO sizes.\n - orientation   String: 'landscape' or 'portrait'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_AbstractDrawer.py", "line_number": 459, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._AbstractDrawer", "name": "set_page_size", "signature": "(self, pagesize, orientation)", "symbol_type": "function"}], "set_parent": [{"docstring": "Set the parent residue.\n\nArguments:\n - parent - Residue object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 372, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "set_parent", "signature": "(self, parent)", "symbol_type": "function"}, {"docstring": "Set the parent Entity object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 251, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "set_parent", "signature": "(self, entity: _Parent)", "symbol_type": "function"}, {"docstring": "Set the parent for the object and its children.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 543, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "set_parent", "signature": "(self, parent)", "symbol_type": "function"}], "set_prev": [{"docstring": "Set the node's predecessor.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 170, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "set_prev", "signature": "(self, id)", "symbol_type": "function"}], "set_python_instance_state": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 595, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "set_python_instance_state", "signature": "(self, instance, state, unsafe = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/constructor.py", "line_number": 725, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.constructor", "name": "set_python_instance_state", "signature": "(self, instance, state)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 595, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "set_python_instance_state", "signature": "(self, instance, state, unsafe = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/constructor.py", "line_number": 725, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.constructor", "name": "set_python_instance_state", "signature": "(self, instance, state)", "symbol_type": "function"}], "set_radius": [{"docstring": "Set radius.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 355, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "set_radius", "signature": "(self, radius: float | None)", "symbol_type": "function"}], "set_reference": [{"docstring": "Define a reference structure onto which all others will be aligned.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/cealign.py", "line_number": 80, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.cealign", "name": "set_reference", "signature": "(self, structure)", "symbol_type": "function"}], "set_scale": [{"docstring": "Set the scale for a specific chromosome segment.\n\nBy default all segments have the same scale -- this allows scaling\nby the size of the segment.\n\nRaises a KeyError is the specified segment name is not found.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/DisplayRepresentation.py", "line_number": 103, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.DisplayRepresentation", "name": "set_scale", "signature": "(self, segment_name, scale)", "symbol_type": "function"}], "set_serial_number": [{"docstring": "Set serial number.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 303, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "set_serial_number", "signature": "(self, n)", "symbol_type": "function"}], "set_sigatm": [{"docstring": "Set standard deviation of atomic parameters.\n\nThe standard deviation of atomic parameters consists\nof 3 positional, 1 B factor and 1 occupancy standard\ndeviation.\n\n:param sigatm_array: standard deviations of atomic parameters.\n:type sigatm_array: NumPy array (length 5)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 323, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "set_sigatm", "signature": "(self, sigatm_array: np.ndarray | None)", "symbol_type": "function"}, {"docstring": "Set standard deviation of atom position of current Atom.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureBuilder.py", "line_number": 308, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureBuilder", "name": "set_sigatm", "signature": "(self, sigatm_array)", "symbol_type": "function"}], "set_siguij": [{"docstring": "Set standard deviations of anisotropic temperature factors.\n\n:param siguij_array: standard deviations of anisotropic temperature factors.\n:type siguij_array: NumPy array (length 6)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 335, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "set_siguij", "signature": "(self, siguij_array: np.ndarray | None)", "symbol_type": "function"}, {"docstring": "Set standard deviation of anisotropic B factor of current Atom.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureBuilder.py", "line_number": 304, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureBuilder", "name": "set_siguij", "signature": "(self, siguij_array)", "symbol_type": "function"}], "set_structure": [{"docstring": "Check what the user is providing and build a structure.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBIO.py", "line_number": 99, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBIO", "name": "set_structure", "signature": "(self, pdb_object)", "symbol_type": "function"}], "set_subtree": [{"docstring": "Return subtree as a set of nested sets.\n\nsets = set_subtree(self,node)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 397, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "set_subtree", "signature": "(self, node)", "symbol_type": "function"}], "set_succ": [{"docstring": "Set the node's successors.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 164, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "set_succ", "signature": "(self, new_succ)", "symbol_type": "function"}], "set_symmetry": [{"docstring": "Set symmetry.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/StructureBuilder.py", "line_number": 320, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.StructureBuilder", "name": "set_symmetry", "signature": "(self, spacegroup, cell)", "symbol_type": "function"}], "set_track_heights": [{"docstring": "Initialize track heights.\n\nSince tracks may not be of identical heights, the bottom and top\nradius for each track is stored in a dictionary - self.track_radii,\nkeyed by track number", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CircularDrawer.py", "line_number": 150, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CircularDrawer", "name": "set_track_heights", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set track heights.\n\nSince tracks may not be of identical heights, the bottom and top\noffsets of each track relative to the fragment top and bottom is\nstored in a dictionary - self.track_offsets, keyed by track number.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_LinearDrawer.py", "line_number": 268, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._LinearDrawer", "name": "set_track_heights", "signature": "(self)", "symbol_type": "function"}], "set_xtal_info": [{"docstring": "Set the crystallographic information for the structure.\n\n:param space_group: the space group name, e.g. \"P 21 21 21\"\n:param unit_cell: an array of length 6 with the unit cell parameters in order: a, b, c, alpha, beta, gamma", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/mmtf/DefaultParser.py", "line_number": 170, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.mmtf.DefaultParser", "name": "set_xtal_info", "signature": "(self, space_group, unit_cell)", "symbol_type": "function"}], "setter": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 113, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "setter", "signature": "(self, value)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 142, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "setter", "signature": "(self, value)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 163, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "setter", "signature": "(self, value)", "symbol_type": "function"}], "setup_logger": [{"docstring": "Set up a logger with file and/or console output.\n\nArgs:\n    name: Logger name\n    log_file: Optional log file path\n    level: Logging level\n\nReturns:\n    Configured logger", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/logging.py", "line_number": 37, "module": "src.metainformant.core.logging", "name": "setup_logger", "signature": "(name: str, log_file: str | None = None, level: str = 'INFO') -> logging.Logger", "symbol_type": "function"}], "setup_method": [{"docstring": "Set up test data for classification.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 34, "module": "tests.test_ml_comprehensive", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test data for regression.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 182, "module": "tests.test_ml_comprehensive", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up high-dimensional biological data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 307, "module": "tests.test_ml_comprehensive", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test data for validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 411, "module": "tests.test_ml_comprehensive", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test data with known statistical properties.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 25, "module": "tests.test_ml_features", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test data for RFE.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 137, "module": "tests.test_ml_features", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test data for stability selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 221, "module": "tests.test_ml_features", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test data with feature names and biological weights.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 319, "module": "tests.test_ml_features", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up comprehensive test data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 458, "module": "tests.test_ml_features", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test data with aligned samples.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 27, "module": "tests.test_multiomics_integration", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up multi-omics data for PCA testing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 257, "module": "tests.test_multiomics_integration", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up non-negative multi-omics data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 331, "module": "tests.test_multiomics_integration", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up correlated multi-omics data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 395, "module": "tests.test_multiomics_integration", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test networks with known community structure.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 21, "module": "tests.test_networks_community", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test network for modularity testing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 137, "module": "tests.test_networks_community", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test network with communities.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 196, "module": "tests.test_networks_community", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 172, "module": "tests.test_networks_graph", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test network with known centrality properties.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 222, "module": "tests.test_networks_graph", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 268, "module": "tests.test_networks_graph", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test pathway network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 26, "module": "tests.test_networks_pathway", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test data for enrichment analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 215, "module": "tests.test_networks_pathway", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up network and pathway data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 311, "module": "tests.test_networks_pathway", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test protein network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 27, "module": "tests.test_networks_ppi", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test data for interaction prediction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 270, "module": "tests.test_networks_ppi", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up PPI network with functional annotations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 360, "module": "tests.test_networks_ppi", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test gene regulatory network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 27, "module": "tests.test_networks_regulatory", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test expression data for GRN inference.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 225, "module": "tests.test_networks_regulatory", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up GRN with known motif structures.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 347, "module": "tests.test_networks_regulatory", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up GRN and pathway data for analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 428, "module": "tests.test_networks_regulatory", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test environment.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_basic.py", "line_number": 15, "module": "tests.test_phenotype_basic", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test FASTQ records with known properties.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 34, "module": "tests.test_quality_fastq", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test environment.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 16, "module": "tests.test_rna_amalgkit_comprehensive", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test environment.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 108, "module": "tests.test_rna_amalgkit_comprehensive", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test environment.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 195, "module": "tests.test_rna_amalgkit_comprehensive", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test environment.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 278, "module": "tests.test_rna_amalgkit_comprehensive", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test environment.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 338, "module": "tests.test_rna_amalgkit_comprehensive", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test environment.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 421, "module": "tests.test_rna_amalgkit_comprehensive", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test environment.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 460, "module": "tests.test_rna_amalgkit_comprehensive", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 21, "module": "tests.test_rna_amalgkit_end_to_end", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 207, "module": "tests.test_rna_amalgkit_end_to_end", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 302, "module": "tests.test_rna_amalgkit_end_to_end", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test single-cell data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 51, "module": "tests.test_singlecell_basic", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test data for dimensionality reduction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 201, "module": "tests.test_singlecell_basic", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set up test data for clustering.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 303, "module": "tests.test_singlecell_basic", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test data with known variance structure.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 37, "module": "tests.test_singlecell_dimensionality", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup preprocessed test data for PCA.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 122, "module": "tests.test_singlecell_dimensionality", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test data with PCA for neighbor computation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 210, "module": "tests.test_singlecell_dimensionality", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test data with neighbors for UMAP.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 291, "module": "tests.test_singlecell_dimensionality", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test data for t-SNE.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 365, "module": "tests.test_singlecell_dimensionality", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test data with neighbors for diffusion map.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 422, "module": "tests.test_singlecell_dimensionality", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test data with known characteristics.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 167, "module": "tests.test_singlecell_preprocessing", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Setup test data for normalization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 247, "module": "tests.test_singlecell_preprocessing", "name": "setup_method", "signature": "(self)", "symbol_type": "function"}], "setup_venv_and_dependencies": [{"docstring": "Automatically setup virtual environment and install dependencies using uv.\n\nUses uv for all operations to handle filesystem limitations (e.g., ext6 without symlinks).\n\nArgs:\n    auto_setup: If True, automatically create venv and install dependencies\n    \nReturns:\n    True if venv exists and is ready, False otherwise", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/_setup_utils.py", "line_number": 60, "module": "scripts.rna._setup_utils", "name": "setup_venv_and_dependencies", "signature": "(auto_setup: bool = True) -> bool", "symbol_type": "function"}], "sha256_bytes": [{"docstring": "Return the SHA-256 hex digest of bytes.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/hash.py", "line_number": 7, "module": "src.metainformant.core.hash", "name": "sha256_bytes", "signature": "(data: bytes) -> str", "symbol_type": "function"}], "sha256_file": [{"docstring": "Return the SHA-256 hex digest of a file without loading it entirely.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/hash.py", "line_number": 12, "module": "src.metainformant.core.hash", "name": "sha256_file", "signature": "(path: str | Path) -> str", "symbol_type": "function"}], "sha256_string": [{"docstring": "Compute SHA256 hash of string content.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/hash.py", "line_number": 39, "module": "src.metainformant.core.hash", "name": "sha256_string", "signature": "(s: str) -> str", "symbol_type": "function"}], "shannon_diversity": [{"docstring": "Calculate Shannon diversity index H' = -\u03a3(pi * ln(pi)).\n\nArgs:\n    abundances: Species abundance values (counts or proportions)\n\nReturns:\n    Shannon diversity index", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/community.py", "line_number": 12, "module": "src.metainformant.ecology.community", "name": "shannon_diversity", "signature": "(abundances: Sequence[float]) -> float", "symbol_type": "function"}], "shannon_entropy": [{"docstring": "Calculate Shannon entropy of a probability distribution.\n\nMeasures the information content or uncertainty in a probability\ndistribution. Higher entropy indicates greater uncertainty/randomness.\n\nArgs:\n    probs: Probability distribution (should sum to 1, but function\n        handles non-normalized inputs by normalizing)\n    base: Logarithm base (2 for bits, e for nats, 10 for dits)\n    \nReturns:\n    Shannon entropy. Formula: H = -\u03a3 p_i \u00d7 log_base(p_i) for p_i > 0\n    \nExamples:\n    >>> shannon_entropy([0.5, 0.5])  # Maximum entropy for 2 outcomes\n    1.0\n    >>> shannon_entropy([1.0, 0.0])  # Certainty (zero entropy)\n    0.0\n    >>> shannon_entropy([0.25, 0.25, 0.25, 0.25])  # Maximum for 4 outcomes\n    2.0\n    \nReferences:\n    Shannon, C. E. (1948). A mathematical theory of communication.\n    Bell System Technical Journal, 27(3), 379-423.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 17, "module": "src.metainformant.information.syntactic", "name": "shannon_entropy", "signature": "(probs: Sequence[float], base: float = 2.0) -> float", "symbol_type": "function"}, {"docstring": "Calculate Shannon entropy of a probability distribution.\n\nMeasures the information content or uncertainty in a probability distribution.\nHigher entropy indicates greater uncertainty/randomness.\n\nArgs:\n    values: List of probability values (should sum to 1, but function\n        handles non-normalized inputs by only considering positive values)\n    \nReturns:\n    Shannon entropy in bits (using log base 2). Formula:\n    H = -\u03a3 p_i \u00d7 log2(p_i) for p_i > 0\n    \nExamples:\n    >>> shannon_entropy([0.5, 0.5])  # Maximum entropy for 2 outcomes\n    1.0\n    >>> shannon_entropy([1.0, 0.0])  # Certainty (zero entropy)\n    0.0\n    >>> shannon_entropy([0.25, 0.25, 0.25, 0.25])  # Maximum for 4 outcomes\n    2.0\n    \nReferences:\n    Shannon, C. E. (1948). A mathematical theory of communication.\n    Bell System Technical Journal, 27(3), 379-423.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/__init__.py", "line_number": 451, "module": "src.metainformant.math.__init__", "name": "shannon_entropy", "signature": "(values: list[float]) -> float", "symbol_type": "function"}], "shannon_entropy_from_counts": [{"docstring": "Calculate Shannon entropy from counts or frequency dictionary.\n\nArgs:\n    counts: Counts or frequency dictionary\n    \nReturns:\n    Shannon entropy in bits", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 60, "module": "src.metainformant.information.syntactic", "name": "shannon_entropy_from_counts", "signature": "(counts: Sequence[int] | dict[Any, int]) -> float", "symbol_type": "function"}], "shape": [{"docstring": "Return the shape of the alignment as a tuple of two integer values.\n\nThe first integer value is the number of sequences in the alignment as\nreturned by len(alignment), which is always 2 for pairwise alignments.\n\nThe second integer value is the number of columns in the alignment when\nit is printed, and is equal to the sum of the number of matches, number\nof mismatches, and the total length of gaps in the target and query.\nSequence sections beyond the aligned segment are not included in the\nnumber of columns.\n\nFor example,\n\n>>> from Bio import Align\n>>> aligner = Align.PairwiseAligner()\n>>> aligner.mode = \"global\"\n>>> alignments = aligner.align(\"GACCTG\", \"CGATCG\")\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            0 -GACCTG 6\n                  0 -||.|-| 7\nquery             0 CGATC-G 6\n<BLANKLINE>\n>>> len(alignment)\n2\n>>> alignment.shape\n(2, 7)\n>>> aligner.mode = \"local\"\n>>> alignments = aligner.align(\"GACCTG\", \"CGATCG\")\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            0 GACC 4\n                  0 ||.| 4\nquery             1 GATC 5\n<BLANKLINE>\n>>> len(alignment)\n2\n>>> alignment.shape\n(2, 4)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 2951, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "shape", "signature": "(self)", "symbol_type": "function"}], "shortest_paths": [{"docstring": "Calculate shortest path distances between all pairs of nodes.\n\nUses breadth-first search (BFS) for unweighted graphs or Dijkstra-like\nBFS for weighted graphs. Finds minimum path length between every\npair of nodes. For large networks, this can be computationally expensive.\n\nArgs:\n    network: Input biological network\n    \nReturns:\n    Nested dictionary mapping source_node -> target_node -> distance.\n    Distance is measured in edge weights (1.0 for unweighted edges).\n    Unreachable nodes have distance of float(\"inf\").\n    Distance to self is always 0.0.\n    \nExamples:\n    >>> network = create_network([\"A\", \"B\", \"C\", \"D\"], directed=False)\n    >>> network.add_edge(\"A\", \"B\", weight=1.0)\n    >>> network.add_edge(\"B\", \"C\", weight=2.0)\n    >>> paths = shortest_paths(network)\n    >>> paths[\"A\"][\"C\"]\n    3.0  # Path A -> B -> C\n    >>> paths[\"A\"][\"D\"]\n    inf  # Not reachable\n    \nNote:\n    For very large networks (>1000 nodes), consider using subgraph\n    extraction or filtering before computing shortest paths.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/graph.py", "line_number": 410, "module": "src.metainformant.networks.graph", "name": "shortest_paths", "signature": "(network: BiologicalNetwork) -> Dict[str, Dict[str, float]]", "symbol_type": "function"}], "show_codes": [{"docstring": "Print a list of supplier codes.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2208, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "show_codes", "signature": "(cls)", "symbol_type": "function"}], "show_only_between": [{"docstring": "Return only results from within start, end.\n\nEnzymes must cut inside start/end and may also cut outside. However,\nonly the cutting positions within start/end will be returned.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2487, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "show_only_between", "signature": "(self, start, end, dct = None)", "symbol_type": "function"}], "simpleElement": [{"docstring": "Create an XML element without children with the given content.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlastIO/blast_xml.py", "line_number": 733, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlastIO.blast_xml", "name": "simpleElement", "signature": "(self, name, content = None)", "symbol_type": "function"}], "simple_classifier": [{"docstring": "Simple majority class classifier for testing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 471, "module": "tests.test_ml_comprehensive", "name": "simple_classifier", "signature": "(X_train, y_train, X_val, y_val)", "symbol_type": "function"}], "simple_helix_coil_propensity": [{"docstring": "Return per-residue helix propensity in [0,1] using a simple scale.\n\nThis is a placeholder deterministic method that avoids external models,\nproviding a quick baseline suitable for unit tests and examples.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/protein/secondary.py", "line_number": 30, "module": "src.metainformant.protein.secondary", "name": "simple_helix_coil_propensity", "signature": "(seq: str) -> List[float]", "symbol_type": "function"}], "simple_mean_model": [{"docstring": "Simple mean predictor for regression testing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 496, "module": "tests.test_ml_comprehensive", "name": "simple_mean_model", "signature": "(X_train, y_train, X_test, y_test)", "symbol_type": "function"}], "simpson_diversity": [{"docstring": "Calculate Simpson's diversity index D = 1 - \u03a3(pi^2).\n\nArgs:\n    abundances: Species abundance values\n\nReturns:\n    Simpson's diversity index", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/community.py", "line_number": 33, "module": "src.metainformant.ecology.community", "name": "simpson_diversity", "signature": "(abundances: Sequence[float]) -> float", "symbol_type": "function"}], "simulate_abundance": [{"docstring": "Simulate species abundance matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_ecology.py", "line_number": 29, "module": "scripts.simulation.simulate_ecology", "name": "simulate_abundance", "signature": "(output_dir: Path, n_species: int, n_samples: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_alignment": [{"docstring": "Simulate sequences for alignment testing.\n\nArgs:\n    output_dir: Output directory for results\n    n_sequences: Number of sequences to generate\n    sequence_length: Length of each sequence\n    gc_content: GC content (0.0-1.0)\n    mutation_rate: Mutation rate per site (0.0-1.0)\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_dna.py", "line_number": 155, "module": "scripts.simulation.simulate_dna", "name": "simulate_alignment", "signature": "(output_dir: Path, n_sequences: int, sequence_length: int, gc_content: float, mutation_rate: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_annotations": [{"docstring": "Simulate gene-to-GO-term annotations.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_ontology.py", "line_number": 26, "module": "scripts.simulation.simulate_ontology", "name": "simulate_annotations", "signature": "(output_dir: Path, n_genes: int, n_terms: int, annotations_per_gene: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_batch": [{"docstring": "Simulate batch effects in expression data.\n\nArgs:\n    output_dir: Output directory for results\n    num_genes: Number of genes\n    num_samples: Number of samples\n    n_batches: Number of batches\n    batch_effect_size: Size of batch effects\n    mean_expression: Mean expression level\n    dispersion: Dispersion parameter\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_rna.py", "line_number": 187, "module": "scripts.simulation.simulate_rna", "name": "simulate_batch", "signature": "(output_dir: Path, num_genes: int, num_samples: int, n_batches: int, batch_effect_size: float, mean_expression: float, dispersion: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_behavioral": [{"docstring": "Simulate behavioral traits.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_phenotype.py", "line_number": 69, "module": "scripts.simulation.simulate_phenotype", "name": "simulate_behavioral", "signature": "(output_dir: Path, n_samples: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_bottleneck_population": [{"docstring": "Simulate a population that went through a bottleneck.\n\nModels a population that experienced a reduction in size (bottleneck),\nthen recovery. This creates a characteristic signature: reduced diversity,\nexcess of rare alleles, and negative Tajima's D.\n\nArgs:\n    n_sequences: Number of sequences to generate\n    sequence_length: Length of each sequence\n    pre_bottleneck_diversity: Nucleotide diversity before bottleneck\n    bottleneck_size: Effective population size during bottleneck\n    bottleneck_duration: Number of generations at bottleneck size\n    recovery_generations: Number of generations since bottleneck\n    mutation_rate: Per-site mutation rate\n    rng: Random number generator\n\nReturns:\n    List of sequences reflecting bottleneck signature\n\nExamples:\n    >>> seqs = simulate_bottleneck_population(\n    ...     n_sequences=20,\n    ...     sequence_length=1000,\n    ...     bottleneck_size=5,\n    ...     bottleneck_duration=10\n    ... )\n    >>> len(seqs)\n    20", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/popgen.py", "line_number": 340, "module": "src.metainformant.simulation.popgen", "name": "simulate_bottleneck_population", "signature": "(n_sequences: int, sequence_length: int) -> list[str]", "symbol_type": "function"}], "simulate_celltypes": [{"docstring": "Simulate single-cell data with cell type annotations.\n\nArgs:\n    output_dir: Output directory for results\n    n_cells: Number of cells\n    n_genes: Number of genes\n    n_types: Number of cell types\n    mean_expression: Mean expression level\n    dispersion: Dispersion parameter\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_singlecell.py", "line_number": 89, "module": "scripts.simulation.simulate_singlecell", "name": "simulate_celltypes", "signature": "(output_dir: Path, n_cells: int, n_genes: int, n_types: int, mean_expression: float, dispersion: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_chipseq": [{"docstring": "Simulate ChIP-seq peak data.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_epigenome.py", "line_number": 125, "module": "scripts.simulation.simulate_epigenome", "name": "simulate_chipseq", "signature": "(output_dir: Path, n_peaks: int, chromosome: str, length: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_chromatin": [{"docstring": "Simulate chromatin accessibility tracks (bedGraph format).", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_epigenome.py", "line_number": 72, "module": "scripts.simulation.simulate_epigenome", "name": "simulate_chromatin", "signature": "(output_dir: Path, chromosome: str, length: int, n_regions: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_classification": [{"docstring": "Simulate classification dataset.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_ml.py", "line_number": 29, "module": "scripts.simulation.simulate_ml", "name": "simulate_classification", "signature": "(output_dir: Path, n_samples: int, n_features: int, n_classes: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_coalescent": [{"docstring": "Simulate coalescent data.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_math.py", "line_number": 31, "module": "scripts.simulation.simulate_math", "name": "simulate_coalescent", "signature": "(output_dir: Path, n_samples: int, n_loci: int, effective_size: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_community": [{"docstring": "Simulate community composition with specified diversity.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_ecology.py", "line_number": 61, "module": "scripts.simulation.simulate_ecology", "name": "simulate_community", "signature": "(output_dir: Path, n_species: int, n_samples: int, diversity_index: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_config": [{"docstring": "Simulate configuration files.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_core.py", "line_number": 26, "module": "scripts.simulation.simulate_core", "name": "simulate_config", "signature": "(output_dir: Path, n_configs: int, config_type: str, seed: int) -> dict", "symbol_type": "function"}], "simulate_contamination": [{"docstring": "Simulate contamination patterns.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_quality.py", "line_number": 94, "module": "scripts.simulation.simulate_quality", "name": "simulate_contamination", "signature": "(output_dir: Path, n_reads: int, read_length: int, contamination_rate: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_correlation": [{"docstring": "Simulate correlated traits.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_phenotype.py", "line_number": 112, "module": "scripts.simulation.simulate_phenotype", "name": "simulate_correlation", "signature": "(output_dir: Path, n_samples: int, n_traits: int, correlation_strength: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_counts": [{"docstring": "Simulate basic RNA-seq count matrix.\n\nArgs:\n    output_dir: Output directory for results\n    num_genes: Number of genes\n    num_samples: Number of samples\n    mean_expression: Mean expression level\n    dispersion: Dispersion parameter (must be > 0)\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_rna.py", "line_number": 29, "module": "scripts.simulation.simulate_rna", "name": "simulate_counts", "signature": "(output_dir: Path, num_genes: int, num_samples: int, mean_expression: float, dispersion: float, seed: int) -> dict", "symbol_type": "function"}, {"docstring": "Simulate basic single-cell count matrix.\n\nArgs:\n    output_dir: Output directory for results\n    n_cells: Number of cells\n    n_genes: Number of genes\n    mean_expression: Mean expression level\n    dispersion: Dispersion parameter\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_singlecell.py", "line_number": 30, "module": "scripts.simulation.simulate_singlecell", "name": "simulate_counts", "signature": "(output_dir: Path, n_cells: int, n_genes: int, mean_expression: float, dispersion: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_counts_negative_binomial": [{"docstring": "Simulate RNA-seq count matrix (genes x samples) from NB.\n\nArgs:\n    num_genes: Number of genes (rows)\n    num_samples: Number of samples (columns)\n    mean_expression: Mean expression level\n    dispersion: Dispersion parameter (must be > 0)\n    rng: Random number generator\n\nReturns:\n    List of rows, each a list of counts per sample\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/rna.py", "line_number": 60, "module": "src.metainformant.simulation.rna", "name": "simulate_counts_negative_binomial", "signature": "(num_genes: int, num_samples: int) -> list[list[int]]", "symbol_type": "function"}], "simulate_crossplatform": [{"docstring": "Simulate cross-platform multi-omics data.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_multiomics.py", "line_number": 31, "module": "scripts.simulation.simulate_multiomics", "name": "simulate_crossplatform", "signature": "(output_dir: Path, n_samples: int, n_genes: int, n_variants: int, n_proteins: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_differential": [{"docstring": "Simulate differential expression between two groups.\n\nArgs:\n    output_dir: Output directory for results\n    num_genes: Number of genes\n    num_samples: Number of samples (split into two groups)\n    n_de_genes: Number of differentially expressed genes\n    fold_change: Fold change for DE genes\n    mean_expression: Mean expression level\n    dispersion: Dispersion parameter\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_rna.py", "line_number": 89, "module": "scripts.simulation.simulate_rna", "name": "simulate_differential", "signature": "(output_dir: Path, num_genes: int, num_samples: int, n_de_genes: int, fold_change: float, mean_expression: float, dispersion: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_domains": [{"docstring": "Simulate protein domain annotations.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_protein.py", "line_number": 130, "module": "scripts.simulation.simulate_protein", "name": "simulate_domains", "signature": "(output_dir: Path, n_sequences: int, sequence_length: int, n_domains_per_seq: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_enrichment": [{"docstring": "Simulate enrichment test results.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_ontology.py", "line_number": 76, "module": "scripts.simulation.simulate_ontology", "name": "simulate_enrichment", "signature": "(output_dir: Path, n_genes: int, n_terms: int, n_significant: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_environmental": [{"docstring": "Simulate environmental metadata.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_ecology.py", "line_number": 116, "module": "scripts.simulation.simulate_ecology", "name": "simulate_environmental", "signature": "(output_dir: Path, n_samples: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_fastq": [{"docstring": "Simulate FASTQ quality scores.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_quality.py", "line_number": 30, "module": "scripts.simulation.simulate_quality", "name": "simulate_fastq", "signature": "(output_dir: Path, n_reads: int, read_length: int, mean_quality: int, quality_degradation: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_features": [{"docstring": "Simulate feature matrix with different feature types.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_ml.py", "line_number": 153, "module": "scripts.simulation.simulate_ml", "name": "simulate_features", "signature": "(output_dir: Path, n_samples: int, n_features: int, feature_types: list[str], seed: int) -> dict", "symbol_type": "function"}], "simulate_generation": [{"docstring": "Simulate one generation of selection on a trait.\n\nArgs:\n    s: Trait values for current generation\n    phi: Transformation function from trait to observable\n    phi_bar: Noiseless transformation function\n    s_hat: Selection strength parameter\n    delta_fn: Mutation/drift function\n    fitness_fn: Fitness function\n    \nReturns:\n    GenerationResult with all statistics for the generation", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/model.py", "line_number": 170, "module": "src.metainformant.math.selection_experiments.model", "name": "simulate_generation", "signature": "(s: np.ndarray) -> GenerationResult", "symbol_type": "function"}], "simulate_generations": [{"docstring": "Simulate multiple generations of selection evolution.\n\nArgs:\n    generations: Number of generations to simulate\n    n: Population size\n    s_hat: Selection strength parameter\n    **kwargs: Additional parameters passed to simulate_generation\n    \nReturns:\n    GenerationsResult with statistics across all generations", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection_experiments/model.py", "line_number": 281, "module": "src.metainformant.math.selection_experiments.model", "name": "simulate_generations", "signature": "(**kwargs: Any) -> GenerationsResult", "symbol_type": "function"}], "simulate_genotypes": [{"docstring": "Simulate genotype matrix.\n\nArgs:\n    output_dir: Output directory for results\n    n_samples: Number of samples\n    n_sites: Number of variant sites\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_gwas.py", "line_number": 106, "module": "scripts.simulation.simulate_gwas", "name": "simulate_genotypes", "signature": "(output_dir: Path, n_samples: int, n_sites: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_integrated": [{"docstring": "Simulate integrated multi-omics dataset.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_multiomics.py", "line_number": 91, "module": "scripts.simulation.simulate_multiomics", "name": "simulate_integrated", "signature": "(output_dir: Path, n_samples: int, n_features_per_omic: int, n_omics: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_io": [{"docstring": "Simulate I/O test data.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_core.py", "line_number": 175, "module": "scripts.simulation.simulate_core", "name": "simulate_io", "signature": "(output_dir: Path, n_files: int, file_types: list[str], seed: int) -> dict", "symbol_type": "function"}], "simulate_methylation": [{"docstring": "Simulate DNA methylation data (CpG sites).", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_epigenome.py", "line_number": 28, "module": "scripts.simulation.simulate_epigenome", "name": "simulate_methylation", "signature": "(output_dir: Path, n_sites: int, chromosome: str, mean_coverage: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_metrics": [{"docstring": "Simulate quality control metrics.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_quality.py", "line_number": 166, "module": "scripts.simulation.simulate_quality", "name": "simulate_metrics", "signature": "(output_dir: Path, n_samples: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_morphological": [{"docstring": "Simulate morphological traits.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_phenotype.py", "line_number": 29, "module": "scripts.simulation.simulate_phenotype", "name": "simulate_morphological", "signature": "(output_dir: Path, n_samples: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_multidim": [{"docstring": "Simulate multi-dimensional data with clusters.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_visualization.py", "line_number": 72, "module": "scripts.simulation.simulate_visualization", "name": "simulate_multidim", "signature": "(output_dir: Path, n_samples: int, n_features: int, n_clusters: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_mutual": [{"docstring": "Simulate data for mutual information analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_information.py", "line_number": 87, "module": "scripts.simulation.simulate_information", "name": "simulate_mutual", "signature": "(output_dir: Path, n_samples: int, correlation_strength: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_pathway": [{"docstring": "Simulate pathway network.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_networks.py", "line_number": 134, "module": "scripts.simulation.simulate_networks", "name": "simulate_pathway", "signature": "(output_dir: Path, n_nodes: int, n_edges: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_patterns": [{"docstring": "Simulate life course patterns.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_life_events.py", "line_number": 94, "module": "scripts.simulation.simulate_life_events", "name": "simulate_patterns", "signature": "(output_dir: Path, n_sequences: int, n_patterns: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_phenotype": [{"docstring": "Simulate phenotype with genetic effects.\n\nArgs:\n    output_dir: Output directory for results\n    n_samples: Number of samples\n    n_causal_variants: Number of causal variants\n    heritability: Heritability (0.0-1.0)\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_gwas.py", "line_number": 154, "module": "scripts.simulation.simulate_gwas", "name": "simulate_phenotype", "signature": "(output_dir: Path, n_samples: int, n_causal_variants: int, heritability: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_phylogeny": [{"docstring": "Simulate sequences for phylogenetic tree construction.\n\nArgs:\n    output_dir: Output directory for results\n    n_sequences: Number of sequences (minimum 3 for tree)\n    sequence_length: Length of each sequence\n    gc_content: GC content (0.0-1.0)\n    diversity: Nucleotide diversity\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_dna.py", "line_number": 213, "module": "scripts.simulation.simulate_dna", "name": "simulate_phylogeny", "signature": "(output_dir: Path, n_sequences: int, sequence_length: int, gc_content: float, diversity: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_popgen": [{"docstring": "Simulate population genetics data.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_math.py", "line_number": 125, "module": "scripts.simulation.simulate_math", "name": "simulate_popgen", "signature": "(output_dir: Path, n_sequences: int, sequence_length: int, diversity: float, fst: float | None, seed: int) -> dict", "symbol_type": "function"}], "simulate_population": [{"docstring": "Simulate population genetics data.\n\nArgs:\n    output_dir: Output directory for results\n    n_sequences: Number of sequences in population\n    sequence_length: Length of each sequence\n    diversity: Nucleotide diversity (None for default)\n    gc_content: GC content (0.0-1.0)\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_dna.py", "line_number": 89, "module": "scripts.simulation.simulate_dna", "name": "simulate_population", "signature": "(output_dir: Path, n_sequences: int, sequence_length: int, diversity: float | None, gc_content: float, seed: int) -> dict", "symbol_type": "function"}, {"docstring": "Simulate population structure.\n\nArgs:\n    output_dir: Output directory for results\n    n_samples: Number of samples\n    n_populations: Number of populations\n    fst: Fst value (0.0-1.0)\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_gwas.py", "line_number": 234, "module": "scripts.simulation.simulate_gwas", "name": "simulate_population", "signature": "(output_dir: Path, n_samples: int, n_populations: int, fst: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_population_expansion": [{"docstring": "Simulate a population that underwent recent expansion.\n\nModels exponential population growth, which creates excess of rare alleles\nand negative Tajima's D (similar to bottleneck but different mechanism).\n\nArgs:\n    n_sequences: Number of sequences to generate\n    sequence_length: Length of each sequence\n    initial_diversity: Nucleotide diversity in small ancestral population\n    expansion_factor: How much population grew (e.g., 10x)\n    growth_rate: Per-generation growth rate\n    mutation_rate: Per-site mutation rate\n    rng: Random number generator\n\nReturns:\n    List of sequences reflecting expansion signature\n\nExamples:\n    >>> seqs = simulate_population_expansion(\n    ...     n_sequences=20,\n    ...     sequence_length=1000,\n    ...     expansion_factor=10.0\n    ... )\n    >>> len(seqs)\n    20", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/popgen.py", "line_number": 417, "module": "src.metainformant.simulation.popgen", "name": "simulate_population_expansion", "signature": "(n_sequences: int, sequence_length: int) -> list[str]", "symbol_type": "function"}], "simulate_ppi": [{"docstring": "Simulate protein-protein interaction network.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_protein.py", "line_number": 195, "module": "scripts.simulation.simulate_protein", "name": "simulate_ppi", "signature": "(output_dir: Path, n_proteins: int, n_interactions: int, seed: int) -> dict", "symbol_type": "function"}, {"docstring": "Simulate protein-protein interaction network.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_networks.py", "line_number": 28, "module": "scripts.simulation.simulate_networks", "name": "simulate_ppi", "signature": "(output_dir: Path, n_nodes: int, n_edges: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_regression": [{"docstring": "Simulate regression dataset.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_ml.py", "line_number": 90, "module": "scripts.simulation.simulate_ml", "name": "simulate_regression", "signature": "(output_dir: Path, n_samples: int, n_features: int, noise_level: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_regulatory": [{"docstring": "Simulate gene regulatory network.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_networks.py", "line_number": 81, "module": "scripts.simulation.simulate_networks", "name": "simulate_regulatory", "signature": "(output_dir: Path, n_nodes: int, n_edges: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_selection": [{"docstring": "Simulate selection experiment.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_math.py", "line_number": 76, "module": "scripts.simulation.simulate_math", "name": "simulate_selection", "signature": "(output_dir: Path, n_generations: int, population_size: int, selection_coefficient: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_sequences": [{"docstring": "Simulate basic DNA sequences.\n\nArgs:\n    output_dir: Output directory for results\n    n_sequences: Number of sequences to generate\n    sequence_length: Length of each sequence\n    gc_content: GC content (0.0-1.0)\n    mutations: Number of mutations per sequence\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_dna.py", "line_number": 35, "module": "scripts.simulation.simulate_dna", "name": "simulate_sequences", "signature": "(output_dir: Path, n_sequences: int, sequence_length: int, gc_content: float, mutations: int, seed: int) -> dict", "symbol_type": "function"}, {"docstring": "Simulate basic protein sequences.\n\nArgs:\n    output_dir: Output directory for results\n    n_sequences: Number of sequences to generate\n    sequence_length: Length of each sequence\n    mutations: Number of mutations per sequence\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_protein.py", "line_number": 29, "module": "scripts.simulation.simulate_protein", "name": "simulate_sequences", "signature": "(output_dir: Path, n_sequences: int, sequence_length: int, mutations: int, seed: int) -> dict", "symbol_type": "function"}, {"docstring": "Simulate life event sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_life_events.py", "line_number": 26, "module": "scripts.simulation.simulate_life_events", "name": "simulate_sequences", "signature": "(output_dir: Path, n_sequences: int, min_events: int, max_events: int, seed: int) -> dict", "symbol_type": "function"}, {"docstring": "Simulate sequences with varying information content.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_information.py", "line_number": 26, "module": "scripts.simulation.simulate_information", "name": "simulate_sequences", "signature": "(output_dir: Path, n_sequences: int, sequence_length: int, gc_content: float, complexity_level: str, seed: int) -> dict", "symbol_type": "function"}], "simulate_statistical": [{"docstring": "Simulate statistical test data.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_visualization.py", "line_number": 128, "module": "scripts.simulation.simulate_visualization", "name": "simulate_statistical", "signature": "(output_dir: Path, n_samples: int, n_groups: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_structure": [{"docstring": "Simulate protein structure coordinates (CA atoms).", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_protein.py", "line_number": 79, "module": "scripts.simulation.simulate_protein", "name": "simulate_structure", "signature": "(output_dir: Path, n_sequences: int, sequence_length: int, seed: int) -> dict", "symbol_type": "function"}], "simulate_timeseries": [{"docstring": "Simulate time-series data.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_visualization.py", "line_number": 29, "module": "scripts.simulation.simulate_visualization", "name": "simulate_timeseries", "signature": "(output_dir: Path, n_points: int, n_series: int, noise_level: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_trajectory": [{"docstring": "Simulate trajectory/pseudotime data.\n\nArgs:\n    output_dir: Output directory for results\n    n_cells: Number of cells\n    n_genes: Number of genes\n    n_states: Number of trajectory states\n    mean_expression: Mean expression level\n    dispersion: Dispersion parameter\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_singlecell.py", "line_number": 219, "module": "scripts.simulation.simulate_singlecell", "name": "simulate_trajectory", "signature": "(output_dir: Path, n_cells: int, n_genes: int, n_states: int, mean_expression: float, dispersion: float, seed: int) -> dict", "symbol_type": "function"}], "simulate_variants": [{"docstring": "Simulate variant VCF file.\n\nArgs:\n    output_dir: Output directory for results\n    n_variants: Number of variants to generate\n    n_samples: Number of samples\n    chromosome: Chromosome name\n    seed: Random seed for reproducibility\n    \nReturns:\n    Dictionary with simulation results and metadata\n    \nRaises:\n    ValidationError: If parameters are invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_gwas.py", "line_number": 31, "module": "scripts.simulation.simulate_gwas", "name": "simulate_variants", "signature": "(output_dir: Path, n_variants: int, n_samples: int, chromosome: str, seed: int) -> dict", "symbol_type": "function"}], "simulate_workflow": [{"docstring": "Simulate workflow test data.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/simulate_core.py", "line_number": 118, "module": "scripts.simulation.simulate_core", "name": "simulate_workflow", "signature": "(output_dir: Path, n_steps: int, seed: int) -> dict", "symbol_type": "function"}], "singlecell_integration": [{"docstring": "Information-theoretic analysis of single-cell data.\n\nArgs:\n    count_matrix: Count matrix (cells x genes)\n    cell_types: Optional list of cell type labels\n    method: Analysis method (\"cell_type_entropy\", \"gene_entropy\")\n    \nReturns:\n    Analysis results dictionary\n    \nRaises:\n    ValueError: If count_matrix is empty or has invalid shape", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/integration.py", "line_number": 239, "module": "src.metainformant.information.integration", "name": "singlecell_integration", "signature": "(count_matrix: np.ndarray, cell_types: list[str] | None = None, method: str = 'cell_type_entropy') -> dict[str, Any]", "symbol_type": "function"}], "singleitem": [{"docstring": "Property for fetching attribute from first entry of container.\n\nReturns a property that fetches the given attribute from\nthe first item in a SearchIO container object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_utils.py", "line_number": 67, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._utils", "name": "singleitem", "signature": "(attr = None, doc = '')", "symbol_type": "function"}], "sink": [{"docstring": "Return list of unique sinks for species.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 300, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "sink", "signature": "(self, species)", "symbol_type": "function"}], "sink_interactions": [{"docstring": "Return list of (sink, interaction) pairs for species.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 304, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "sink_interactions", "signature": "(self, species)", "symbol_type": "function"}], "sir_step": [{"docstring": "Perform single Euler integration step of the SIR epidemiological model.\n\nThe SIR model divides population into Susceptible (S), Infected (I), and\nRecovered (R) compartments. Used to model disease spread dynamics.\n\nDifferential equations:\n- dS/dt = -beta * S * I\n- dI/dt = beta * S * I - gamma * I\n- dR/dt = gamma * I\n\nArgs:\n    S: Current susceptible population\n    I: Current infected population\n    R: Current recovered population\n    beta: Transmission rate (contact rate * probability of transmission)\n    gamma: Recovery rate (1 / average infectious period)\n    dt: Time step size for Euler integration (default 0.01)\n    \nReturns:\n    Tuple of (next_S, next_I, next_R) after one time step.\n    Values are clamped to non-negative.\n    \nExamples:\n    >>> S, I, R = sir_step(S=990.0, I=10.0, R=0.0, beta=0.3, gamma=0.1, dt=0.01)\n    >>> S + I + R  # Total population should be preserved\n    1000.0\n    \nReferences:\n    Kermack, W. O., & McKendrick, A. G. (1927). A contribution to the\n    mathematical theory of epidemics. Proceedings of the royal society of\n    London. Series A, 115(772), 700-721.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/epidemiology.py", "line_number": 4, "module": "src.metainformant.math.epidemiology", "name": "sir_step", "signature": "(S: float, I: float, R: float, beta: float, gamma: float, dt: float = 0.01) -> tuple[float, float, float]", "symbol_type": "function"}], "sis_step": [{"docstring": "Single Euler step for SIS model (no removed class).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/epidemiology.py", "line_number": 116, "module": "src.metainformant.math.epidemiology", "name": "sis_step", "signature": "(S: float, I: float, beta: float, gamma: float, dt: float = 0.01) -> tuple[float, float]", "symbol_type": "function"}], "site_frequency_spectrum_counts": [{"docstring": "Count sites by derived allele frequency to construct site frequency spectrum.\n\nConverts a list of derived allele counts (how many derived alleles at each site)\ninto the site frequency spectrum, which counts how many sites have i derived\nalleles for each i = 1, 2, ..., n-1.\n\nArgs:\n    derived_counts: Iterable of derived allele counts, one per polymorphic site\n        (e.g., [1, 2, 1, 3, 1] means 5 sites with 1, 2, 1, 3, 1 derived alleles)\n    sample_size: Number of sampled sequences (n). Derived counts must be in [1, n-1]\n        for polymorphic sites.\n        \nReturns:\n    List of length (n//2) where the i-th element (0-indexed) is the count of sites\n    with minor allele frequency (i+1). Only counts minor allele frequencies (frequencies\n    up to n/2), as frequencies > n/2 are symmetric to frequencies < n/2.\n    \n    For example, with n=5:\n    - Sites with 1 or 4 derived alleles both map to minor frequency 1\n    - Sites with 2 or 3 derived alleles both map to minor frequency 2\n    \nNote:\n    This function only counts minor allele frequencies (frequencies \u2264 n/2).\n    Major allele frequencies (frequencies > n/2) are folded into the minor\n    frequency counts. This is standard practice in SFS analysis to avoid\n    ambiguity about which allele is ancestral.\n    \nExamples:\n    >>> counts = site_frequency_spectrum_counts([1, 1, 2, 2, 3], sample_size=5)\n    >>> counts[0]  # Sites with minor allele frequency 1 (1 or 4 derived alleles)\n    2\n    >>> counts[1]  # Sites with minor allele frequency 2 (2 or 3 derived alleles)\n    3", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 860, "module": "src.metainformant.math.coalescent", "name": "site_frequency_spectrum_counts", "signature": "(derived_counts: Iterable[int], sample_size: int) -> list[int]", "symbol_type": "function"}], "six_frame_translations": [{"docstring": "Return pretty string showing the 6 frame translations and GC content.\n\nNice looking 6 frame translation with GC content - code from xbbtools\nsimilar to DNA Striders six-frame translation\n\n>>> from Bio.SeqUtils import six_frame_translations\n>>> print(six_frame_translations(\"AUGGCCAUUGUAAUGGGCCGCUGA\"))\nGC_Frame: a:5 t:0 g:8 c:5\nSequence: auggccauug ... gggccgcuga, 24 nt, 54.17 %GC\n<BLANKLINE>\n<BLANKLINE>\n1/1\n  G  H  C  N  G  P  L\n W  P  L  *  W  A  A\nM  A  I  V  M  G  R  *\nauggccauuguaaugggccgcuga   54 %\nuaccgguaacauuacccggcgacu\nA  M  T  I  P  R  Q\n H  G  N  Y  H  A  A  S\n  P  W  Q  L  P  G  S\n<BLANKLINE>\n<BLANKLINE>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/__init__.py", "line_number": 503, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.__init__", "name": "six_frame_translations", "signature": "(seq, genetic_code = 1)", "symbol_type": "function"}], "size": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1270, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "size", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Record the sequence length.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 328, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "size", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 909, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "size", "signature": "(self, content)", "symbol_type": "function"}], "skipCharacterDataHandler": [{"docstring": "Handle character data by skipping it.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 864, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "skipCharacterDataHandler", "signature": "(self, content)", "symbol_type": "function"}], "skip_header": [{"docstring": "Skip the Header. To be done after a re-open.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/FileParser.py", "line_number": 133, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.FileParser", "name": "skip_header", "signature": "(self)", "symbol_type": "function"}], "skip_population": [{"docstring": "Skip the current population. Returns true if there is another pop.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/FileParser.py", "line_number": 158, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.FileParser", "name": "skip_population", "signature": "(self)", "symbol_type": "function"}], "skip_whitespace": [{"docstring": "Skip whitespace characters in NEXUS file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 110, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "skip_whitespace", "signature": "(self)", "symbol_type": "function"}], "slugify": [{"docstring": "Lowercase, normalize spaces to dashes, and drop invalid URL chars.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/text.py", "line_number": 15, "module": "src.metainformant.core.text", "name": "slugify", "signature": "(s: str) -> str", "symbol_type": "function"}], "smprint": [{"docstring": "Print a stepmatrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 232, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "smprint", "signature": "(self, name = 'your_name_here')", "symbol_type": "function"}], "solexa_quality_from_phred": [{"docstring": "Convert a PHRED quality (range 0 to about 90) to a Solexa quality.\n\nPHRED and Solexa quality scores are both log transformations of a\nprobality of error (high score = low probability of error). This function\ntakes a PHRED score, transforms it back to a probability of error, and\nthen re-expresses it as a Solexa score. This assumes the error estimates\nare equivalent.\n\nHow does this work exactly? Well the PHRED quality is minus ten times the\nbase ten logarithm of the probability of error::\n\n    phred_quality = -10*log(error,10)\n\nTherefore, turning this round::\n\n    error = 10 ** (- phred_quality / 10)\n\nNow, Solexa qualities use a different log transformation::\n\n    solexa_quality = -10*log(error/(1-error),10)\n\nAfter substitution and a little manipulation we get::\n\n     solexa_quality = 10*log(10**(phred_quality/10.0) - 1, 10)\n\nHowever, real Solexa files use a minimum quality of -5. This does have a\ngood reason - a random base call would be correct 25% of the time,\nand thus have a probability of error of 0.75, which gives 1.25 as the PHRED\nquality, or -4.77 as the Solexa quality. Thus (after rounding), a random\nnucleotide read would have a PHRED quality of 1, or a Solexa quality of -5.\n\nTaken literally, this logarithic formula would map a PHRED quality of zero\nto a Solexa quality of minus infinity. Of course, taken literally, a PHRED\nscore of zero means a probability of error of one (i.e. the base call is\ndefinitely wrong), which is worse than random! In practice, a PHRED quality\nof zero usually means a default value, or perhaps random - and therefore\nmapping it to the minimum Solexa score of -5 is reasonable.\n\nIn conclusion, we follow EMBOSS, and take this logarithmic formula but also\napply a minimum value of -5.0 for the Solexa quality, and also map a PHRED\nquality of zero to -5.0 as well.\n\nNote this function will return a floating point number, it is up to you to\nround this to the nearest integer if appropriate.  e.g.\n\n>>> print(\"%0.2f\" % round(solexa_quality_from_phred(80), 2))\n80.00\n>>> print(\"%0.2f\" % round(solexa_quality_from_phred(50), 2))\n50.00\n>>> print(\"%0.2f\" % round(solexa_quality_from_phred(20), 2))\n19.96\n>>> print(\"%0.2f\" % round(solexa_quality_from_phred(10), 2))\n9.54\n>>> print(\"%0.2f\" % round(solexa_quality_from_phred(5), 2))\n3.35\n>>> print(\"%0.2f\" % round(solexa_quality_from_phred(4), 2))\n1.80\n>>> print(\"%0.2f\" % round(solexa_quality_from_phred(3), 2))\n-0.02\n>>> print(\"%0.2f\" % round(solexa_quality_from_phred(2), 2))\n-2.33\n>>> print(\"%0.2f\" % round(solexa_quality_from_phred(1), 2))\n-5.00\n>>> print(\"%0.2f\" % round(solexa_quality_from_phred(0), 2))\n-5.00\n\nNotice that for high quality reads PHRED and Solexa scores are numerically\nequal. The differences are important for poor quality reads, where PHRED\nhas a minimum of zero but Solexa scores can be negative.\n\nFinally, as a special case where None is used for a \"missing value\", None\nis returned:\n\n>>> print(solexa_quality_from_phred(None))\nNone", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 399, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "solexa_quality_from_phred", "signature": "(phred_quality: float) -> float", "symbol_type": "function"}], "somcluster": [{"docstring": "Calculate a Self-Organizing Map.\n\nThis function implements a Self-Organizing Map on a rectangular grid.\n\nKeyword arguments:\n - data: nrows x ncolumns array containing the data values;\n - mask: nrows x ncolumns array of integers, showing which data are\n   missing. If mask[i][j]==0, then data[i][j] is missing.\n - weight: the weights to be used when calculating distances\n - transpose:\n   - if False: rows are clustered;\n   - if True: columns are clustered.\n - nxgrid: the horizontal dimension of the rectangular SOM map\n - nygrid: the vertical dimension of the rectangular SOM map\n - inittau: the initial value of tau (the neighborbood function)\n - niter: the number of iterations\n - dist: specifies the distance function to be used:\n   - dist == 'e': Euclidean distance\n   - dist == 'b': City Block distance\n   - dist == 'c': Pearson correlation\n   - dist == 'a': absolute value of the correlation\n   - dist == 'u': uncentered correlation\n   - dist == 'x': absolute uncentered correlation\n   - dist == 's': Spearman's rank correlation\n   - dist == 'k': Kendall's tau\n\nReturn values:\n\n - clusterid: array with two columns, with the number of rows equal to\n   the items that are being clustered. Each row in the array contains\n   the x and y coordinates of the cell in the rectangular SOM grid to\n   which the item was assigned.\n - celldata:  an array with dimensions [nxgrid, nygrid, number of columns]\n   if rows are being clustered, or [nxgrid, nygrid, number of rows) if\n   columns are being clustered.\n   Each element [ix, iy] of this array is a 1D vector containing the\n   data values for the centroid of the cluster in the SOM grid cell\n   with coordinates [ix, iy].", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 344, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "somcluster", "signature": "(data, mask = None, weight = None, transpose = False, nxgrid = 2, nygrid = 1, inittau = 0.02, niter = 1, dist = 'e')", "symbol_type": "function"}, {"docstring": "Calculate a self-organizing map on a rectangular grid.\n\nThe somcluster method returns a tuple (clusterid, celldata).\n\nKeyword arguments:\n - transpose: if False, genes (rows) are clustered;\n              if True,  samples (columns) are clustered.\n - nxgrid: the horizontal dimension of the rectangular SOM map\n - nygrid: the vertical dimension of the rectangular SOM map\n - inittau: the initial value of tau (the neighborbood function)\n - niter: the number of iterations\n - dist: specifies the distance function to be used:\n   - dist == 'e': Euclidean distance\n   - dist == 'b': City Block distance\n   - dist == 'c': Pearson correlation\n   - dist == 'a': absolute value of the correlation\n   - dist == 'u': uncentered correlation\n   - dist == 'x': absolute uncentered correlation\n   - dist == 's': Spearman's rank correlation\n   - dist == 'k': Kendall's tau\n\nReturn values:\n - clusterid: array with two columns, while the number of rows is equal\n   to the number of genes or the number of samples depending on\n   whether genes or samples are being clustered. Each row in\n   the array contains the x and y coordinates of the cell in the\n   rectangular SOM grid to which the gene or samples was assigned.\n - celldata: an array with dimensions (nxgrid, nygrid, number of\n   samples) if genes are being clustered, or (nxgrid, nygrid,\n   number of genes) if samples are being clustered. Each item\n   [ix, iy] of this array is a 1D vector containing the gene\n   expression data for the centroid of the cluster in the SOM grid\n   cell with coordinates [ix, iy].", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 837, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "somcluster", "signature": "(self, transpose = False, nxgrid = 2, nygrid = 1, inittau = 0.02, niter = 1, dist = 'e')", "symbol_type": "function"}], "sorensen_similarity": [{"docstring": "Calculate S\u00f8rensen similarity coefficient between two sites.\n\nS = 2|A \u2229 B| / (|A| + |B|)\n\nArgs:\n    site1, site2: Species abundance vectors\n    presence_threshold: Minimum abundance to consider species present\n\nReturns:\n    S\u00f8rensen similarity coefficient (0-1)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/community.py", "line_number": 166, "module": "src.metainformant.ecology.community", "name": "sorensen_similarity", "signature": "(site1: Sequence[float], site2: Sequence[float], presence_threshold: float = 0.0) -> float", "symbol_type": "function"}], "sort": [{"docstring": "Sort the rows (SeqRecord objects) of the alignment in place.\n\nThis sorts the rows alphabetically using the SeqRecord object id by\ndefault. The sorting can be controlled by supplying a key function\nwhich must map each SeqRecord to a sort value.\n\nThis is useful if you want to add two alignments which use the same\nrecord identifiers, but in a different order. For example,\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqRecord import SeqRecord\n>>> from Bio.Align import MultipleSeqAlignment\n>>> align1 = MultipleSeqAlignment([\n...              SeqRecord(Seq(\"ACGT\"), id=\"Human\"),\n...              SeqRecord(Seq(\"ACGG\"), id=\"Mouse\"),\n...              SeqRecord(Seq(\"ACGC\"), id=\"Chicken\"),\n...          ])\n>>> align2 = MultipleSeqAlignment([\n...              SeqRecord(Seq(\"CGGT\"), id=\"Mouse\"),\n...              SeqRecord(Seq(\"CGTT\"), id=\"Human\"),\n...              SeqRecord(Seq(\"CGCT\"), id=\"Chicken\"),\n...          ])\n\nIf you simple try and add these without sorting, you get this:\n\n>>> print(align1 + align2)\nAlignment with 3 rows and 8 columns\nACGTCGGT <unknown id>\nACGGCGTT <unknown id>\nACGCCGCT Chicken\n\nConsult the SeqRecord documentation which explains why you get a\ndefault value when annotation like the identifier doesn't match up.\nHowever, if we sort the alignments first, then add them we get the\ndesired result:\n\n>>> align1.sort()\n>>> align2.sort()\n>>> print(align1 + align2)\nAlignment with 3 rows and 8 columns\nACGCCGCT Chicken\nACGTCGTT Human\nACGGCGGT Mouse\n\nAs an example using a different sort order, you could sort on the\nGC content of each sequence.\n\n>>> from Bio.SeqUtils import gc_fraction\n>>> print(align1)\nAlignment with 3 rows and 4 columns\nACGC Chicken\nACGT Human\nACGG Mouse\n>>> align1.sort(key = lambda record: gc_fraction(record.seq))\n>>> print(align1)\nAlignment with 3 rows and 4 columns\nACGT Human\nACGC Chicken\nACGG Mouse\n\nThere is also a reverse argument, so if you wanted to sort by ID\nbut backwards:\n\n>>> align1.sort(reverse=True)\n>>> print(align1)\nAlignment with 3 rows and 4 columns\nACGG Mouse\nACGT Human\nACGC Chicken", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 811, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "sort", "signature": "(self, key = None, reverse = False)", "symbol_type": "function"}, {"docstring": "Sort the sequences of the alignment in place.\n\nBy default, this sorts the sequences alphabetically using their id\nattribute if available, or by their sequence contents otherwise.\nFor example,\n\n>>> from Bio.Align import PairwiseAligner\n>>> aligner = PairwiseAligner()\n>>> aligner.gap_score = -1\n>>> alignments = aligner.align(\"AATAA\", \"AAGAA\")\n>>> len(alignments)\n1\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            0 AATAA 5\n                  0 ||.|| 5\nquery             0 AAGAA 5\n<BLANKLINE>\n>>> alignment.sort()\n>>> print(alignment)\ntarget            0 AAGAA 5\n                  0 ||.|| 5\nquery             0 AATAA 5\n<BLANKLINE>\n\nAlternatively, a key function can be supplied that maps each sequence\nto a sort value.  For example, you could sort on the GC content of each\nsequence.\n\n>>> from Bio.SeqUtils import gc_fraction\n>>> alignment.sort(key=gc_fraction)\n>>> print(alignment)\ntarget            0 AATAA 5\n                  0 ||.|| 5\nquery             0 AAGAA 5\n<BLANKLINE>\n\nYou can reverse the sort order by passing `reverse=True`:\n\n>>> alignment.sort(key=gc_fraction, reverse=True)\n>>> print(alignment)\ntarget            0 AAGAA 5\n                  0 ||.|| 5\nquery             0 AATAA 5\n<BLANKLINE>\n\nThe sequences are now sorted by decreasing GC content value.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 3280, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "sort", "signature": "(self, key = None, reverse = False)", "symbol_type": "function"}, {"docstring": "Sort the hierarchical clustering tree.\n\nSort the hierarchical clustering tree by switching the left and\nright subnode of nodes such that the elements in the left-to-right\norder of the tree tend to have increasing order values.\n\nReturn the indices of the elements in the left-to-right order in\nthe hierarchical clustering tree, such that the element with index\nindices[i] occurs at position i in the dendrogram.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 63, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "sort", "signature": "(self, order = None)", "symbol_type": "function"}, {"docstring": "Sort the atoms in the child Residue objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Residue.py", "line_number": 156, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Residue", "name": "sort", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Sort the HSP objects.\n\n:param key: sorting function\n:type key: callable, accepts HSP, returns key for sorting\n:param reverse: whether to reverse sorting results or no\n:type reverse: bool\n:param in_place: whether to do in-place sorting or no\n:type in_place: bool\n\n``sort`` defaults to sorting in-place, to mimic Python's ``list.sort``\nmethod. If you set the ``in_place`` argument to False, it will treat\nreturn a new, sorted Hit object and keep the initial one unsorted", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/hit.py", "line_number": 435, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.hit", "name": "sort", "signature": "(self, key = None, reverse = False, in_place = True)", "symbol_type": "function"}, {"docstring": "Sort the Hit objects.\n\n:param key: sorting function\n:type key: callable, accepts Hit, returns key for sorting\n:param reverse: whether to reverse sorting results or no\n:type reverse: bool\n:param in_place: whether to do in-place sorting or no\n:type in_place: bool\n\n``sort`` defaults to sorting in-place, to mimic Python's ``list.sort``\nmethod. If you set the ``in_place`` argument to False, it will treat\nreturn a new, sorted QueryResult object and keep the initial one\nunsorted.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/_model/query.py", "line_number": 689, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO._model.query", "name": "sort", "signature": "(self, key = None, reverse = False, in_place = True)", "symbol_type": "function"}, {"docstring": "Sorts wr, rt and ct tags into the appropriate contig / read instance, if possible.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Sequencing/Ace.py", "line_number": 529, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Sequencing.Ace", "name": "sort", "signature": "(self)", "symbol_type": "function"}], "sort_by_time": [{"docstring": "Sort events by timestamp.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 102, "module": "src.metainformant.life_events.events", "name": "sort_by_time", "signature": "(self) -> None", "symbol_type": "function"}], "source": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 534, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "source", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 995, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "source", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": "Return list of unique sources for species.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 292, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "source", "signature": "(self, species)", "symbol_type": "function"}], "source_interactions": [{"docstring": "Return list of (source, interaction) pairs for species.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 296, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "source_interactions", "signature": "(self, species)", "symbol_type": "function"}], "spatial_autocorrelation": [{"docstring": "Calculate spatial autocorrelation in species distributions.\n\nMeasures the degree to which nearby sites have similar species\ncomposition (spatial clustering).\n\nArgs:\n    species_abundances: DataFrame with sites as rows and species as columns\n    site_coordinates: DataFrame with sites as rows and 'x', 'y' columns\n    method: Autocorrelation method ('moran', 'geary', 'mantel')\n    \nReturns:\n    Dictionary with autocorrelation statistics:\n    - 'moran_i': Moran's I statistic (if method='moran')\n    - 'p_value': Statistical significance\n    - 'spatial_structure': Description of spatial pattern", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/environmental.py", "line_number": 112, "module": "src.metainformant.ecology.environmental", "name": "spatial_autocorrelation", "signature": "(species_abundances: pd.DataFrame, site_coordinates: pd.DataFrame, method: str = 'moran') -> Dict[str, Any]", "symbol_type": "function"}], "species": [{"docstring": "Return a list of all Species involved in self.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 146, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "species", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a list of the species in this system.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 196, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "species", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return list of the species in this network.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 308, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "species", "signature": "(self)", "symbol_type": "function"}], "species_accumulation_curve": [{"docstring": "Generate species accumulation curve across multiple sites.\n\nArgs:\n    site_abundances: List of abundance vectors, one per site\n\nReturns:\n    List of (num_sites, cumulative_species_richness) tuples", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/community.py", "line_number": 232, "module": "src.metainformant.ecology.community", "name": "species_accumulation_curve", "signature": "(site_abundances: List[Sequence[float]]) -> List[Tuple[int, float]]", "symbol_type": "function"}], "species_richness": [{"docstring": "Calculate species richness (number of species with non-zero abundance).\n\nArgs:\n    abundances: Species abundance values\n\nReturns:\n    Number of species with abundance > 0", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ecology/community.py", "line_number": 54, "module": "src.metainformant.ecology.community", "name": "species_richness", "signature": "(abundances: Sequence[float]) -> int", "symbol_type": "function"}], "split": [{"docstring": "Return a list of the sections in the data, using sep as the delimiter.\n\nsep\n  The delimiter according which to split the data.\n  None (the default value) means split on ASCII whitespace characters\n  (space, tab, return, newline, formfeed, vertical tab).\nmaxsplit\n  Maximum number of splits to do.\n  -1 (the default value) means no limit.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 230, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "split", "signature": "(self, sep = None, maxsplit = -1)", "symbol_type": "function"}, {"docstring": "Return a list of subsequences when splitting the sequence by separator sep.\n\nReturn a list of the subsequences in the sequence (as Seq objects),\nusing sep as the delimiter string.  If maxsplit is given, at\nmost maxsplit splits are done.  If maxsplit is omitted, all\nsplits are made.\n\nFor consistency with the ``split`` method of Python strings, any\nwhitespace (tabs, spaces, newlines) is a separator if sep is None, the\ndefault value\n\ne.g.\n\n>>> from Bio.Seq import Seq\n>>> my_rna = Seq(\"GUCAUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAGUUG\")\n>>> my_aa = my_rna.translate()\n>>> my_aa\nSeq('VMAIVMGR*KGAR*L')\n>>> for pep in my_aa.split(\"*\"):\n...     pep\nSeq('VMAIVMGR')\nSeq('KGAR')\nSeq('L')\n>>> for pep in my_aa.split(\"*\", 1):\n...     pep\nSeq('VMAIVMGR')\nSeq('KGAR*L')\n\nSee also the rsplit method, which splits the sequence starting from the\nend:\n\n>>> for pep in my_aa.rsplit(\"*\", 1):\n...     pep\nSeq('VMAIVMGR*KGAR')\nSeq('L')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1070, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "split", "signature": "(self, sep = None, maxsplit = -1)", "symbol_type": "function"}, {"docstring": "Speciation: generates n (default two) descendants of a node.\n\n[new ids] = split(self,parent_id=None,n=2,branchlength=1.0):", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 241, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "split", "signature": "(self, parent_id = None, n = 2, branchlength = 1.0)", "symbol_type": "function"}, {"docstring": "Generate n (default 2) new descendants.\n\nIn a species tree, this is a speciation event.\n\nNew clades have the given branch_length and the same name as this\nclade's root plus an integer suffix (counting from 0). For example,\nsplitting a clade named \"A\" produces sub-clades named \"A0\" and \"A1\".\nIf the clade has no name, the prefix \"n\" is used for child nodes, e.g.\n\"n0\" and \"n1\".", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 701, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "split", "signature": "(self, n = 2, branch_length = 1.0)", "symbol_type": "function"}, {"docstring": "Extract enzymes of a certain class and put in new RestrictionBatch.\n\nIt works but it is slow, so it has really an interest when splitting\nover multiple conditions.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2158, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "split", "signature": "(self, *classes, **bool)", "symbol_type": "function"}], "split_akl": [{"docstring": "Get AtomKeys for this residue (ak_set) for generic list of AtomKeys.\n\nChanges and/or expands a list of 'generic' AtomKeys (e.g. 'N, C, C') to\nbe specific to this Residue's altlocs etc., e.g.\n'(N-Ca_A_0.3-C, N-Ca_B_0.7-C)'\n\nGiven a list of AtomKeys for a Hedron or Dihedron,\n  return:\n        list of matching atomkeys that have id3_dh in this residue\n        (ak may change if occupancy != 1.00)\n\n    or\n        multiple lists of matching atomkeys expanded for all atom altlocs\n\n    or\n        empty list if any of atom_coord(ak) missing and not missingOK\n\n:param list lst: list[3] or [4] of AtomKeys.\n    Non-altloc AtomKeys to match to specific AtomKeys for this residue\n:param bool missingOK: default False, see above.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 2985, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "split_akl", "signature": "(self, lst: tuple['AtomKey', ...] | list['AtomKey'], missingOK: bool = False) -> list[tuple['AtomKey', ...]]", "symbol_type": "function"}], "split_in_loci": [{"docstring": "Split a GP record in a dictionary with 1 locus per entry.\n\nGiven a record with n pops and m loci returns a dictionary\nof records (key locus name) where each item is a record\nwith a single locus and n pops.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/__init__.py", "line_number": 183, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.__init__", "name": "split_in_loci", "signature": "(self, gp)", "symbol_type": "function"}], "split_in_pops": [{"docstring": "Split a GP record in a dictionary with 1 pop per entry.\n\nGiven a record with n pops and m loci returns a dictionary\nof records (key pop_name) where each item is a record\nwith a single pop and m loci.\n\nArguments:\n- pop_names - Population names", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/__init__.py", "line_number": 162, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.__init__", "name": "split_in_pops", "signature": "(self, pop_names)", "symbol_type": "function"}], "split_jaspar_id": [{"docstring": "Split a JASPAR matrix ID into its component.\n\nComponents are base ID and version number, e.g. 'MA0047.2' is returned as\n('MA0047', 2).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/jaspar/__init__.py", "line_number": 358, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.jaspar.__init__", "name": "split_jaspar_id", "signature": "(id)", "symbol_type": "function"}], "split_virtual_offset": [{"docstring": "Divides a 64-bit BGZF virtual offset into block start & within block offsets.\n\n>>> (100000, 0) == split_virtual_offset(6553600000)\nTrue\n>>> (100000, 10) == split_virtual_offset(6553600010)\nTrue", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 335, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "split_virtual_offset", "signature": "(virtual_offset)", "symbol_type": "function"}], "splits": [{"docstring": "Extract clade splits from tree as sorted tuples of terminal names.\n\nArgs:\n    tree: Phylogenetic tree\n    \nReturns:\n    List of tuples representing clades", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/phylogeny.py", "line_number": 114, "module": "src.metainformant.dna.phylogeny", "name": "splits", "signature": "(tree)", "symbol_type": "function"}], "splittest": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2165, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "splittest", "signature": "(element)", "symbol_type": "function"}], "splom_plot": [{"docstring": "Create a scatter plot matrix (SPLOM).\n\nArgs:\n    data: DataFrame with numeric columns\n    hue: Optional column name for coloring\n    figsize: Figure size tuple\n    **kwargs: Additional arguments\n\nReturns:\n    matplotlib Figure\n\nExample:\n    >>> from metainformant.visualization import splom_plot\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> df = pd.DataFrame(np.random.random((50, 4)), columns=['A', 'B', 'C', 'D'])\n    >>> fig = splom_plot(df)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/multidim.py", "line_number": 207, "module": "src.metainformant.visualization.multidim", "name": "splom_plot", "signature": "(data: pd.DataFrame, **kwargs)", "symbol_type": "function"}], "square": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 557, "module": "tests.test_core_comprehensive", "name": "square", "signature": "(x)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_parallel.py", "line_number": 8, "module": "tests.test_core_parallel", "name": "square", "signature": "(x: int) -> int", "symbol_type": "function"}], "ss_to_index": [{"docstring": "Secondary structure symbol to index.\n\nH=0\nE=1\nC=2", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/DSSP.py", "line_number": 119, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.DSSP", "name": "ss_to_index", "signature": "(ss)", "symbol_type": "function"}], "stale_possible_simple_keys": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 279, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "stale_possible_simple_keys", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 279, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "stale_possible_simple_keys", "signature": "(self)", "symbol_type": "function"}], "standard_deviation": [{"docstring": "Population standard deviation (sqrt of population variance).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 86, "module": "src.metainformant.math.price", "name": "standard_deviation", "signature": "(values: Sequence[float]) -> float", "symbol_type": "function"}], "standardize_gene_name": [{"docstring": "Standardize gene name format.\n\nArgs:\n    gene_name: Raw gene name\n\nReturns:\n    Standardized gene name", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/text.py", "line_number": 57, "module": "src.metainformant.core.text", "name": "standardize_gene_name", "signature": "(gene_name: str) -> str", "symbol_type": "function"}], "start": [{"docstring": "Start location - left most (minimum) value, regardless of strand.\n\nRead only, returns an integer like position object, possibly a fuzzy\nposition.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 1255, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "start", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Start location - left most (minimum) value, regardless of strand.\n\nRead only, returns an integer like position object, possibly a fuzzy\nposition.\n\nFor the special case of a CompoundLocation wrapping the origin of a\ncircular genome, this will return zero.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 1653, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "start", "signature": "(self)", "symbol_type": "function"}], "startA": [{"docstring": "Start position of Feature A.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CrossLink.py", "line_number": 41, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CrossLink", "name": "startA", "signature": "(self)", "symbol_type": "function"}], "startB": [{"docstring": "Start position of Feature B.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_CrossLink.py", "line_number": 72, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._CrossLink", "name": "startB", "signature": "(self)", "symbol_type": "function"}], "startDBRefElement": [{"docstring": "Parse a database cross reference.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 315, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "startDBRefElement", "signature": "(self, attrs)", "symbol_type": "function"}], "startDescriptionElement": [{"docstring": "Parse the description.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 251, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "startDescriptionElement", "signature": "(self, attrs)", "symbol_type": "function"}], "startDocument": [{"docstring": "Start the XML document.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlastIO/blast_xml.py", "line_number": 669, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlastIO.blast_xml", "name": "startDocument", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Set XML handlers when an XML declaration is found.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 44, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "startDocument", "signature": "(self)", "symbol_type": "function"}], "startElement": [{"docstring": "Found XML start tag.\n\nNo real need of attr, BLAST DTD doesn't use them\n\nArguments:\n - name -- name of the tag\n - attr -- tag attributes", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIXML.py", "line_number": 496, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIXML", "name": "startElement", "signature": "(self, name, attr)", "symbol_type": "function"}, {"docstring": "Define the beginning of a record and stores the search record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/ExPASy/ScanProsite.py", "line_number": 120, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.ExPASy.ScanProsite", "name": "startElement", "signature": "(self, name, attrs)", "symbol_type": "function"}, {"docstring": "Start an XML element.\n\n:param name: element name\n:type name: string\n:param attrs: element attributes\n:type attrs: dictionary {string: object}\n:param children: whether the element has children or not\n:type children: bool", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlastIO/blast_xml.py", "line_number": 677, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlastIO.blast_xml", "name": "startElement", "signature": "(self, name, attrs = None, children = False)", "symbol_type": "function"}], "startElementHandler": [{"docstring": "Handle start of an XML element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 597, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "startElementHandler", "signature": "(self, tag, attrs)", "symbol_type": "function"}], "startEntryElement": [{"docstring": "Set new entry with id and the optional entry source (PRIVATE).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 116, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "startEntryElement", "signature": "(self, name, qname, attrs)", "symbol_type": "function"}], "startEntryFieldElement": [{"docstring": "Receive a field of an entry element and forward it for versions >=0.2.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 186, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "startEntryFieldElement", "signature": "(self, name, qname, attrs)", "symbol_type": "function"}], "startEntryFieldElementVersion01": [{"docstring": "Receive a field of an entry element and forward it for version 0.1.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 165, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "startEntryFieldElementVersion01", "signature": "(self, name, qname, attrs)", "symbol_type": "function"}], "startNamespaceDeclHandler": [{"docstring": "Handle start of an XML namespace declaration.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 540, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "startNamespaceDeclHandler", "signature": "(self, prefix, uri)", "symbol_type": "function"}], "startParent": [{"docstring": "Start an XML element which has children.\n\n:param name: element name\n:type name: string\n:param attrs: element attributes\n:type attrs: dictionary {string: object}", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlastIO/blast_xml.py", "line_number": 698, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlastIO.blast_xml", "name": "startParent", "signature": "(self, name, attrs = None)", "symbol_type": "function"}], "startParents": [{"docstring": "Start XML elements without children.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlastIO/blast_xml.py", "line_number": 723, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlastIO.blast_xml", "name": "startParents", "signature": "(self, *names)", "symbol_type": "function"}], "startPropertyElement": [{"docstring": "Handle the start of a property element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 374, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "startPropertyElement", "signature": "(self, attrs)", "symbol_type": "function"}], "startRawElementHandler": [{"docstring": "Handle start of an XML raw element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 724, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "startRawElementHandler", "signature": "(self, name, attrs)", "symbol_type": "function"}], "startSeqXMLElement": [{"docstring": "Handle start of a seqXML element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 48, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "startSeqXMLElement", "signature": "(self, name, qname, attrs)", "symbol_type": "function"}], "startSequenceElement": [{"docstring": "Parse DNA, RNA, or protein sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 278, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "startSequenceElement", "signature": "(self, attrs)", "symbol_type": "function"}], "startSkipElementHandler": [{"docstring": "Handle start of an XML skip element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 751, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "startSkipElementHandler", "signature": "(self, name, attrs)", "symbol_type": "function"}], "startSpeciesElement": [{"docstring": "Parse the species information.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 207, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "startSpeciesElement", "signature": "(self, attrs)", "symbol_type": "function"}], "start_feature_table": [{"docstring": "Indicate we've got to the start of the feature table.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 684, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "start_feature_table", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Signal the start of the feature table.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1061, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "start_feature_table", "signature": "(self)", "symbol_type": "function"}], "start_monitoring": [{"docstring": "Start background monitoring thread that updates progress and shows summaries.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/download_progress.py", "line_number": 361, "module": "src.metainformant.rna.steps.download_progress", "name": "start_monitoring", "signature": "(self) -> None", "symbol_type": "function"}], "start_read": [{"docstring": "Start parsing a file containing a GenePop file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PopGen/GenePop/FileParser.py", "line_number": 110, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PopGen.GenePop.FileParser", "name": "start_read", "signature": "(self)", "symbol_type": "function"}], "startswith": [{"docstring": "Return True if data starts with the specified prefix, False otherwise.\n\nWith optional start, test data beginning at that position.\nWith optional end, stop comparing data at that position.\nprefix can also be a tuple of bytes to try.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 212, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "startswith", "signature": "(self, prefix, start = None, end = None)", "symbol_type": "function"}, {"docstring": "Return True if the sequence starts with the given prefix, False otherwise.\n\nReturn True if the sequence starts with the specified prefix\n(a string or another Seq object), False otherwise.\nWith optional start, test sequence beginning at that position.\nWith optional end, stop comparing sequence at that position.\nprefix can also be a tuple of strings to try.  e.g.\n\n>>> from Bio.Seq import Seq\n>>> my_rna = Seq(\"GUCAUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAGUUG\")\n>>> my_rna.startswith(\"GUC\")\nTrue\n>>> my_rna.startswith(\"AUG\")\nFalse\n>>> my_rna.startswith(\"AUG\", 3)\nTrue\n>>> my_rna.startswith((\"UCC\", \"UCA\", \"UCG\"), 1)\nTrue", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1008, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "startswith", "signature": "(self, prefix, start = None, end = None)", "symbol_type": "function"}], "statistic_func": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen_stats.py", "line_number": 154, "module": "src.metainformant.math.popgen_stats", "name": "statistic_func", "signature": "(g1, g2)", "symbol_type": "function"}], "std": [{"docstring": "Return standard deviation of the score of a motif.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/matrix.py", "line_number": 539, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.matrix", "name": "std", "signature": "(self, background = None)", "symbol_type": "function"}], "stdev": [{"docstring": "Return the sample standard deviation for the data (float).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Graph.py", "line_number": 139, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Graph", "name": "stdev", "signature": "(self)", "symbol_type": "function"}], "step": [{"docstring": "Move agent randomly one step in grid (with wraparound).\n\nArgs:\n    world: Grid world environment\n    rng: Random number generator", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/agents.py", "line_number": 24, "module": "src.metainformant.simulation.agents", "name": "step", "signature": "(self, world: 'GridWorld', rng: random.Random) -> None", "symbol_type": "function"}, {"docstring": "Advance simulation one time step (all agents move).", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/simulation/agents.py", "line_number": 74, "module": "src.metainformant.simulation.agents", "name": "step", "signature": "(self) -> None", "symbol_type": "function"}], "step_plot": [{"docstring": "Create a step plot.\n\nArgs:\n    x: X-axis values\n    y: Y-axis values\n    ax: Matplotlib axes (creates new if None)\n    where: Step position ('pre', 'post', 'mid')\n    label: Label for legend\n    color: Line color\n    xlabel: X-axis label\n    ylabel: Y-axis label\n    title: Plot title\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import step_plot\n    >>> ax = step_plot([1, 2, 3, 4], [1, 4, 2, 3])", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/basic.py", "line_number": 293, "module": "src.metainformant.visualization.basic", "name": "step_plot", "signature": "(x: Sequence[float], y: Sequence[float]) -> plt.Axes", "symbol_type": "function"}], "stochiometry": [{"docstring": "Compute the stoichiometry matrix for self.\n\nReturns (species, reactions, stoch) where:\n - species    = ordered list of species in this system\n - reactions  = ordered list of reactions in this system\n - stoch      = 2D array where stoch[i][j] is coef of the\n   jth species in the ith reaction, as defined\n   by species and reactions above", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Pathway/__init__.py", "line_number": 202, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Pathway.__init__", "name": "stochiometry", "signature": "(self)", "symbol_type": "function"}], "stop_monitoring": [{"docstring": "Stop background monitoring and cleanup.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/download_progress.py", "line_number": 398, "module": "src.metainformant.rna.steps.download_progress", "name": "stop_monitoring", "signature": "(self) -> None", "symbol_type": "function"}], "store": [{"docstring": "Append an element to the list, checking tags.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 159, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "store", "signature": "(self, value)", "symbol_type": "function"}, {"docstring": "Add an entry to the dictionary, checking tags.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 193, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "store", "signature": "(self, value)", "symbol_type": "function"}, {"docstring": "Append an element to the list, checking tags.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 233, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "store", "signature": "(self, value)", "symbol_type": "function"}], "stream_reports": [{"docstring": "Retrieve report records defined via protobuf schema from jsonl files.\n\nParameters:\n    file_type: The type of file from the dataset catalog, e.g.\n               'DATA_REPORT' or 'SEQUENCE_REPORT'.\n    protobuf_report_type: Schema, defined using GRPC protobuf, for the\n                          current dataset and file type.\n\nReturns:\n    Yields a set of protobuf objects for the dataset and file type.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/package/dataset.py", "line_number": 217, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.package.dataset", "name": "stream_reports", "signature": "(self, file_type: str, protobuf_report_type: Any) -> Any", "symbol_type": "function"}], "strict_consensus": [{"docstring": "Search strict consensus tree from multiple trees.\n\n:Parameters:\n    trees : iterable\n        iterable of trees to produce consensus tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/Consensus.py", "line_number": 223, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.Consensus", "name": "strict_consensus", "signature": "(trees)", "symbol_type": "function"}], "strictly_equals": [{"docstring": "Compare this atom to the other atom using a strict definition of equality.\n\nIndicates whether the atoms have the same name, B factor, occupancy,\nalternate location indicator (altloc), fullname, element, charge, and radius.\nIf ``compare_coordinates`` is true, then the coordinates are also compared.\n\n:param other: The atom to compare this atom with\n:type other: Atom\n:param compare_coordinates: Whether to compare the coordinates of the atoms\n:type compare_coordinates: bool\n:return: Whether the atoms are strictly equal\n:rtype: bool", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 270, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "strictly_equals", "signature": "(self: _AtomT, other: _AtomT, compare_coordinates: bool = False) -> bool", "symbol_type": "function"}, {"docstring": "Compare this entity to the other entity for equality.\n\nRecursively compare the children of this entity to the other entity's children.\nCompare most properties including names and IDs.\n\n:param other: The entity to compare this entity with\n:type other: Entity\n:param compare_coordinates: Whether to compare atomic coordinates\n:type compare_coordinates: bool\n:return: Whether the two entities are strictly equal\n:rtype: bool", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 209, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "strictly_equals", "signature": "(self: _Self, other: _Self, compare_coordinates: bool = False) -> bool", "symbol_type": "function"}, {"docstring": "Compare this entity to the other entity using a strict definition of equality.\n\nRecursively compare the children of this entity to the other entity's children.\nCompare most properties including the selected child, names, and IDs.\n\n:param other: The entity to compare this entity with\n:type other: DisorderedEntityWrapper\n:param compare_coordinates: Whether to compare atomic coordinates\n:type compare_coordinates: bool\n:return: Whether the two entities are strictly equal\n:rtype: bool", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 492, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "strictly_equals", "signature": "(self, other: 'DisorderedEntityWrapper', compare_coordinates: bool = False) -> bool", "symbol_type": "function"}, {"docstring": "Compare this residue to the other residue using a strict definition of equality.\n\nThe residues are equal if they have the same name, identifier,\nand their constituent atoms are strictly equal.\n\n:param other: The residue to compare this residue to\n:type other: Residue\n:param compare_coordinates: Whether to compare the coordinates of the atoms\n:type compare_coordinates: bool\n:return: Whether the residues are strictly equal\n:rtype: bool", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Residue.py", "line_number": 50, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Residue", "name": "strictly_equals", "signature": "(self: _ResidueT, other: _ResidueT, compare_coordinates: bool = False) -> bool", "symbol_type": "function"}], "strip": [{"docstring": "Strip leading and trailing characters contained in the argument.\n\nIf the argument is omitted or None, strip leading and trailing ASCII whitespace.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 258, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "strip", "signature": "(self, chars = None)", "symbol_type": "function"}, {"docstring": "Return a sequence object with leading and trailing ends stripped.\n\nWith default arguments, leading and trailing whitespace is removed:\n\n>>> seq = Seq(\" ACGT \")\n>>> seq.strip()\nSeq('ACGT')\n>>> seq\nSeq(' ACGT ')\n\nIf ``chars`` is given and not ``None``, remove characters in ``chars``\ninstead.  The order of the characters to be removed is not important:\n\n>>> Seq(\"ACGTACGT\").strip(\"TGCA\")\nSeq('')\n\nA copy of the sequence is returned if ``inplace`` is ``False`` (the\ndefault value).  If ``inplace`` is ``True``, the sequence is stripped\nin-place and returned.\n\n>>> seq = MutableSeq(\" ACGT \")\n>>> seq.strip()\nMutableSeq('ACGT')\n>>> seq\nMutableSeq(' ACGT ')\n>>> seq.strip(inplace=True)\nMutableSeq('ACGT')\n>>> seq\nMutableSeq('ACGT')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if ``strip``\nis called on a ``Seq`` object with ``inplace=True``.\n\nSee also the lstrip and rstrip methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1156, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "strip", "signature": "(self, chars = None, inplace = False)", "symbol_type": "function"}], "strtobool": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 15, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "strtobool", "signature": "(val)", "symbol_type": "function"}], "structure_rebuild_test": [{"docstring": "Test rebuild PDB structure from internal coordinates.\n\nGenerates internal coordinates for entity and writes to a .pic file in\nmemory, then generates XYZ coordinates from the .pic file and compares the\nresulting entity against the original.\n\nSee :data:`IC_Residue.pic_accuracy` to vary numeric accuracy of the\nintermediate .pic file if the only issue is small differences in coordinates.\n\nNote that with default settings, deuterated initial structures will fail\nthe comparison, as will structures loaded with alternate `IC_Residue.accept_atoms`\nsettings.  Use `quick=True` and/or variations on `AtomKey.d2h` and\n`IC_Residue.accept_atoms` settings.\n\n:param Entity entity: Biopython Structure, Model or Chain.\n    Structure to test\n:param bool verbose: default False.\n    print extra messages\n:param bool quick: default False.\n    only check the internal coords atomArrays are identical\n:returns: dict\n    comparison dict from :func:`.compare_residues`", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/ic_rebuild.py", "line_number": 33, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.ic_rebuild", "name": "structure_rebuild_test", "signature": "(entity, verbose: bool = False, quick: bool = False) -> dict", "symbol_type": "function"}], "structured_comment": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 677, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "structured_comment", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1047, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "structured_comment", "signature": "(self, content)", "symbol_type": "function"}], "subcomponent_size": [{"docstring": "Return the scaled size of all subcomponents of this component.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/BasicChromosome.py", "line_number": 232, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.BasicChromosome", "name": "subcomponent_size", "signature": "(self)", "symbol_type": "function"}], "subgraph": [{"docstring": "Extract subgraph of ontology rooted at specified terms.\n\nCreates a new ontology containing only the specified root terms and\nall their descendants (transitively). Useful for focusing analysis\non specific ontology branches.\n\nArgs:\n    onto: Source ontology object\n    roots: Iterable of term IDs to use as root nodes. All descendants\n        of these terms will be included in the subgraph.\n        \nReturns:\n    New Ontology object containing only the root terms and their\n    descendants. Term relationships are preserved within the subgraph.\n    \nRaises:\n    ValueError: If any root term_id is empty or not found in ontology\n    \nExamples:\n    >>> onto = load_go_obo(\"go-basic.obo\")\n    >>> sub_onto = subgraph(onto, [\"GO:0008150\"])  # biological_process\n    >>> sub_onto.num_terms() < onto.num_terms()\n    True\n    >>> \"GO:0008150\" in sub_onto.terms\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/query.py", "line_number": 190, "module": "src.metainformant.ontology.query", "name": "subgraph", "signature": "(onto: Ontology, roots: Iterable[str]) -> Ontology", "symbol_type": "function"}], "subset_features": [{"docstring": "Create a new MultiOmicsData object with subset of features.\n\nFilters specific features (genes, proteins, metabolites, etc.) from\neach omics layer. Layers not specified in feature_dict are retained\nin full.\n\nArgs:\n    feature_dict: Dictionary mapping layer names to lists of feature\n        identifiers to include (e.g., {\"transcriptomics\": [\"GENE1\", \"GENE2\"]})\n        \nReturns:\n    New MultiOmicsData object with filtered features. Samples remain\n    aligned across all layers.\n    \nExamples:\n    >>> data = MultiOmicsData(genomics=genomics_df, transcriptomics=transcriptomics_df)\n    >>> subset = data.subset_features({\n    ...     \"transcriptomics\": [\"GENE1\", \"GENE2\", \"GENE3\"]\n    ... })\n    >>> subset.get_layer(\"transcriptomics\").shape\n    (10, 3)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 203, "module": "src.metainformant.multiomics.integration", "name": "subset_features", "signature": "(self, feature_dict: Dict[str, List[str]]) -> 'MultiOmicsData'", "symbol_type": "function"}], "subset_samples": [{"docstring": "Create a new MultiOmicsData object with subset of samples.\n\nFilters all omics layers and metadata to include only the specified\nsamples. Only samples present in the original data are retained.\n\nArgs:\n    sample_list: List of sample identifiers to include\n    \nReturns:\n    New MultiOmicsData object containing only the specified samples.\n    Sample alignment is automatically performed on the subset.\n    \nExamples:\n    >>> data = MultiOmicsData(genomics=genomics_df, transcriptomics=transcriptomics_df)\n    >>> subset = data.subset_samples([\"S0\", \"S1\", \"S2\"])\n    >>> subset.n_samples\n    3", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/multiomics/integration.py", "line_number": 169, "module": "src.metainformant.multiomics.integration", "name": "subset_samples", "signature": "(self, sample_list: List[str]) -> 'MultiOmicsData'", "symbol_type": "function"}], "substitutions": [{"docstring": "Return an Array with the number of substitutions of letters in the alignment.\n\nAs an example, consider a multiple sequence alignment of three DNA sequences:\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqRecord import SeqRecord\n>>> from Bio.Align import MultipleSeqAlignment\n>>> seq1 = SeqRecord(Seq(\"ACGT\"), id=\"seq1\")\n>>> seq2 = SeqRecord(Seq(\"A--A\"), id=\"seq2\")\n>>> seq3 = SeqRecord(Seq(\"ACGT\"), id=\"seq3\")\n>>> seq4 = SeqRecord(Seq(\"TTTC\"), id=\"seq4\")\n>>> alignment = MultipleSeqAlignment([seq1, seq2, seq3, seq4])\n>>> print(alignment)\nAlignment with 4 rows and 4 columns\nACGT seq1\nA--A seq2\nACGT seq3\nTTTC seq4\n\n>>> m = alignment.substitutions\n>>> print(m)\n    A   C   G   T\nA 3.0 0.5 0.0 2.5\nC 0.5 1.0 0.0 2.0\nG 0.0 0.0 1.0 1.0\nT 2.5 2.0 1.0 1.0\n<BLANKLINE>\n\nNote that the matrix is symmetric, with counts divided equally on both\nsides of the diagonal. For example, the total number of substitutions\nbetween A and T in the alignment is 3.5 + 3.5 = 7.\n\nAny weights associated with the sequences are taken into account when\ncalculating the substitution matrix.  For example, given the following\nmultiple sequence alignment::\n\n    GTATC  0.5\n    AT--C  0.8\n    CTGTC  1.0\n\nFor the first column we have::\n\n    ('A', 'G') : 0.5 * 0.8 = 0.4\n    ('C', 'G') : 0.5 * 1.0 = 0.5\n    ('A', 'C') : 0.8 * 1.0 = 0.8", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 889, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "substitutions", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return an Array with the number of substitutions of letters in the alignment.\n\nAs an example, consider a sequence alignment of two RNA sequences:\n\n>>> from Bio.Align import PairwiseAligner\n>>> target = \"ATACTTACCTGGCAGGGGAGATACCATGATCACGAAGGTGGTTTTCCCAGGGCGAGGCTTATCCATTGCACTCCGGATGTGCTGACCCCTGCGATTTCCCCAAATGTGGGAAACTCGACTGCATAATTTGTGGTAGTGGGGGACTGCGTTCGCGCTTTCCCCTG\"  # human spliceosomal small nuclear RNA U1\n>>> query = \"ATACTTACCTGACAGGGGAGGCACCATGATCACACAGGTGGTCCTCCCAGGGCGAGGCTCTTCCATTGCACTGCGGGAGGGTTGACCCCTGCGATTTCCCCAAATGTGGGAAACTCGACTGTATAATTTGTGGTAGTGGGGGACTGCGTTCGCGCTATCCCCCG\"  # sea lamprey spliceosomal small RNA U1\n>>> aligner = PairwiseAligner()\n>>> aligner.gap_score = -10\n>>> alignments = aligner.align(target, query)\n>>> len(alignments)\n1\n>>> alignment = alignments[0]\n>>> print(alignment)\ntarget            0 ATACTTACCTGGCAGGGGAGATACCATGATCACGAAGGTGGTTTTCCCAGGGCGAGGCTT\n                  0 |||||||||||.||||||||..|||||||||||..|||||||..|||||||||||||||.\nquery             0 ATACTTACCTGACAGGGGAGGCACCATGATCACACAGGTGGTCCTCCCAGGGCGAGGCTC\n<BLANKLINE>\ntarget           60 ATCCATTGCACTCCGGATGTGCTGACCCCTGCGATTTCCCCAAATGTGGGAAACTCGACT\n                 60 .|||||||||||.|||..|.|.||||||||||||||||||||||||||||||||||||||\nquery            60 TTCCATTGCACTGCGGGAGGGTTGACCCCTGCGATTTCCCCAAATGTGGGAAACTCGACT\n<BLANKLINE>\ntarget          120 GCATAATTTGTGGTAGTGGGGGACTGCGTTCGCGCTTTCCCCTG 164\n                120 |.||||||||||||||||||||||||||||||||||.|||||.| 164\nquery           120 GTATAATTTGTGGTAGTGGGGGACTGCGTTCGCGCTATCCCCCG 164\n<BLANKLINE>\n>>> m = alignment.substitutions\n>>> print(m)\n     A    C    G    T\nA 28.0  1.0  2.0  1.0\nC  0.0 39.0  1.0  2.0\nG  2.0  0.0 45.0  0.0\nT  2.0  5.0  1.0 35.0\n<BLANKLINE>\n\nNote that the matrix is not symmetric: rows correspond to the target\nsequence, and columns to the query sequence.  For example, the number\nof T's in the target sequence that are aligned to a C in the query\nsequence is\n\n>>> m['T', 'C']\n5.0\n\nand the number of C's in the query sequence tat are aligned to a T in\nthe query sequence is\n\n>>> m['C', 'T']\n2.0\n\nFor some applications (for example, to define a scoring matrix from\nthe substitution matrix), a symmetric matrix may be preferred, which\ncan be calculated as follows:\n\n>>> m += m.transpose()\n>>> m /= 2.0\n>>> print(m)\n     A    C    G    T\nA 28.0  0.5  2.0  1.5\nC  0.5 39.0  0.5  3.5\nG  2.0  0.5 45.0  0.5\nT  1.5  3.5  0.5 35.0\n<BLANKLINE>\n\nThe matrix is now symmetric, with counts divided equally on both sides\nof the diagonal:\n\n>>> m['C', 'T']\n3.5\n>>> m['T', 'C']\n3.5\n\nThe total number of substitutions between T's and C's in the alignment\nis 3.5 + 3.5 = 7.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 3656, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "substitutions", "signature": "(self)", "symbol_type": "function"}], "substrates": [{"docstring": "Return list of substrate Entry elements.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/KEGG/KGML/KGML_pathway.py", "line_number": 738, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.KEGG.KGML.KGML_pathway", "name": "substrates", "signature": "(self)", "symbol_type": "function"}], "subtract_control": [{"docstring": "Subtract a 'control' well from the other plates wells.\n\nBy default the control is subtracted to all wells, unless\na list of well ID is provided\n\nThe control well should belong to the plate\nA new PlateRecord object is returned", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/phen_micro.py", "line_number": 491, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.phen_micro", "name": "subtract_control", "signature": "(self, control = 'A01', wells = None)", "symbol_type": "function"}], "sum": [{"docstring": "Calculate the associations, makes matrix of associations.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 206, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "sum", "signature": "(self)", "symbol_type": "function"}], "sum_branchlength": [{"docstring": "Add up the branchlengths from root (default self.root) to node.\n\nsum = sum_branchlength(self,root=None,node=None)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 382, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "sum_branchlength", "signature": "(self, root = None, node = None)", "symbol_type": "function"}], "summarize_beta_by_chromosome": [{"docstring": "Return per-chromosome mean beta as a DataFrame indexed by chrom.\n\nA single column 'beta_mean' is returned so that downstream code can\nselect a row (e.g., summary.loc[\"chr1\"]) yielding a Series, which\nplays well with vectorized assertions in tests.\nRequires a 'beta' column.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/epigenome/methylation.py", "line_number": 40, "module": "src.metainformant.epigenome.methylation", "name": "summarize_beta_by_chromosome", "signature": "(df_with_beta: pd.DataFrame) -> pd.DataFrame", "symbol_type": "function"}], "summarize_curate_tables": [{"docstring": "Return simple counts of expected TSV tables in a curate directory.\n\nThis uses existing repository outputs if present.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/pipeline.py", "line_number": 17, "module": "src.metainformant.rna.pipeline", "name": "summarize_curate_tables", "signature": "(curate_dir: Path) -> dict[str, int]", "symbol_type": "function"}], "summarize_fastq": [{"docstring": "Compute lightweight summary statistics over a FASTQ file.\n\nReturns a dictionary with keys:\n- ``num_reads``: total reads processed (bounded by ``max_reads`` if provided)\n- ``length_min``, ``length_max``, ``length_mean``\n- ``gc_mean``: average GC fraction across reads\n- ``n_content_mean``: average fraction of 'N' bases across reads\n- ``avg_phred_by_pos``: list[float] average Phred+33 per position (truncated to shortest)\n\nStreaming implementation; processes ``.gz`` transparently.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/fastq.py", "line_number": 118, "module": "src.metainformant.dna.fastq", "name": "summarize_fastq", "signature": "(path: Path | str, max_reads: Optional[int] = None) -> Dict[str, object]", "symbol_type": "function"}], "suppl_codes": [{"docstring": "Return a dictionary with supplier codes.\n\nLetter code for the suppliers.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2199, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "suppl_codes", "signature": "(cls)", "symbol_type": "function"}], "supplier_list": [{"docstring": "Return a list of suppliers of the enzyme.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1928, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "supplier_list", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Return a list of suppliers of the enzyme.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1960, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "supplier_list", "signature": "(cls)", "symbol_type": "function"}], "suppliers": [{"docstring": "Print a list of suppliers of the enzyme.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1922, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "suppliers", "signature": "(cls)", "symbol_type": "function"}, {"docstring": "Print a list of suppliers of the enzyme.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 1955, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "suppliers", "signature": "()", "symbol_type": "function"}], "tajima_constants": [{"docstring": "Calculate constants required for Tajima's D statistic.\n\nComputes the standard normalization constants used in Tajima's D calculation,\nwhich compare diversity-based and segregating-sites-based estimates of \u03b8.\n\nArgs:\n    sample_size: Number of sampled sequences (n)\n    \nReturns:\n    Dictionary with keys: \"a1\", \"a2\", \"b1\", \"b2\", \"c1\", \"c2\", \"e1\", \"e2\".\n    These constants are used for variance calculations in Tajima's D.\n    Returns zeros for all constants if n < 2.\n    \nExamples:\n    >>> constants = tajima_constants(sample_size=10)\n    >>> \"a1\" in constants\n    True\n    >>> constants[\"a1\"] > 0\n    True\n    \nReferences:\n    Tajima, F. (1989). Statistical method for testing the neutral mutation\n    hypothesis by DNA polymorphism. Genetics, 123(3), 585-595.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 131, "module": "src.metainformant.math.coalescent", "name": "tajima_constants", "signature": "(sample_size: int) -> dict[str, float]", "symbol_type": "function"}], "tajima_nei_distance": [{"docstring": "Tajima-Nei distance accounting for unequal base frequencies.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/distances.py", "line_number": 131, "module": "src.metainformant.dna.distances", "name": "tajima_nei_distance", "signature": "(s1: str, s2: str) -> float", "symbol_type": "function"}], "tajimas_D": [{"docstring": "Calculate Tajima's D test statistic for departure from neutral equilibrium.\n\nTajima's D compares two estimators of the population mutation parameter \u03b8:\n- \u03b8_\u03c0 (average pairwise diversity)\n- \u03b8_S (Watterson's estimator based on segregating sites)\n\nD > 0 suggests balancing selection or population contraction.\nD < 0 suggests directional selection or population expansion.\nD \u2248 0 is consistent with neutral equilibrium.\n\nArgs:\n    num_segregating_sites: Number of segregating sites (S)\n    pairwise_diversity: Average pairwise nucleotide diversity (\u03c0)\n    sample_size: Number of sampled sequences (n)\n    \nReturns:\n    Tajima's D statistic (standardized difference). Returns 0.0 if variance\n    term is zero or inputs are invalid.\n    \nExamples:\n    >>> tajimas_D(num_segregating_sites=10, pairwise_diversity=5.0, sample_size=10)\n    -2.1...\n    \nReferences:\n    Tajima, F. (1989). Statistical method for testing the neutral mutation\n    hypothesis by DNA polymorphism. Genetics, 123(3), 585-595.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 170, "module": "src.metainformant.math.coalescent", "name": "tajimas_D", "signature": "(num_segregating_sites: int, pairwise_diversity: float, sample_size: int) -> float", "symbol_type": "function"}, {"docstring": "Calculate Tajima's D statistic.\n\nArgs:\n    num_segregating_sites: Number of segregating sites (S)\n    \nReturns:\n    Tajima's D statistic", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 821, "module": "src.metainformant.math.coalescent", "name": "tajimas_D", "signature": "(self, num_segregating_sites: int) -> float", "symbol_type": "function"}], "tajimas_d": [{"docstring": "Simplified Tajima's D approximation for small samples.\n\nThis is a simplified version of Tajima's D that provides a basic measure\nof departure from neutral equilibrium. For accurate statistical testing,\nuse `metainformant.math.coalescent.tajimas_D()` which implements the\nfull formula with proper variance calculation.\n\nTajima's D compares two estimators of the population mutation parameter \u03b8:\n- \u03b8_\u03c0 (average pairwise diversity)\n- \u03b8_S (Watterson's estimator based on segregating sites)\n\nD > 0 suggests balancing selection or population contraction.\nD < 0 suggests directional selection or population expansion.\nD \u2248 0 is consistent with neutral equilibrium.\n\nArgs:\n    seqs: Sequence of DNA sequences (must be same length)\n\nReturns:\n    Simplified Tajima's D statistic. Returns 0.0 when:\n    - Less than 2 sequences\n    - No segregating sites\n    - Zero-length sequences\n\nNote:\n    This simplified version uses a basic normalization and may not\n    match the standard Tajima's D statistic exactly. For publication-\n    quality analysis, use the full implementation in `math.coalescent`.\n\nExamples:\n    >>> seqs = [\"AAAA\", \"AAAT\", \"AATT\"]\n    >>> d = tajimas_d(seqs)\n    >>> isinstance(d, float)\n    True\n\nReferences:\n    Tajima, F. (1989). Statistical method for testing the neutral mutation\n    hypothesis by DNA polymorphism. Genetics, 123(3), 585-595.\n\nSee Also:\n    `metainformant.math.coalescent.tajimas_D()` : Full Tajima's D implementation", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population.py", "line_number": 154, "module": "src.metainformant.dna.population", "name": "tajimas_d", "signature": "(seqs: Sequence[str]) -> float", "symbol_type": "function"}], "tajimas_d_outliers": [{"docstring": "Detect outlier loci based on Tajima's D values.\n\nIdentifies loci with unusually high or low Tajima's D, which may indicate\nselection or demographic effects.\n\nArgs:\n    tajimas_d_values: Sequence of Tajima's D values per locus\n    threshold: Threshold in standard deviations\n\nReturns:\n    Dictionary with outlier information (same format as detect_outliers)\n    \nExamples:\n    >>> d_values = [-0.5, -0.3, 0.1, 5.0, 0.2]\n    >>> result = tajimas_d_outliers(d_values, threshold=2.0)\n    >>> len(result[\"outlier_indices\"]) > 0\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen_stats.py", "line_number": 308, "module": "src.metainformant.math.popgen_stats", "name": "tajimas_d_outliers", "signature": "(tajimas_d_values: Sequence[float], threshold: float = 2.0) -> dict[str, list[int] | list[float]]", "symbol_type": "function"}], "target": [{"docstring": "Return self.sequences[0] for a pairwise alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 1557, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "target", "signature": "(self)", "symbol_type": "function"}, {"docstring": "For a pairwise alignment, set self.sequences[0].", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 1569, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "target", "signature": "(self, value)", "symbol_type": "function"}], "task_context": [{"docstring": "Context manager for tracking multi-step tasks.\n\nArgs:\n    task_name: Name of the task\n    total_steps: Total number of steps (optional)\n\nYields:\n    Task tracker object\n\nExample:\n    with task_context(\"Processing data\", total_steps=10) as task:\n        for i in range(10):\n            process_step(i)\n            task.update(1)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/progress.py", "line_number": 74, "module": "src.metainformant.core.progress", "name": "task_context", "signature": "(task_name: str, total_steps: int | None = None) -> Iterator[Any]", "symbol_type": "function"}], "tax_name_query": [{"docstring": "Get a list of taxonomy names and IDs given a partial taxonomic name  # noqa: E501\n\nThis endpoint retrieves a list of taxonomy names and IDs given a partial taxonomic name of any rank.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.tax_name_query(taxon_query, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    taxon_query (str): NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank\n\nKeyword Args:\n    tax_rank_filter (V1OrganismQueryRequestTaxRankFilter): Set the scope of searched tax ranks. [optional]\n    tax_resource_filter (V1OrganismQueryRequestTaxonResourceFilter): [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1SciNameAndIds\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/taxonomy_api.py", "line_number": 333, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.taxonomy_api", "name": "tax_name_query", "signature": "(self, taxon_query, **kwargs)", "symbol_type": "function"}], "taxonomy": [{"docstring": "Record (another line of) the taxonomy lineage.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 548, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "taxonomy", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1001, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "taxonomy", "signature": "(self, content)", "symbol_type": "function"}], "taxonomy_filtered_subtree": [{"docstring": "Use taxonomic identifiers to get a filtered taxonomic subtree  # noqa: E501\n\nUsing NCBI Taxonomy IDs or names (common or scientific) at any rank, get a filtered taxonomic subtree that includes the full parent lineage and all immediate children from the selected taxonomic ranks in JSON format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.taxonomy_filtered_subtree(taxons, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    taxons ([str]):\n\nKeyword Args:\n    specified_limit (bool): Limit to specified species. [optional]\n    rank_limits ([V1OrganismRankType]): Limit to the provided ranks.  If empty, accept any rank.. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1TaxonomyFilteredSubtreeResponse\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/taxonomy_api.py", "line_number": 410, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.taxonomy_api", "name": "taxonomy_filtered_subtree", "signature": "(self, taxons, **kwargs)", "symbol_type": "function"}], "taxonomy_filtered_subtree_post": [{"docstring": "Use taxonomic identifiers to get a filtered taxonomic subtree by post  # noqa: E501\n\nUsing NCBI Taxonomy IDs or names (common or scientific) at any rank, get a filtered taxonomic subtree that includes the full parent lineage and all immediate children from the selected taxonomic ranks in JSON format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.taxonomy_filtered_subtree_post(v1_taxonomy_filtered_subtree_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_taxonomy_filtered_subtree_request (V1TaxonomyFilteredSubtreeRequest):\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1TaxonomyFilteredSubtreeResponse\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/taxonomy_api.py", "line_number": 487, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.taxonomy_api", "name": "taxonomy_filtered_subtree_post", "signature": "(self, v1_taxonomy_filtered_subtree_request, **kwargs)", "symbol_type": "function"}], "taxonomy_metadata": [{"docstring": "Use taxonomic identifiers to get taxonomic metadata  # noqa: E501\n\nUsing NCBI Taxonomy IDs or names (common or scientific) at any rank, get metadata about a taxonomic node including taxonomic identifiers, lineage information, child nodes, and gene and genome counts in JSON format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.taxonomy_metadata(taxons, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    taxons ([str]):\n\nKeyword Args:\n    returned_content (V1TaxonomyMetadataRequestContentType): Return either tax-ids alone, or entire taxononmy-metadata records. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1TaxonomyMetadataResponse\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/taxonomy_api.py", "line_number": 562, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.taxonomy_api", "name": "taxonomy_metadata", "signature": "(self, taxons, **kwargs)", "symbol_type": "function"}], "taxonomy_metadata_post": [{"docstring": "Use taxonomic identifiers to get taxonomic metadata by post  # noqa: E501\n\nUsing NCBI Taxonomy IDs or names (common or scientific) at any rank, get metadata about a taxonomic node including taxonomic identifiers, lineage information, child nodes, and gene and genome counts in JSON format.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.taxonomy_metadata_post(v1_taxonomy_metadata_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_taxonomy_metadata_request (V1TaxonomyMetadataRequest):\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1TaxonomyMetadataResponse\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/taxonomy_api.py", "line_number": 638, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.taxonomy_api", "name": "taxonomy_metadata_post", "signature": "(self, v1_taxonomy_metadata_request, **kwargs)", "symbol_type": "function"}], "teardown_method": [{"docstring": "Cleanup test directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 26, "module": "tests.test_rna_amalgkit_end_to_end", "name": "teardown_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Cleanup test directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 212, "module": "tests.test_rna_amalgkit_end_to_end", "name": "teardown_method", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Cleanup test directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 307, "module": "tests.test_rna_amalgkit_end_to_end", "name": "teardown_method", "signature": "(self)", "symbol_type": "function"}], "tell": [{"docstring": "Return a 64-bit unsigned BGZF virtual offset.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 656, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "tell", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a BGZF 64-bit virtual offset.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 903, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "tell", "signature": "(self)", "symbol_type": "function"}], "temporal_patterns": [{"docstring": "Identify critical time periods for predictions.\n\nArgs:\n    sequences: List of event sequences (must not be empty)\n    predictions: Model predictions (must match sequence length)\n    time_windows: Optional time windows for analysis (not yet implemented)\n    \nReturns:\n    Dictionary with temporal pattern analysis including position importance\n    \nRaises:\n    ValueError: If sequences empty or predictions length doesn't match sequences length\n    \nExamples:\n    >>> import numpy as np\n    >>> sequences = [[\"health:diagnosis\", \"occupation:job_change\"]]\n    >>> predictions = np.array([0.8])\n    >>> patterns = temporal_patterns(sequences, predictions)\n    >>> \"position_importance\" in patterns\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/interpretability.py", "line_number": 141, "module": "src.metainformant.life_events.interpretability", "name": "temporal_patterns", "signature": "(sequences: List[List[str]], predictions: NDArray, time_windows: Optional[List[float]] = None) -> Dict[str, Any]", "symbol_type": "function"}], "terminal_gap_to_missing": [{"docstring": "Replace all terminal gaps with missing character.\n\nMixtures like ???------??------- are properly resolved.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 2076, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "terminal_gap_to_missing", "signature": "(self, missing = None, skip_n = True)", "symbol_type": "function"}], "test_adapter_detection_basic": [{"docstring": "Test basic adapter detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 203, "module": "tests.test_quality_fastq", "name": "test_adapter_detection_basic", "signature": "(self)", "symbol_type": "function"}], "test_add_edges_from_correlation": [{"docstring": "Test adding edges based on correlation matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 321, "module": "tests.test_networks_comprehensive", "name": "test_add_edges_from_correlation", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test adding edges based on correlation matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 126, "module": "tests.test_networks_graph", "name": "test_add_edges_from_correlation", "signature": "(self)", "symbol_type": "function"}], "test_add_edges_from_correlation_dimension_mismatch": [{"docstring": "Test error handling for dimension mismatch.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 146, "module": "tests.test_networks_graph", "name": "test_add_edges_from_correlation_dimension_mismatch", "signature": "(self)", "symbol_type": "function"}], "test_add_edges_from_interactions": [{"docstring": "Test adding edges from interaction list.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 334, "module": "tests.test_networks_comprehensive", "name": "test_add_edges_from_interactions", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test adding edges from interaction list.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 155, "module": "tests.test_networks_graph", "name": "test_add_edges_from_interactions", "signature": "(self)", "symbol_type": "function"}], "test_add_gene_metadata": [{"docstring": "Test adding gene metadata.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 113, "module": "tests.test_networks_regulatory", "name": "test_add_gene_metadata", "signature": "(self)", "symbol_type": "function"}], "test_add_interaction": [{"docstring": "Test adding protein interactions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 63, "module": "tests.test_networks_ppi", "name": "test_add_interaction", "signature": "(self)", "symbol_type": "function"}], "test_add_nodes_and_edges": [{"docstring": "Test adding nodes and edges.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 36, "module": "tests.test_networks_comprehensive", "name": "test_add_nodes_and_edges", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test adding nodes and edges to network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 38, "module": "tests.test_networks_graph", "name": "test_add_nodes_and_edges", "signature": "(self)", "symbol_type": "function"}], "test_add_pathway": [{"docstring": "Test adding pathways.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 55, "module": "tests.test_networks_pathway", "name": "test_add_pathway", "signature": "(self)", "symbol_type": "function"}], "test_add_protein_metadata": [{"docstring": "Test adding protein metadata.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 88, "module": "tests.test_networks_ppi", "name": "test_add_protein_metadata", "signature": "(self)", "symbol_type": "function"}], "test_add_regulation": [{"docstring": "Test adding regulatory interactions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 68, "module": "tests.test_networks_regulatory", "name": "test_add_regulation", "signature": "(self)", "symbol_type": "function"}], "test_add_temporal_noise": [{"docstring": "Test temporal noise addition to sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_simulation_advanced.py", "line_number": 51, "module": "tests.test_life_events_simulation_advanced", "name": "test_add_temporal_noise", "signature": "(tmp_path)", "symbol_type": "function"}], "test_add_transcription_factor": [{"docstring": "Test adding transcription factors.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 96, "module": "tests.test_networks_regulatory", "name": "test_add_transcription_factor", "signature": "(self)", "symbol_type": "function"}], "test_advanced_slugify": [{"docstring": "Test advanced text slugification.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 311, "module": "tests.test_core_comprehensive", "name": "test_advanced_slugify", "signature": "(self)", "symbol_type": "function"}], "test_agent_creation": [{"docstring": "Test individual Agent creation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 192, "module": "tests.test_simulation", "name": "test_agent_creation", "signature": "()", "symbol_type": "function"}], "test_agent_step": [{"docstring": "Test agent movement during step.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 199, "module": "tests.test_simulation", "name": "test_agent_step", "signature": "()", "symbol_type": "function"}], "test_align_msa_returns_equal_length_alignment": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_msa.py", "line_number": 8, "module": "tests.test_dna_msa", "name": "test_align_msa_returns_equal_length_alignment", "signature": "() -> None", "symbol_type": "function"}], "test_alignment_edge_cases": [{"docstring": "Test edge cases in alignment functions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_alignment_enhanced.py", "line_number": 80, "module": "tests.test_dna_alignment_enhanced", "name": "test_alignment_edge_cases", "signature": "(self)", "symbol_type": "function"}], "test_alignment_identity_calculation": [{"docstring": "Test alignment identity calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_alignment_enhanced.py", "line_number": 10, "module": "tests.test_dna_alignment_enhanced", "name": "test_alignment_identity_calculation", "signature": "(self)", "symbol_type": "function"}], "test_alignment_result_dataclass": [{"docstring": "Test AlignmentResult dataclass functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_alignment_enhanced.py", "line_number": 97, "module": "tests.test_dna_alignment_enhanced", "name": "test_alignment_result_dataclass", "signature": "(self)", "symbol_type": "function"}], "test_alignment_statistics": [{"docstring": "Test comprehensive alignment statistics.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_alignment_enhanced.py", "line_number": 45, "module": "tests.test_dna_alignment_enhanced", "name": "test_alignment_statistics", "signature": "(self)", "symbol_type": "function"}], "test_all_exports_present": [{"docstring": "Verify all items in __all__ are actually exported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 593, "module": "tests.test_rna_amalgkit_steps", "name": "test_all_exports_present", "signature": "(self)", "symbol_type": "function"}], "test_all_heterozygous": [{"docstring": "Test with all heterozygous genotypes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 68, "module": "tests.test_dna_population_comprehensive", "name": "test_all_heterozygous", "signature": "(self)", "symbol_type": "function"}], "test_all_homozygous": [{"docstring": "Test with all homozygous genotypes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 62, "module": "tests.test_dna_population_comprehensive", "name": "test_all_homozygous", "signature": "(self)", "symbol_type": "function"}], "test_all_ones": [{"docstring": "Test with all ones (all alternate alleles).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 41, "module": "tests.test_dna_population_comprehensive", "name": "test_all_ones", "signature": "(self)", "symbol_type": "function"}], "test_all_orchestrators_exist": [{"docstring": "Verify all orchestrator scripts exist.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 208, "module": "tests.test_orchestrators", "name": "test_all_orchestrators_exist", "signature": "(self)", "symbol_type": "function"}], "test_all_runners_accept_standard_params": [{"docstring": "Test that all runners accept the standard parameter set.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 632, "module": "tests.test_rna_amalgkit_steps", "name": "test_all_runners_accept_standard_params", "signature": "(self)", "symbol_type": "function"}], "test_all_runners_are_callable": [{"docstring": "Verify all runners in STEP_RUNNERS are callable.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 55, "module": "tests.test_rna_amalgkit_steps", "name": "test_all_runners_are_callable", "signature": "(self)", "symbol_type": "function"}], "test_all_runners_have_correct_signature": [{"docstring": "Verify all runners accept standard parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 60, "module": "tests.test_rna_amalgkit_steps", "name": "test_all_runners_have_correct_signature", "signature": "(self)", "symbol_type": "function"}], "test_all_same_class": [{"docstring": "Test feature selection when all samples have same class.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 607, "module": "tests.test_ml_features", "name": "test_all_same_class", "signature": "(self)", "symbol_type": "function"}], "test_all_species_startup": [{"docstring": "Test that all species configs can be loaded and workflows planned.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/test_end_to_end_startup.py", "line_number": 16, "module": "scripts.test_end_to_end_startup", "name": "test_all_species_startup", "signature": "()", "symbol_type": "function"}], "test_all_step_runners_have_docstrings": [{"docstring": "Verify all step runners have docstrings.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 649, "module": "tests.test_rna_amalgkit_steps", "name": "test_all_step_runners_have_docstrings", "signature": "(self)", "symbol_type": "function"}], "test_all_steps_execute_in_order": [{"docstring": "Test that all 11 steps execute in correct order.\n\nThis test verifies the complete workflow execution order:\nmetadata \u2192 integrate \u2192 config \u2192 select \u2192 getfastq \u2192 quant \u2192 merge \u2192 cstmm \u2192 curate \u2192 csca \u2192 sanity", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 217, "module": "tests.test_rna_amalgkit_end_to_end", "name": "test_all_steps_execute_in_order", "signature": "(self, ensure_amalgkit_available)", "symbol_type": "function"}], "test_all_zero_data": [{"docstring": "Test handling of all-zero data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 409, "module": "tests.test_singlecell_preprocessing", "name": "test_all_zero_data", "signature": "(self)", "symbol_type": "function"}], "test_all_zero_matrix": [{"docstring": "Test handling of all-zero count matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 466, "module": "tests.test_singlecell_basic", "name": "test_all_zero_matrix", "signature": "(self)", "symbol_type": "function"}], "test_all_zeros": [{"docstring": "Test with all zeros (no alternate alleles).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 35, "module": "tests.test_dna_population_comprehensive", "name": "test_all_zeros", "signature": "(self)", "symbol_type": "function"}], "test_alphafold_offline_behavior": [{"docstring": "Document real offline behavior for AlphaFold downloads.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_alphafold_fetch.py", "line_number": 132, "module": "tests.test_protein_alphafold_fetch", "name": "test_alphafold_offline_behavior", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_amalgkit_core_functions_have_docstrings": [{"docstring": "Verify core amalgkit functions have docstrings.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 668, "module": "tests.test_rna_amalgkit_steps", "name": "test_amalgkit_core_functions_have_docstrings", "signature": "(self)", "symbol_type": "function"}], "test_amalgkit_params_type_exists": [{"docstring": "Verify AmalgkitParams type is defined.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 617, "module": "tests.test_rna_amalgkit_steps", "name": "test_amalgkit_params_type_exists", "signature": "(self)", "symbol_type": "function"}], "test_amalgkit_subcommand_wrappers_have_docstrings": [{"docstring": "Verify all subcommand wrapper functions have docstrings.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 681, "module": "tests.test_rna_amalgkit_steps", "name": "test_amalgkit_subcommand_wrappers_have_docstrings", "signature": "(self)", "symbol_type": "function"}], "test_analyze_fastq_quality_with_file": [{"docstring": "Test complete FASTQ analysis with actual file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 350, "module": "tests.test_quality_fastq", "name": "test_analyze_fastq_quality_with_file", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_analyze_fastq_quality_with_subsampling": [{"docstring": "Test FASTQ analysis with subsampling.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 406, "module": "tests.test_quality_fastq", "name": "test_analyze_fastq_quality_with_subsampling", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_analyze_life_course_basic": [{"docstring": "Test basic life course analysis workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_workflow.py", "line_number": 21, "module": "tests.test_life_events_workflow", "name": "test_analyze_life_course_basic", "signature": "(tmp_path)", "symbol_type": "function"}], "test_analyze_life_course_config_embedding_params": [{"docstring": "Test that embedding params from config are used.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_workflow.py", "line_number": 297, "module": "tests.test_life_events_workflow", "name": "test_analyze_life_course_config_embedding_params", "signature": "(tmp_path)", "symbol_type": "function"}], "test_analyze_life_course_config_model_params": [{"docstring": "Test that model params from config are used.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_workflow.py", "line_number": 325, "module": "tests.test_life_events_workflow", "name": "test_analyze_life_course_config_model_params", "signature": "(tmp_path)", "symbol_type": "function"}], "test_analyze_life_course_config_work_dir": [{"docstring": "Test that work_dir from config is used.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_workflow.py", "line_number": 269, "module": "tests.test_life_events_workflow", "name": "test_analyze_life_course_config_work_dir", "signature": "(tmp_path)", "symbol_type": "function"}], "test_analyze_life_course_saves_model": [{"docstring": "Test that model is saved when outcomes provided.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_workflow.py", "line_number": 357, "module": "tests.test_life_events_workflow", "name": "test_analyze_life_course_saves_model", "signature": "(tmp_path)", "symbol_type": "function"}], "test_analyze_life_course_with_config_obj": [{"docstring": "Test analyze_life_course with LifeEventsWorkflowConfig object.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_workflow.py", "line_number": 166, "module": "tests.test_life_events_workflow", "name": "test_analyze_life_course_with_config_obj", "signature": "(tmp_path)", "symbol_type": "function"}], "test_analyze_life_course_with_config_path": [{"docstring": "Test analyze_life_course with config file path.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_workflow.py", "line_number": 198, "module": "tests.test_life_events_workflow", "name": "test_analyze_life_course_with_config_path", "signature": "(tmp_path)", "symbol_type": "function"}], "test_analyze_life_course_with_dict_config": [{"docstring": "Test analyze_life_course with dict config (backward compatibility).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_workflow.py", "line_number": 237, "module": "tests.test_life_events_workflow", "name": "test_analyze_life_course_with_dict_config", "signature": "(tmp_path)", "symbol_type": "function"}], "test_analyze_life_course_with_outcomes": [{"docstring": "Test life course analysis with outcome prediction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_workflow.py", "line_number": 48, "module": "tests.test_life_events_workflow", "name": "test_analyze_life_course_with_outcomes", "signature": "(tmp_path)", "symbol_type": "function"}], "test_analyze_sequence_information": [{"docstring": "Test sequence information analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 190, "module": "tests.test_information_comprehensive", "name": "test_analyze_sequence_information", "signature": "(self)", "symbol_type": "function"}], "test_ancestors_empty_term_id": [{"docstring": "Test ancestors with empty term_id raises ValueError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 59, "module": "tests.test_ontology_query", "name": "test_ancestors_empty_term_id", "signature": "(self)", "symbol_type": "function"}], "test_ancestors_missing_term": [{"docstring": "Test ancestors for non-existent term.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_comprehensive.py", "line_number": 216, "module": "tests.test_ontology_comprehensive", "name": "test_ancestors_missing_term", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test ancestors of non-existent term raises ValueError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 53, "module": "tests.test_ontology_query", "name": "test_ancestors_missing_term", "signature": "(self)", "symbol_type": "function"}], "test_ancestors_no_parents": [{"docstring": "Test ancestors of root term.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 41, "module": "tests.test_ontology_query", "name": "test_ancestors_no_parents", "signature": "(self)", "symbol_type": "function"}], "test_ancestors_query": [{"docstring": "Test ancestor retrieval.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_comprehensive.py", "line_number": 66, "module": "tests.test_ontology_comprehensive", "name": "test_ancestors_query", "signature": "(self)", "symbol_type": "function"}], "test_ancestors_simple_hierarchy": [{"docstring": "Test finding ancestors in simple hierarchy.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 22, "module": "tests.test_ontology_query", "name": "test_ancestors_simple_hierarchy", "signature": "(self)", "symbol_type": "function"}], "test_animation_builds": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization.py", "line_number": 46, "module": "tests.test_visualization", "name": "test_animation_builds", "signature": "()", "symbol_type": "function"}], "test_animation_constructs": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization.py", "line_number": 19, "module": "tests.test_visualization", "name": "test_animation_constructs", "signature": "()", "symbol_type": "function"}], "test_antwiki_json_structure": [{"docstring": "Test that AntWiki data has expected structure.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_basic.py", "line_number": 72, "module": "tests.test_phenotype_basic", "name": "test_antwiki_json_structure", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_antwiki_json_validation": [{"docstring": "Test data validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_basic.py", "line_number": 90, "module": "tests.test_phenotype_basic", "name": "test_antwiki_json_validation", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_apply_qc_filters_basic": [{"docstring": "Test applying basic QC filters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_quality.py", "line_number": 54, "module": "tests.test_gwas_quality", "name": "test_apply_qc_filters_basic", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_apply_qc_filters_hwe": [{"docstring": "Test Hardy-Weinberg equilibrium filtering.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_quality.py", "line_number": 126, "module": "tests.test_gwas_quality", "name": "test_apply_qc_filters_hwe", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_apply_qc_filters_maf": [{"docstring": "Test MAF filtering.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_quality.py", "line_number": 85, "module": "tests.test_gwas_quality", "name": "test_apply_qc_filters_maf", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_apply_qc_filters_missing_data": [{"docstring": "Test missing data filtering.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_quality.py", "line_number": 107, "module": "tests.test_gwas_quality", "name": "test_apply_qc_filters_missing_data", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_association_linear_basic": [{"docstring": "Test basic linear regression association test.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_association.py", "line_number": 14, "module": "tests.test_gwas_association", "name": "test_association_linear_basic", "signature": "() -> None", "symbol_type": "function"}], "test_association_linear_missing_data": [{"docstring": "Test linear regression with missing genotypes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_association.py", "line_number": 57, "module": "tests.test_gwas_association", "name": "test_association_linear_missing_data", "signature": "() -> None", "symbol_type": "function"}], "test_association_linear_no_association": [{"docstring": "Test linear regression with no association.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_association.py", "line_number": 31, "module": "tests.test_gwas_association", "name": "test_association_linear_no_association", "signature": "() -> None", "symbol_type": "function"}], "test_association_linear_with_covariates": [{"docstring": "Test linear regression with covariates.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_association.py", "line_number": 44, "module": "tests.test_gwas_association", "name": "test_association_linear_with_covariates", "signature": "() -> None", "symbol_type": "function"}], "test_association_logistic_basic": [{"docstring": "Test basic logistic regression association test.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_association.py", "line_number": 68, "module": "tests.test_gwas_association", "name": "test_association_logistic_basic", "signature": "() -> None", "symbol_type": "function"}], "test_association_logistic_insufficient_cases": [{"docstring": "Test logistic regression with insufficient cases/controls.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_association.py", "line_number": 101, "module": "tests.test_gwas_association", "name": "test_association_logistic_insufficient_cases", "signature": "() -> None", "symbol_type": "function"}], "test_association_logistic_no_association": [{"docstring": "Test logistic regression with no association.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_association.py", "line_number": 88, "module": "tests.test_gwas_association", "name": "test_association_logistic_no_association", "signature": "() -> None", "symbol_type": "function"}], "test_at_skew_calculation": [{"docstring": "Test AT skew calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 191, "module": "tests.test_dna_sequences_enhanced", "name": "test_at_skew_calculation", "signature": "(self)", "symbol_type": "function"}], "test_attention_weights": [{"docstring": "Test attention weights extraction (placeholder).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_interpretability.py", "line_number": 105, "module": "tests.test_life_events_interpretability", "name": "test_attention_weights", "signature": "()", "symbol_type": "function"}], "test_average_phred_by_position": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_fastq.py", "line_number": 8, "module": "tests.test_dna_fastq", "name": "test_average_phred_by_position", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_average_phred_calculation": [{"docstring": "Test average Phred score calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 323, "module": "tests.test_dna_comprehensive", "name": "test_average_phred_calculation", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_basic_aggregation": [{"docstring": "Test basic temporal aggregation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 119, "module": "tests.test_phenotype_life_course", "name": "test_basic_aggregation", "signature": "(self)", "symbol_type": "function"}], "test_basic_allele_frequencies": [{"docstring": "Test basic allele frequency calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 13, "module": "tests.test_dna_population_comprehensive", "name": "test_basic_allele_frequencies", "signature": "(self)", "symbol_type": "function"}], "test_basic_bottleneck": [{"docstring": "Test basic bottleneck simulation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 200, "module": "tests.test_simulation_popgen", "name": "test_basic_bottleneck", "signature": "(self)", "symbol_type": "function"}], "test_basic_creation": [{"docstring": "Test creating MultiOmicsData with two layers.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 27, "module": "tests.test_multiomics_comprehensive", "name": "test_basic_creation", "signature": "(self)", "symbol_type": "function"}], "test_basic_diversity": [{"docstring": "Test basic nucleotide diversity calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 78, "module": "tests.test_dna_population_comprehensive", "name": "test_basic_diversity", "signature": "(self)", "symbol_type": "function"}], "test_basic_expansion": [{"docstring": "Test basic expansion simulation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 229, "module": "tests.test_simulation_popgen", "name": "test_basic_expansion", "signature": "(self)", "symbol_type": "function"}], "test_basic_expectations_monotonic": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_coalescent.py", "line_number": 19, "module": "tests.test_math_coalescent", "name": "test_basic_expectations_monotonic", "signature": "()", "symbol_type": "function"}], "test_basic_extraction": [{"docstring": "Test basic phenotype extraction from event sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 29, "module": "tests.test_phenotype_life_course", "name": "test_basic_extraction", "signature": "(self)", "symbol_type": "function"}], "test_basic_generation": [{"docstring": "Test basic sequence generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 23, "module": "tests.test_simulation_popgen", "name": "test_basic_generation", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test basic two-population generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 91, "module": "tests.test_simulation_popgen", "name": "test_basic_generation", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test basic genotype matrix generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 135, "module": "tests.test_simulation_popgen", "name": "test_basic_generation", "signature": "(self)", "symbol_type": "function"}], "test_basic_heterozygosity": [{"docstring": "Test basic heterozygosity calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 51, "module": "tests.test_dna_population_comprehensive", "name": "test_basic_heterozygosity", "signature": "(self)", "symbol_type": "function"}], "test_basic_ld_generation": [{"docstring": "Test basic LD data generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 287, "module": "tests.test_simulation_popgen", "name": "test_basic_ld_generation", "signature": "(self)", "symbol_type": "function"}], "test_basic_network_metrics": [{"docstring": "Test basic network metric calculations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 183, "module": "tests.test_networks_graph", "name": "test_basic_network_metrics", "signature": "(self)", "symbol_type": "function"}], "test_basic_neutrality_tests": [{"docstring": "Test basic neutrality test suite.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_analysis.py", "line_number": 107, "module": "tests.test_dna_population_analysis", "name": "test_basic_neutrality_tests", "signature": "(self)", "symbol_type": "function"}], "test_basic_plot": [{"docstring": "Test basic diversity comparison plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 26, "module": "tests.test_dna_population_viz", "name": "test_basic_plot", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}, {"docstring": "Test basic Tajima's D plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 54, "module": "tests.test_dna_population_viz", "name": "test_basic_plot", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}, {"docstring": "Test basic Fst plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 75, "module": "tests.test_dna_population_viz", "name": "test_basic_plot", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_basic_reproduction_number": [{"docstring": "Test R0 calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 226, "module": "tests.test_math_comprehensive", "name": "test_basic_reproduction_number", "signature": "(self)", "symbol_type": "function"}], "test_basic_segregating_sites": [{"docstring": "Test basic segregating sites count.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 187, "module": "tests.test_dna_population_comprehensive", "name": "test_basic_segregating_sites", "signature": "(self)", "symbol_type": "function"}], "test_basic_singlecell_workflow": [{"docstring": "Test basic single-cell analysis workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 405, "module": "tests.test_singlecell_basic", "name": "test_basic_singlecell_workflow", "signature": "(self)", "symbol_type": "function"}], "test_basic_statistics_calculation": [{"docstring": "Test calculation of basic FASTQ statistics.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 43, "module": "tests.test_quality_fastq", "name": "test_basic_statistics_calculation", "signature": "(self)", "symbol_type": "function"}], "test_basic_statistics_empty_input": [{"docstring": "Test handling of empty input.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 85, "module": "tests.test_quality_fastq", "name": "test_basic_statistics_empty_input", "signature": "(self)", "symbol_type": "function"}], "test_basic_statistics_uniform_length": [{"docstring": "Test statistics with uniform-length reads.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 71, "module": "tests.test_quality_fastq", "name": "test_basic_statistics_uniform_length", "signature": "(self)", "symbol_type": "function"}], "test_basic_tajimas_d": [{"docstring": "Test basic Tajima's D calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 126, "module": "tests.test_dna_population_comprehensive", "name": "test_basic_tajimas_d", "signature": "(self)", "symbol_type": "function"}], "test_basic_wattersons_theta": [{"docstring": "Test basic Watterson's theta calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 215, "module": "tests.test_dna_population_comprehensive", "name": "test_basic_wattersons_theta", "signature": "(self)", "symbol_type": "function"}], "test_batch_download": [{"docstring": "Test batch download functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io_enhanced.py", "line_number": 64, "module": "tests.test_core_io_enhanced", "name": "test_batch_download", "signature": "(self)", "symbol_type": "function"}], "test_batch_entropy_analysis": [{"docstring": "Test batch entropy analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 431, "module": "tests.test_information_comprehensive", "name": "test_batch_entropy_analysis", "signature": "(self)", "symbol_type": "function"}], "test_bias_correction": [{"docstring": "Test bias correction function.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 415, "module": "tests.test_information_comprehensive", "name": "test_bias_correction", "signature": "(self)", "symbol_type": "function"}], "test_binary_features": [{"docstring": "Test feature selection with binary features.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 564, "module": "tests.test_ml_features", "name": "test_binary_features", "signature": "(self)", "symbol_type": "function"}], "test_biological_embedding": [{"docstring": "Test biological embedding methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 366, "module": "tests.test_ml_comprehensive", "name": "test_biological_embedding", "signature": "(self)", "symbol_type": "function"}], "test_biological_ranking_biological_only": [{"docstring": "Test ranking using only biological weights.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 373, "module": "tests.test_ml_features", "name": "test_biological_ranking_biological_only", "signature": "(self)", "symbol_type": "function"}], "test_biological_ranking_combined": [{"docstring": "Test combined statistical + biological ranking.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 389, "module": "tests.test_ml_features", "name": "test_biological_ranking_combined", "signature": "(self)", "symbol_type": "function"}], "test_biological_ranking_default_feature_names": [{"docstring": "Test ranking with default feature names.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 426, "module": "tests.test_ml_features", "name": "test_biological_ranking_default_feature_names", "signature": "(self)", "symbol_type": "function"}], "test_biological_ranking_invalid_method": [{"docstring": "Test error handling for invalid ranking method.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 442, "module": "tests.test_ml_features", "name": "test_biological_ranking_invalid_method", "signature": "(self)", "symbol_type": "function"}], "test_biological_ranking_name_mismatch": [{"docstring": "Test error handling when feature names don't match X columns.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 447, "module": "tests.test_ml_features", "name": "test_biological_ranking_name_mismatch", "signature": "(self)", "symbol_type": "function"}], "test_biological_ranking_no_weights": [{"docstring": "Test ranking when no biological weights provided.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 405, "module": "tests.test_ml_features", "name": "test_biological_ranking_no_weights", "signature": "(self)", "symbol_type": "function"}], "test_biological_ranking_statistical_only": [{"docstring": "Test ranking using only statistical criteria.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 350, "module": "tests.test_ml_features", "name": "test_biological_ranking_statistical_only", "signature": "(self)", "symbol_type": "function"}], "test_biological_text_processing": [{"docstring": "Test biology-specific text processing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 336, "module": "tests.test_core_comprehensive", "name": "test_biological_text_processing", "signature": "(self)", "symbol_type": "function"}], "test_bonferroni_correction_all_significant": [{"docstring": "Test Bonferroni correction where all results are significant.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_correction.py", "line_number": 36, "module": "tests.test_gwas_correction", "name": "test_bonferroni_correction_all_significant", "signature": "() -> None", "symbol_type": "function"}], "test_bonferroni_correction_basic": [{"docstring": "Test basic Bonferroni correction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_correction.py", "line_number": 11, "module": "tests.test_gwas_correction", "name": "test_bonferroni_correction_basic", "signature": "() -> None", "symbol_type": "function"}], "test_bonferroni_correction_no_significant": [{"docstring": "Test Bonferroni correction with no significant results.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_correction.py", "line_number": 26, "module": "tests.test_gwas_correction", "name": "test_bonferroni_correction_no_significant", "signature": "() -> None", "symbol_type": "function"}], "test_bool_value_flags": [{"docstring": "Test flags that require explicit yes/no values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 563, "module": "tests.test_rna_amalgkit_steps", "name": "test_bool_value_flags", "signature": "(self)", "symbol_type": "function"}], "test_bootstrap_confidence_interval": [{"docstring": "Test bootstrap confidence interval calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_stats.py", "line_number": 19, "module": "tests.test_math_popgen_stats", "name": "test_bootstrap_confidence_interval", "signature": "()", "symbol_type": "function"}], "test_bootstrap_support_and_upgma": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_phylogeny_extra.py", "line_number": 8, "module": "tests.test_dna_phylogeny_extra", "name": "test_bootstrap_support_and_upgma", "signature": "() -> None", "symbol_type": "function"}], "test_bootstrap_support_deterministic_with_seed": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_phylogeny_bootstrap.py", "line_number": 8, "module": "tests.test_dna_phylogeny_bootstrap", "name": "test_bootstrap_support_deterministic_with_seed", "signature": "() -> None", "symbol_type": "function"}], "test_bootstrap_validate": [{"docstring": "Test bootstrap validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 492, "module": "tests.test_ml_comprehensive", "name": "test_bootstrap_validate", "signature": "(self)", "symbol_type": "function"}], "test_bootstrap_with_empty_data": [{"docstring": "Test bootstrap with empty data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_stats.py", "line_number": 105, "module": "tests.test_math_popgen_stats", "name": "test_bootstrap_with_empty_data", "signature": "()", "symbol_type": "function"}], "test_both_sequence_and_genotype": [{"docstring": "Test with both sequence and genotype data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_analysis.py", "line_number": 43, "module": "tests.test_dna_population_analysis", "name": "test_both_sequence_and_genotype", "signature": "(self)", "symbol_type": "function"}], "test_bottleneck_reduces_diversity": [{"docstring": "Test that bottleneck reduces diversity.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 211, "module": "tests.test_simulation_popgen", "name": "test_bottleneck_reduces_diversity", "signature": "(self)", "symbol_type": "function"}], "test_bottleneck_with_recovery": [{"docstring": "Test bottleneck with recovery period.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_demography.py", "line_number": 60, "module": "tests.test_math_demography", "name": "test_bottleneck_with_recovery", "signature": "(self)", "symbol_type": "function"}], "test_box_plot_functionality": [{"docstring": "Test enhanced box plot functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 79, "module": "tests.test_visualization_enhanced", "name": "test_box_plot_functionality", "signature": "(self)", "symbol_type": "function"}], "test_breeders_equation_response": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_quantgen.py", "line_number": 12, "module": "tests.test_math_quantgen", "name": "test_breeders_equation_response", "signature": "()", "symbol_type": "function"}], "test_build_alphafold_url_cif_format": [{"docstring": "Test AlphaFold URL construction for CIF format (no network required).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_alphafold_fetch.py", "line_number": 29, "module": "tests.test_protein_alphafold_fetch", "name": "test_build_alphafold_url_cif_format", "signature": "()", "symbol_type": "function"}], "test_build_alphafold_url_edge_cases": [{"docstring": "Test URL construction with various edge cases (no network required).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_alphafold_fetch.py", "line_number": 42, "module": "tests.test_protein_alphafold_fetch", "name": "test_build_alphafold_url_edge_cases", "signature": "()", "symbol_type": "function"}], "test_build_alphafold_url_invalid_format": [{"docstring": "Test error handling for invalid format (no network required).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_alphafold_fetch.py", "line_number": 36, "module": "tests.test_protein_alphafold_fetch", "name": "test_build_alphafold_url_invalid_format", "signature": "()", "symbol_type": "function"}], "test_build_alphafold_url_pdb_format": [{"docstring": "Test AlphaFold URL construction for PDB format (no network required).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_alphafold_fetch.py", "line_number": 22, "module": "tests.test_protein_alphafold_fetch", "name": "test_build_alphafold_url_pdb_format", "signature": "()", "symbol_type": "function"}], "test_build_amalgkit_command": [{"docstring": "Test amalgkit command construction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 66, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_build_amalgkit_command", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test complete command building.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 430, "module": "tests.test_rna_amalgkit_end_to_end", "name": "test_build_amalgkit_command", "signature": "(self)", "symbol_type": "function"}], "test_build_amalgkit_command_exists": [{"docstring": "Verify build_amalgkit_command function exists.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 461, "module": "tests.test_rna_amalgkit_steps", "name": "test_build_amalgkit_command_exists", "signature": "(self)", "symbol_type": "function"}], "test_build_amalgkit_command_prefix_and_order": [{"docstring": "Test that build_amalgkit_command creates commands with correct prefix and order.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit.py", "line_number": 50, "module": "tests.test_rna_amalgkit", "name": "test_build_amalgkit_command_prefix_and_order", "signature": "()", "symbol_type": "function"}], "test_build_amalgkit_command_structure": [{"docstring": "Test build_amalgkit_command produces correct structure.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 531, "module": "tests.test_rna_amalgkit_steps", "name": "test_build_amalgkit_command_structure", "signature": "(self)", "symbol_type": "function"}], "test_build_amalgkit_command_with_v0_12_20_features": [{"docstring": "Test command building with v0.12.20 features.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_cli_args.py", "line_number": 62, "module": "tests.test_rna_amalgkit_cli_args", "name": "test_build_amalgkit_command_with_v0_12_20_features", "signature": "()", "symbol_type": "function"}], "test_build_call_graph_simple_module": [{"docstring": "Test building call graph for a simple module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_discovery.py", "line_number": 98, "module": "tests.test_core_discovery", "name": "test_build_call_graph_simple_module", "signature": "(self)", "symbol_type": "function"}], "test_build_cli_args_basic": [{"docstring": "Test basic CLI argument building with various parameter types.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_cli_args.py", "line_number": 11, "module": "tests.test_rna_amalgkit_cli_args", "name": "test_build_cli_args_basic", "signature": "()", "symbol_type": "function"}, {"docstring": "Test basic CLI argument building.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 33, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_build_cli_args_basic", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test CLI argument building.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 397, "module": "tests.test_rna_amalgkit_end_to_end", "name": "test_build_cli_args_basic", "signature": "(self)", "symbol_type": "function"}], "test_build_cli_args_exists": [{"docstring": "Verify build_cli_args function exists.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 456, "module": "tests.test_rna_amalgkit_steps", "name": "test_build_cli_args_exists", "signature": "(self)", "symbol_type": "function"}], "test_build_cli_args_filters_none_values": [{"docstring": "Test that None values are filtered out.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 500, "module": "tests.test_rna_amalgkit_steps", "name": "test_build_cli_args_filters_none_values", "signature": "(self)", "symbol_type": "function"}], "test_build_cli_args_handles_boolean_flags": [{"docstring": "Test boolean flag handling.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 508, "module": "tests.test_rna_amalgkit_steps", "name": "test_build_cli_args_handles_boolean_flags", "signature": "(self)", "symbol_type": "function"}], "test_build_cli_args_handles_list_values": [{"docstring": "Test list values produce repeated flags.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 515, "module": "tests.test_rna_amalgkit_steps", "name": "test_build_cli_args_handles_list_values", "signature": "(self)", "symbol_type": "function"}], "test_build_cli_args_handles_path_values": [{"docstring": "Test Path values are converted to strings.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 524, "module": "tests.test_rna_amalgkit_steps", "name": "test_build_cli_args_handles_path_values", "signature": "(self)", "symbol_type": "function"}], "test_build_cli_args_lists": [{"docstring": "Test CLI argument building with lists.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 414, "module": "tests.test_rna_amalgkit_end_to_end", "name": "test_build_cli_args_lists", "signature": "(self)", "symbol_type": "function"}], "test_build_cli_args_mark_missing_rank": [{"docstring": "Test mark_missing_rank parameter (v0.12.20 feature).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_cli_args.py", "line_number": 52, "module": "tests.test_rna_amalgkit_cli_args", "name": "test_build_cli_args_mark_missing_rank", "signature": "()", "symbol_type": "function"}], "test_build_cli_args_resolve_names_boolean": [{"docstring": "Test resolve_names parameter as boolean (v0.12.20 feature).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_cli_args.py", "line_number": 42, "module": "tests.test_rna_amalgkit_cli_args", "name": "test_build_cli_args_resolve_names_boolean", "signature": "()", "symbol_type": "function"}], "test_build_cli_args_resolve_names_string": [{"docstring": "Test resolve_names parameter as string (v0.12.20 feature).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_cli_args.py", "line_number": 32, "module": "tests.test_rna_amalgkit_cli_args", "name": "test_build_cli_args_resolve_names_string", "signature": "()", "symbol_type": "function"}], "test_build_cli_args_transforms_types": [{"docstring": "Test that build_cli_args correctly transforms various parameter types.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit.py", "line_number": 15, "module": "tests.test_rna_amalgkit", "name": "test_build_cli_args_transforms_types", "signature": "()", "symbol_type": "function"}], "test_build_cli_args_with_empty_params": [{"docstring": "Test build_cli_args handles empty params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 494, "module": "tests.test_rna_amalgkit_steps", "name": "test_build_cli_args_with_empty_params", "signature": "(self)", "symbol_type": "function"}], "test_build_cli_args_with_lists": [{"docstring": "Test CLI argument building with list parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 43, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_build_cli_args_with_lists", "signature": "(self)", "symbol_type": "function"}], "test_build_cli_args_with_none_params": [{"docstring": "Test build_cli_args handles None params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 488, "module": "tests.test_rna_amalgkit_steps", "name": "test_build_cli_args_with_none_params", "signature": "(self)", "symbol_type": "function"}], "test_build_cli_args_with_paths": [{"docstring": "Test CLI argument building with Path objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 55, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_build_cli_args_with_paths", "signature": "(self)", "symbol_type": "function"}], "test_build_postgres_url": [{"docstring": "Test PostgreSQL URL construction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_db.py", "line_number": 18, "module": "tests.test_core_db", "name": "test_build_postgres_url", "signature": "(self)", "symbol_type": "function"}], "test_build_postgres_url_different_port": [{"docstring": "Test URL construction with non-standard port.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_db.py", "line_number": 23, "module": "tests.test_core_db", "name": "test_build_postgres_url_different_port", "signature": "(self)", "symbol_type": "function"}], "test_build_step_params_includes_species_tissues_and_layout": [{"docstring": "Test that build_step_params includes species, tissues, and layout information in step parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_configs.py", "line_number": 16, "module": "tests.test_rna_configs", "name": "test_build_step_params_includes_species_tissues_and_layout", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_cache_enabled_disabled": [{"docstring": "Test enabling/disabling cache.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 332, "module": "tests.test_ontology_query", "name": "test_cache_enabled_disabled", "signature": "(self)", "symbol_type": "function"}], "test_cache_with_ttl": [{"docstring": "Test cache with time-to-live functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 54, "module": "tests.test_core_comprehensive", "name": "test_cache_with_ttl", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_calculate_complexity_metrics_basic": [{"docstring": "Test basic complexity metrics calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 150, "module": "tests.test_quality_metrics", "name": "test_calculate_complexity_metrics_basic", "signature": "(self)", "symbol_type": "function"}], "test_calculate_complexity_metrics_empty": [{"docstring": "Test handling of empty sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 163, "module": "tests.test_quality_metrics", "name": "test_calculate_complexity_metrics_empty", "signature": "(self)", "symbol_type": "function"}], "test_calculate_complexity_metrics_identical": [{"docstring": "Test with identical sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 169, "module": "tests.test_quality_metrics", "name": "test_calculate_complexity_metrics_identical", "signature": "(self)", "symbol_type": "function"}], "test_calculate_confidence_intervals": [{"docstring": "Test confidence interval calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_stats.py", "line_number": 93, "module": "tests.test_math_popgen_stats", "name": "test_calculate_confidence_intervals", "signature": "()", "symbol_type": "function"}], "test_calculate_coverage_metrics_basic": [{"docstring": "Test basic coverage metrics calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 181, "module": "tests.test_quality_metrics", "name": "test_calculate_coverage_metrics_basic", "signature": "(self)", "symbol_type": "function"}], "test_calculate_coverage_metrics_empty": [{"docstring": "Test handling of empty coverage data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 195, "module": "tests.test_quality_metrics", "name": "test_calculate_coverage_metrics_empty", "signature": "(self)", "symbol_type": "function"}], "test_calculate_duplication_metrics_all_unique": [{"docstring": "Test with all unique reads.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 137, "module": "tests.test_quality_metrics", "name": "test_calculate_duplication_metrics_all_unique", "signature": "(self)", "symbol_type": "function"}], "test_calculate_duplication_metrics_basic": [{"docstring": "Test basic duplication metrics calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 116, "module": "tests.test_quality_metrics", "name": "test_calculate_duplication_metrics_basic", "signature": "(self)", "symbol_type": "function"}], "test_calculate_duplication_metrics_empty": [{"docstring": "Test handling of empty duplication data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 131, "module": "tests.test_quality_metrics", "name": "test_calculate_duplication_metrics_empty", "signature": "(self)", "symbol_type": "function"}], "test_calculate_gc_metrics_basic": [{"docstring": "Test basic GC metrics calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 53, "module": "tests.test_quality_metrics", "name": "test_calculate_gc_metrics_basic", "signature": "(self)", "symbol_type": "function"}], "test_calculate_gc_metrics_empty": [{"docstring": "Test handling of empty GC content.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 65, "module": "tests.test_quality_metrics", "name": "test_calculate_gc_metrics_empty", "signature": "(self)", "symbol_type": "function"}], "test_calculate_gc_metrics_single_value": [{"docstring": "Test with single GC value.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 71, "module": "tests.test_quality_metrics", "name": "test_calculate_gc_metrics_single_value", "signature": "(self)", "symbol_type": "function"}], "test_calculate_length_metrics_basic": [{"docstring": "Test basic length metrics calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 84, "module": "tests.test_quality_metrics", "name": "test_calculate_length_metrics_basic", "signature": "(self)", "symbol_type": "function"}], "test_calculate_length_metrics_empty": [{"docstring": "Test handling of empty lengths.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 98, "module": "tests.test_quality_metrics", "name": "test_calculate_length_metrics_empty", "signature": "(self)", "symbol_type": "function"}], "test_calculate_length_metrics_with_short_reads": [{"docstring": "Test with short reads.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 104, "module": "tests.test_quality_metrics", "name": "test_calculate_length_metrics_with_short_reads", "signature": "(self)", "symbol_type": "function"}], "test_calculate_qc_metrics": [{"docstring": "Test QC metrics calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 191, "module": "tests.test_singlecell_preprocessing", "name": "test_calculate_qc_metrics", "signature": "(self)", "symbol_type": "function"}], "test_calculate_quality_metrics_basic": [{"docstring": "Test basic quality metrics calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 20, "module": "tests.test_quality_metrics", "name": "test_calculate_quality_metrics_basic", "signature": "(self)", "symbol_type": "function"}], "test_calculate_quality_metrics_empty": [{"docstring": "Test handling of empty input.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 33, "module": "tests.test_quality_metrics", "name": "test_calculate_quality_metrics_empty", "signature": "(self)", "symbol_type": "function"}], "test_calculate_quality_metrics_single_score": [{"docstring": "Test with single quality score.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 39, "module": "tests.test_quality_metrics", "name": "test_calculate_quality_metrics_single_score", "signature": "(self)", "symbol_type": "function"}], "test_cancer_multiomics_analysis_pipeline": [{"docstring": "Test cancer research pipeline: Multi-omics -> Networks -> Biomarkers.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_integration_comprehensive.py", "line_number": 624, "module": "tests.test_integration_comprehensive", "name": "test_cancer_multiomics_analysis_pipeline", "signature": "(self)", "symbol_type": "function"}], "test_canonical_correlation_actual_correlation": [{"docstring": "Test that canonical variables achieve expected correlations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 434, "module": "tests.test_multiomics_integration", "name": "test_canonical_correlation_actual_correlation", "signature": "(self)", "symbol_type": "function"}], "test_canonical_correlation_basic": [{"docstring": "Test basic canonical correlation analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 228, "module": "tests.test_multiomics_comprehensive", "name": "test_canonical_correlation_basic", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test basic CCA functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 414, "module": "tests.test_multiomics_integration", "name": "test_canonical_correlation_basic", "signature": "(self)", "symbol_type": "function"}], "test_canonical_correlation_high_correlation": [{"docstring": "Test CCA with highly correlated layers.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 255, "module": "tests.test_multiomics_comprehensive", "name": "test_canonical_correlation_high_correlation", "signature": "(self)", "symbol_type": "function"}], "test_canonical_correlation_invalid_layer": [{"docstring": "Test error handling for invalid layer names.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 247, "module": "tests.test_multiomics_comprehensive", "name": "test_canonical_correlation_invalid_layer", "signature": "(self)", "symbol_type": "function"}], "test_canonical_correlation_invalid_layers": [{"docstring": "Test error handling for invalid layer names.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 448, "module": "tests.test_multiomics_integration", "name": "test_canonical_correlation_invalid_layers", "signature": "(self)", "symbol_type": "function"}], "test_canonical_correlation_regularization": [{"docstring": "Test CCA with different regularization values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 453, "module": "tests.test_multiomics_integration", "name": "test_canonical_correlation_regularization", "signature": "(self)", "symbol_type": "function"}], "test_centrality_empty_network": [{"docstring": "Test centrality measures on empty network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 255, "module": "tests.test_networks_graph", "name": "test_centrality_empty_network", "signature": "(self)", "symbol_type": "function"}], "test_centrality_measures": [{"docstring": "Test centrality calculations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 99, "module": "tests.test_networks_comprehensive", "name": "test_centrality_measures", "signature": "(self)", "symbol_type": "function"}], "test_cfloridanus_config_exists": [{"docstring": "Verify C. floridanus config exists for testing (or skip if not present).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 87, "module": "tests.test_rna_ena_workflow", "name": "test_cfloridanus_config_exists", "signature": "(self)", "symbol_type": "function"}], "test_cfloridanus_metadata_exists": [{"docstring": "Verify C. floridanus metadata exists.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 96, "module": "tests.test_rna_ena_workflow", "name": "test_cfloridanus_metadata_exists", "signature": "(self)", "symbol_type": "function"}], "test_chao1_estimator_all_singletons": [{"docstring": "Test Chao1 with all singletons.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 99, "module": "tests.test_ecology_basic", "name": "test_chao1_estimator_all_singletons", "signature": "(self)", "symbol_type": "function"}], "test_chao1_estimator_basic": [{"docstring": "Test Chao1 species richness estimator.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 90, "module": "tests.test_ecology_basic", "name": "test_chao1_estimator_basic", "signature": "(self)", "symbol_type": "function"}], "test_chao1_estimator_empty": [{"docstring": "Test Chao1 with empty abundances.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 105, "module": "tests.test_ecology_basic", "name": "test_chao1_estimator_empty", "signature": "(self)", "symbol_type": "function"}], "test_check_bcftools_available": [{"docstring": "Test checking if bcftools is available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_calling.py", "line_number": 16, "module": "tests.test_gwas_calling", "name": "test_check_bcftools_available", "signature": "() -> None", "symbol_type": "function"}], "test_check_cli_available": [{"docstring": "Test CLI availability checking.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 21, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_check_cli_available", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test CLI availability check.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 444, "module": "tests.test_rna_amalgkit_end_to_end", "name": "test_check_cli_available", "signature": "(self)", "symbol_type": "function"}], "test_check_cli_available_exists": [{"docstring": "Verify check_cli_available function exists.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 466, "module": "tests.test_rna_amalgkit_steps", "name": "test_check_cli_available_exists", "signature": "(self)", "symbol_type": "function"}], "test_check_cli_available_returns_tuple": [{"docstring": "Test check_cli_available returns (bool, str) tuple.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 481, "module": "tests.test_rna_amalgkit_steps", "name": "test_check_cli_available_returns_tuple", "signature": "(self)", "symbol_type": "function"}], "test_check_cli_available_runs_help": [{"docstring": "Test that check_cli_available returns True and help text when amalgkit is available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit.py", "line_number": 64, "module": "tests.test_rna_amalgkit", "name": "test_check_cli_available_runs_help", "signature": "(ensure_amalgkit_available)", "symbol_type": "function"}], "test_check_disk_space_high_threshold": [{"docstring": "Test with high threshold (may fail on small drives).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 62, "module": "tests.test_core_disk", "name": "test_check_disk_space_high_threshold", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_check_disk_space_sufficient": [{"docstring": "Test checking disk space when sufficient.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 49, "module": "tests.test_core_disk", "name": "test_check_disk_space_sufficient", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_check_disk_space_very_low_threshold": [{"docstring": "Test with very low threshold (should pass).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 56, "module": "tests.test_core_disk", "name": "test_check_disk_space_very_low_threshold", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_check_gatk_available": [{"docstring": "Test checking if GATK is available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_calling.py", "line_number": 22, "module": "tests.test_gwas_calling", "name": "test_check_gatk_available", "signature": "() -> None", "symbol_type": "function"}], "test_check_returns_boolean": [{"docstring": "Test that function returns boolean value.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_sra_download.py", "line_number": 34, "module": "tests.test_gwas_sra_download", "name": "test_check_returns_boolean", "signature": "(self)", "symbol_type": "function"}], "test_check_sra_tools_available_real": [{"docstring": "Test real check for SRA tools availability.\n\nUses real subprocess calls following NO_MOCKING_POLICY.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_sra_download.py", "line_number": 25, "module": "tests.test_gwas_sra_download", "name": "test_check_sra_tools_available_real", "signature": "(self)", "symbol_type": "function"}], "test_chi2_feature_selection": [{"docstring": "Test Chi-squared based feature selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 69, "module": "tests.test_ml_features", "name": "test_chi2_feature_selection", "signature": "(self)", "symbol_type": "function"}], "test_circular_manhattan_plot": [{"docstring": "Test circular Manhattan plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 74, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_circular_manhattan_plot", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_classifier_different_algorithms": [{"docstring": "Test different classification algorithms.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 124, "module": "tests.test_ml_comprehensive", "name": "test_classifier_different_algorithms", "signature": "(self)", "symbol_type": "function"}], "test_classifier_evaluation": [{"docstring": "Test classifier evaluation functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 147, "module": "tests.test_ml_comprehensive", "name": "test_classifier_evaluation", "signature": "(self)", "symbol_type": "function"}], "test_classifier_feature_importance": [{"docstring": "Test feature importance extraction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 106, "module": "tests.test_ml_comprehensive", "name": "test_classifier_feature_importance", "signature": "(self)", "symbol_type": "function"}], "test_classifier_fit_predict": [{"docstring": "Test classifier fitting and prediction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 75, "module": "tests.test_ml_comprehensive", "name": "test_classifier_fit_predict", "signature": "(self)", "symbol_type": "function"}], "test_classifier_initialization": [{"docstring": "Test BiologicalClassifier initialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 60, "module": "tests.test_ml_comprehensive", "name": "test_classifier_initialization", "signature": "(self)", "symbol_type": "function"}], "test_clear_cache": [{"docstring": "Test clearing cache.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 338, "module": "tests.test_ontology_query", "name": "test_clear_cache", "signature": "(self)", "symbol_type": "function"}], "test_cli_availability": [{"docstring": "Test that amalgkit CLI is available.\n\nUses ensure_amalgkit_available fixture to ensure amalgkit is available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 84, "module": "tests.test_rna_amalgkit_end_to_end", "name": "test_cli_availability", "signature": "(self, ensure_amalgkit_available)", "symbol_type": "function"}], "test_cli_end_to_end_workflow": [{"docstring": "Test embed -> predict -> interpret CLI workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_integration.py", "line_number": 247, "module": "tests.test_life_events_integration", "name": "test_cli_end_to_end_workflow", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_cli_example_from_docs": [{"docstring": "Test CLI example functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 445, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_cli_example_from_docs", "signature": "(self)", "symbol_type": "function"}], "test_cli_interpret_basic": [{"docstring": "Test interpret command with valid inputs.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 289, "module": "tests.test_life_events_cli", "name": "test_cli_interpret_basic", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_cli_interpret_missing_model": [{"docstring": "Test interpret command with missing model file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 324, "module": "tests.test_life_events_cli", "name": "test_cli_interpret_missing_model", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_cli_interpret_missing_sequences": [{"docstring": "Test interpret command with missing sequences file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 348, "module": "tests.test_life_events_cli", "name": "test_cli_interpret_missing_sequences", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_cli_interpret_no_embeddings_error": [{"docstring": "Test interpret command with model without embeddings.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 372, "module": "tests.test_life_events_cli", "name": "test_cli_interpret_no_embeddings_error", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_cli_interpret_output_format": [{"docstring": "Test that interpretation report has correct format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 414, "module": "tests.test_life_events_cli", "name": "test_cli_interpret_output_format", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_cli_interpret_visualization": [{"docstring": "Test that visualization is created when matplotlib available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 454, "module": "tests.test_life_events_cli", "name": "test_cli_interpret_visualization", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_cli_predict_basic": [{"docstring": "Test predict command with valid model and sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 70, "module": "tests.test_life_events_cli", "name": "test_cli_predict_basic", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_cli_predict_classification_probs": [{"docstring": "Test that probabilities are included for classification tasks.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 214, "module": "tests.test_life_events_cli", "name": "test_cli_predict_classification_probs", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_cli_predict_invalid_model": [{"docstring": "Test predict command with corrupted model file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 153, "module": "tests.test_life_events_cli", "name": "test_cli_predict_invalid_model", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_cli_predict_missing_events": [{"docstring": "Test predict command with missing events file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 129, "module": "tests.test_life_events_cli", "name": "test_cli_predict_missing_events", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_cli_predict_missing_model": [{"docstring": "Test predict command with missing model file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 105, "module": "tests.test_life_events_cli", "name": "test_cli_predict_missing_model", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_cli_predict_output_format": [{"docstring": "Test that predictions output has correct format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 178, "module": "tests.test_life_events_cli", "name": "test_cli_predict_output_format", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_cli_predict_regression_stats": [{"docstring": "Test that statistics are printed for regression tasks.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_cli.py", "line_number": 246, "module": "tests.test_life_events_cli", "name": "test_cli_predict_regression_stats", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_cli_run_config_offline_behavior": [{"docstring": "Test CLI behavior when amalgkit is not available (documents real failure modes).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_run_config_cli.py", "line_number": 72, "module": "tests.test_rna_run_config_cli", "name": "test_cli_run_config_offline_behavior", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_cli_run_config_smoke_real_amalgkit": [{"docstring": "Test real CLI execution with actual amalgkit external tool.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_run_config_cli.py", "line_number": 16, "module": "tests.test_rna_run_config_cli", "name": "test_cli_run_config_smoke_real_amalgkit", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_cli_unavailable_handling": [{"docstring": "Test handling when amalgkit is not available.\n\nUses real check_cli_available() implementation following NO_MOCKING_POLICY.\nIf amalgkit is available, this test verifies the available case instead.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 260, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_cli_unavailable_handling", "signature": "(self)", "symbol_type": "function"}], "test_closeness_centrality": [{"docstring": "Test closeness centrality calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 243, "module": "tests.test_networks_graph", "name": "test_closeness_centrality", "signature": "(self)", "symbol_type": "function"}], "test_coalescent_time_calculation": [{"docstring": "Test coalescent time to most recent common ancestor.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_enhanced.py", "line_number": 117, "module": "tests.test_math_enhanced", "name": "test_coalescent_time_calculation", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test coalescent time to most recent common ancestor.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_enhanced.py", "line_number": 73, "module": "tests.test_math_popgen_enhanced", "name": "test_coalescent_time_calculation", "signature": "(self)", "symbol_type": "function"}], "test_codon_usage_calculation": [{"docstring": "Test codon usage calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 234, "module": "tests.test_dna_sequences_enhanced", "name": "test_codon_usage_calculation", "signature": "(self)", "symbol_type": "function"}], "test_codon_usage_counts_and_freqs": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_codon_usage.py", "line_number": 4, "module": "tests.test_dna_codon_usage", "name": "test_codon_usage_counts_and_freqs", "signature": "() -> None", "symbol_type": "function"}], "test_common_ancestors_simple": [{"docstring": "Test finding common ancestors.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 164, "module": "tests.test_ontology_query", "name": "test_common_ancestors_simple", "signature": "(self)", "symbol_type": "function"}], "test_community_metrics": [{"docstring": "Test community metrics calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 165, "module": "tests.test_networks_comprehensive", "name": "test_community_metrics", "signature": "(self)", "symbol_type": "function"}], "test_community_metrics_all_zeros": [{"docstring": "Test community metrics with all zero abundances.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 138, "module": "tests.test_ecology_basic", "name": "test_community_metrics_all_zeros", "signature": "(self)", "symbol_type": "function"}], "test_community_metrics_basic": [{"docstring": "Test comprehensive community metrics.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 110, "module": "tests.test_ecology_basic", "name": "test_community_metrics_basic", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test basic community metrics calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 217, "module": "tests.test_networks_community", "name": "test_community_metrics_basic", "signature": "(self)", "symbol_type": "function"}], "test_community_metrics_empty": [{"docstring": "Test community metrics with empty data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 129, "module": "tests.test_ecology_basic", "name": "test_community_metrics_empty", "signature": "(self)", "symbol_type": "function"}], "test_community_metrics_empty_network": [{"docstring": "Test metrics on empty network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 235, "module": "tests.test_networks_community", "name": "test_community_metrics_empty_network", "signature": "(self)", "symbol_type": "function"}], "test_community_metrics_single_node": [{"docstring": "Test metrics on single node network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 247, "module": "tests.test_networks_community", "name": "test_community_metrics_single_node", "signature": "(self)", "symbol_type": "function"}], "test_community_stability": [{"docstring": "Test community stability assessment.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 399, "module": "tests.test_networks_community", "name": "test_community_stability", "signature": "(self)", "symbol_type": "function"}], "test_compare_communities": [{"docstring": "Test community comparison.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 414, "module": "tests.test_networks_community", "name": "test_compare_communities", "signature": "(self)", "symbol_type": "function"}], "test_compare_datasets": [{"docstring": "Test dataset comparison.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 450, "module": "tests.test_information_comprehensive", "name": "test_compare_datasets", "signature": "(self)", "symbol_type": "function"}], "test_compare_populations": [{"docstring": "Test population comparison workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_workflow.py", "line_number": 78, "module": "tests.test_life_events_workflow", "name": "test_compare_populations", "signature": "(tmp_path)", "symbol_type": "function"}], "test_compare_sequences_different": [{"docstring": "Test comparison of different sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 208, "module": "tests.test_information_comprehensive", "name": "test_compare_sequences_different", "signature": "(self)", "symbol_type": "function"}], "test_compare_sequences_information": [{"docstring": "Test sequence comparison.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 198, "module": "tests.test_information_comprehensive", "name": "test_compare_sequences_information", "signature": "(self)", "symbol_type": "function"}], "test_compare_statistics": [{"docstring": "Test statistical comparison.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_stats.py", "line_number": 67, "module": "tests.test_math_popgen_stats", "name": "test_compare_statistics", "signature": "()", "symbol_type": "function"}], "test_comparison_plot": [{"docstring": "Test comparison between studies.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 179, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_comparison_plot", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_complementarity_score": [{"docstring": "Test complementarity score calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 39, "module": "tests.test_dna_sequences_enhanced", "name": "test_complementarity_score", "signature": "(self)", "symbol_type": "function"}], "test_complete_classification_pipeline": [{"docstring": "Test complete classification analysis pipeline.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 569, "module": "tests.test_ml_comprehensive", "name": "test_complete_classification_pipeline", "signature": "(self)", "symbol_type": "function"}], "test_complete_grn_analysis_workflow": [{"docstring": "Test complete GRN analysis workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 506, "module": "tests.test_networks_regulatory", "name": "test_complete_grn_analysis_workflow", "signature": "(self)", "symbol_type": "function"}], "test_complete_mini_workflow": [{"docstring": "Test a minimal complete workflow with very limited data.\n\nUses ensure_amalgkit_available fixture to ensure amalgkit is available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 134, "module": "tests.test_rna_amalgkit_end_to_end", "name": "test_complete_mini_workflow", "signature": "(self, ensure_amalgkit_available)", "symbol_type": "function"}], "test_complete_pathway_analysis_workflow": [{"docstring": "Test complete pathway analysis workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 366, "module": "tests.test_networks_pathway", "name": "test_complete_pathway_analysis_workflow", "signature": "(self)", "symbol_type": "function"}], "test_complete_ppi_analysis_workflow": [{"docstring": "Test complete PPI analysis workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 472, "module": "tests.test_networks_ppi", "name": "test_complete_ppi_analysis_workflow", "signature": "(self)", "symbol_type": "function"}], "test_complete_regression_pipeline": [{"docstring": "Test complete regression analysis pipeline.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 611, "module": "tests.test_ml_comprehensive", "name": "test_complete_regression_pipeline", "signature": "(self)", "symbol_type": "function"}], "test_complete_workflow_simulation": [{"docstring": "Test complete workflow with simulated steps.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 283, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_complete_workflow_simulation", "signature": "(self)", "symbol_type": "function"}], "test_complex_antwiki_structure": [{"docstring": "Test loading complex AntWiki data structure.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_comprehensive.py", "line_number": 65, "module": "tests.test_phenotype_comprehensive", "name": "test_complex_antwiki_structure", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_composition_edge_cases": [{"docstring": "Test edge cases for composition functions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 109, "module": "tests.test_dna_comprehensive", "name": "test_composition_edge_cases", "signature": "(self)", "symbol_type": "function"}], "test_compute_diffusion_map_basic": [{"docstring": "Test basic diffusion map computation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 444, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_diffusion_map_basic", "signature": "(self)", "symbol_type": "function"}], "test_compute_diffusion_map_without_neighbors": [{"docstring": "Test diffusion map when neighbors need to be computed.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 462, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_diffusion_map_without_neighbors", "signature": "(self)", "symbol_type": "function"}], "test_compute_kinship_matrix_astle": [{"docstring": "Test kinship computation using Astle-Balding method.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_structure.py", "line_number": 76, "module": "tests.test_gwas_structure", "name": "test_compute_kinship_matrix_astle", "signature": "() -> None", "symbol_type": "function"}], "test_compute_kinship_matrix_invalid_method": [{"docstring": "Test kinship computation with invalid method.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_structure.py", "line_number": 102, "module": "tests.test_gwas_structure", "name": "test_compute_kinship_matrix_invalid_method", "signature": "() -> None", "symbol_type": "function"}], "test_compute_kinship_matrix_vanraden": [{"docstring": "Test kinship matrix computation using VanRaden method.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_structure.py", "line_number": 55, "module": "tests.test_gwas_structure", "name": "test_compute_kinship_matrix_vanraden", "signature": "() -> None", "symbol_type": "function"}], "test_compute_kinship_matrix_yang": [{"docstring": "Test kinship computation using Yang method.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_structure.py", "line_number": 89, "module": "tests.test_gwas_structure", "name": "test_compute_kinship_matrix_yang", "signature": "() -> None", "symbol_type": "function"}], "test_compute_methylation_beta_and_summary": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_epigenome.py", "line_number": 20, "module": "tests.test_epigenome", "name": "test_compute_methylation_beta_and_summary", "signature": "()", "symbol_type": "function"}], "test_compute_neighbors_basic": [{"docstring": "Test basic neighbor graph computation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 233, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_neighbors_basic", "signature": "(self)", "symbol_type": "function"}], "test_compute_neighbors_different_metrics": [{"docstring": "Test neighbor computation with different distance metrics.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 264, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_neighbors_different_metrics", "signature": "(self)", "symbol_type": "function"}], "test_compute_neighbors_without_pca": [{"docstring": "Test neighbor computation without PCA coordinates.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 275, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_neighbors_without_pca", "signature": "(self)", "symbol_type": "function"}], "test_compute_pca_basic": [{"docstring": "Test PCA computation on genotype matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_structure.py", "line_number": 13, "module": "tests.test_gwas_structure", "name": "test_compute_pca_basic", "signature": "() -> None", "symbol_type": "function"}, {"docstring": "Test basic PCA computation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 155, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_pca_basic", "signature": "(self)", "symbol_type": "function"}], "test_compute_pca_empty_matrix": [{"docstring": "Test PCA with empty genotype matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_structure.py", "line_number": 35, "module": "tests.test_gwas_structure", "name": "test_compute_pca_empty_matrix", "signature": "() -> None", "symbol_type": "function"}], "test_compute_pca_too_many_components": [{"docstring": "Test PCA with more components than possible.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 196, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_pca_too_many_components", "signature": "(self)", "symbol_type": "function"}], "test_compute_pca_with_hvgs": [{"docstring": "Test PCA computation using HVGs.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 180, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_pca_with_hvgs", "signature": "(self)", "symbol_type": "function"}], "test_compute_pca_with_missing_data": [{"docstring": "Test PCA with missing genotypes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_structure.py", "line_number": 42, "module": "tests.test_gwas_structure", "name": "test_compute_pca_with_missing_data", "signature": "() -> None", "symbol_type": "function"}], "test_compute_pca_without_hvgs": [{"docstring": "Test PCA computation using all genes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 188, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_pca_without_hvgs", "signature": "(self)", "symbol_type": "function"}], "test_compute_tsne_basic": [{"docstring": "Test basic t-SNE computation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 384, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_tsne_basic", "signature": "(self)", "symbol_type": "function"}], "test_compute_tsne_different_perplexity": [{"docstring": "Test t-SNE with different perplexity values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 398, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_tsne_different_perplexity", "signature": "(self)", "symbol_type": "function"}], "test_compute_tsne_perplexity_adjustment": [{"docstring": "Test that perplexity is adjusted for small datasets.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 405, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_tsne_perplexity_adjustment", "signature": "(self)", "symbol_type": "function"}], "test_compute_umap_basic": [{"docstring": "Test basic UMAP computation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 314, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_umap_basic", "signature": "(self)", "symbol_type": "function"}], "test_compute_umap_different_dimensions": [{"docstring": "Test UMAP with different output dimensions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 332, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_umap_different_dimensions", "signature": "(self)", "symbol_type": "function"}], "test_compute_umap_without_neighbors": [{"docstring": "Test UMAP computation when neighbors aren't precomputed.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 346, "module": "tests.test_singlecell_dimensionality", "name": "test_compute_umap_without_neighbors", "signature": "(self)", "symbol_type": "function"}], "test_concurrent_workflow_execution": [{"docstring": "Test that multiple workflows can be planned concurrently.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 361, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_concurrent_workflow_execution", "signature": "(self)", "symbol_type": "function"}], "test_conditional_entropy": [{"docstring": "Test conditional entropy calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 73, "module": "tests.test_information_comprehensive", "name": "test_conditional_entropy", "signature": "(self)", "symbol_type": "function"}], "test_conditional_entropy_properties": [{"docstring": "Test properties of conditional entropy.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 270, "module": "tests.test_information_comprehensive", "name": "test_conditional_entropy_properties", "signature": "(self)", "symbol_type": "function"}], "test_conditional_mutual_information_length_mismatch": [{"docstring": "Test conditional MI with mismatched lengths.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 238, "module": "tests.test_information_comprehensive", "name": "test_conditional_mutual_information_length_mismatch", "signature": "(self)", "symbol_type": "function"}], "test_config_basic_execution": [{"docstring": "Test config step can execute with minimal params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 179, "module": "tests.test_rna_amalgkit_steps", "name": "test_config_basic_execution", "signature": "(self, tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_config_creation": [{"docstring": "Test creating pipeline configuration.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_pipeline.py", "line_number": 18, "module": "tests.test_rna_pipeline", "name": "test_config_creation", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_config_env_override_edge_cases": [{"docstring": "Test invalid environment variable values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 404, "module": "tests.test_life_events_embeddings", "name": "test_config_env_override_edge_cases", "signature": "(tmp_path)", "symbol_type": "function"}], "test_config_function_exists": [{"docstring": "Verify config runner function is exported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 165, "module": "tests.test_rna_amalgkit_steps", "name": "test_config_function_exists", "signature": "(self)", "symbol_type": "function"}], "test_config_in_amalgkit_module": [{"docstring": "Verify config function exists in amalgkit module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 174, "module": "tests.test_rna_amalgkit_steps", "name": "test_config_in_amalgkit_module", "signature": "(self)", "symbol_type": "function"}], "test_config_in_step_runners": [{"docstring": "Verify config is in STEP_RUNNERS.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 169, "module": "tests.test_rna_amalgkit_steps", "name": "test_config_in_step_runners", "signature": "(self)", "symbol_type": "function"}], "test_config_loading": [{"docstring": "Test loading configuration from files.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 78, "module": "tests.test_core_comprehensive", "name": "test_config_loading", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_config_processing_error_handling": [{"docstring": "Test error handling in config processing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_processing.py", "line_number": 163, "module": "tests.test_core_processing", "name": "test_config_processing_error_handling", "signature": "(self)", "symbol_type": "function"}], "test_config_runner": [{"docstring": "Test config step runner.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 217, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_config_runner", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test config step runner.\n\nUses ensure_amalgkit_available fixture to ensure amalgkit is available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 336, "module": "tests.test_rna_amalgkit_end_to_end", "name": "test_config_runner", "signature": "(self, ensure_amalgkit_available)", "symbol_type": "function"}], "test_config_step_execution": [{"docstring": "Test config step execution.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 92, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_config_step_execution", "signature": "(self)", "symbol_type": "function"}], "test_config_validation": [{"docstring": "Test configuration validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 243, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_config_validation", "signature": "(self)", "symbol_type": "function"}], "test_config_work_dir_path": [{"docstring": "Test that work_dir can be any Path.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_pipeline.py", "line_number": 24, "module": "tests.test_rna_pipeline", "name": "test_config_work_dir_path", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_config_workflow_integration": [{"docstring": "Test using config file in complete workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_integration.py", "line_number": 194, "module": "tests.test_life_events_integration", "name": "test_config_workflow_integration", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_configure_logging_from_env": [{"docstring": "Test configure_logging_from_env function.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_logging.py", "line_number": 36, "module": "tests.test_core_logging", "name": "test_configure_logging_from_env", "signature": "(monkeypatch) -> None", "symbol_type": "function"}], "test_connection_string_building": [{"docstring": "Test database connection string construction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 124, "module": "tests.test_core_comprehensive", "name": "test_connection_string_building", "signature": "(self)", "symbol_type": "function"}], "test_consensus_majority_ignores_gaps": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_consensus.py", "line_number": 6, "module": "tests.test_dna_consensus", "name": "test_consensus_majority_ignores_gaps", "signature": "() -> None", "symbol_type": "function"}], "test_conserved_regions_finding": [{"docstring": "Test finding conserved regions in alignments.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_alignment_enhanced.py", "line_number": 27, "module": "tests.test_dna_alignment_enhanced", "name": "test_conserved_regions_finding", "signature": "(self)", "symbol_type": "function"}], "test_constant_features": [{"docstring": "Test handling of constant (zero-variance) features.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 577, "module": "tests.test_ml_features", "name": "test_constant_features", "signature": "(self)", "symbol_type": "function"}], "test_contact_pairs_threshold": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_contacts.py", "line_number": 4, "module": "tests.test_protein_contacts", "name": "test_contact_pairs_threshold", "signature": "()", "symbol_type": "function"}], "test_content_hash_and_file_hash": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_hash.py", "line_number": 8, "module": "tests.test_core_hash", "name": "test_content_hash_and_file_hash", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_convert_sequences_to_tokens": [{"docstring": "Test converting sequences to token format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_utils.py", "line_number": 113, "module": "tests.test_life_events_utils", "name": "test_convert_sequences_to_tokens", "signature": "()", "symbol_type": "function"}], "test_core_utilities_integration": [{"docstring": "Test that core utilities work across all modules.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_integration_comprehensive.py", "line_number": 371, "module": "tests.test_integration_comprehensive", "name": "test_core_utilities_integration", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_correlation_coefficient": [{"docstring": "Test Pearson correlation coefficient calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_enhanced.py", "line_number": 11, "module": "tests.test_math_enhanced", "name": "test_correlation_coefficient", "signature": "(self)", "symbol_type": "function"}], "test_correlation_heatmap": [{"docstring": "Test correlation heatmap functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 252, "module": "tests.test_visualization_enhanced", "name": "test_correlation_heatmap", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test correlation heatmap functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 377, "module": "tests.test_visualization_enhanced", "name": "test_correlation_heatmap", "signature": "(self)", "symbol_type": "function"}], "test_correlation_large_arrays": [{"docstring": "Test correlation with large arrays.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 287, "module": "tests.test_math_utilities", "name": "test_correlation_large_arrays", "signature": "(self)", "symbol_type": "function"}], "test_covariance_and_correlation": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_price.py", "line_number": 45, "module": "tests.test_math_price", "name": "test_covariance_and_correlation", "signature": "()", "symbol_type": "function"}], "test_create_network": [{"docstring": "Test creating network from node list.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 112, "module": "tests.test_networks_graph", "name": "test_create_network", "signature": "(self)", "symbol_type": "function"}], "test_create_network_with_confidence_filter": [{"docstring": "Test creating network with confidence threshold.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 230, "module": "tests.test_networks_comprehensive", "name": "test_create_network_with_confidence_filter", "signature": "(self)", "symbol_type": "function"}], "test_create_sample_config": [{"docstring": "Test sample configuration file creation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_processing.py", "line_number": 61, "module": "tests.test_core_processing", "name": "test_create_sample_config", "signature": "(self)", "symbol_type": "function"}], "test_cross_entropy": [{"docstring": "Test cross-entropy calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 94, "module": "tests.test_information_comprehensive", "name": "test_cross_entropy", "signature": "(self)", "symbol_type": "function"}], "test_cross_validate": [{"docstring": "Test cross-validation evaluation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 467, "module": "tests.test_ml_comprehensive", "name": "test_cross_validate", "signature": "(self)", "symbol_type": "function"}], "test_cross_validate_biological": [{"docstring": "Test biological cross-validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 165, "module": "tests.test_ml_comprehensive", "name": "test_cross_validate_biological", "signature": "(self)", "symbol_type": "function"}], "test_csca_basic_execution": [{"docstring": "Test csca step can execute with minimal params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 410, "module": "tests.test_rna_amalgkit_steps", "name": "test_csca_basic_execution", "signature": "(self, tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_csca_function_exists": [{"docstring": "Verify csca runner function is exported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 396, "module": "tests.test_rna_amalgkit_steps", "name": "test_csca_function_exists", "signature": "(self)", "symbol_type": "function"}], "test_csca_in_amalgkit_module": [{"docstring": "Verify csca function exists in amalgkit module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 405, "module": "tests.test_rna_amalgkit_steps", "name": "test_csca_in_amalgkit_module", "signature": "(self)", "symbol_type": "function"}], "test_csca_in_step_runners": [{"docstring": "Verify csca is in STEP_RUNNERS.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 400, "module": "tests.test_rna_amalgkit_steps", "name": "test_csca_in_step_runners", "signature": "(self)", "symbol_type": "function"}], "test_cstmm_basic_execution": [{"docstring": "Test cstmm step can execute with minimal params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 350, "module": "tests.test_rna_amalgkit_steps", "name": "test_cstmm_basic_execution", "signature": "(self, tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_cstmm_function_exists": [{"docstring": "Verify cstmm runner function is exported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 336, "module": "tests.test_rna_amalgkit_steps", "name": "test_cstmm_function_exists", "signature": "(self)", "symbol_type": "function"}], "test_cstmm_in_amalgkit_module": [{"docstring": "Verify cstmm function exists in amalgkit module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 345, "module": "tests.test_rna_amalgkit_steps", "name": "test_cstmm_in_amalgkit_module", "signature": "(self)", "symbol_type": "function"}], "test_cstmm_in_step_runners": [{"docstring": "Verify cstmm is in STEP_RUNNERS.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 340, "module": "tests.test_rna_amalgkit_steps", "name": "test_cstmm_in_step_runners", "signature": "(self)", "symbol_type": "function"}], "test_csv_download": [{"docstring": "Test CSV download functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io_enhanced.py", "line_number": 84, "module": "tests.test_core_io_enhanced", "name": "test_csv_download", "signature": "(self)", "symbol_type": "function"}], "test_csv_operations": [{"docstring": "Test CSV reading and writing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 207, "module": "tests.test_core_comprehensive", "name": "test_csv_operations", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_cumulative_gc_skew": [{"docstring": "Test cumulative GC skew calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 74, "module": "tests.test_dna_comprehensive", "name": "test_cumulative_gc_skew", "signature": "(self)", "symbol_type": "function"}], "test_curate_basic_execution": [{"docstring": "Test curate step can execute with minimal params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 380, "module": "tests.test_rna_amalgkit_steps", "name": "test_curate_basic_execution", "signature": "(self, tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_curate_function_exists": [{"docstring": "Verify curate runner function is exported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 366, "module": "tests.test_rna_amalgkit_steps", "name": "test_curate_function_exists", "signature": "(self)", "symbol_type": "function"}], "test_curate_in_amalgkit_module": [{"docstring": "Verify curate function exists in amalgkit module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 375, "module": "tests.test_rna_amalgkit_steps", "name": "test_curate_in_amalgkit_module", "signature": "(self)", "symbol_type": "function"}], "test_curate_in_step_runners": [{"docstring": "Verify curate is in STEP_RUNNERS.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 370, "module": "tests.test_rna_amalgkit_steps", "name": "test_curate_in_step_runners", "signature": "(self)", "symbol_type": "function"}], "test_curate_summary_counts_from_fixture": [{"docstring": "Test that summarize_curate_tables correctly counts TSV files from test fixtures.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit.py", "line_number": 73, "module": "tests.test_rna_amalgkit", "name": "test_curate_summary_counts_from_fixture", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_custom_adapters": [{"docstring": "Test custom adapter sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 221, "module": "tests.test_quality_fastq", "name": "test_custom_adapters", "signature": "(self)", "symbol_type": "function"}], "test_custom_mapping": [{"docstring": "Test custom trait mapping.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 210, "module": "tests.test_phenotype_life_course", "name": "test_custom_mapping", "signature": "(self)", "symbol_type": "function"}], "test_custom_phenotype_categories": [{"docstring": "Test custom phenotype categories.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 80, "module": "tests.test_phenotype_life_course", "name": "test_custom_phenotype_categories", "signature": "(self)", "symbol_type": "function"}], "test_data_dir": [{"docstring": "Provide path to test data directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 35, "module": "tests.conftest", "name": "test_data_dir", "signature": "() -> Path", "symbol_type": "function"}], "test_data_flow_consistency": [{"docstring": "Test that data structures are consistent across modules.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_integration_comprehensive.py", "line_number": 452, "module": "tests.test_integration_comprehensive", "name": "test_data_flow_consistency", "signature": "(self)", "symbol_type": "function"}], "test_database_add_sequence": [{"docstring": "Test adding sequence to database.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 270, "module": "tests.test_life_events", "name": "test_database_add_sequence", "signature": "(self)", "symbol_type": "function"}], "test_database_creation_empty": [{"docstring": "Test creating empty database.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 253, "module": "tests.test_life_events", "name": "test_database_creation_empty", "signature": "(self)", "symbol_type": "function"}], "test_database_creation_with_sequences": [{"docstring": "Test creating database with sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 259, "module": "tests.test_life_events", "name": "test_database_creation_with_sequences", "signature": "(self)", "symbol_type": "function"}], "test_database_filter_by_domain": [{"docstring": "Test filtering database by domain.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 278, "module": "tests.test_life_events", "name": "test_database_filter_by_domain", "signature": "(self)", "symbol_type": "function"}], "test_database_from_dict": [{"docstring": "Test database deserialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 350, "module": "tests.test_life_events", "name": "test_database_from_dict", "signature": "(self)", "symbol_type": "function"}], "test_database_get_statistics": [{"docstring": "Test getting database statistics.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 293, "module": "tests.test_life_events", "name": "test_database_get_statistics", "signature": "(self)", "symbol_type": "function"}], "test_database_get_statistics_empty": [{"docstring": "Test statistics for empty database.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 311, "module": "tests.test_life_events", "name": "test_database_get_statistics_empty", "signature": "(self)", "symbol_type": "function"}], "test_database_to_dataframe": [{"docstring": "Test converting database to DataFrame.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 320, "module": "tests.test_life_events", "name": "test_database_to_dataframe", "signature": "(self)", "symbol_type": "function"}], "test_database_to_dataframe_empty": [{"docstring": "Test converting empty database to DataFrame.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 334, "module": "tests.test_life_events", "name": "test_database_to_dataframe_empty", "signature": "(self)", "symbol_type": "function"}], "test_database_to_dict": [{"docstring": "Test database serialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 340, "module": "tests.test_life_events", "name": "test_database_to_dict", "signature": "(self)", "symbol_type": "function"}], "test_ddm_accuracy_positive_drift": [{"docstring": "Test DDM accuracy with positive drift.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 287, "module": "tests.test_math_comprehensive", "name": "test_ddm_accuracy_positive_drift", "signature": "(self)", "symbol_type": "function"}], "test_ddm_accuracy_symmetric": [{"docstring": "Test DDM accuracy for symmetric case.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 281, "module": "tests.test_math_comprehensive", "name": "test_ddm_accuracy_symmetric", "signature": "(self)", "symbol_type": "function"}], "test_ddm_decision_time": [{"docstring": "Test DDM mean decision time.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 293, "module": "tests.test_math_comprehensive", "name": "test_ddm_decision_time", "signature": "(self)", "symbol_type": "function"}], "test_default_mapping": [{"docstring": "Test default trait mapping.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 189, "module": "tests.test_phenotype_life_course", "name": "test_default_mapping", "signature": "(self)", "symbol_type": "function"}], "test_degree_centrality": [{"docstring": "Test degree centrality calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 230, "module": "tests.test_networks_graph", "name": "test_degree_centrality", "signature": "(self)", "symbol_type": "function"}], "test_demographic_plot": [{"docstring": "Test demographic comparison plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 204, "module": "tests.test_dna_population_viz", "name": "test_demographic_plot", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_descendants_empty_term_id": [{"docstring": "Test descendants with empty term_id raises ValueError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 106, "module": "tests.test_ontology_query", "name": "test_descendants_empty_term_id", "signature": "(self)", "symbol_type": "function"}], "test_descendants_missing_term": [{"docstring": "Test descendants for non-existent term.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_comprehensive.py", "line_number": 223, "module": "tests.test_ontology_comprehensive", "name": "test_descendants_missing_term", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test descendants of non-existent term raises ValueError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 100, "module": "tests.test_ontology_query", "name": "test_descendants_missing_term", "signature": "(self)", "symbol_type": "function"}], "test_descendants_no_children": [{"docstring": "Test descendants of leaf term.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 88, "module": "tests.test_ontology_query", "name": "test_descendants_no_children", "signature": "(self)", "symbol_type": "function"}], "test_descendants_query": [{"docstring": "Test descendant retrieval.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_comprehensive.py", "line_number": 86, "module": "tests.test_ontology_comprehensive", "name": "test_descendants_query", "signature": "(self)", "symbol_type": "function"}], "test_descendants_simple_hierarchy": [{"docstring": "Test finding descendants in simple hierarchy.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 69, "module": "tests.test_ontology_query", "name": "test_descendants_simple_hierarchy", "signature": "(self)", "symbol_type": "function"}], "test_detect_adapter_contamination_basic": [{"docstring": "Test basic adapter contamination detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_contamination.py", "line_number": 107, "module": "tests.test_quality_contamination", "name": "test_detect_adapter_contamination_basic", "signature": "(self)", "symbol_type": "function"}], "test_detect_communities_basic": [{"docstring": "Test basic community detection functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 42, "module": "tests.test_networks_community", "name": "test_detect_communities_basic", "signature": "(self)", "symbol_type": "function"}], "test_detect_communities_different_algorithms": [{"docstring": "Test different community detection algorithms.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 59, "module": "tests.test_networks_community", "name": "test_detect_communities_different_algorithms", "signature": "(self)", "symbol_type": "function"}], "test_detect_communities_disconnected": [{"docstring": "Test community detection on disconnected network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 112, "module": "tests.test_networks_community", "name": "test_detect_communities_disconnected", "signature": "(self)", "symbol_type": "function"}], "test_detect_communities_empty_network": [{"docstring": "Test community detection on empty network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 94, "module": "tests.test_networks_community", "name": "test_detect_communities_empty_network", "signature": "(self)", "symbol_type": "function"}], "test_detect_communities_louvain": [{"docstring": "Test Louvain community detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 134, "module": "tests.test_networks_comprehensive", "name": "test_detect_communities_louvain", "signature": "(self)", "symbol_type": "function"}], "test_detect_communities_resolution": [{"docstring": "Test community detection with different resolution parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 75, "module": "tests.test_networks_community", "name": "test_detect_communities_resolution", "signature": "(self)", "symbol_type": "function"}], "test_detect_communities_single_node": [{"docstring": "Test community detection on single node network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 102, "module": "tests.test_networks_community", "name": "test_detect_communities_single_node", "signature": "(self)", "symbol_type": "function"}], "test_detect_complexes": [{"docstring": "Test protein complex detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 637, "module": "tests.test_networks_ppi", "name": "test_detect_complexes", "signature": "(self)", "symbol_type": "function"}], "test_detect_cross_species_basic": [{"docstring": "Test basic cross-species contamination detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_contamination.py", "line_number": 18, "module": "tests.test_quality_contamination", "name": "test_detect_cross_species_basic", "signature": "(self)", "symbol_type": "function"}], "test_detect_cross_species_empty_input": [{"docstring": "Test handling of empty input.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_contamination.py", "line_number": 44, "module": "tests.test_quality_contamination", "name": "test_detect_cross_species_empty_input", "signature": "(self)", "symbol_type": "function"}], "test_detect_cross_species_no_contamination": [{"docstring": "Test detection when no contamination is present.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_contamination.py", "line_number": 32, "module": "tests.test_quality_contamination", "name": "test_detect_cross_species_no_contamination", "signature": "(self)", "symbol_type": "function"}], "test_detect_drive_size_category": [{"docstring": "Test detecting drive size category.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 92, "module": "tests.test_core_disk", "name": "test_detect_drive_size_category", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_detect_drive_size_category_nonexistent": [{"docstring": "Test detecting category for nonexistent path.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 97, "module": "tests.test_core_disk", "name": "test_detect_drive_size_category_nonexistent", "signature": "(self)", "symbol_type": "function"}], "test_detect_mycoplasma_contamination_basic": [{"docstring": "Test basic mycoplasma contamination detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_contamination.py", "line_number": 80, "module": "tests.test_quality_contamination", "name": "test_detect_mycoplasma_contamination_basic", "signature": "(self)", "symbol_type": "function"}], "test_detect_mycoplasma_contamination_with_genome": [{"docstring": "Test detection with custom mycoplasma genome.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_contamination.py", "line_number": 93, "module": "tests.test_quality_contamination", "name": "test_detect_mycoplasma_contamination_with_genome", "signature": "(self)", "symbol_type": "function"}], "test_detect_outliers": [{"docstring": "Test outlier detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_stats.py", "line_number": 45, "module": "tests.test_math_popgen_stats", "name": "test_detect_outliers", "signature": "()", "symbol_type": "function"}], "test_detect_regulatory_cascades": [{"docstring": "Test regulatory cascade detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 690, "module": "tests.test_networks_regulatory", "name": "test_detect_regulatory_cascades", "signature": "(self)", "symbol_type": "function"}], "test_detect_rrna_contamination_basic": [{"docstring": "Test basic rRNA contamination detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_contamination.py", "line_number": 54, "module": "tests.test_quality_contamination", "name": "test_detect_rrna_contamination_basic", "signature": "(self)", "symbol_type": "function"}], "test_detect_rrna_contamination_custom_patterns": [{"docstring": "Test detection with custom rRNA patterns.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_contamination.py", "line_number": 66, "module": "tests.test_quality_contamination", "name": "test_detect_rrna_contamination_custom_patterns", "signature": "(self)", "symbol_type": "function"}], "test_detect_vector_contamination_basic": [{"docstring": "Test basic vector contamination detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_contamination.py", "line_number": 124, "module": "tests.test_quality_contamination", "name": "test_detect_vector_contamination_basic", "signature": "(self)", "symbol_type": "function"}], "test_deterministic_functions": [{"docstring": "Test that deterministic functions are reproducible.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 315, "module": "tests.test_core_functionality", "name": "test_deterministic_functions", "signature": "(self)", "symbol_type": "function"}], "test_deterministic_seeding": [{"docstring": "Test deterministic hash-based seeding.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 174, "module": "tests.test_core_comprehensive", "name": "test_deterministic_seeding", "signature": "(self)", "symbol_type": "function"}], "test_different_distributions": [{"docstring": "Test that different distributions have JS divergence > 0.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 239, "module": "tests.test_math_utilities", "name": "test_different_distributions", "signature": "(self)", "symbol_type": "function"}], "test_different_length_sequences": [{"docstring": "Test with sequences of different lengths (truncates to shortest).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 109, "module": "tests.test_dna_population_comprehensive", "name": "test_different_length_sequences", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test with sequences of different lengths.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 175, "module": "tests.test_dna_population_comprehensive", "name": "test_different_length_sequences", "signature": "(self)", "symbol_type": "function"}], "test_different_lengths_raises_error": [{"docstring": "Test that different length lists raise ValueError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 57, "module": "tests.test_math_utilities", "name": "test_different_lengths_raises_error", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test that different length lists raise ValueError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 117, "module": "tests.test_math_utilities", "name": "test_different_lengths_raises_error", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test that different length distributions raise ValueError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 254, "module": "tests.test_math_utilities", "name": "test_different_lengths_raises_error", "signature": "(self)", "symbol_type": "function"}], "test_differential_entropy": [{"docstring": "Test differential entropy calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 358, "module": "tests.test_information_comprehensive", "name": "test_differential_entropy", "signature": "(self)", "symbol_type": "function"}], "test_dimension_mismatch_error": [{"docstring": "Test error handling for dimension mismatch.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 97, "module": "tests.test_ml_features", "name": "test_dimension_mismatch_error", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test that dimension mismatches raise appropriate errors.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 436, "module": "tests.test_singlecell_preprocessing", "name": "test_dimension_mismatch_error", "signature": "(self)", "symbol_type": "function"}], "test_directed_vs_undirected": [{"docstring": "Test directed vs undirected network behavior.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 47, "module": "tests.test_networks_comprehensive", "name": "test_directed_vs_undirected", "signature": "(self)", "symbol_type": "function"}], "test_directed_vs_undirected_edges": [{"docstring": "Test edge behavior in directed vs undirected networks.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 57, "module": "tests.test_networks_graph", "name": "test_directed_vs_undirected_edges", "signature": "(self)", "symbol_type": "function"}], "test_discover_configs_repo_root": [{"docstring": "Test discovering configs from repo root.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_discovery.py", "line_number": 57, "module": "tests.test_core_discovery", "name": "test_discover_configs_repo_root", "signature": "(self)", "symbol_type": "function"}], "test_discover_configs_with_domain": [{"docstring": "Test discovering configs for specific domain.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_discovery.py", "line_number": 68, "module": "tests.test_core_discovery", "name": "test_discover_configs_with_domain", "signature": "(self)", "symbol_type": "function"}], "test_discover_functions_in_core_module": [{"docstring": "Test discovering functions in a core module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_discovery.py", "line_number": 18, "module": "tests.test_core_discovery", "name": "test_discover_functions_in_core_module", "signature": "(self)", "symbol_type": "function"}], "test_discover_functions_invalid_syntax": [{"docstring": "Test that invalid syntax raises SyntaxError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_discovery.py", "line_number": 46, "module": "tests.test_core_discovery", "name": "test_discover_functions_invalid_syntax", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_discover_functions_nonexistent_file": [{"docstring": "Test that nonexistent file raises FileNotFoundError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_discovery.py", "line_number": 40, "module": "tests.test_core_discovery", "name": "test_discover_functions_nonexistent_file", "signature": "(self)", "symbol_type": "function"}], "test_discover_functions_with_pattern": [{"docstring": "Test discovering functions with name pattern.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_discovery.py", "line_number": 30, "module": "tests.test_core_discovery", "name": "test_discover_functions_with_pattern", "signature": "(self)", "symbol_type": "function"}], "test_discover_output_patterns_core": [{"docstring": "Test discovering output patterns for core module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_discovery.py", "line_number": 81, "module": "tests.test_core_discovery", "name": "test_discover_output_patterns_core", "signature": "(self)", "symbol_type": "function"}], "test_discover_output_patterns_dna": [{"docstring": "Test discovering output patterns for dna module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_discovery.py", "line_number": 88, "module": "tests.test_core_discovery", "name": "test_discover_output_patterns_dna", "signature": "(self)", "symbol_type": "function"}], "test_discover_workflows_none": [{"docstring": "Test discovering workflows with None repo_root.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_discovery.py", "line_number": 153, "module": "tests.test_core_discovery", "name": "test_discover_workflows_none", "signature": "(self)", "symbol_type": "function"}], "test_discover_workflows_repo_root": [{"docstring": "Test discovering workflows from repo root.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_discovery.py", "line_number": 144, "module": "tests.test_core_discovery", "name": "test_discover_workflows_repo_root", "signature": "(self)", "symbol_type": "function"}], "test_distance_edge_cases": [{"docstring": "Test edge cases for distance calculations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 215, "module": "tests.test_dna_comprehensive", "name": "test_distance_edge_cases", "signature": "(self)", "symbol_type": "function"}], "test_distance_same_term": [{"docstring": "Test distance to self is zero.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 227, "module": "tests.test_ontology_query", "name": "test_distance_same_term", "signature": "(self)", "symbol_type": "function"}], "test_distance_simple": [{"docstring": "Test calculating distance between terms.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 212, "module": "tests.test_ontology_query", "name": "test_distance_simple", "signature": "(self)", "symbol_type": "function"}], "test_distance_validation": [{"docstring": "Test input validation for distance functions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 200, "module": "tests.test_dna_comprehensive", "name": "test_distance_validation", "signature": "(self)", "symbol_type": "function"}], "test_diversity_and_segregating_sites": [{"docstring": "Test that diversity and segregating sites are related.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 243, "module": "tests.test_dna_population_comprehensive", "name": "test_diversity_and_segregating_sites", "signature": "(self)", "symbol_type": "function"}], "test_diversity_metrics": [{"docstring": "Test diversity calculations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 180, "module": "tests.test_core_functionality", "name": "test_diversity_metrics", "signature": "(self)", "symbol_type": "function"}], "test_dna_analysis_workflow": [{"docstring": "Test DNA sequence analysis workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_integration_comprehensive.py", "line_number": 96, "module": "tests.test_integration_comprehensive", "name": "test_dna_analysis_workflow", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_dna_integration": [{"docstring": "Test DNA integration.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 464, "module": "tests.test_information_comprehensive", "name": "test_dna_integration", "signature": "(self)", "symbol_type": "function"}], "test_dna_integration_function": [{"docstring": "Test DNA integration wrapper function.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 47, "module": "tests.test_information_integration", "name": "test_dna_integration_function", "signature": "(self)", "symbol_type": "function"}], "test_dna_integration_profile": [{"docstring": "Test DNA integration with profile analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 54, "module": "tests.test_information_integration", "name": "test_dna_integration_profile", "signature": "(self)", "symbol_type": "function"}], "test_dna_orchestrator_help": [{"docstring": "Test DNA orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 23, "module": "tests.test_orchestrators", "name": "test_dna_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_dna_sequence_entropy": [{"docstring": "Test entropy calculation with DNA sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 29, "module": "tests.test_information_integration", "name": "test_dna_sequence_entropy", "signature": "(self)", "symbol_type": "function"}], "test_dna_sequence_validation": [{"docstring": "Test DNA sequence validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 26, "module": "tests.test_dna_sequences_enhanced", "name": "test_dna_sequence_validation", "signature": "(self)", "symbol_type": "function"}], "test_dna_to_network_information": [{"docstring": "Test information flow from DNA analysis to network analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 297, "module": "tests.test_information_integration", "name": "test_dna_to_network_information", "signature": "(self)", "symbol_type": "function"}], "test_docs_rna_readme_mentions_ena": [{"docstring": "Verify docs/rna/README.md mentions ENA approach.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 155, "module": "tests.test_rna_ena_workflow", "name": "test_docs_rna_readme_mentions_ena", "signature": "(self)", "symbol_type": "function"}], "test_domain_specific_embeddings": [{"docstring": "Test domain-specific embedding learning.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 229, "module": "tests.test_life_events_embeddings", "name": "test_domain_specific_embeddings", "signature": "()", "symbol_type": "function"}], "test_domain_specific_embeddings_empty_domain": [{"docstring": "Test domain-specific embeddings with empty domain.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 260, "module": "tests.test_life_events_embeddings", "name": "test_domain_specific_embeddings_empty_domain", "signature": "()", "symbol_type": "function"}], "test_download_and_process_data": [{"docstring": "Test the main processing function.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_processing.py", "line_number": 91, "module": "tests.test_core_processing", "name": "test_download_and_process_data", "signature": "(self)", "symbol_type": "function"}], "test_download_file": [{"docstring": "Test file download functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io_enhanced.py", "line_number": 14, "module": "tests.test_core_io_enhanced", "name": "test_download_file", "signature": "(self)", "symbol_type": "function"}], "test_download_functionality_in_workflow": [{"docstring": "Verify ENA download functionality is available in run_workflow.py.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 28, "module": "tests.test_rna_ena_workflow", "name": "test_download_functionality_in_workflow", "signature": "(self)", "symbol_type": "function"}], "test_download_json": [{"docstring": "Test JSON download functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io_enhanced.py", "line_number": 35, "module": "tests.test_core_io_enhanced", "name": "test_download_json", "signature": "(self)", "symbol_type": "function"}], "test_download_reference_genome_invalid_accession": [{"docstring": "Test genome download with invalid accession (should handle gracefully).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_download.py", "line_number": 89, "module": "tests.test_gwas_download", "name": "test_download_reference_genome_invalid_accession", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_download_reference_genome_skip_if_offline": [{"docstring": "Test genome download (skips if network unavailable).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_download.py", "line_number": 13, "module": "tests.test_gwas_download", "name": "test_download_reference_genome_skip_if_offline", "signature": "(tmp_path: Path, pytestconfig) -> None", "symbol_type": "function"}], "test_download_sra_project_requires_tools": [{"docstring": "Test project download interface.\n\nVerifies function structure without requiring actual download.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_sra_download.py", "line_number": 94, "module": "tests.test_gwas_sra_download", "name": "test_download_sra_project_requires_tools", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_download_sra_run_invalid_accession": [{"docstring": "Test behavior with invalid accession.\n\nUses real implementation - may fail or skip depending on tool availability.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_sra_download.py", "line_number": 69, "module": "tests.test_gwas_sra_download", "name": "test_download_sra_run_invalid_accession", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_download_sra_run_requires_tools": [{"docstring": "Test that download requires SRA tools to be available.\n\nThis test verifies the function structure but will skip if\nSRA tools are not available on the system.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_sra_download.py", "line_number": 47, "module": "tests.test_gwas_sra_download", "name": "test_download_sra_run_requires_tools", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_download_text": [{"docstring": "Test text download functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io_enhanced.py", "line_number": 50, "module": "tests.test_core_io_enhanced", "name": "test_download_text", "signature": "(self)", "symbol_type": "function"}], "test_download_validation_imports": [{"docstring": "Test that download validation functions can be imported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_steps_comprehensive.py", "line_number": 57, "module": "tests.test_rna_steps_comprehensive", "name": "test_download_validation_imports", "signature": "(self)", "symbol_type": "function"}], "test_download_variant_data_missing_dest": [{"docstring": "Test variant download without destination directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_download.py", "line_number": 47, "module": "tests.test_gwas_download", "name": "test_download_variant_data_missing_dest", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_download_variant_data_unsupported_source": [{"docstring": "Test variant download with unsupported source.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_download.py", "line_number": 36, "module": "tests.test_gwas_download", "name": "test_download_variant_data_unsupported_source", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_downloaded_fastq_processed": [{"docstring": "Test that if FASTQ exists, it's quantified and deleted (not re-downloaded).\n\nThis test verifies the behavior described: if raw FASTQ file is there,\nprocess it (quantify) then delete it, rather than skipping.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_skip.py", "line_number": 142, "module": "tests.test_rna_download_skip", "name": "test_downloaded_fastq_processed", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_duplicate_edges": [{"docstring": "Test behavior with duplicate edge additions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 527, "module": "tests.test_networks_graph", "name": "test_duplicate_edges", "signature": "(self)", "symbol_type": "function"}], "test_duplicate_interactions": [{"docstring": "Test handling of duplicate interactions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 548, "module": "tests.test_networks_ppi", "name": "test_duplicate_interactions", "signature": "(self)", "symbol_type": "function"}], "test_duplicate_pathways": [{"docstring": "Test handling of duplicate pathway addition.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 428, "module": "tests.test_networks_pathway", "name": "test_duplicate_pathways", "signature": "(self)", "symbol_type": "function"}], "test_duplicate_regulations": [{"docstring": "Test handling of duplicate regulatory interactions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 603, "module": "tests.test_networks_regulatory", "name": "test_duplicate_regulations", "signature": "(self)", "symbol_type": "function"}], "test_duplication_analysis": [{"docstring": "Test sequence duplication level analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 285, "module": "tests.test_quality_fastq", "name": "test_duplication_analysis", "signature": "(self)", "symbol_type": "function"}], "test_each_step_runner_invokes_real_subcommand_or_skips": [{"docstring": "Test that each step runner can invoke real amalgkit subcommands or skip gracefully.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_step_runners_dispatch.py", "line_number": 11, "module": "tests.test_rna_step_runners_dispatch", "name": "test_each_step_runner_invokes_real_subcommand_or_skips", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_ecology_orchestrator_help": [{"docstring": "Test ecology orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 100, "module": "tests.test_orchestrators", "name": "test_ecology_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_effect_plot": [{"docstring": "Test effect size visualization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 164, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_effect_plot", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_effective_population_size_estimation": [{"docstring": "Test effective population size estimation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_enhanced.py", "line_number": 86, "module": "tests.test_math_enhanced", "name": "test_effective_population_size_estimation", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test effective population size estimation from heterozygosity.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_enhanced.py", "line_number": 10, "module": "tests.test_math_popgen_enhanced", "name": "test_effective_population_size_estimation", "signature": "(self)", "symbol_type": "function"}], "test_effective_size": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_egt_epi_fst_ne.py", "line_number": 39, "module": "tests.test_math_egt_epi_fst_ne", "name": "test_effective_size", "signature": "()", "symbol_type": "function"}], "test_effective_size_from_family_size_variance": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_effective_size_extras.py", "line_number": 6, "module": "tests.test_math_effective_size_extras", "name": "test_effective_size_from_family_size_variance", "signature": "()", "symbol_type": "function"}], "test_empty_data": [{"docstring": "Test handling of empty datasets.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 658, "module": "tests.test_ml_comprehensive", "name": "test_empty_data", "signature": "(self)", "symbol_type": "function"}], "test_empty_data_handling": [{"docstring": "Test handling of empty or minimal data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 398, "module": "tests.test_singlecell_preprocessing", "name": "test_empty_data_handling", "signature": "(self)", "symbol_type": "function"}], "test_empty_fastq_file": [{"docstring": "Test handling of empty FASTQ file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 432, "module": "tests.test_quality_fastq", "name": "test_empty_fastq_file", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_empty_genotypes": [{"docstring": "Test with empty genotype list.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 57, "module": "tests.test_dna_population_comprehensive", "name": "test_empty_genotypes", "signature": "(self)", "symbol_type": "function"}], "test_empty_grn_operations": [{"docstring": "Test operations on empty GRN.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 568, "module": "tests.test_networks_regulatory", "name": "test_empty_grn_operations", "signature": "(self)", "symbol_type": "function"}], "test_empty_input": [{"docstring": "Test with empty input.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_analysis.py", "line_number": 52, "module": "tests.test_dna_population_analysis", "name": "test_empty_input", "signature": "(self)", "symbol_type": "function"}], "test_empty_input_consistency": [{"docstring": "Test that all functions handle empty input consistently.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 231, "module": "tests.test_core_text", "name": "test_empty_input_consistency", "signature": "(self) -> None", "symbol_type": "function"}], "test_empty_input_handling": [{"docstring": "Test functions handle empty inputs gracefully.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 281, "module": "tests.test_core_functionality", "name": "test_empty_input_handling", "signature": "(self)", "symbol_type": "function"}], "test_empty_inputs": [{"docstring": "Test functions with empty inputs.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 333, "module": "tests.test_math_comprehensive", "name": "test_empty_inputs", "signature": "(self)", "symbol_type": "function"}], "test_empty_layers": [{"docstring": "Test behavior with empty omics layers.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 474, "module": "tests.test_multiomics_integration", "name": "test_empty_layers", "signature": "(self)", "symbol_type": "function"}], "test_empty_list": [{"docstring": "Test empty list returns 0.0.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 218, "module": "tests.test_math_utilities", "name": "test_empty_list", "signature": "(self)", "symbol_type": "function"}], "test_empty_matrix": [{"docstring": "Test with empty genotype matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 24, "module": "tests.test_dna_population_comprehensive", "name": "test_empty_matrix", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test handling of empty matrices.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 447, "module": "tests.test_singlecell_basic", "name": "test_empty_matrix", "signature": "(self)", "symbol_type": "function"}], "test_empty_omics_error": [{"docstring": "Test error when no omics data provided.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 116, "module": "tests.test_multiomics_integration", "name": "test_empty_omics_error", "signature": "(self)", "symbol_type": "function"}], "test_empty_ontology": [{"docstring": "Test operations on empty ontology.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_comprehensive.py", "line_number": 230, "module": "tests.test_ontology_comprehensive", "name": "test_empty_ontology", "signature": "(self)", "symbol_type": "function"}], "test_empty_pathway_network": [{"docstring": "Test operations on empty pathway network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 415, "module": "tests.test_networks_pathway", "name": "test_empty_pathway_network", "signature": "(self)", "symbol_type": "function"}], "test_empty_population": [{"docstring": "Test with empty population.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 168, "module": "tests.test_dna_population_comprehensive", "name": "test_empty_population", "signature": "(self)", "symbol_type": "function"}], "test_empty_ppi_network": [{"docstring": "Test operations on empty PPI network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 536, "module": "tests.test_networks_ppi", "name": "test_empty_ppi_network", "signature": "(self)", "symbol_type": "function"}], "test_empty_results": [{"docstring": "Test handling of empty results.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 222, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_empty_results", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_empty_sequence": [{"docstring": "Test extraction from empty sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 52, "module": "tests.test_phenotype_life_course", "name": "test_empty_sequence", "signature": "(self)", "symbol_type": "function"}], "test_empty_sequences": [{"docstring": "Test with empty sequence list.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 97, "module": "tests.test_dna_population_comprehensive", "name": "test_empty_sequences", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test with empty sequence list.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 205, "module": "tests.test_dna_population_comprehensive", "name": "test_empty_sequences", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test with empty sequence list.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 233, "module": "tests.test_dna_population_comprehensive", "name": "test_empty_sequences", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test aggregation with empty sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 138, "module": "tests.test_phenotype_life_course", "name": "test_empty_sequences", "signature": "(self)", "symbol_type": "function"}], "test_end_to_end_save_load_predict": [{"docstring": "Test complete workflow: train -> save -> load -> predict.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_integration.py", "line_number": 151, "module": "tests.test_life_events_integration", "name": "test_end_to_end_save_load_predict", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_enhanced_cache_utilities": [{"docstring": "Test enhanced cache utilities.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 484, "module": "tests.test_core_comprehensive", "name": "test_enhanced_cache_utilities", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_enhanced_hash_utilities": [{"docstring": "Test enhanced hash utilities.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 403, "module": "tests.test_core_comprehensive", "name": "test_enhanced_hash_utilities", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_enhanced_io_utilities": [{"docstring": "Test enhanced I/O utilities.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 506, "module": "tests.test_core_comprehensive", "name": "test_enhanced_io_utilities", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_enhanced_parallel_utilities": [{"docstring": "Test enhanced parallel utilities.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 550, "module": "tests.test_core_comprehensive", "name": "test_enhanced_parallel_utilities", "signature": "(self)", "symbol_type": "function"}], "test_enhanced_path_utilities": [{"docstring": "Test enhanced path utilities.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 433, "module": "tests.test_core_comprehensive", "name": "test_enhanced_path_utilities", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_enhanced_plot": [{"docstring": "Test enhanced visualization features.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 192, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_enhanced_plot", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_enhanced_text_utilities": [{"docstring": "Test enhanced text utilities.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 461, "module": "tests.test_core_comprehensive", "name": "test_enhanced_text_utilities", "signature": "(self)", "symbol_type": "function"}], "test_enrichment_plot": [{"docstring": "Test enrichment plot functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 496, "module": "tests.test_visualization_enhanced", "name": "test_enrichment_plot", "signature": "(self)", "symbol_type": "function"}], "test_ensemble_predictor": [{"docstring": "Test ensemble predictor.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models_advanced.py", "line_number": 65, "module": "tests.test_life_events_models_advanced", "name": "test_ensemble_predictor", "signature": "(tmp_path)", "symbol_type": "function"}], "test_ensure_cli_available": [{"docstring": "Test CLI availability check and optional auto-install.\n\nNote: ensure_cli_available returns a tuple (ok, msg, install_record),\nit does not raise exceptions. This test verifies the return value.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 452, "module": "tests.test_rna_amalgkit_end_to_end", "name": "test_ensure_cli_available", "signature": "(self)", "symbol_type": "function"}], "test_ensure_cli_available_exists": [{"docstring": "Verify ensure_cli_available function exists.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 471, "module": "tests.test_rna_amalgkit_steps", "name": "test_ensure_cli_available_exists", "signature": "(self)", "symbol_type": "function"}], "test_ensure_cli_available_no_auto_install": [{"docstring": "Test ensure_cli_available without auto-install.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 538, "module": "tests.test_rna_amalgkit_steps", "name": "test_ensure_cli_available_no_auto_install", "signature": "(self)", "symbol_type": "function"}], "test_ensure_directory_creates": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io.py", "line_number": 9, "module": "tests.test_core_io", "name": "test_ensure_directory_creates", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_entrez_different_accession_types_real": [{"docstring": "Test with different types of valid accession numbers.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_entrez_integration.py", "line_number": 78, "module": "tests.test_dna_entrez_integration", "name": "test_entrez_different_accession_types_real", "signature": "()", "symbol_type": "function"}], "test_entrez_email_parameter_validation": [{"docstring": "Test email parameter handling without network calls.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_entrez_integration.py", "line_number": 148, "module": "tests.test_dna_entrez_integration", "name": "test_entrez_email_parameter_validation", "signature": "()", "symbol_type": "function"}], "test_entrez_fetch_phix_fasta_real_network": [{"docstring": "Test real NCBI Entrez API with actual network requests.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_entrez_integration.py", "line_number": 25, "module": "tests.test_dna_entrez_integration", "name": "test_entrez_fetch_phix_fasta_real_network", "signature": "()", "symbol_type": "function"}], "test_entrez_invalid_accession_real": [{"docstring": "Test real behavior with invalid accession numbers.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_entrez_integration.py", "line_number": 58, "module": "tests.test_dna_entrez_integration", "name": "test_entrez_invalid_accession_real", "signature": "()", "symbol_type": "function"}], "test_entrez_no_email_behavior": [{"docstring": "Test behavior when no email is provided (no network required).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_entrez_integration.py", "line_number": 45, "module": "tests.test_dna_entrez_integration", "name": "test_entrez_no_email_behavior", "signature": "()", "symbol_type": "function"}], "test_entrez_offline_behavior": [{"docstring": "Document real offline behavior for NCBI queries.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_entrez_integration.py", "line_number": 104, "module": "tests.test_dna_entrez_integration", "name": "test_entrez_offline_behavior", "signature": "()", "symbol_type": "function"}], "test_entrez_rate_limiting_behavior": [{"docstring": "Test how real API handles rapid successive requests.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_entrez_integration.py", "line_number": 122, "module": "tests.test_dna_entrez_integration", "name": "test_entrez_rate_limiting_behavior", "signature": "()", "symbol_type": "function"}], "test_entropy_distribution_plot": [{"docstring": "Test entropy distribution plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 232, "module": "tests.test_information_integration", "name": "test_entropy_distribution_plot", "signature": "(self)", "symbol_type": "function"}], "test_entropy_estimation": [{"docstring": "Test entropy estimation methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 379, "module": "tests.test_information_comprehensive", "name": "test_entropy_estimation", "signature": "(self)", "symbol_type": "function"}], "test_entropy_estimator": [{"docstring": "Test entropy estimation with various methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 396, "module": "tests.test_information_comprehensive", "name": "test_entropy_estimator", "signature": "(self)", "symbol_type": "function"}], "test_entropy_large_distribution": [{"docstring": "Test entropy with many outcomes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 305, "module": "tests.test_math_utilities", "name": "test_entropy_large_distribution", "signature": "(self)", "symbol_type": "function"}], "test_env_override": [{"docstring": "Test environment variable configuration override.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 98, "module": "tests.test_core_comprehensive", "name": "test_env_override", "signature": "(self)", "symbol_type": "function"}], "test_env_overrides_for_config_threads": [{"docstring": "Test that environment variables can override config values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_config_load_plan.py", "line_number": 58, "module": "tests.test_rna_config_load_plan", "name": "test_env_overrides_for_config_threads", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_environment_variable_override": [{"docstring": "Test that AK_THREADS environment variable works.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/validate_all_species_workflow.py", "line_number": 94, "module": "scripts.validate_all_species_workflow", "name": "test_environment_variable_override", "signature": "(config_path: Path) -> Tuple[bool, str]", "symbol_type": "function"}], "test_epigenome_orchestrator_help": [{"docstring": "Test epigenome orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 93, "module": "tests.test_orchestrators", "name": "test_epigenome_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_equilibrium_heterozygosity_infinite_alleles": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_drift_migration.py", "line_number": 25, "module": "tests.test_math_drift_migration", "name": "test_equilibrium_heterozygosity_infinite_alleles", "signature": "()", "symbol_type": "function"}], "test_estimate_population_structure_integration": [{"docstring": "Test full population structure estimation from VCF.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_structure.py", "line_number": 111, "module": "tests.test_gwas_structure", "name": "test_estimate_population_structure_integration", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_event_creation": [{"docstring": "Test creating Event objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 12, "module": "tests.test_life_events_events", "name": "test_event_creation", "signature": "()", "symbol_type": "function"}], "test_event_creation_basic": [{"docstring": "Test basic event creation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 19, "module": "tests.test_life_events", "name": "test_event_creation_basic", "signature": "(self)", "symbol_type": "function"}], "test_event_creation_with_attributes": [{"docstring": "Test event creation with additional attributes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 31, "module": "tests.test_life_events", "name": "test_event_creation_with_attributes", "signature": "(self)", "symbol_type": "function"}], "test_event_creation_with_numeric_timestamp": [{"docstring": "Test event creation with numeric timestamp.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 42, "module": "tests.test_life_events", "name": "test_event_creation_with_numeric_timestamp", "signature": "(self)", "symbol_type": "function"}], "test_event_database_add_sequence": [{"docstring": "Test adding sequences to database.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 171, "module": "tests.test_life_events_events", "name": "test_event_database_add_sequence", "signature": "()", "symbol_type": "function"}], "test_event_database_creation": [{"docstring": "Test creating EventDatabase.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 156, "module": "tests.test_life_events_events", "name": "test_event_database_creation", "signature": "()", "symbol_type": "function"}], "test_event_database_filter_by_domain": [{"docstring": "Test EventDatabase domain filtering.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 183, "module": "tests.test_life_events_events", "name": "test_event_database_filter_by_domain", "signature": "()", "symbol_type": "function"}], "test_event_database_statistics": [{"docstring": "Test EventDatabase statistics.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 201, "module": "tests.test_life_events_events", "name": "test_event_database_statistics", "signature": "()", "symbol_type": "function"}], "test_event_database_to_dataframe": [{"docstring": "Test EventDatabase DataFrame conversion.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 225, "module": "tests.test_life_events_events", "name": "test_event_database_to_dataframe", "signature": "()", "symbol_type": "function"}], "test_event_database_to_from_dict": [{"docstring": "Test EventDatabase serialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 243, "module": "tests.test_life_events_events", "name": "test_event_database_to_from_dict", "signature": "()", "symbol_type": "function"}], "test_event_from_dict": [{"docstring": "Test event deserialization from dictionary.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 84, "module": "tests.test_life_events", "name": "test_event_from_dict", "signature": "(self)", "symbol_type": "function"}], "test_event_from_dict_numeric_timestamp": [{"docstring": "Test event from dict with numeric timestamp.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 97, "module": "tests.test_life_events", "name": "test_event_from_dict_numeric_timestamp", "signature": "(self)", "symbol_type": "function"}], "test_event_importance_empty_sequences": [{"docstring": "Test event importance with empty sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_interpretability.py", "line_number": 49, "module": "tests.test_life_events_interpretability", "name": "test_event_importance_empty_sequences", "signature": "()", "symbol_type": "function"}], "test_event_importance_invalid_method": [{"docstring": "Test event importance with invalid method.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_interpretability.py", "line_number": 61, "module": "tests.test_life_events_interpretability", "name": "test_event_importance_invalid_method", "signature": "()", "symbol_type": "function"}], "test_event_importance_not_fitted": [{"docstring": "Test event importance with unfitted predictor.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_interpretability.py", "line_number": 38, "module": "tests.test_life_events_interpretability", "name": "test_event_importance_not_fitted", "signature": "()", "symbol_type": "function"}], "test_event_importance_permutation": [{"docstring": "Test event importance computation with permutation method.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_interpretability.py", "line_number": 18, "module": "tests.test_life_events_interpretability", "name": "test_event_importance_permutation", "signature": "()", "symbol_type": "function"}], "test_event_sequence_creation": [{"docstring": "Test creating EventSequence objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 59, "module": "tests.test_life_events_events", "name": "test_event_sequence_creation", "signature": "()", "symbol_type": "function"}], "test_event_sequence_filtering": [{"docstring": "Test EventSequence filtering methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 75, "module": "tests.test_life_events_events", "name": "test_event_sequence_filtering", "signature": "()", "symbol_type": "function"}], "test_event_sequence_get_methods": [{"docstring": "Test EventSequence getter methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 98, "module": "tests.test_life_events_events", "name": "test_event_sequence_get_methods", "signature": "()", "symbol_type": "function"}], "test_event_sequence_predictor_embedding_classification": [{"docstring": "Test EventSequencePredictor with embedding model for classification.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 13, "module": "tests.test_life_events_models", "name": "test_event_sequence_predictor_embedding_classification", "signature": "()", "symbol_type": "function"}], "test_event_sequence_predictor_not_fitted_error": [{"docstring": "Test that prediction fails if model not fitted.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 99, "module": "tests.test_life_events_models", "name": "test_event_sequence_predictor_not_fitted_error", "signature": "()", "symbol_type": "function"}], "test_event_sequence_predictor_predict_proba_classification_only": [{"docstring": "Test that predict_proba only works for classification.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 109, "module": "tests.test_life_events_models", "name": "test_event_sequence_predictor_predict_proba_classification_only", "signature": "()", "symbol_type": "function"}], "test_event_sequence_predictor_simple_regression": [{"docstring": "Test EventSequencePredictor with simple model for regression.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 45, "module": "tests.test_life_events_models", "name": "test_event_sequence_predictor_simple_regression", "signature": "()", "symbol_type": "function"}], "test_event_sequence_predictor_with_embeddings": [{"docstring": "Test EventSequencePredictor with pre-computed embeddings.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 69, "module": "tests.test_life_events_models", "name": "test_event_sequence_predictor_with_embeddings", "signature": "()", "symbol_type": "function"}], "test_event_sequence_to_dataframe": [{"docstring": "Test EventSequence DataFrame conversion.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 119, "module": "tests.test_life_events_events", "name": "test_event_sequence_to_dataframe", "signature": "()", "symbol_type": "function"}], "test_event_sequence_to_from_dict": [{"docstring": "Test EventSequence serialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 136, "module": "tests.test_life_events_events", "name": "test_event_sequence_to_from_dict", "signature": "()", "symbol_type": "function"}], "test_event_to_dict": [{"docstring": "Test event serialization to dictionary.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 70, "module": "tests.test_life_events", "name": "test_event_to_dict", "signature": "(self)", "symbol_type": "function"}], "test_event_to_from_dict": [{"docstring": "Test Event serialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 38, "module": "tests.test_life_events_events", "name": "test_event_to_from_dict", "signature": "()", "symbol_type": "function"}], "test_event_validation": [{"docstring": "Test Event validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_events.py", "line_number": 27, "module": "tests.test_life_events_events", "name": "test_event_validation", "signature": "()", "symbol_type": "function"}], "test_event_validation_empty_domain": [{"docstring": "Test that empty domain raises ValueError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 61, "module": "tests.test_life_events", "name": "test_event_validation_empty_domain", "signature": "(self)", "symbol_type": "function"}], "test_event_validation_empty_type": [{"docstring": "Test that empty event_type raises ValueError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 52, "module": "tests.test_life_events", "name": "test_event_validation_empty_type", "signature": "(self)", "symbol_type": "function"}], "test_expand_and_resolve_user": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_paths.py", "line_number": 9, "module": "tests.test_core_paths", "name": "test_expand_and_resolve_user", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_expansion_increases_sample_size": [{"docstring": "Test that expansion creates more sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 239, "module": "tests.test_simulation_popgen", "name": "test_expansion_increases_sample_size", "signature": "(self)", "symbol_type": "function"}], "test_expectation_and_variance_basic": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_price.py", "line_number": 23, "module": "tests.test_math_price", "name": "test_expectation_and_variance_basic", "signature": "()", "symbol_type": "function"}], "test_expected_index_path": [{"docstring": "Test expected index path generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/test_genome_prep.py", "line_number": 48, "module": "scripts.rna.test_genome_prep", "name": "test_expected_index_path", "signature": "()", "symbol_type": "function"}], "test_expected_package_layout_exists": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_repo_structure.py", "line_number": 4, "module": "tests.test_repo_structure", "name": "test_expected_package_layout_exists", "signature": "()", "symbol_type": "function"}], "test_expected_pairwise_diversity": [{"docstring": "Test expected pairwise diversity calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 185, "module": "tests.test_math_comprehensive", "name": "test_expected_pairwise_diversity", "signature": "(self)", "symbol_type": "function"}], "test_expected_pairwise_diversity_and_tajima_constants": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_coalescent_extras.py", "line_number": 6, "module": "tests.test_math_coalescent_extras", "name": "test_expected_pairwise_diversity_and_tajima_constants", "signature": "()", "symbol_type": "function"}], "test_expected_r2_from_Ne_c": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_ld_maps.py", "line_number": 20, "module": "tests.test_math_ld_maps", "name": "test_expected_r2_from_Ne_c", "signature": "()", "symbol_type": "function"}], "test_expected_segregating_sites": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_coalescent_expectations.py", "line_number": 6, "module": "tests.test_math_coalescent_expectations", "name": "test_expected_segregating_sites", "signature": "()", "symbol_type": "function"}], "test_expected_time_to_mrca": [{"docstring": "Test expected time to MRCA calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 173, "module": "tests.test_math_comprehensive", "name": "test_expected_time_to_mrca", "signature": "(self)", "symbol_type": "function"}], "test_expected_time_to_mrca_simple": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_coalescent.py", "line_number": 68, "module": "tests.test_math_coalescent", "name": "test_expected_time_to_mrca_simple", "signature": "()", "symbol_type": "function"}], "test_expected_total_branch_length_harmonic": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_coalescent.py", "line_number": 73, "module": "tests.test_math_coalescent", "name": "test_expected_total_branch_length_harmonic", "signature": "()", "symbol_type": "function"}], "test_export_import_csv": [{"docstring": "Test CSV export and import.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 418, "module": "tests.test_networks_graph", "name": "test_export_import_csv", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_export_import_json": [{"docstring": "Test JSON export and import.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 401, "module": "tests.test_networks_graph", "name": "test_export_import_json", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_export_import_roundtrip": [{"docstring": "Test network export and import round-trip.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 345, "module": "tests.test_networks_comprehensive", "name": "test_export_import_roundtrip", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_export_invalid_format": [{"docstring": "Test error handling for invalid export format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 432, "module": "tests.test_networks_graph", "name": "test_export_invalid_format", "signature": "(self)", "symbol_type": "function"}], "test_export_to_string_format": [{"docstring": "Test STRING format export.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 650, "module": "tests.test_networks_ppi", "name": "test_export_to_string_format", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_expression_heatmap": [{"docstring": "Test expression heatmap functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 289, "module": "tests.test_visualization_enhanced", "name": "test_expression_heatmap", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test expression heatmap functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 415, "module": "tests.test_visualization_enhanced", "name": "test_expression_heatmap", "signature": "(self)", "symbol_type": "function"}], "test_extract_subgraph": [{"docstring": "Test subgraph extraction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 459, "module": "tests.test_networks_graph", "name": "test_extract_subgraph", "signature": "(self)", "symbol_type": "function"}], "test_extract_variant_regions_bcftools_unavailable": [{"docstring": "Test region extraction when bcftools unavailable (should fail gracefully).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_download.py", "line_number": 56, "module": "tests.test_gwas_download", "name": "test_extract_variant_regions_bcftools_unavailable", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_extract_variant_regions_file_not_found": [{"docstring": "Test region extraction with non-existent VCF file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_download.py", "line_number": 76, "module": "tests.test_gwas_download", "name": "test_extract_variant_regions_file_not_found", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_extreme_quality_scores": [{"docstring": "Test handling of extreme quality scores.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 458, "module": "tests.test_quality_fastq", "name": "test_extreme_quality_scores", "signature": "(self)", "symbol_type": "function"}], "test_extreme_regulation_strengths": [{"docstring": "Test handling of extreme regulation strengths.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 633, "module": "tests.test_networks_regulatory", "name": "test_extreme_regulation_strengths", "signature": "(self)", "symbol_type": "function"}], "test_extreme_selection_coefficients": [{"docstring": "Test with extreme selection coefficients.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 353, "module": "tests.test_math_comprehensive", "name": "test_extreme_selection_coefficients", "signature": "(self)", "symbol_type": "function"}], "test_f_score_feature_selection": [{"docstring": "Test F-score based feature selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 50, "module": "tests.test_ml_features", "name": "test_f_score_feature_selection", "signature": "(self)", "symbol_type": "function"}], "test_fastq_dir_extraction_fallback": [{"docstring": "Test fastq_dir extraction fallback logic.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_validation.py", "line_number": 65, "module": "tests.test_rna_download_validation", "name": "test_fastq_dir_extraction_fallback", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_fastq_dir_extraction_from_params": [{"docstring": "Test that fastq_dir is correctly extracted from getfastq_params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_validation.py", "line_number": 22, "module": "tests.test_rna_download_validation", "name": "test_fastq_dir_extraction_from_params", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_fastq_dir_extraction_logic": [{"docstring": "Test fastq_dir extraction from getfastq_params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_steps_comprehensive.py", "line_number": 67, "module": "tests.test_rna_steps_comprehensive", "name": "test_fastq_dir_extraction_logic", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_fastq_dir_extraction_relative_path": [{"docstring": "Test fastq_dir extraction with relative path.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_validation.py", "line_number": 45, "module": "tests.test_rna_download_validation", "name": "test_fastq_dir_extraction_relative_path", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_fastq_edge_cases": [{"docstring": "Test edge cases in FASTQ processing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 361, "module": "tests.test_dna_comprehensive", "name": "test_fastq_edge_cases", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_fastq_iteration": [{"docstring": "Test FASTQ file iteration.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 294, "module": "tests.test_dna_comprehensive", "name": "test_fastq_iteration", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_fdr_correction_basic": [{"docstring": "Test basic FDR (Benjamini-Hochberg) correction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_correction.py", "line_number": 48, "module": "tests.test_gwas_correction", "name": "test_fdr_correction_basic", "signature": "() -> None", "symbol_type": "function"}], "test_fdr_correction_properties": [{"docstring": "Test FDR correction mathematical properties.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_correction.py", "line_number": 61, "module": "tests.test_gwas_correction", "name": "test_fdr_correction_properties", "signature": "() -> None", "symbol_type": "function"}], "test_feature_attribution": [{"docstring": "Test feature attribution computation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_interpretability.py", "line_number": 119, "module": "tests.test_life_events_interpretability", "name": "test_feature_attribution", "signature": "()", "symbol_type": "function"}], "test_feature_attribution_empty_sequences": [{"docstring": "Test feature attribution with empty sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_interpretability.py", "line_number": 147, "module": "tests.test_life_events_interpretability", "name": "test_feature_attribution_empty_sequences", "signature": "()", "symbol_type": "function"}], "test_feature_attribution_not_fitted": [{"docstring": "Test feature attribution with unfitted predictor.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_interpretability.py", "line_number": 136, "module": "tests.test_life_events_interpretability", "name": "test_feature_attribution_not_fitted", "signature": "()", "symbol_type": "function"}], "test_feature_selection_consistency": [{"docstring": "Test consistency across different feature selection methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 486, "module": "tests.test_ml_features", "name": "test_feature_selection_consistency", "signature": "(self)", "symbol_type": "function"}], "test_feature_selection_pipeline": [{"docstring": "Test complete feature selection pipeline.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 519, "module": "tests.test_ml_features", "name": "test_feature_selection_pipeline", "signature": "(self)", "symbol_type": "function"}], "test_fetch_alphafold_model_cif_format_real_network": [{"docstring": "Test real AlphaFold model download in CIF format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_alphafold_fetch.py", "line_number": 78, "module": "tests.test_protein_alphafold_fetch", "name": "test_fetch_alphafold_model_cif_format_real_network", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_fetch_alphafold_model_directory_creation": [{"docstring": "Test that output directory is created if it doesn't exist.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_alphafold_fetch.py", "line_number": 112, "module": "tests.test_protein_alphafold_fetch", "name": "test_fetch_alphafold_model_directory_creation", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_fetch_alphafold_model_invalid_format_error": [{"docstring": "Test that invalid format raises error before making HTTP request (no network required).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_alphafold_fetch.py", "line_number": 106, "module": "tests.test_protein_alphafold_fetch", "name": "test_fetch_alphafold_model_invalid_format_error", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_fetch_alphafold_model_nonexistent_protein": [{"docstring": "Test real behavior with non-existent protein ID.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_alphafold_fetch.py", "line_number": 96, "module": "tests.test_protein_alphafold_fetch", "name": "test_fetch_alphafold_model_nonexistent_protein", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_fetch_alphafold_model_real_network": [{"docstring": "Test real AlphaFold model download with actual HTTP requests.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_alphafold_fetch.py", "line_number": 57, "module": "tests.test_protein_alphafold_fetch", "name": "test_fetch_alphafold_model_real_network", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_fetch_interpro_domains_case_sensitivity": [{"docstring": "Test how real API handles case sensitivity.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_interpro.py", "line_number": 103, "module": "tests.test_protein_interpro", "name": "test_fetch_interpro_domains_case_sensitivity", "signature": "()", "symbol_type": "function"}], "test_fetch_interpro_domains_empty_accession": [{"docstring": "Test edge case: empty accession string.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_interpro.py", "line_number": 39, "module": "tests.test_protein_interpro", "name": "test_fetch_interpro_domains_empty_accession", "signature": "()", "symbol_type": "function"}], "test_fetch_interpro_domains_invalid_accession": [{"docstring": "Test behavior with clearly invalid accession.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_interpro.py", "line_number": 57, "module": "tests.test_protein_interpro", "name": "test_fetch_interpro_domains_invalid_accession", "signature": "()", "symbol_type": "function"}], "test_fetch_interpro_domains_multiple_proteins_real": [{"docstring": "Test with multiple different proteins to verify real API behavior.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_interpro.py", "line_number": 72, "module": "tests.test_protein_interpro", "name": "test_fetch_interpro_domains_multiple_proteins_real", "signature": "()", "symbol_type": "function"}], "test_fetch_interpro_domains_none_accession": [{"docstring": "Test edge case: None as accession.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_interpro.py", "line_number": 50, "module": "tests.test_protein_interpro", "name": "test_fetch_interpro_domains_none_accession", "signature": "()", "symbol_type": "function"}], "test_fetch_interpro_domains_offline_behavior": [{"docstring": "Document real offline behavior for InterPro queries.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_interpro.py", "line_number": 90, "module": "tests.test_protein_interpro", "name": "test_fetch_interpro_domains_offline_behavior", "signature": "()", "symbol_type": "function"}], "test_fetch_interpro_domains_real_network": [{"docstring": "Test real InterPro domain fetching with actual API calls.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_interpro.py", "line_number": 20, "module": "tests.test_protein_interpro", "name": "test_fetch_interpro_domains_real_network", "signature": "()", "symbol_type": "function"}], "test_fetch_interpro_domains_with_timeout": [{"docstring": "Test behavior with network timeout scenarios.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_interpro.py", "line_number": 123, "module": "tests.test_protein_interpro", "name": "test_fetch_interpro_domains_with_timeout", "signature": "()", "symbol_type": "function"}], "test_file_extension_handling": [{"docstring": "Test file extension utilities.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 296, "module": "tests.test_core_comprehensive", "name": "test_file_extension_handling", "signature": "(self)", "symbol_type": "function"}], "test_file_hashing": [{"docstring": "Test hashing file contents.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 163, "module": "tests.test_core_comprehensive", "name": "test_file_hashing", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_file_io_with_analysis": [{"docstring": "Test file I/O combined with analysis functions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 241, "module": "tests.test_core_functionality", "name": "test_file_io_with_analysis", "signature": "(self)", "symbol_type": "function"}], "test_file_size_operations": [{"docstring": "Test file size calculation operations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io_enhanced.py", "line_number": 189, "module": "tests.test_core_io_enhanced", "name": "test_file_size_operations", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_filesystem": [{"docstring": "Provide a test filesystem helper for testing.\n\nUses real file operations via tmp_path, following NO_MOCKING_POLICY.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 171, "module": "tests.conftest", "name": "test_filesystem", "signature": "(isolated_tmp_dir) -> TestFileSystem", "symbol_type": "function"}], "test_filter_by_confidence": [{"docstring": "Test filtering interactions by confidence threshold.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 121, "module": "tests.test_networks_ppi", "name": "test_filter_by_confidence", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test filtering regulations by confidence threshold.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 153, "module": "tests.test_networks_regulatory", "name": "test_filter_by_confidence", "signature": "(self)", "symbol_type": "function"}], "test_filter_by_evidence": [{"docstring": "Test filtering interactions by evidence type.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 135, "module": "tests.test_networks_ppi", "name": "test_filter_by_evidence", "signature": "(self)", "symbol_type": "function"}], "test_filter_by_namespace": [{"docstring": "Test filtering ontology by namespace.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 280, "module": "tests.test_ontology_query", "name": "test_filter_by_namespace", "signature": "(self)", "symbol_type": "function"}], "test_filter_by_regulation_type": [{"docstring": "Test filtering by regulation type.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 167, "module": "tests.test_networks_regulatory", "name": "test_filter_by_regulation_type", "signature": "(self)", "symbol_type": "function"}], "test_filter_cells": [{"docstring": "Test cell filtering.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 212, "module": "tests.test_singlecell_preprocessing", "name": "test_filter_cells", "signature": "(self)", "symbol_type": "function"}], "test_filter_cells_basic": [{"docstring": "Test basic cell filtering functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 75, "module": "tests.test_singlecell_basic", "name": "test_filter_cells_basic", "signature": "(self)", "symbol_type": "function"}], "test_filter_genes": [{"docstring": "Test gene filtering.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 228, "module": "tests.test_singlecell_preprocessing", "name": "test_filter_genes", "signature": "(self)", "symbol_type": "function"}], "test_filter_genes_basic": [{"docstring": "Test basic gene filtering functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 98, "module": "tests.test_singlecell_basic", "name": "test_filter_genes_basic", "signature": "(self)", "symbol_type": "function"}], "test_filter_network": [{"docstring": "Test network filtering.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 472, "module": "tests.test_networks_graph", "name": "test_filter_network", "signature": "(self)", "symbol_type": "function"}], "test_find_markers_basic": [{"docstring": "Test marker gene identification.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 360, "module": "tests.test_singlecell_basic", "name": "test_find_markers_basic", "signature": "(self)", "symbol_type": "function"}], "test_find_motif_positions_iupac": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_motifs.py", "line_number": 6, "module": "tests.test_dna_motifs", "name": "test_find_motif_positions_iupac", "signature": "() -> None", "symbol_type": "function"}], "test_find_orfs_simple": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_translation.py", "line_number": 11, "module": "tests.test_dna_translation", "name": "test_find_orfs_simple", "signature": "() -> None", "symbol_type": "function"}], "test_find_overlapping_pathways": [{"docstring": "Test finding pathways that share genes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 134, "module": "tests.test_networks_pathway", "name": "test_find_overlapping_pathways", "signature": "(self)", "symbol_type": "function"}], "test_find_restriction_sites_simple": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_restriction_sites.py", "line_number": 4, "module": "tests.test_dna_restriction_sites", "name": "test_find_restriction_sites_simple", "signature": "() -> None", "symbol_type": "function"}], "test_find_restriction_sites_with_ambiguity": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_restriction_sites.py", "line_number": 10, "module": "tests.test_dna_restriction_sites", "name": "test_find_restriction_sites_with_ambiguity", "signature": "() -> None", "symbol_type": "function"}], "test_find_rna_fasta": [{"docstring": "Test finding RNA FASTA in genome directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/test_genome_prep.py", "line_number": 24, "module": "scripts.rna.test_genome_prep", "name": "test_find_rna_fasta", "signature": "()", "symbol_type": "function"}], "test_find_symbol_class": [{"docstring": "Test finding a class symbol.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_symbols.py", "line_number": 60, "module": "tests.test_core_symbols", "name": "test_find_symbol_class", "signature": "(self)", "symbol_type": "function"}], "test_find_symbol_function": [{"docstring": "Test finding a function symbol.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_symbols.py", "line_number": 48, "module": "tests.test_core_symbols", "name": "test_find_symbol_function", "signature": "(self)", "symbol_type": "function"}], "test_find_symbol_nonexistent": [{"docstring": "Test finding nonexistent symbol.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_symbols.py", "line_number": 67, "module": "tests.test_core_symbols", "name": "test_find_symbol_nonexistent", "signature": "(self)", "symbol_type": "function"}], "test_find_symbol_references_common": [{"docstring": "Test finding references to a common symbol.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_symbols.py", "line_number": 97, "module": "tests.test_core_symbols", "name": "test_find_symbol_references_common", "signature": "(self)", "symbol_type": "function"}], "test_find_symbol_usage_common_function": [{"docstring": "Test finding usage of a common function.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_discovery.py", "line_number": 113, "module": "tests.test_core_discovery", "name": "test_find_symbol_usage_common_function", "signature": "(self)", "symbol_type": "function"}], "test_find_term_by_name_case_insensitive": [{"docstring": "Test case-insensitive matching.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 255, "module": "tests.test_ontology_query", "name": "test_find_term_by_name_case_insensitive", "signature": "(self)", "symbol_type": "function"}], "test_find_term_by_name_exact": [{"docstring": "Test finding term by exact name.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 239, "module": "tests.test_ontology_query", "name": "test_find_term_by_name_exact", "signature": "(self)", "symbol_type": "function"}], "test_find_term_by_name_partial": [{"docstring": "Test finding term by partial name.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 247, "module": "tests.test_ontology_query", "name": "test_find_term_by_name_partial", "signature": "(self)", "symbol_type": "function"}], "test_find_term_by_name_with_namespace": [{"docstring": "Test finding term with namespace filter.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 263, "module": "tests.test_ontology_query", "name": "test_find_term_by_name_with_namespace", "signature": "(self)", "symbol_type": "function"}], "test_fisher_exact_test": [{"docstring": "Test Fisher's exact test calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_enhanced.py", "line_number": 45, "module": "tests.test_math_enhanced", "name": "test_fisher_exact_test", "signature": "(self)", "symbol_type": "function"}], "test_fixation_probability_advantageous": [{"docstring": "Test fixation probability for advantageous allele.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 137, "module": "tests.test_math_comprehensive", "name": "test_fixation_probability_advantageous", "signature": "(self)", "symbol_type": "function"}], "test_fixation_probability_limits": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen.py", "line_number": 29, "module": "tests.test_math_popgen", "name": "test_fixation_probability_limits", "signature": "()", "symbol_type": "function"}], "test_fixation_probability_neutral": [{"docstring": "Test neutral fixation probability equals initial frequency.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 129, "module": "tests.test_math_comprehensive", "name": "test_fixation_probability_neutral", "signature": "(self)", "symbol_type": "function"}], "test_fixed_differences": [{"docstring": "Test with fixed differences between populations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 154, "module": "tests.test_dna_population_comprehensive", "name": "test_fixed_differences", "signature": "(self)", "symbol_type": "function"}], "test_folded_sfs": [{"docstring": "Test folded SFS generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 252, "module": "tests.test_simulation_popgen", "name": "test_folded_sfs", "signature": "(self)", "symbol_type": "function"}], "test_fst": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_egt_epi_fst_ne.py", "line_number": 32, "module": "tests.test_math_egt_epi_fst_ne", "name": "test_fst", "signature": "()", "symbol_type": "function"}], "test_fst_and_diversity_relationship": [{"docstring": "Test that Fst relates to diversity within and between populations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 258, "module": "tests.test_dna_population_comprehensive", "name": "test_fst_and_diversity_relationship", "signature": "(self)", "symbol_type": "function"}], "test_fst_fixed_differences_is_one": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_stats.py", "line_number": 18, "module": "tests.test_dna_population_stats", "name": "test_fst_fixed_differences_is_one", "signature": "() -> None", "symbol_type": "function"}], "test_full_community_analysis_workflow": [{"docstring": "Test complete community analysis workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 263, "module": "tests.test_networks_community", "name": "test_full_community_analysis_workflow", "signature": "(self)", "symbol_type": "function"}], "test_full_dimensionality_pipeline": [{"docstring": "Test complete pipeline from HVG selection to visualization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 478, "module": "tests.test_singlecell_dimensionality", "name": "test_full_dimensionality_pipeline", "signature": "(self)", "symbol_type": "function"}], "test_full_network_analysis_workflow": [{"docstring": "Test complete network analysis workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 318, "module": "tests.test_networks_graph", "name": "test_full_network_analysis_workflow", "signature": "(self)", "symbol_type": "function"}], "test_full_preprocessing_pipeline": [{"docstring": "Test complete preprocessing pipeline with real data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 332, "module": "tests.test_singlecell_preprocessing", "name": "test_full_preprocessing_pipeline", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_full_workflow": [{"docstring": "Test complete workflow from sequences to phenotypes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 275, "module": "tests.test_phenotype_life_course", "name": "test_full_workflow", "signature": "(self)", "symbol_type": "function"}], "test_functional_enrichment_basic": [{"docstring": "Test basic functional enrichment analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 393, "module": "tests.test_networks_ppi", "name": "test_functional_enrichment_basic", "signature": "(self)", "symbol_type": "function"}], "test_functional_enrichment_complex_analysis": [{"docstring": "Test enrichment analysis for protein complexes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 412, "module": "tests.test_networks_ppi", "name": "test_functional_enrichment_complex_analysis", "signature": "(self)", "symbol_type": "function"}], "test_functional_enrichment_no_annotation": [{"docstring": "Test enrichment when proteins lack functional annotations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 431, "module": "tests.test_networks_ppi", "name": "test_functional_enrichment_no_annotation", "signature": "(self)", "symbol_type": "function"}], "test_functional_enrichment_statistical_significance": [{"docstring": "Test statistical significance calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 448, "module": "tests.test_networks_ppi", "name": "test_functional_enrichment_statistical_significance", "signature": "(self)", "symbol_type": "function"}], "test_fuzzy_find_symbol_close_match": [{"docstring": "Test fuzzy finding with close match.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_symbols.py", "line_number": 126, "module": "tests.test_core_symbols", "name": "test_fuzzy_find_symbol_close_match", "signature": "(self)", "symbol_type": "function"}], "test_fuzzy_find_symbol_no_match": [{"docstring": "Test fuzzy finding with no close match.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_symbols.py", "line_number": 137, "module": "tests.test_core_symbols", "name": "test_fuzzy_find_symbol_no_match", "signature": "(self)", "symbol_type": "function"}], "test_gc_content_calculation": [{"docstring": "Test GC content calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 117, "module": "tests.test_core_functionality", "name": "test_gc_content_calculation", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test GC content calculation with various sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 27, "module": "tests.test_dna_comprehensive", "name": "test_gc_content_calculation", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test GC content calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 174, "module": "tests.test_quality_fastq", "name": "test_gc_content_calculation", "signature": "(self)", "symbol_type": "function"}], "test_gc_skew_and_cumulative": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_gc_skew_tm.py", "line_number": 4, "module": "tests.test_dna_gc_skew_tm", "name": "test_gc_skew_and_cumulative", "signature": "() -> None", "symbol_type": "function"}], "test_gc_skew_calculation": [{"docstring": "Test GC skew calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 129, "module": "tests.test_core_functionality", "name": "test_gc_skew_calculation", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test GC skew calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 53, "module": "tests.test_dna_comprehensive", "name": "test_gc_skew_calculation", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test GC skew calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 174, "module": "tests.test_dna_sequences_enhanced", "name": "test_gc_skew_calculation", "signature": "(self)", "symbol_type": "function"}], "test_generate_all_plots_basic": [{"docstring": "Test generating all plots via visualization suite.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization.py", "line_number": 133, "module": "tests.test_gwas_visualization", "name": "test_generate_all_plots_basic", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_generate_cohort_sequences": [{"docstring": "Test cohort sequence generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_simulation_advanced.py", "line_number": 99, "module": "tests.test_life_events_simulation_advanced", "name": "test_generate_cohort_sequences", "signature": "(tmp_path)", "symbol_type": "function"}], "test_generate_contamination_report_basic": [{"docstring": "Test basic contamination report generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_contamination.py", "line_number": 141, "module": "tests.test_quality_contamination", "name": "test_generate_contamination_report_basic", "signature": "(self)", "symbol_type": "function"}], "test_generate_contamination_report_empty": [{"docstring": "Test report generation with no contamination.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_contamination.py", "line_number": 157, "module": "tests.test_quality_contamination", "name": "test_generate_contamination_report_empty", "signature": "(self)", "symbol_type": "function"}], "test_generate_event_chain": [{"docstring": "Test event chain generation with transition probabilities.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_simulation_advanced.py", "line_number": 20, "module": "tests.test_life_events_simulation_advanced", "name": "test_generate_event_chain", "signature": "(tmp_path)", "symbol_type": "function"}], "test_generate_quality_report_basic": [{"docstring": "Test basic quality report generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 205, "module": "tests.test_quality_metrics", "name": "test_generate_quality_report_basic", "signature": "(self)", "symbol_type": "function"}], "test_generate_quality_report_empty": [{"docstring": "Test report generation with no quality data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 223, "module": "tests.test_quality_metrics", "name": "test_generate_quality_report_empty", "signature": "(self)", "symbol_type": "function"}], "test_generate_quality_report_excellent_quality": [{"docstring": "Test report generation with excellent quality scores.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_metrics.py", "line_number": 230, "module": "tests.test_quality_metrics", "name": "test_generate_quality_report_excellent_quality", "signature": "(self)", "symbol_type": "function"}], "test_generate_random_dna_basic": [{"docstring": "Test DNA sequence generation with proper length and nucleotides.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 15, "module": "tests.test_simulation", "name": "test_generate_random_dna_basic", "signature": "()", "symbol_type": "function"}], "test_generate_random_dna_edge_cases": [{"docstring": "Test DNA generation edge cases.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 28, "module": "tests.test_simulation", "name": "test_generate_random_dna_edge_cases", "signature": "()", "symbol_type": "function"}], "test_generate_random_protein_basic": [{"docstring": "Test protein sequence generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 77, "module": "tests.test_simulation", "name": "test_generate_random_protein_basic", "signature": "()", "symbol_type": "function"}], "test_generate_random_protein_edge_cases": [{"docstring": "Test protein generation edge cases.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 92, "module": "tests.test_simulation", "name": "test_generate_random_protein_edge_cases", "signature": "()", "symbol_type": "function"}], "test_generate_realistic_cooccurrence": [{"docstring": "Test realistic generation with co-occurrence patterns.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_simulation_advanced.py", "line_number": 128, "module": "tests.test_life_events_simulation_advanced", "name": "test_generate_realistic_cooccurrence", "signature": "(tmp_path)", "symbol_type": "function"}], "test_generate_realistic_life_events": [{"docstring": "Test realistic life events generation with advanced patterns.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_simulation_advanced.py", "line_number": 75, "module": "tests.test_life_events_simulation_advanced", "name": "test_generate_realistic_life_events", "signature": "(tmp_path)", "symbol_type": "function"}], "test_generate_realistic_with_noise": [{"docstring": "Test realistic generation with temporal noise and missing data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_simulation_advanced.py", "line_number": 114, "module": "tests.test_life_events_simulation_advanced", "name": "test_generate_realistic_with_noise", "signature": "(tmp_path)", "symbol_type": "function"}], "test_genomic_control_from_chi2": [{"docstring": "Test genomic control calculation from chi-square statistics.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_correction.py", "line_number": 93, "module": "tests.test_gwas_correction", "name": "test_genomic_control_from_chi2", "signature": "() -> None", "symbol_type": "function"}], "test_genomic_control_from_pvalues": [{"docstring": "Test genomic control calculation from p-values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_correction.py", "line_number": 79, "module": "tests.test_gwas_correction", "name": "test_genomic_control_from_pvalues", "signature": "() -> None", "symbol_type": "function"}], "test_genomic_control_inflation": [{"docstring": "Test genomic control detects inflation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_correction.py", "line_number": 111, "module": "tests.test_gwas_correction", "name": "test_genomic_control_inflation", "signature": "() -> None", "symbol_type": "function"}], "test_genomic_control_no_data": [{"docstring": "Test genomic control with no valid data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_correction.py", "line_number": 104, "module": "tests.test_gwas_correction", "name": "test_genomic_control_no_data", "signature": "() -> None", "symbol_type": "function"}], "test_genotype_matrix_comparison": [{"docstring": "Test comparison using genotype matrices.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_analysis.py", "line_number": 84, "module": "tests.test_dna_population_analysis", "name": "test_genotype_matrix_comparison", "signature": "(self)", "symbol_type": "function"}], "test_genotype_matrix_statistics": [{"docstring": "Test calculation from genotype matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_analysis.py", "line_number": 29, "module": "tests.test_dna_population_analysis", "name": "test_genotype_matrix_statistics", "signature": "(self)", "symbol_type": "function"}], "test_get_connected_components": [{"docstring": "Test connected component detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 483, "module": "tests.test_networks_graph", "name": "test_get_connected_components", "signature": "(self)", "symbol_type": "function"}], "test_get_db_client_with_config": [{"docstring": "Test database client creation with environment configuration.\n\nRequires:\n    - PG_HOST, PG_PORT, PG_DATABASE, PG_USER, PG_PASSWORD environment variables\n    - OR: DB_NAME, DB_USER, DB_PASSWORD, PG_HOST environment variables", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_db.py", "line_number": 74, "module": "tests.test_core_db", "name": "test_get_db_client_with_config", "signature": "(self)", "symbol_type": "function"}], "test_get_db_client_without_config": [{"docstring": "Test database client creation fails gracefully without configuration.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_db.py", "line_number": 99, "module": "tests.test_core_db", "name": "test_get_db_client_without_config", "signature": "(self)", "symbol_type": "function"}], "test_get_disk_space_info": [{"docstring": "Test getting comprehensive disk space information.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 73, "module": "tests.test_core_disk", "name": "test_get_disk_space_info", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_get_disk_usage_current_dir": [{"docstring": "Test getting disk usage for current directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 18, "module": "tests.test_core_disk", "name": "test_get_disk_usage_current_dir", "signature": "(self)", "symbol_type": "function"}], "test_get_disk_usage_nonexistent_path": [{"docstring": "Test getting disk usage for nonexistent path (should still work).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 35, "module": "tests.test_core_disk", "name": "test_get_disk_usage_nonexistent_path", "signature": "(self)", "symbol_type": "function"}], "test_get_disk_usage_output_dir": [{"docstring": "Test getting disk usage for temporary directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 27, "module": "tests.test_core_disk", "name": "test_get_disk_usage_output_dir", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_get_event_statistics": [{"docstring": "Test event statistics computation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_utils.py", "line_number": 132, "module": "tests.test_life_events_utils", "name": "test_get_event_statistics", "signature": "()", "symbol_type": "function"}], "test_get_event_statistics_empty": [{"docstring": "Test statistics with empty sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_utils.py", "line_number": 158, "module": "tests.test_life_events_utils", "name": "test_get_event_statistics_empty", "signature": "()", "symbol_type": "function"}], "test_get_gene_pathways": [{"docstring": "Test getting pathways for a gene.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 86, "module": "tests.test_networks_pathway", "name": "test_get_gene_pathways", "signature": "(self)", "symbol_type": "function"}], "test_get_layer": [{"docstring": "Test retrieving specific omics layer.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 51, "module": "tests.test_multiomics_comprehensive", "name": "test_get_layer", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test getting specific omics layers.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 126, "module": "tests.test_multiomics_integration", "name": "test_get_layer", "signature": "(self)", "symbol_type": "function"}], "test_get_layer_error": [{"docstring": "Test error when requesting non-existent layer.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 62, "module": "tests.test_multiomics_comprehensive", "name": "test_get_layer_error", "signature": "(self)", "symbol_type": "function"}], "test_get_leaves": [{"docstring": "Test getting leaf terms.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 313, "module": "tests.test_ontology_query", "name": "test_get_leaves", "signature": "(self)", "symbol_type": "function"}], "test_get_logger_returns_configured_logger": [{"docstring": "Test that get_logger returns a configured logger.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_logging.py", "line_number": 12, "module": "tests.test_core_logging", "name": "test_get_logger_returns_configured_logger", "signature": "() -> None", "symbol_type": "function"}], "test_get_logger_with_level": [{"docstring": "Test get_logger_with_level function.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_logging.py", "line_number": 19, "module": "tests.test_core_logging", "name": "test_get_logger_with_level", "signature": "() -> None", "symbol_type": "function"}], "test_get_logger_with_level_from_env": [{"docstring": "Test that get_logger_with_level reads from CORE_LOG_LEVEL env var.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_logging.py", "line_number": 29, "module": "tests.test_core_logging", "name": "test_get_logger_with_level_from_env", "signature": "(tmp_path, monkeypatch) -> None", "symbol_type": "function"}], "test_get_module_dependencies_core_io": [{"docstring": "Test getting dependencies for core/io module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_discovery.py", "line_number": 129, "module": "tests.test_core_discovery", "name": "test_get_module_dependencies_core_io", "signature": "(self)", "symbol_type": "function"}], "test_get_neighbors": [{"docstring": "Test neighbor retrieval.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 71, "module": "tests.test_networks_comprehensive", "name": "test_get_neighbors", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test neighbor finding functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 73, "module": "tests.test_networks_graph", "name": "test_get_neighbors", "signature": "(self)", "symbol_type": "function"}], "test_get_network_statistics": [{"docstring": "Test network statistics calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 148, "module": "tests.test_networks_ppi", "name": "test_get_network_statistics", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test GRN statistics calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 190, "module": "tests.test_networks_regulatory", "name": "test_get_network_statistics", "signature": "(self)", "symbol_type": "function"}], "test_get_pathway_genes": [{"docstring": "Test getting genes in a pathway.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 76, "module": "tests.test_networks_pathway", "name": "test_get_pathway_genes", "signature": "(self)", "symbol_type": "function"}], "test_get_pathway_statistics": [{"docstring": "Test pathway statistics calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 123, "module": "tests.test_networks_pathway", "name": "test_get_pathway_statistics", "signature": "(self)", "symbol_type": "function"}], "test_get_protein_partners": [{"docstring": "Test getting interaction partners of a protein.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 107, "module": "tests.test_networks_ppi", "name": "test_get_protein_partners", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test get_protein_partners method.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 611, "module": "tests.test_networks_ppi", "name": "test_get_protein_partners", "signature": "(self)", "symbol_type": "function"}], "test_get_recommended_batch_size_custom": [{"docstring": "Test getting recommended batch size with custom parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 113, "module": "tests.test_core_disk", "name": "test_get_recommended_batch_size_custom", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_get_recommended_batch_size_default": [{"docstring": "Test getting recommended batch size with default parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 107, "module": "tests.test_core_disk", "name": "test_get_recommended_batch_size_default", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_get_recommended_batch_size_large_samples": [{"docstring": "Test with large sample size (should reduce batch size).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 119, "module": "tests.test_core_disk", "name": "test_get_recommended_batch_size_large_samples", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_get_recommended_temp_dir": [{"docstring": "Test getting recommended temporary directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 129, "module": "tests.test_core_disk", "name": "test_get_recommended_temp_dir", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_get_recommended_temp_dir_with_output": [{"docstring": "Test with output directory present.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_disk.py", "line_number": 136, "module": "tests.test_core_disk", "name": "test_get_recommended_temp_dir_with_output", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_get_regulators": [{"docstring": "Test getting regulators of a gene.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 140, "module": "tests.test_networks_regulatory", "name": "test_get_regulators", "signature": "(self)", "symbol_type": "function"}], "test_get_regulators_and_targets": [{"docstring": "Test retrieving regulators and targets.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 272, "module": "tests.test_networks_comprehensive", "name": "test_get_regulators_and_targets", "signature": "(self)", "symbol_type": "function"}], "test_get_roots": [{"docstring": "Test getting root terms.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 298, "module": "tests.test_ontology_query", "name": "test_get_roots", "signature": "(self)", "symbol_type": "function"}], "test_get_symbol_metadata_existing": [{"docstring": "Test getting metadata for existing symbol.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_symbols.py", "line_number": 113, "module": "tests.test_core_symbols", "name": "test_get_symbol_metadata_existing", "signature": "(self)", "symbol_type": "function"}], "test_get_symbol_signature_existing": [{"docstring": "Test getting signature for existing symbol.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_symbols.py", "line_number": 79, "module": "tests.test_core_symbols", "name": "test_get_symbol_signature_existing", "signature": "(self)", "symbol_type": "function"}], "test_get_symbol_signature_nonexistent": [{"docstring": "Test getting signature for nonexistent symbol.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_symbols.py", "line_number": 86, "module": "tests.test_core_symbols", "name": "test_get_symbol_signature_nonexistent", "signature": "(self)", "symbol_type": "function"}], "test_get_targets": [{"docstring": "Test getting targets of a transcription factor.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 126, "module": "tests.test_networks_regulatory", "name": "test_get_targets", "signature": "(self)", "symbol_type": "function"}], "test_getfastq_basic_execution": [{"docstring": "Test getfastq step can execute with minimal params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 257, "module": "tests.test_rna_amalgkit_steps", "name": "test_getfastq_basic_execution", "signature": "(self, tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_getfastq_function_exists": [{"docstring": "Verify getfastq runner function is exported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 243, "module": "tests.test_rna_amalgkit_steps", "name": "test_getfastq_function_exists", "signature": "(self)", "symbol_type": "function"}], "test_getfastq_in_amalgkit_module": [{"docstring": "Verify getfastq function exists in amalgkit module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 252, "module": "tests.test_rna_amalgkit_steps", "name": "test_getfastq_in_amalgkit_module", "signature": "(self)", "symbol_type": "function"}], "test_getfastq_in_step_runners": [{"docstring": "Verify getfastq is in STEP_RUNNERS.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 247, "module": "tests.test_rna_amalgkit_steps", "name": "test_getfastq_in_step_runners", "signature": "(self)", "symbol_type": "function"}], "test_global_alignment_functionality": [{"docstring": "Test global alignment functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_alignment_enhanced.py", "line_number": 59, "module": "tests.test_dna_alignment_enhanced", "name": "test_global_alignment_functionality", "signature": "(self)", "symbol_type": "function"}], "test_global_alignment_score_and_lengths": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_alignment.py", "line_number": 8, "module": "tests.test_dna_alignment", "name": "test_global_alignment_score_and_lengths", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_gridworld_initialization": [{"docstring": "Test GridWorld agent-based simulation initialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 138, "module": "tests.test_simulation", "name": "test_gridworld_initialization", "signature": "()", "symbol_type": "function"}], "test_gridworld_multiple_steps": [{"docstring": "Test running multiple GridWorld simulation steps.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 171, "module": "tests.test_simulation", "name": "test_gridworld_multiple_steps", "signature": "()", "symbol_type": "function"}], "test_gridworld_step": [{"docstring": "Test GridWorld simulation step functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 152, "module": "tests.test_simulation", "name": "test_gridworld_step", "signature": "()", "symbol_type": "function"}], "test_grn_creation": [{"docstring": "Test creating GRN.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 264, "module": "tests.test_networks_comprehensive", "name": "test_grn_creation", "signature": "(self)", "symbol_type": "function"}], "test_grn_initialization": [{"docstring": "Test GeneRegulatoryNetwork initialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 59, "module": "tests.test_networks_regulatory", "name": "test_grn_initialization", "signature": "(self)", "symbol_type": "function"}], "test_gru_sequence_model": [{"docstring": "Test GRU sequence model.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models_advanced.py", "line_number": 44, "module": "tests.test_life_events_models_advanced", "name": "test_gru_sequence_model", "signature": "(tmp_path)", "symbol_type": "function"}], "test_gwas_network_analysis_pipeline": [{"docstring": "Test GWAS -> Gene Networks -> ML prediction pipeline.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_integration_comprehensive.py", "line_number": 562, "module": "tests.test_integration_comprehensive", "name": "test_gwas_network_analysis_pipeline", "signature": "(self)", "symbol_type": "function"}], "test_gwas_workflow_cli": [{"docstring": "Test GWAS workflow via CLI.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_workflow_comprehensive.py", "line_number": 117, "module": "tests.test_gwas_workflow_comprehensive", "name": "test_gwas_workflow_cli", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_gwas_workflow_config_defaults": [{"docstring": "Test GWASWorkflowConfig with default values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_config.py", "line_number": 90, "module": "tests.test_gwas_config", "name": "test_gwas_workflow_config_defaults", "signature": "() -> None", "symbol_type": "function"}], "test_gwas_workflow_config_only": [{"docstring": "Test GWAS workflow in check mode (configuration validation only).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_workflow_comprehensive.py", "line_number": 14, "module": "tests.test_gwas_workflow_comprehensive", "name": "test_gwas_workflow_config_only", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_gwas_workflow_genome_download": [{"docstring": "Test GWAS workflow with genome download (requires network).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_workflow_comprehensive.py", "line_number": 151, "module": "tests.test_gwas_workflow_comprehensive", "name": "test_gwas_workflow_genome_download", "signature": "(tmp_path: Path, pytestconfig) -> None", "symbol_type": "function"}], "test_gwas_workflow_invalid_config": [{"docstring": "Test GWAS workflow with invalid configuration.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_workflow_comprehensive.py", "line_number": 186, "module": "tests.test_gwas_workflow_comprehensive", "name": "test_gwas_workflow_invalid_config", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_gwas_workflow_missing_phenotype": [{"docstring": "Test GWAS workflow with missing phenotype file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_workflow_comprehensive.py", "line_number": 200, "module": "tests.test_gwas_workflow_comprehensive", "name": "test_gwas_workflow_missing_phenotype", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_gwas_workflow_with_vcf_file": [{"docstring": "Test full GWAS workflow with pre-existing VCF file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_workflow_comprehensive.py", "line_number": 38, "module": "tests.test_gwas_workflow_comprehensive", "name": "test_gwas_workflow_with_vcf_file", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_gzipped_json_io": [{"docstring": "Test gzipped JSON I/O operations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io_enhanced.py", "line_number": 96, "module": "tests.test_core_io_enhanced", "name": "test_gzipped_json_io", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_haldane_and_kosambi_mapping_functions": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_ld_maps.py", "line_number": 6, "module": "tests.test_math_ld_maps", "name": "test_haldane_and_kosambi_mapping_functions", "signature": "()", "symbol_type": "function"}], "test_haploid": [{"docstring": "Test haploid genotype generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 186, "module": "tests.test_simulation_popgen", "name": "test_haploid", "signature": "(self)", "symbol_type": "function"}], "test_hardy_weinberg_equilibrium": [{"docstring": "Test Hardy-Weinberg genotype frequency calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 88, "module": "tests.test_math_comprehensive", "name": "test_hardy_weinberg_equilibrium", "signature": "(self)", "symbol_type": "function"}], "test_hardy_weinberg_genotype_freqs": [{"docstring": "Test Hardy-Weinberg genotype frequency calculations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 205, "module": "tests.test_core_functionality", "name": "test_hardy_weinberg_genotype_freqs", "signature": "(self)", "symbol_type": "function"}], "test_hardy_weinberg_genotype_freqs_basic": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen.py", "line_number": 6, "module": "tests.test_math_popgen", "name": "test_hardy_weinberg_genotype_freqs_basic", "signature": "()", "symbol_type": "function"}], "test_hash_operations": [{"docstring": "Test byte hashing for reproducibility.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 79, "module": "tests.test_core_functionality", "name": "test_hash_operations", "signature": "(self)", "symbol_type": "function"}], "test_heatmap_basic": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization.py", "line_number": 37, "module": "tests.test_visualization", "name": "test_heatmap_basic", "signature": "()", "symbol_type": "function"}], "test_herd_immunity_threshold": [{"docstring": "Test herd immunity threshold calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 235, "module": "tests.test_math_comprehensive", "name": "test_herd_immunity_threshold", "signature": "(self)", "symbol_type": "function"}], "test_heterozygosity_and_inbreeding_drift": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_drift_migration.py", "line_number": 13, "module": "tests.test_math_drift_migration", "name": "test_heterozygosity_and_inbreeding_drift", "signature": "()", "symbol_type": "function"}], "test_heterozygosity_decay": [{"docstring": "Test heterozygosity decay under drift.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 158, "module": "tests.test_math_comprehensive", "name": "test_heterozygosity_decay", "signature": "(self)", "symbol_type": "function"}], "test_hierarchical_communities": [{"docstring": "Test hierarchical community detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 384, "module": "tests.test_networks_community", "name": "test_hierarchical_communities", "signature": "(self)", "symbol_type": "function"}], "test_hierarchical_community_detection": [{"docstring": "Test hierarchical community detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 362, "module": "tests.test_networks_comprehensive", "name": "test_hierarchical_community_detection", "signature": "(self)", "symbol_type": "function"}], "test_high_fst": [{"docstring": "Test high Fst scenario.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 120, "module": "tests.test_simulation_popgen", "name": "test_high_fst", "signature": "(self)", "symbol_type": "function"}], "test_highdimensional_data_handling": [{"docstring": "Test handling of high-dimensional biological data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_integration_comprehensive.py", "line_number": 517, "module": "tests.test_integration_comprehensive", "name": "test_highdimensional_data_handling", "signature": "(self)", "symbol_type": "function"}], "test_histogram_functionality": [{"docstring": "Test enhanced histogram functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 45, "module": "tests.test_visualization_enhanced", "name": "test_histogram_functionality", "signature": "(self)", "symbol_type": "function"}], "test_hwe": [{"docstring": "Test Hardy-Weinberg equilibrium for a variant.\n\nArgs:\n    genotypes: List of genotypes for one variant (0=homREF, 1=het, 2=homALT, -1=missing)\n\nReturns:\n    Tuple of (chi2_statistic, p_value)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/quality.py", "line_number": 237, "module": "src.metainformant.gwas.quality", "name": "test_hwe", "signature": "(genotypes: list[int]) -> tuple[float, float]", "symbol_type": "function"}], "test_hwe_vs_non_hwe": [{"docstring": "Test Hardy-Weinberg equilibrium vs non-HWE.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 163, "module": "tests.test_simulation_popgen", "name": "test_hwe_vs_non_hwe", "signature": "(self)", "symbol_type": "function"}], "test_identical_distributions": [{"docstring": "Test that identical distributions have JS divergence = 0.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 232, "module": "tests.test_math_utilities", "name": "test_identical_distributions", "signature": "(self)", "symbol_type": "function"}], "test_identical_populations": [{"docstring": "Test comparison of identical populations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_analysis.py", "line_number": 75, "module": "tests.test_dna_population_analysis", "name": "test_identical_populations", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test with identical populations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 161, "module": "tests.test_dna_population_comprehensive", "name": "test_identical_populations", "signature": "(self)", "symbol_type": "function"}], "test_identical_sequences": [{"docstring": "Test with all identical sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 103, "module": "tests.test_dna_population_comprehensive", "name": "test_identical_sequences", "signature": "(self)", "symbol_type": "function"}], "test_inbreeding_from_fst": [{"docstring": "Test inbreeding coefficient estimation from F_ST.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_enhanced.py", "line_number": 99, "module": "tests.test_math_enhanced", "name": "test_inbreeding_from_fst", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test inbreeding coefficient estimation from F_ST.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_enhanced.py", "line_number": 35, "module": "tests.test_math_popgen_enhanced", "name": "test_inbreeding_from_fst", "signature": "(self)", "symbol_type": "function"}], "test_index_classes_repo_root": [{"docstring": "Test indexing classes in repository.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_symbols.py", "line_number": 36, "module": "tests.test_core_symbols", "name": "test_index_classes_repo_root", "signature": "(self)", "symbol_type": "function"}], "test_index_functions_repo_root": [{"docstring": "Test indexing functions in repository.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_symbols.py", "line_number": 18, "module": "tests.test_core_symbols", "name": "test_index_functions_repo_root", "signature": "(self)", "symbol_type": "function"}], "test_index_functions_with_cache": [{"docstring": "Test indexing functions with cache enabled.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_symbols.py", "line_number": 26, "module": "tests.test_core_symbols", "name": "test_index_functions_with_cache", "signature": "(self)", "symbol_type": "function"}], "test_infer_grn_basic": [{"docstring": "Test basic GRN inference.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 259, "module": "tests.test_networks_regulatory", "name": "test_infer_grn_basic", "signature": "(self)", "symbol_type": "function"}], "test_infer_grn_correlation": [{"docstring": "Test GRN inference from expression data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 285, "module": "tests.test_networks_comprehensive", "name": "test_infer_grn_correlation", "signature": "(self)", "symbol_type": "function"}], "test_infer_grn_different_methods": [{"docstring": "Test GRN inference with different methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 291, "module": "tests.test_networks_regulatory", "name": "test_infer_grn_different_methods", "signature": "(self)", "symbol_type": "function"}], "test_infer_grn_small_dataset": [{"docstring": "Test GRN inference with small dataset.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 329, "module": "tests.test_networks_regulatory", "name": "test_infer_grn_small_dataset", "signature": "(self)", "symbol_type": "function"}], "test_infer_grn_thresholds": [{"docstring": "Test effect of different thresholds on GRN inference.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 311, "module": "tests.test_networks_regulatory", "name": "test_infer_grn_thresholds", "signature": "(self)", "symbol_type": "function"}], "test_infer_grn_with_tf_prior": [{"docstring": "Test GRN inference with TF prior knowledge.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 271, "module": "tests.test_networks_regulatory", "name": "test_infer_grn_with_tf_prior", "signature": "(self)", "symbol_type": "function"}], "test_information_coefficient": [{"docstring": "Test information coefficient.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 345, "module": "tests.test_information_comprehensive", "name": "test_information_coefficient", "signature": "(self)", "symbol_type": "function"}], "test_information_content": [{"docstring": "Test information content calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 120, "module": "tests.test_information_comprehensive", "name": "test_information_content", "signature": "(self)", "symbol_type": "function"}], "test_information_content_from_annotations_exported": [{"docstring": "Test that information_content_from_annotations is accessible from main import.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 505, "module": "tests.test_information_comprehensive", "name": "test_information_content_from_annotations_exported", "signature": "(self)", "symbol_type": "function"}], "test_information_content_not_found": [{"docstring": "Test information content for non-existent term.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 127, "module": "tests.test_information_comprehensive", "name": "test_information_content_not_found", "signature": "(self)", "symbol_type": "function"}], "test_information_flow": [{"docstring": "Test information flow calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 281, "module": "tests.test_information_integration", "name": "test_information_flow", "signature": "(self)", "symbol_type": "function"}], "test_information_profile": [{"docstring": "Test information profile calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 168, "module": "tests.test_information_comprehensive", "name": "test_information_profile", "signature": "(self)", "symbol_type": "function"}], "test_information_profile_empty": [{"docstring": "Test information profile with empty sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 177, "module": "tests.test_information_comprehensive", "name": "test_information_profile_empty", "signature": "(self)", "symbol_type": "function"}], "test_information_profile_with_dna_sequences": [{"docstring": "Test information profile with DNA-like sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 263, "module": "tests.test_information_comprehensive", "name": "test_information_profile_with_dna_sequences", "signature": "(self)", "symbol_type": "function"}], "test_information_signature_entropy": [{"docstring": "Test information signature with entropy method.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 182, "module": "tests.test_information_comprehensive", "name": "test_information_signature_entropy", "signature": "(self)", "symbol_type": "function"}], "test_information_to_visualization_pipeline": [{"docstring": "Test pipeline from information analysis to visualization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 320, "module": "tests.test_information_integration", "name": "test_information_to_visualization_pipeline", "signature": "(self)", "symbol_type": "function"}], "test_information_workflow": [{"docstring": "Test complete information workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 441, "module": "tests.test_information_comprehensive", "name": "test_information_workflow", "signature": "(self)", "symbol_type": "function"}], "test_input_validation": [{"docstring": "Test input validation for all new functions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_enhanced.py", "line_number": 125, "module": "tests.test_math_enhanced", "name": "test_input_validation", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test input validation for all new functions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_enhanced.py", "line_number": 89, "module": "tests.test_math_popgen_enhanced", "name": "test_input_validation", "signature": "(self)", "symbol_type": "function"}], "test_insufficient_sequences": [{"docstring": "Test with less than 2 sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 144, "module": "tests.test_dna_population_comprehensive", "name": "test_insufficient_sequences", "signature": "(self)", "symbol_type": "function"}], "test_integrate_basic_execution": [{"docstring": "Test integrate step can execute with minimal params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 148, "module": "tests.test_rna_amalgkit_steps", "name": "test_integrate_basic_execution", "signature": "(self, tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_integrate_from_dataframes": [{"docstring": "Test integration from pandas DataFrames.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 108, "module": "tests.test_multiomics_comprehensive", "name": "test_integrate_from_dataframes", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test integration from DataFrame dictionary.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 181, "module": "tests.test_multiomics_integration", "name": "test_integrate_from_dataframes", "signature": "(self)", "symbol_type": "function"}], "test_integrate_from_files": [{"docstring": "Test integration from file paths.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 120, "module": "tests.test_multiomics_comprehensive", "name": "test_integrate_from_files", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}, {"docstring": "Test integration from CSV files.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 219, "module": "tests.test_multiomics_integration", "name": "test_integrate_from_files", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_integrate_function_exists": [{"docstring": "Verify integrate runner function is exported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 134, "module": "tests.test_rna_amalgkit_steps", "name": "test_integrate_function_exists", "signature": "(self)", "symbol_type": "function"}], "test_integrate_in_amalgkit_module": [{"docstring": "Verify integrate function exists in amalgkit module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 143, "module": "tests.test_rna_amalgkit_steps", "name": "test_integrate_in_amalgkit_module", "signature": "(self)", "symbol_type": "function"}], "test_integrate_in_step_runners": [{"docstring": "Verify integrate is in STEP_RUNNERS.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 138, "module": "tests.test_rna_amalgkit_steps", "name": "test_integrate_in_step_runners", "signature": "(self)", "symbol_type": "function"}], "test_integrate_omics_mapping_preserves_data": [{"docstring": "Test that sample mapping preserves data integrity.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_sample_mapping.py", "line_number": 144, "module": "tests.test_multiomics_sample_mapping", "name": "test_integrate_omics_mapping_preserves_data", "signature": "(self)", "symbol_type": "function"}], "test_integrate_omics_with_both_mappings": [{"docstring": "Test integration with both sample and feature mapping.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_sample_mapping.py", "line_number": 79, "module": "tests.test_multiomics_sample_mapping", "name": "test_integrate_omics_with_both_mappings", "signature": "(self)", "symbol_type": "function"}], "test_integrate_omics_with_feature_mapping": [{"docstring": "Test integration with feature ID mapping.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_sample_mapping.py", "line_number": 49, "module": "tests.test_multiomics_sample_mapping", "name": "test_integrate_omics_with_feature_mapping", "signature": "(self)", "symbol_type": "function"}], "test_integrate_omics_with_metadata_mapping": [{"docstring": "Test integration with metadata and sample mapping.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_sample_mapping.py", "line_number": 115, "module": "tests.test_multiomics_sample_mapping", "name": "test_integrate_omics_with_metadata_mapping", "signature": "(self)", "symbol_type": "function"}], "test_integrate_omics_with_sample_mapping": [{"docstring": "Test integration with sample ID mapping.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_sample_mapping.py", "line_number": 12, "module": "tests.test_multiomics_sample_mapping", "name": "test_integrate_omics_with_sample_mapping", "signature": "(self)", "symbol_type": "function"}], "test_integrate_with_metadata": [{"docstring": "Test integration with metadata.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 201, "module": "tests.test_multiomics_integration", "name": "test_integrate_with_metadata", "signature": "(self)", "symbol_type": "function"}], "test_integration_embedding_to_classifier": [{"docstring": "Test embedding to classifier pipeline.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_integration.py", "line_number": 123, "module": "tests.test_life_events_integration", "name": "test_integration_embedding_to_classifier", "signature": "()", "symbol_type": "function"}], "test_integration_with_ml_module": [{"docstring": "Test integration with ML module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_integration.py", "line_number": 23, "module": "tests.test_life_events_integration", "name": "test_integration_with_ml_module", "signature": "()", "symbol_type": "function"}], "test_integration_with_phenotype_module": [{"docstring": "Test integration with phenotype module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_integration.py", "line_number": 49, "module": "tests.test_life_events_integration", "name": "test_integration_with_phenotype_module", "signature": "()", "symbol_type": "function"}], "test_integration_with_visualization_module": [{"docstring": "Test integration with visualization module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_integration.py", "line_number": 72, "module": "tests.test_life_events_integration", "name": "test_integration_with_visualization_module", "signature": "()", "symbol_type": "function"}], "test_integration_workflow_with_ml": [{"docstring": "Test complete workflow with ML integration.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_integration.py", "line_number": 97, "module": "tests.test_life_events_integration", "name": "test_integration_workflow_with_ml", "signature": "(tmp_path)", "symbol_type": "function"}], "test_interpretation_negative_d": [{"docstring": "Test negative Tajima's D interpretation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_analysis.py", "line_number": 120, "module": "tests.test_dna_population_analysis", "name": "test_interpretation_negative_d", "signature": "(self)", "symbol_type": "function"}], "test_interpretation_positive_d": [{"docstring": "Test positive Tajima's D interpretation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_analysis.py", "line_number": 130, "module": "tests.test_dna_population_analysis", "name": "test_interpretation_positive_d", "signature": "(self)", "symbol_type": "function"}], "test_intervention_analysis": [{"docstring": "Test intervention analysis workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_workflow.py", "line_number": 109, "module": "tests.test_life_events_workflow", "name": "test_intervention_analysis", "signature": "(tmp_path)", "symbol_type": "function"}], "test_intervention_analysis_with_outcomes": [{"docstring": "Test intervention analysis with outcome comparison.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_workflow.py", "line_number": 135, "module": "tests.test_life_events_workflow", "name": "test_intervention_analysis_with_outcomes", "signature": "(tmp_path)", "symbol_type": "function"}], "test_invalid_algorithm_error": [{"docstring": "Test error handling for invalid algorithm.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 312, "module": "tests.test_networks_community", "name": "test_invalid_algorithm_error", "signature": "(self)", "symbol_type": "function"}], "test_invalid_algorithms": [{"docstring": "Test error handling for invalid algorithms.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 694, "module": "tests.test_ml_comprehensive", "name": "test_invalid_algorithms", "signature": "(self)", "symbol_type": "function"}], "test_invalid_confidence_values": [{"docstring": "Test handling of invalid confidence values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 573, "module": "tests.test_networks_ppi", "name": "test_invalid_confidence_values", "signature": "(self)", "symbol_type": "function"}], "test_invalid_config_file": [{"docstring": "Test handling of invalid config files.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 236, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_invalid_config_file", "signature": "(self)", "symbol_type": "function"}], "test_invalid_custom_categories": [{"docstring": "Test invalid custom categories.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 102, "module": "tests.test_phenotype_life_course", "name": "test_invalid_custom_categories", "signature": "(self)", "symbol_type": "function"}], "test_invalid_data_type_error": [{"docstring": "Test error with invalid data types.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 121, "module": "tests.test_multiomics_integration", "name": "test_invalid_data_type_error", "signature": "(self)", "symbol_type": "function"}], "test_invalid_frequencies": [{"docstring": "Test functions with invalid frequency inputs.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 344, "module": "tests.test_math_comprehensive", "name": "test_invalid_frequencies", "signature": "(self)", "symbol_type": "function"}], "test_invalid_input_handling": [{"docstring": "Test handling of invalid inputs.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 298, "module": "tests.test_core_functionality", "name": "test_invalid_input_handling", "signature": "(self)", "symbol_type": "function"}], "test_invalid_json": [{"docstring": "Test handling invalid JSON.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_comprehensive.py", "line_number": 57, "module": "tests.test_phenotype_comprehensive", "name": "test_invalid_json", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_invalid_method_error": [{"docstring": "Test error handling for invalid method.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 92, "module": "tests.test_ml_features", "name": "test_invalid_method_error", "signature": "(self)", "symbol_type": "function"}], "test_invalid_normalization_method": [{"docstring": "Test invalid normalization method raises error.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 444, "module": "tests.test_singlecell_preprocessing", "name": "test_invalid_normalization_method", "signature": "(self)", "symbol_type": "function"}], "test_invalid_pvalues": [{"docstring": "Test handling of invalid p-values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 241, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_invalid_pvalues", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_invalid_regulation_types": [{"docstring": "Test handling of invalid regulation types.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 618, "module": "tests.test_networks_regulatory", "name": "test_invalid_regulation_types", "signature": "(self)", "symbol_type": "function"}], "test_invalid_sequences_type": [{"docstring": "Test that non-list sequences raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 169, "module": "tests.test_phenotype_life_course", "name": "test_invalid_sequences_type", "signature": "(self)", "symbol_type": "function"}], "test_invalid_time_window": [{"docstring": "Test that invalid time window raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 174, "module": "tests.test_phenotype_life_course", "name": "test_invalid_time_window", "signature": "(self)", "symbol_type": "function"}], "test_invalid_trait_mapping": [{"docstring": "Test invalid trait mapping.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 244, "module": "tests.test_phenotype_life_course", "name": "test_invalid_trait_mapping", "signature": "(self)", "symbol_type": "function"}], "test_io_error_handling": [{"docstring": "Test error handling in I/O operations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io_enhanced.py", "line_number": 175, "module": "tests.test_core_io_enhanced", "name": "test_io_error_handling", "signature": "(self)", "symbol_type": "function"}], "test_is_valid_assembly_accession_invalid_cases": [{"docstring": "Test that invalid NCBI assembly accession formats are rejected.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_accession.py", "line_number": 10, "module": "tests.test_dna_accession", "name": "test_is_valid_assembly_accession_invalid_cases", "signature": "()", "symbol_type": "function"}], "test_is_valid_assembly_accession_valid_cases": [{"docstring": "Test that valid NCBI assembly accession formats are recognized.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_accession.py", "line_number": 4, "module": "tests.test_dna_accession", "name": "test_is_valid_assembly_accession_valid_cases", "signature": "()", "symbol_type": "function"}], "test_is_within": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_paths.py", "line_number": 24, "module": "tests.test_core_paths", "name": "test_is_within", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_island_model_update_and_mutation_selection_balance": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_drift_migration.py", "line_number": 33, "module": "tests.test_math_drift_migration", "name": "test_island_model_update_and_mutation_selection_balance", "signature": "()", "symbol_type": "function"}], "test_iter_fastq_and_head": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_fastq.py", "line_number": 25, "module": "tests.test_dna_fastq", "name": "test_iter_fastq_and_head", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_iter_fastq_gz": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_fastq.py", "line_number": 48, "module": "tests.test_dna_fastq", "name": "test_iter_fastq_gz", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_jc69_distance": [{"docstring": "Test Jukes-Cantor 69 corrected distance.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 150, "module": "tests.test_dna_comprehensive", "name": "test_jc69_distance", "signature": "(self)", "symbol_type": "function"}], "test_jensen_shannon_divergence": [{"docstring": "Test Jensen-Shannon divergence.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 299, "module": "tests.test_information_comprehensive", "name": "test_jensen_shannon_divergence", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test Jensen-Shannon divergence calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_enhanced.py", "line_number": 70, "module": "tests.test_math_enhanced", "name": "test_jensen_shannon_divergence", "signature": "(self)", "symbol_type": "function"}], "test_joint_nmf_basic": [{"docstring": "Test basic joint NMF.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 192, "module": "tests.test_multiomics_comprehensive", "name": "test_joint_nmf_basic", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test basic joint NMF functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 350, "module": "tests.test_multiomics_integration", "name": "test_joint_nmf_basic", "signature": "(self)", "symbol_type": "function"}], "test_joint_nmf_reconstruction": [{"docstring": "Test NMF reconstruction quality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 377, "module": "tests.test_multiomics_integration", "name": "test_joint_nmf_reconstruction", "signature": "(self)", "symbol_type": "function"}], "test_joint_nmf_reproducibility": [{"docstring": "Test NMF reproducibility with fixed seed.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 367, "module": "tests.test_multiomics_integration", "name": "test_joint_nmf_reproducibility", "signature": "(self)", "symbol_type": "function"}], "test_joint_nmf_with_regularization": [{"docstring": "Test joint NMF with different regularization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 213, "module": "tests.test_multiomics_comprehensive", "name": "test_joint_nmf_with_regularization", "signature": "(self)", "symbol_type": "function"}], "test_joint_pca_basic": [{"docstring": "Test basic joint PCA.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 143, "module": "tests.test_multiomics_comprehensive", "name": "test_joint_pca_basic", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test basic joint PCA functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 279, "module": "tests.test_multiomics_integration", "name": "test_joint_pca_basic", "signature": "(self)", "symbol_type": "function"}], "test_joint_pca_no_standardization": [{"docstring": "Test joint PCA without standardization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 310, "module": "tests.test_multiomics_integration", "name": "test_joint_pca_no_standardization", "signature": "(self)", "symbol_type": "function"}], "test_joint_pca_single_layer": [{"docstring": "Test joint PCA with single omics layer.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 317, "module": "tests.test_multiomics_integration", "name": "test_joint_pca_single_layer", "signature": "(self)", "symbol_type": "function"}], "test_joint_pca_standardization": [{"docstring": "Test joint PCA with and without standardization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 171, "module": "tests.test_multiomics_comprehensive", "name": "test_joint_pca_standardization", "signature": "(self)", "symbol_type": "function"}], "test_joint_pca_with_weights": [{"docstring": "Test joint PCA with layer weights.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 159, "module": "tests.test_multiomics_comprehensive", "name": "test_joint_pca_with_weights", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test joint PCA with layer weights.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 299, "module": "tests.test_multiomics_integration", "name": "test_joint_pca_with_weights", "signature": "(self)", "symbol_type": "function"}], "test_js_divergence_large_distributions": [{"docstring": "Test JS divergence with many outcomes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 313, "module": "tests.test_math_utilities", "name": "test_js_divergence_large_distributions", "signature": "(self)", "symbol_type": "function"}], "test_json_cache_roundtrip": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_cache.py", "line_number": 8, "module": "tests.test_core_cache", "name": "test_json_cache_roundtrip", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_json_cache_ttl_expired": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_cache.py", "line_number": 17, "module": "tests.test_core_cache", "name": "test_json_cache_ttl_expired", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_json_gz_roundtrip": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io.py", "line_number": 24, "module": "tests.test_core_io", "name": "test_json_gz_roundtrip", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_json_operations": [{"docstring": "Test JSON read/write operations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 42, "module": "tests.test_core_functionality", "name": "test_json_operations", "signature": "(self)", "symbol_type": "function"}], "test_json_roundtrip": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io.py", "line_number": 16, "module": "tests.test_core_io", "name": "test_json_roundtrip", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_json_with_compression": [{"docstring": "Test JSON I/O with compression using gzip extension.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 189, "module": "tests.test_core_comprehensive", "name": "test_json_with_compression", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_jsonl_roundtrip": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io.py", "line_number": 32, "module": "tests.test_core_io", "name": "test_jsonl_roundtrip", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_k_fold_split": [{"docstring": "Test k-fold cross-validation splitting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 447, "module": "tests.test_ml_comprehensive", "name": "test_k_fold_split", "signature": "(self)", "symbol_type": "function"}], "test_k_larger_than_features": [{"docstring": "Test behavior when k is larger than number of features.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 111, "module": "tests.test_ml_features", "name": "test_k_larger_than_features", "signature": "(self)", "symbol_type": "function"}], "test_kabsch_rmsd_invariant_to_rotation_translation": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_structure_rmsd.py", "line_number": 14, "module": "tests.test_protein_structure_rmsd", "name": "test_kabsch_rmsd_invariant_to_rotation_translation", "signature": "()", "symbol_type": "function"}], "test_kabsch_rmsd_zero_for_identical": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_structure_rmsd.py", "line_number": 6, "module": "tests.test_protein_structure_rmsd", "name": "test_kabsch_rmsd_zero_for_identical", "signature": "()", "symbol_type": "function"}], "test_kallisto_available": [{"docstring": "Verify kallisto is installed (required for quantification).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 176, "module": "tests.test_rna_ena_workflow", "name": "test_kallisto_available", "signature": "(self)", "symbol_type": "function"}], "test_kallisto_index_exists": [{"docstring": "Verify kallisto index exists for C. floridanus.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 108, "module": "tests.test_rna_ena_workflow", "name": "test_kallisto_index_exists", "signature": "(self)", "symbol_type": "function"}], "test_key_normalization_hyphens": [{"docstring": "Test that hyphenated keys are normalized.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 556, "module": "tests.test_rna_amalgkit_steps", "name": "test_key_normalization_hyphens", "signature": "(self)", "symbol_type": "function"}], "test_key_normalization_underscores": [{"docstring": "Test that underscored keys work.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 549, "module": "tests.test_rna_amalgkit_steps", "name": "test_key_normalization_underscores", "signature": "(self)", "symbol_type": "function"}], "test_kimura_2p_distance": [{"docstring": "Test Kimura 2-parameter distance.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 169, "module": "tests.test_dna_comprehensive", "name": "test_kimura_2p_distance", "signature": "(self)", "symbol_type": "function"}], "test_kin_selection_favored": [{"docstring": "Test when kin selection favors trait (r*b > c).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_selection.py", "line_number": 19, "module": "tests.test_math_selection", "name": "test_kin_selection_favored", "signature": "(self)", "symbol_type": "function"}], "test_kin_selection_hamiltons_rule": [{"docstring": "Test Hamilton's rule calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 306, "module": "tests.test_math_comprehensive", "name": "test_kin_selection_hamiltons_rule", "signature": "(self)", "symbol_type": "function"}], "test_kin_selection_neutral": [{"docstring": "Test when kin selection is neutral (r*b = c).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_selection.py", "line_number": 33, "module": "tests.test_math_selection", "name": "test_kin_selection_neutral", "signature": "(self)", "symbol_type": "function"}], "test_kin_selection_not_favored": [{"docstring": "Test Hamilton's rule when trait not favored.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 318, "module": "tests.test_math_comprehensive", "name": "test_kin_selection_not_favored", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test when kin selection does not favor trait (r*b < c).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_selection.py", "line_number": 26, "module": "tests.test_math_selection", "name": "test_kin_selection_not_favored", "signature": "(self)", "symbol_type": "function"}], "test_kin_selection_zero_cost": [{"docstring": "Test with zero cost.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_selection.py", "line_number": 44, "module": "tests.test_math_selection", "name": "test_kin_selection_zero_cost", "signature": "(self)", "symbol_type": "function"}], "test_kin_selection_zero_relatedness": [{"docstring": "Test with zero relatedness.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_selection.py", "line_number": 39, "module": "tests.test_math_selection", "name": "test_kin_selection_zero_relatedness", "signature": "(self)", "symbol_type": "function"}], "test_kinship_matrix_diagonal_range": [{"docstring": "Test that diagonal elements (self-kinship) are in reasonable range.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_kinship_properties.py", "line_number": 55, "module": "tests.test_gwas_kinship_properties", "name": "test_kinship_matrix_diagonal_range", "signature": "(self)", "symbol_type": "function"}], "test_kinship_matrix_identical_samples": [{"docstring": "Test that identical samples have high kinship.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_kinship_properties.py", "line_number": 76, "module": "tests.test_gwas_kinship_properties", "name": "test_kinship_matrix_identical_samples", "signature": "(self)", "symbol_type": "function"}], "test_kinship_matrix_positive_semi_definite": [{"docstring": "Test that kinship matrix is positive semi-definite.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_kinship_properties.py", "line_number": 32, "module": "tests.test_gwas_kinship_properties", "name": "test_kinship_matrix_positive_semi_definite", "signature": "(self)", "symbol_type": "function"}], "test_kinship_matrix_shape": [{"docstring": "Test that kinship matrix has correct shape.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_kinship_properties.py", "line_number": 162, "module": "tests.test_gwas_kinship_properties", "name": "test_kinship_matrix_shape", "signature": "(self)", "symbol_type": "function"}], "test_kinship_matrix_symmetric": [{"docstring": "Test that kinship matrix is symmetric.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_kinship_properties.py", "line_number": 14, "module": "tests.test_gwas_kinship_properties", "name": "test_kinship_matrix_symmetric", "signature": "(self)", "symbol_type": "function"}], "test_kinship_method_comparison": [{"docstring": "Test that different methods give consistent but not identical results.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_kinship_properties.py", "line_number": 99, "module": "tests.test_gwas_kinship_properties", "name": "test_kinship_method_comparison", "signature": "(self)", "symbol_type": "function"}], "test_kinship_plot": [{"docstring": "Test kinship matrix plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 127, "module": "tests.test_dna_population_viz", "name": "test_kinship_plot", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_kinship_plot_failure": [{"docstring": "Test kinship plot with failed status.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 145, "module": "tests.test_dna_population_viz", "name": "test_kinship_plot_failure", "signature": "(self)", "symbol_type": "function"}], "test_kinship_with_missing_data": [{"docstring": "Test kinship computation with missing data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_kinship_properties.py", "line_number": 141, "module": "tests.test_gwas_kinship_properties", "name": "test_kinship_with_missing_data", "signature": "(self)", "symbol_type": "function"}], "test_kl_divergence_different": [{"docstring": "Test KL divergence with different distributions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 87, "module": "tests.test_information_comprehensive", "name": "test_kl_divergence_different", "signature": "(self)", "symbol_type": "function"}], "test_kl_divergence_identical": [{"docstring": "Test KL divergence with identical distributions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 80, "module": "tests.test_information_comprehensive", "name": "test_kl_divergence_identical", "signature": "(self)", "symbol_type": "function"}], "test_kl_divergence_length_mismatch": [{"docstring": "Test KL divergence with mismatched lengths.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 231, "module": "tests.test_information_comprehensive", "name": "test_kl_divergence_length_mismatch", "signature": "(self)", "symbol_type": "function"}], "test_kmer_counts_and_freqs": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequence_utils.py", "line_number": 14, "module": "tests.test_dna_sequence_utils", "name": "test_kmer_counts_and_freqs", "signature": "() -> None", "symbol_type": "function"}], "test_kmer_distance": [{"docstring": "Test k-mer based distance calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 187, "module": "tests.test_dna_comprehensive", "name": "test_kmer_distance", "signature": "(self)", "symbol_type": "function"}], "test_kmer_distance_identical_zero_and_diff_positive": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_kmer_distances.py", "line_number": 6, "module": "tests.test_dna_kmer_distances", "name": "test_kmer_distance_identical_zero_and_diff_positive", "signature": "() -> None", "symbol_type": "function"}], "test_lambda_gc_plot": [{"docstring": "Test lambda GC plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 108, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_lambda_gc_plot", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_lande_equation_response": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_quantgen.py", "line_number": 16, "module": "tests.test_math_quantgen", "name": "test_lande_equation_response", "signature": "()", "symbol_type": "function"}], "test_large_config_handling": [{"docstring": "Test handling of large configuration files.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 343, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_large_config_handling", "signature": "(self)", "symbol_type": "function"}], "test_large_dataset_performance": [{"docstring": "Test performance with larger datasets.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 710, "module": "tests.test_ml_comprehensive", "name": "test_large_dataset_performance", "signature": "(self)", "symbol_type": "function"}], "test_large_grn_performance": [{"docstring": "Test performance with large GRN.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 649, "module": "tests.test_networks_regulatory", "name": "test_large_grn_performance", "signature": "(self)", "symbol_type": "function"}], "test_large_ppi_network": [{"docstring": "Test performance with large PPI network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 586, "module": "tests.test_networks_ppi", "name": "test_large_ppi_network", "signature": "(self)", "symbol_type": "function"}], "test_large_weights": [{"docstring": "Test handling of very large edge weights.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 385, "module": "tests.test_networks_graph", "name": "test_large_weights", "signature": "(self)", "symbol_type": "function"}], "test_ld_coefficients_and_r2": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_ld.py", "line_number": 6, "module": "tests.test_math_ld", "name": "test_ld_coefficients_and_r2", "signature": "()", "symbol_type": "function"}], "test_ld_decay_and_watterson_theta_and_realized_h2": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_extensions.py", "line_number": 6, "module": "tests.test_math_extensions", "name": "test_ld_decay_and_watterson_theta_and_realized_h2", "signature": "()", "symbol_type": "function"}], "test_ld_decay_plot": [{"docstring": "Test LD decay plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 266, "module": "tests.test_dna_population_viz", "name": "test_ld_decay_plot", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_ld_decay_plot_no_distances": [{"docstring": "Test LD decay plot without distances.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 281, "module": "tests.test_dna_population_viz", "name": "test_ld_decay_plot_no_distances", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_learn_event_embeddings_basic": [{"docstring": "Test basic event embedding learning.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 15, "module": "tests.test_life_events_embeddings", "name": "test_learn_event_embeddings_basic", "signature": "()", "symbol_type": "function"}], "test_learn_event_embeddings_empty_sequences": [{"docstring": "Test embedding learning with empty sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 40, "module": "tests.test_life_events_embeddings", "name": "test_learn_event_embeddings_empty_sequences", "signature": "()", "symbol_type": "function"}], "test_learn_event_embeddings_methods": [{"docstring": "Test different embedding methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 54, "module": "tests.test_life_events_embeddings", "name": "test_learn_event_embeddings_methods", "signature": "()", "symbol_type": "function"}], "test_learn_event_embeddings_validation": [{"docstring": "Test all validation checks in learn_event_embeddings.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 282, "module": "tests.test_life_events_embeddings", "name": "test_learn_event_embeddings_validation", "signature": "()", "symbol_type": "function"}], "test_learn_event_embeddings_verbose": [{"docstring": "Test verbose mode output.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 313, "module": "tests.test_life_events_embeddings", "name": "test_learn_event_embeddings_verbose", "signature": "(capsys)", "symbol_type": "function"}], "test_learning_curve": [{"docstring": "Test learning curve generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 519, "module": "tests.test_ml_comprehensive", "name": "test_learning_curve", "signature": "(self)", "symbol_type": "function"}], "test_leiden_clustering_basic": [{"docstring": "Test Leiden clustering.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 339, "module": "tests.test_singlecell_basic", "name": "test_leiden_clustering_basic", "signature": "(self)", "symbol_type": "function"}], "test_length_distribution_calculation": [{"docstring": "Test sequence length distribution calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 146, "module": "tests.test_quality_fastq", "name": "test_length_distribution_calculation", "signature": "(self)", "symbol_type": "function"}], "test_life_events_config_defaults": [{"docstring": "Test LifeEventsWorkflowConfig with default values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_config.py", "line_number": 151, "module": "tests.test_life_events_config", "name": "test_life_events_config_defaults", "signature": "() -> None", "symbol_type": "function"}], "test_life_events_config_invalid_file": [{"docstring": "Test error handling for missing configuration file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_config.py", "line_number": 162, "module": "tests.test_life_events_config", "name": "test_life_events_config_invalid_file", "signature": "() -> None", "symbol_type": "function"}], "test_life_events_config_malformed": [{"docstring": "Test handling of malformed YAML/JSON.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_config.py", "line_number": 169, "module": "tests.test_life_events_config", "name": "test_life_events_config_malformed", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_life_events_config_nested_values": [{"docstring": "Test config with nested values in sections.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_config.py", "line_number": 204, "module": "tests.test_life_events_config", "name": "test_life_events_config_nested_values", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_life_events_config_partial_sections": [{"docstring": "Test config with some sections missing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_config.py", "line_number": 184, "module": "tests.test_life_events_config", "name": "test_life_events_config_partial_sections", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_linear_regression": [{"docstring": "Test linear regression calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_enhanced.py", "line_number": 31, "module": "tests.test_math_enhanced", "name": "test_linear_regression", "signature": "(self)", "symbol_type": "function"}], "test_linear_regression_large_arrays": [{"docstring": "Test linear regression with large arrays.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 295, "module": "tests.test_math_utilities", "name": "test_linear_regression_large_arrays", "signature": "(self)", "symbol_type": "function"}], "test_lineplot_and_heatmap_render": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization.py", "line_number": 9, "module": "tests.test_visualization", "name": "test_lineplot_and_heatmap_render", "signature": "()", "symbol_type": "function"}], "test_lineplot_basic": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization.py", "line_number": 29, "module": "tests.test_visualization", "name": "test_lineplot_basic", "signature": "()", "symbol_type": "function"}], "test_linkage_disequilibrium_decay": [{"docstring": "Test linkage disequilibrium decay distance calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_enhanced.py", "line_number": 105, "module": "tests.test_math_enhanced", "name": "test_linkage_disequilibrium_decay", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test linkage disequilibrium decay distance calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_enhanced.py", "line_number": 49, "module": "tests.test_math_popgen_enhanced", "name": "test_linkage_disequilibrium_decay", "signature": "(self)", "symbol_type": "function"}], "test_load_antwiki_json_empty": [{"docstring": "Test loading empty AntWiki JSON.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_basic.py", "line_number": 46, "module": "tests.test_phenotype_basic", "name": "test_load_antwiki_json_empty", "signature": "(self)", "symbol_type": "function"}], "test_load_antwiki_json_invalid_format": [{"docstring": "Test loading AntWiki JSON with invalid format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_basic.py", "line_number": 56, "module": "tests.test_phenotype_basic", "name": "test_load_antwiki_json_invalid_format", "signature": "(self)", "symbol_type": "function"}], "test_load_antwiki_json_nonexistent_file": [{"docstring": "Test loading from nonexistent file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_basic.py", "line_number": 64, "module": "tests.test_phenotype_basic", "name": "test_load_antwiki_json_nonexistent_file", "signature": "(self)", "symbol_type": "function"}], "test_load_antwiki_json_with_dict": [{"docstring": "Test loading AntWiki JSON with dict format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_basic.py", "line_number": 35, "module": "tests.test_phenotype_basic", "name": "test_load_antwiki_json_with_dict", "signature": "(self)", "symbol_type": "function"}], "test_load_antwiki_json_with_list": [{"docstring": "Test loading AntWiki JSON with list format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_basic.py", "line_number": 20, "module": "tests.test_phenotype_basic", "name": "test_load_antwiki_json_with_list", "signature": "(self)", "symbol_type": "function"}], "test_load_count_matrix_csv": [{"docstring": "Test loading CSV count matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 103, "module": "tests.test_singlecell_preprocessing", "name": "test_load_count_matrix_csv", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_load_count_matrix_transpose": [{"docstring": "Test transpose functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 144, "module": "tests.test_singlecell_preprocessing", "name": "test_load_count_matrix_transpose", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_load_count_matrix_tsv": [{"docstring": "Test loading TSV count matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 124, "module": "tests.test_singlecell_preprocessing", "name": "test_load_count_matrix_tsv", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_load_dict_format": [{"docstring": "Test loading JSON file with single dict format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_comprehensive.py", "line_number": 35, "module": "tests.test_phenotype_comprehensive", "name": "test_load_dict_format", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_load_empty_database": [{"docstring": "Test loading empty pathway database.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 173, "module": "tests.test_networks_pathway", "name": "test_load_empty_database", "signature": "(self)", "symbol_type": "function"}], "test_load_empty_list": [{"docstring": "Test loading empty JSON.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_comprehensive.py", "line_number": 48, "module": "tests.test_phenotype_comprehensive", "name": "test_load_empty_list", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_load_from_dict": [{"docstring": "Test loading pathways from dictionary format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 151, "module": "tests.test_networks_pathway", "name": "test_load_from_dict", "signature": "(self)", "symbol_type": "function"}], "test_load_go_and_traverse": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_go_basic.py", "line_number": 16, "module": "tests.test_ontology_go_basic", "name": "test_load_go_and_traverse", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_load_go_obo": [{"docstring": "Test loading GO OBO file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_comprehensive.py", "line_number": 181, "module": "tests.test_ontology_comprehensive", "name": "test_load_go_obo", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_load_go_obo_nonexistent_file": [{"docstring": "Test loading nonexistent OBO file raises error.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_go_basic.py", "line_number": 51, "module": "tests.test_ontology_go_basic", "name": "test_load_go_obo_nonexistent_file", "signature": "() -> None", "symbol_type": "function"}], "test_load_gwas_config_basic": [{"docstring": "Test loading basic GWAS configuration from YAML.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_config.py", "line_number": 13, "module": "tests.test_gwas_config", "name": "test_load_gwas_config_basic", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_load_gwas_config_json": [{"docstring": "Test loading GWAS configuration from JSON.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_config.py", "line_number": 65, "module": "tests.test_gwas_config", "name": "test_load_gwas_config_json", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_load_gwas_config_missing_file": [{"docstring": "Test error handling for missing configuration file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_config.py", "line_number": 83, "module": "tests.test_gwas_config", "name": "test_load_gwas_config_missing_file", "signature": "() -> None", "symbol_type": "function"}], "test_load_gwas_config_with_all_sections": [{"docstring": "Test loading complete GWAS configuration with all sections.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_config.py", "line_number": 28, "module": "tests.test_gwas_config", "name": "test_load_gwas_config_with_all_sections", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_load_invalid_format": [{"docstring": "Test error handling for invalid pathway format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 195, "module": "tests.test_networks_pathway", "name": "test_load_invalid_format", "signature": "(self)", "symbol_type": "function"}], "test_load_life_events_config_all_sections": [{"docstring": "Test loading complete config with all sections.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_config.py", "line_number": 34, "module": "tests.test_life_events_config", "name": "test_load_life_events_config_all_sections", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_load_life_events_config_basic": [{"docstring": "Test loading minimal config from YAML.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_config.py", "line_number": 14, "module": "tests.test_life_events_config", "name": "test_load_life_events_config_basic", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_load_life_events_config_env_overrides": [{"docstring": "Test LE_ prefix environment variable overrides.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_config.py", "line_number": 128, "module": "tests.test_life_events_config", "name": "test_load_life_events_config_env_overrides", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_load_life_events_config_json": [{"docstring": "Test loading config from JSON format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_config.py", "line_number": 76, "module": "tests.test_life_events_config", "name": "test_load_life_events_config_json", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_load_life_events_config_toml": [{"docstring": "Test loading config from TOML format (if available).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_config.py", "line_number": 100, "module": "tests.test_life_events_config", "name": "test_load_life_events_config_toml", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_load_list_format": [{"docstring": "Test loading JSON file with list format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_comprehensive.py", "line_number": 20, "module": "tests.test_phenotype_comprehensive", "name": "test_load_list_format", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_load_minimal_pathways": [{"docstring": "Test loading pathways with minimal information.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 181, "module": "tests.test_networks_pathway", "name": "test_load_minimal_pathways", "signature": "(self)", "symbol_type": "function"}], "test_load_model_invalid_file": [{"docstring": "Test handling of corrupted/missing model files.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 283, "module": "tests.test_life_events_models", "name": "test_load_model_invalid_file", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_load_model_missing_fields": [{"docstring": "Test handling of model files with missing required fields.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 297, "module": "tests.test_life_events_models", "name": "test_load_model_missing_fields", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_load_model_roundtrip": [{"docstring": "Test save then load, verify predictions match.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 242, "module": "tests.test_life_events_models", "name": "test_load_model_roundtrip", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_load_model_unfitted_error": [{"docstring": "Test rejection of loading unfitted models.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 314, "module": "tests.test_life_events_models", "name": "test_load_model_unfitted_error", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_load_nonexistent_file": [{"docstring": "Test loading nonexistent file raises error.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_serialize.py", "line_number": 85, "module": "tests.test_ontology_serialize", "name": "test_load_nonexistent_file", "signature": "(self)", "symbol_type": "function"}], "test_load_pbarbatus_config": [{"docstring": "Test loading P. barbatus GWAS configuration.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_config_pbarbatus.py", "line_number": 12, "module": "tests.test_gwas_config_pbarbatus", "name": "test_load_pbarbatus_config", "signature": "() -> None", "symbol_type": "function"}], "test_load_postgres_config_from_env_roundtrip": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_config.py", "line_number": 9, "module": "tests.test_core_config", "name": "test_load_postgres_config_from_env_roundtrip", "signature": "() -> None", "symbol_type": "function"}], "test_load_sequences_from_json_database_format": [{"docstring": "Test loading sequences from database format JSON.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_utils.py", "line_number": 14, "module": "tests.test_life_events_utils", "name": "test_load_sequences_from_json_database_format", "signature": "(tmp_path)", "symbol_type": "function"}], "test_load_sequences_from_json_list_format": [{"docstring": "Test loading sequences from list format JSON.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_utils.py", "line_number": 45, "module": "tests.test_life_events_utils", "name": "test_load_sequences_from_json_list_format", "signature": "(tmp_path)", "symbol_type": "function"}], "test_load_sequences_from_json_not_found": [{"docstring": "Test loading from non-existent file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_utils.py", "line_number": 72, "module": "tests.test_life_events_utils", "name": "test_load_sequences_from_json_not_found", "signature": "()", "symbol_type": "function"}], "test_load_string_confidence_filtering": [{"docstring": "Test confidence threshold filtering during loading.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 217, "module": "tests.test_networks_ppi", "name": "test_load_string_confidence_filtering", "signature": "(self)", "symbol_type": "function"}], "test_load_string_empty_data": [{"docstring": "Test loading empty STRING data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 239, "module": "tests.test_networks_ppi", "name": "test_load_string_empty_data", "signature": "(self)", "symbol_type": "function"}], "test_load_string_from_dataframe": [{"docstring": "Test loading STRING interactions from DataFrame.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 179, "module": "tests.test_networks_ppi", "name": "test_load_string_from_dataframe", "signature": "(self)", "symbol_type": "function"}], "test_load_string_invalid_data": [{"docstring": "Test error handling for invalid STRING data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 249, "module": "tests.test_networks_ppi", "name": "test_load_string_invalid_data", "signature": "(self)", "symbol_type": "function"}], "test_load_typed_env": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_config.py", "line_number": 25, "module": "tests.test_core_config", "name": "test_load_typed_env", "signature": "() -> None", "symbol_type": "function"}], "test_load_workflow_config_and_plan_uses_yaml_values": [{"docstring": "Test that workflow config loading and planning uses YAML values correctly.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_config_load_plan.py", "line_number": 11, "module": "tests.test_rna_config_load_plan", "name": "test_load_workflow_config_and_plan_uses_yaml_values", "signature": "()", "symbol_type": "function"}], "test_load_workflow_config_yaml": [{"docstring": "Test that load_workflow_config correctly parses YAML configuration files.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_workflow_config.py", "line_number": 11, "module": "tests.test_rna_workflow_config", "name": "test_load_workflow_config_yaml", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_local_alignment_functionality": [{"docstring": "Test local alignment functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_alignment_enhanced.py", "line_number": 70, "module": "tests.test_dna_alignment_enhanced", "name": "test_local_alignment_functionality", "signature": "(self)", "symbol_type": "function"}], "test_local_alignment_non_trivial": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_alignment.py", "line_number": 20, "module": "tests.test_dna_alignment", "name": "test_local_alignment_non_trivial", "signature": "() -> None", "symbol_type": "function"}], "test_log_transform": [{"docstring": "Test log transformation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 288, "module": "tests.test_singlecell_preprocessing", "name": "test_log_transform", "signature": "(self)", "symbol_type": "function"}], "test_log_transform_basic": [{"docstring": "Test log transformation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 146, "module": "tests.test_singlecell_basic", "name": "test_log_transform_basic", "signature": "(self)", "symbol_type": "function"}], "test_log_with_metadata_basic": [{"docstring": "Test log_with_metadata with basic usage.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_logging.py", "line_number": 48, "module": "tests.test_core_logging", "name": "test_log_with_metadata_basic", "signature": "() -> None", "symbol_type": "function"}], "test_log_with_metadata_level": [{"docstring": "Test log_with_metadata with different log levels.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_logging.py", "line_number": 88, "module": "tests.test_core_logging", "name": "test_log_with_metadata_level", "signature": "() -> None", "symbol_type": "function"}], "test_log_with_metadata_structured": [{"docstring": "Test log_with_metadata with structured=True.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_logging.py", "line_number": 68, "module": "tests.test_core_logging", "name": "test_log_with_metadata_structured", "signature": "() -> None", "symbol_type": "function"}], "test_logger_setup": [{"docstring": "Test logger configuration.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 358, "module": "tests.test_core_comprehensive", "name": "test_logger_setup", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_logistic_map_basic": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_dynamics.py", "line_number": 6, "module": "tests.test_math_dynamics", "name": "test_logistic_map_basic", "signature": "()", "symbol_type": "function"}], "test_logistic_map_stability": [{"docstring": "Test logistic map with stable parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 249, "module": "tests.test_math_comprehensive", "name": "test_logistic_map_stability", "signature": "(self)", "symbol_type": "function"}], "test_lotka_volterra_oscillations": [{"docstring": "Test Lotka-Volterra model oscillations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 260, "module": "tests.test_math_comprehensive", "name": "test_lotka_volterra_oscillations", "signature": "(self)", "symbol_type": "function"}], "test_lotka_volterra_step_nonnegative": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_dynamics.py", "line_number": 12, "module": "tests.test_math_dynamics", "name": "test_lotka_volterra_step_nonnegative", "signature": "()", "symbol_type": "function"}], "test_lstm_sequence_model": [{"docstring": "Test LSTMSequenceModel (may fallback to simple model).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 125, "module": "tests.test_life_events_models", "name": "test_lstm_sequence_model", "signature": "()", "symbol_type": "function"}, {"docstring": "Test LSTM sequence model.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models_advanced.py", "line_number": 19, "module": "tests.test_life_events_models_advanced", "name": "test_lstm_sequence_model", "signature": "(tmp_path)", "symbol_type": "function"}], "test_manhattan_plot": [{"docstring": "Test Manhattan plot functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 455, "module": "tests.test_visualization_enhanced", "name": "test_manhattan_plot", "signature": "(self)", "symbol_type": "function"}], "test_manhattan_plot_basic": [{"docstring": "Test generating Manhattan plot from results.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization.py", "line_number": 14, "module": "tests.test_gwas_visualization", "name": "test_manhattan_plot_basic", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}, {"docstring": "Test basic Manhattan plot generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 37, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_manhattan_plot_basic", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_manhattan_plot_from_file": [{"docstring": "Test generating Manhattan plot from results file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization.py", "line_number": 32, "module": "tests.test_gwas_visualization", "name": "test_manhattan_plot_from_file", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_manhattan_plot_genome": [{"docstring": "Test genome-wide Manhattan plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 63, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_manhattan_plot_genome", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_manifest_can_be_used_for_resume": [{"docstring": "Test that manifest contains enough info to resume workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_workflow_error_handling.py", "line_number": 181, "module": "tests.test_rna_workflow_error_handling", "name": "test_manifest_can_be_used_for_resume", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_manifest_includes_all_step_info": [{"docstring": "Test that manifest records include all required information.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_workflow_error_handling.py", "line_number": 149, "module": "tests.test_rna_workflow_error_handling", "name": "test_manifest_includes_all_step_info", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_manifest_records_steps_in_order": [{"docstring": "Test that manifest records are written in execution order.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_workflow_error_handling.py", "line_number": 107, "module": "tests.test_rna_workflow_error_handling", "name": "test_manifest_records_steps_in_order", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_manifest_written_and_logs_directory": [{"docstring": "Test that workflow planning creates correct default paths for logs and manifest.\n\nNote: This test only checks planning and default paths, not actual execution.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_manifest.py", "line_number": 13, "module": "tests.test_rna_manifest", "name": "test_manifest_written_and_logs_directory", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_manifest_written_with_records": [{"docstring": "Test that workflow execution writes manifest files with execution records.\n\nUses ensure_amalgkit_available fixture to ensure amalgkit is available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_workflow_manifest.py", "line_number": 13, "module": "tests.test_rna_workflow_manifest", "name": "test_manifest_written_with_records", "signature": "(tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_manifold_learning_methods": [{"docstring": "Test different manifold learning methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 382, "module": "tests.test_ml_comprehensive", "name": "test_manifold_learning_methods", "signature": "(self)", "symbol_type": "function"}], "test_mark_redundant_biosamples_flag": [{"docstring": "Test mark_redundant_biosamples flag (v0.12.20 feature).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 581, "module": "tests.test_rna_amalgkit_steps", "name": "test_mark_redundant_biosamples_flag", "signature": "(self)", "symbol_type": "function"}], "test_math_orchestrator_help": [{"docstring": "Test math orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 114, "module": "tests.test_orchestrators", "name": "test_math_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_mathematical_consistency": [{"docstring": "Test mathematical consistency of calculations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_enhanced.py", "line_number": 144, "module": "tests.test_math_enhanced", "name": "test_mathematical_consistency", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test mathematical consistency of calculations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_enhanced.py", "line_number": 112, "module": "tests.test_math_popgen_enhanced", "name": "test_mathematical_consistency", "signature": "(self)", "symbol_type": "function"}], "test_maximum_entropy_four_outcomes": [{"docstring": "Test maximum entropy for 4 outcomes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 193, "module": "tests.test_math_utilities", "name": "test_maximum_entropy_four_outcomes", "signature": "(self)", "symbol_type": "function"}], "test_maximum_entropy_two_outcomes": [{"docstring": "Test maximum entropy for 2 outcomes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 187, "module": "tests.test_math_utilities", "name": "test_maximum_entropy_two_outcomes", "signature": "(self)", "symbol_type": "function"}], "test_melting_temp_basic": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_gc_skew_tm.py", "line_number": 12, "module": "tests.test_dna_gc_skew_tm", "name": "test_melting_temp_basic", "signature": "() -> None", "symbol_type": "function"}], "test_melting_temperature": [{"docstring": "Test melting temperature calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 144, "module": "tests.test_core_functionality", "name": "test_melting_temperature", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test DNA melting temperature calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 89, "module": "tests.test_dna_comprehensive", "name": "test_melting_temperature", "signature": "(self)", "symbol_type": "function"}], "test_melting_temperature_calculation": [{"docstring": "Test melting temperature calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 220, "module": "tests.test_dna_sequences_enhanced", "name": "test_melting_temperature_calculation", "signature": "(self)", "symbol_type": "function"}], "test_merge_basic_execution": [{"docstring": "Test merge step can execute with minimal params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 320, "module": "tests.test_rna_amalgkit_steps", "name": "test_merge_basic_execution", "signature": "(self, tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_merge_function_exists": [{"docstring": "Verify merge runner function is exported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 306, "module": "tests.test_rna_amalgkit_steps", "name": "test_merge_function_exists", "signature": "(self)", "symbol_type": "function"}], "test_merge_in_amalgkit_module": [{"docstring": "Verify merge function exists in amalgkit module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 315, "module": "tests.test_rna_amalgkit_steps", "name": "test_merge_in_amalgkit_module", "signature": "(self)", "symbol_type": "function"}], "test_merge_in_step_runners": [{"docstring": "Verify merge is in STEP_RUNNERS.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 310, "module": "tests.test_rna_amalgkit_steps", "name": "test_merge_in_step_runners", "signature": "(self)", "symbol_type": "function"}], "test_merge_vcf_files_bcftools_unavailable": [{"docstring": "Test VCF merging when bcftools unavailable (should fail gracefully).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_calling.py", "line_number": 28, "module": "tests.test_gwas_calling", "name": "test_merge_vcf_files_bcftools_unavailable", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_merge_vcf_files_empty_list": [{"docstring": "Test VCF merging with empty file list.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_calling.py", "line_number": 53, "module": "tests.test_gwas_calling", "name": "test_merge_vcf_files_empty_list", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_merge_vcf_files_file_not_found": [{"docstring": "Test VCF merging with non-existent files.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_calling.py", "line_number": 43, "module": "tests.test_gwas_calling", "name": "test_merge_vcf_files_file_not_found", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_metadata_basic_execution": [{"docstring": "Test metadata step can execute with minimal params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 92, "module": "tests.test_rna_amalgkit_steps", "name": "test_metadata_basic_execution", "signature": "(self, tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_metadata_function_exists": [{"docstring": "Verify metadata runner function is exported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 78, "module": "tests.test_rna_amalgkit_steps", "name": "test_metadata_function_exists", "signature": "(self)", "symbol_type": "function"}], "test_metadata_in_amalgkit_module": [{"docstring": "Verify metadata function exists in amalgkit module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 87, "module": "tests.test_rna_amalgkit_steps", "name": "test_metadata_in_amalgkit_module", "signature": "(self)", "symbol_type": "function"}], "test_metadata_in_step_runners": [{"docstring": "Verify metadata is in STEP_RUNNERS.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 82, "module": "tests.test_rna_amalgkit_steps", "name": "test_metadata_in_step_runners", "signature": "(self)", "symbol_type": "function"}], "test_metadata_integration": [{"docstring": "Test metadata integration.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 94, "module": "tests.test_multiomics_comprehensive", "name": "test_metadata_integration", "signature": "(self)", "symbol_type": "function"}], "test_metadata_passes_work_dir": [{"docstring": "Test that metadata runner passes work_dir parameter.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 625, "module": "tests.test_rna_amalgkit_steps", "name": "test_metadata_passes_work_dir", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_metadata_runner": [{"docstring": "Test metadata step runner.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 200, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_metadata_runner", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test metadata step runner.\n\nUses ensure_amalgkit_available fixture to ensure amalgkit is available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 312, "module": "tests.test_rna_amalgkit_end_to_end", "name": "test_metadata_runner", "signature": "(self, ensure_amalgkit_available)", "symbol_type": "function"}], "test_metadata_selection": [{"docstring": "Test that metadata file selection works correctly.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/test_getfastq_fix.py", "line_number": 26, "module": "scripts.rna.test_getfastq_fix", "name": "test_metadata_selection", "signature": "()", "symbol_type": "function"}], "test_metadata_step_execution": [{"docstring": "Test metadata step execution.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 78, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_metadata_step_execution", "signature": "(self)", "symbol_type": "function"}], "test_metadata_to_config_workflow": [{"docstring": "Test metadata \u2192 integrate \u2192 config workflow.\n\nUses ensure_amalgkit_available fixture to ensure amalgkit is available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 31, "module": "tests.test_rna_amalgkit_end_to_end", "name": "test_metadata_to_config_workflow", "signature": "(self, ensure_amalgkit_available)", "symbol_type": "function"}], "test_metadata_with_resolve_names": [{"docstring": "Test metadata step with resolve_names parameter (v0.12.20 feature).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 110, "module": "tests.test_rna_amalgkit_steps", "name": "test_metadata_with_resolve_names", "signature": "(self, tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_metrics_empty_network": [{"docstring": "Test metrics on empty network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 197, "module": "tests.test_networks_graph", "name": "test_metrics_empty_network", "signature": "(self)", "symbol_type": "function"}], "test_metrics_single_node": [{"docstring": "Test metrics on single node network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 207, "module": "tests.test_networks_graph", "name": "test_metrics_single_node", "signature": "(self)", "symbol_type": "function"}], "test_mi_matrix_plot": [{"docstring": "Test MI matrix plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 246, "module": "tests.test_information_integration", "name": "test_mi_matrix_plot", "signature": "(self)", "symbol_type": "function"}], "test_mild_bottleneck": [{"docstring": "Test mild bottleneck.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_demography.py", "line_number": 53, "module": "tests.test_math_demography", "name": "test_mild_bottleneck", "signature": "(self)", "symbol_type": "function"}], "test_mismatched_dimensions": [{"docstring": "Test error handling for mismatched X and y dimensions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 684, "module": "tests.test_ml_comprehensive", "name": "test_mismatched_dimensions", "signature": "(self)", "symbol_type": "function"}], "test_mismatched_samples_warning": [{"docstring": "Test warning when samples don't fully overlap.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 495, "module": "tests.test_multiomics_integration", "name": "test_mismatched_samples_warning", "signature": "(self)", "symbol_type": "function"}], "test_missing_data_error": [{"docstring": "Test that missing data raises error.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_analysis.py", "line_number": 98, "module": "tests.test_dna_population_analysis", "name": "test_missing_data_error", "signature": "(self)", "symbol_type": "function"}], "test_missing_fields": [{"docstring": "Test handling of results with missing fields.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 231, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_missing_fields", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_ml_feature_entropy": [{"docstring": "Test feature entropy calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 219, "module": "tests.test_information_integration", "name": "test_ml_feature_entropy", "signature": "(self)", "symbol_type": "function"}], "test_ml_feature_selection_mi": [{"docstring": "Test feature selection using mutual information.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 209, "module": "tests.test_information_integration", "name": "test_ml_feature_selection_mi", "signature": "(self)", "symbol_type": "function"}], "test_ml_integration": [{"docstring": "Test ML integration.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 482, "module": "tests.test_information_comprehensive", "name": "test_ml_integration", "signature": "(self)", "symbol_type": "function"}], "test_ml_orchestrator_help": [{"docstring": "Test ML orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 107, "module": "tests.test_orchestrators", "name": "test_ml_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_model_persistence_across_sessions": [{"docstring": "Verify model works after program restart (simulated).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_integration.py", "line_number": 319, "module": "tests.test_life_events_integration", "name": "test_model_persistence_across_sessions", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_model_persistence_predictions_match": [{"docstring": "Verify loaded model makes same predictions as original for new sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 338, "module": "tests.test_life_events_models", "name": "test_model_persistence_predictions_match", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_modularity_calculation": [{"docstring": "Test basic modularity calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 145, "module": "tests.test_networks_community", "name": "test_modularity_calculation", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test modularity calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 152, "module": "tests.test_networks_comprehensive", "name": "test_modularity_calculation", "signature": "(self)", "symbol_type": "function"}], "test_modularity_each_node_separate": [{"docstring": "Test modularity when each node is its own community.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 167, "module": "tests.test_networks_community", "name": "test_modularity_each_node_separate", "signature": "(self)", "symbol_type": "function"}], "test_modularity_empty_communities": [{"docstring": "Test modularity with empty communities dict.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 177, "module": "tests.test_networks_community", "name": "test_modularity_empty_communities", "signature": "(self)", "symbol_type": "function"}], "test_modularity_invalid_communities": [{"docstring": "Test modularity with communities containing non-existent nodes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 184, "module": "tests.test_networks_community", "name": "test_modularity_invalid_communities", "signature": "(self)", "symbol_type": "function"}], "test_modularity_single_community": [{"docstring": "Test modularity when all nodes are in one community.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 157, "module": "tests.test_networks_community", "name": "test_modularity_single_community", "signature": "(self)", "symbol_type": "function"}], "test_module_invocation_shows_help": [{"docstring": "Test that module invocation displays help information.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_cli.py", "line_number": 5, "module": "tests.test_cli", "name": "test_module_invocation_shows_help", "signature": "()", "symbol_type": "function"}], "test_more_features_than_samples": [{"docstring": "Test high-dimensional case (p >> n).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 621, "module": "tests.test_ml_features", "name": "test_more_features_than_samples", "signature": "(self)", "symbol_type": "function"}], "test_motif_finding": [{"docstring": "Test multiple motif finding.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 73, "module": "tests.test_dna_sequences_enhanced", "name": "test_motif_finding", "signature": "(self)", "symbol_type": "function"}], "test_multi_task_predictor": [{"docstring": "Test multi-task predictor.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models_advanced.py", "line_number": 113, "module": "tests.test_life_events_models_advanced", "name": "test_multi_task_predictor", "signature": "(tmp_path)", "symbol_type": "function"}], "test_multiclass_classification": [{"docstring": "Test feature selection with multi-class targets.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 123, "module": "tests.test_ml_features", "name": "test_multiclass_classification", "signature": "(self)", "symbol_type": "function"}], "test_multilevel_selection_basic": [{"docstring": "Test basic multilevel selection decomposition.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_selection.py", "line_number": 53, "module": "tests.test_math_selection", "name": "test_multilevel_selection_basic", "signature": "(self)", "symbol_type": "function"}], "test_multilevel_selection_equal_groups": [{"docstring": "Test with equal group means.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_selection.py", "line_number": 92, "module": "tests.test_math_selection", "name": "test_multilevel_selection_equal_groups", "signature": "(self)", "symbol_type": "function"}], "test_multilevel_selection_single_group": [{"docstring": "Test with single group.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_selection.py", "line_number": 73, "module": "tests.test_math_selection", "name": "test_multilevel_selection_single_group", "signature": "(self)", "symbol_type": "function"}], "test_multilevel_selection_zero_individual_selection": [{"docstring": "Test with zero individual-level selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_selection.py", "line_number": 110, "module": "tests.test_math_selection", "name": "test_multilevel_selection_zero_individual_selection", "signature": "(self)", "symbol_type": "function"}], "test_multiomics_cross_platform_mi": [{"docstring": "Test cross-platform mutual information.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 141, "module": "tests.test_information_integration", "name": "test_multiomics_cross_platform_mi", "signature": "(self)", "symbol_type": "function"}], "test_multiomics_data_initialization": [{"docstring": "Test basic MultiOmicsData initialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 64, "module": "tests.test_multiomics_integration", "name": "test_multiomics_data_initialization", "signature": "(self)", "symbol_type": "function"}], "test_multiomics_feature_selection": [{"docstring": "Test multi-omics integration with feature selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 161, "module": "tests.test_information_integration", "name": "test_multiomics_feature_selection", "signature": "(self)", "symbol_type": "function"}], "test_multiomics_feature_selection_single": [{"docstring": "Test multi-omics integration with single feature indices.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 185, "module": "tests.test_information_integration", "name": "test_multiomics_feature_selection_single", "signature": "(self)", "symbol_type": "function"}], "test_multiomics_integration": [{"docstring": "Test multi-omics integration function.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 124, "module": "tests.test_information_integration", "name": "test_multiomics_integration", "signature": "(self)", "symbol_type": "function"}], "test_multiomics_integration_workflow": [{"docstring": "Test multi-omics data integration workflow.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_integration_comprehensive.py", "line_number": 188, "module": "tests.test_integration_comprehensive", "name": "test_multiomics_integration_workflow", "signature": "(self)", "symbol_type": "function"}], "test_multiomics_orchestrator_help": [{"docstring": "Test multiomics orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 58, "module": "tests.test_orchestrators", "name": "test_multiomics_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_muscle_cli_alignment_roundtrip": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_msa_cli.py", "line_number": 12, "module": "tests.test_dna_msa_cli", "name": "test_muscle_cli_alignment_roundtrip", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_mutate_sequence_basic": [{"docstring": "Test sequence mutation functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 42, "module": "tests.test_simulation", "name": "test_mutate_sequence_basic", "signature": "()", "symbol_type": "function"}], "test_mutate_sequence_edge_cases": [{"docstring": "Test mutation edge cases.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 64, "module": "tests.test_simulation", "name": "test_mutate_sequence_edge_cases", "signature": "()", "symbol_type": "function"}], "test_mutate_sequence_reproducible": [{"docstring": "Test mutation reproducibility with seeds.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 54, "module": "tests.test_simulation", "name": "test_mutate_sequence_reproducible", "signature": "()", "symbol_type": "function"}], "test_mutation_update_equilibrium": [{"docstring": "Test mutation update approaching equilibrium.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 115, "module": "tests.test_math_comprehensive", "name": "test_mutation_update_equilibrium", "signature": "(self)", "symbol_type": "function"}], "test_mutation_update_forward_and_back": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen.py", "line_number": 23, "module": "tests.test_math_popgen", "name": "test_mutation_update_forward_and_back", "signature": "()", "symbol_type": "function"}], "test_mutual_info_feature_selection": [{"docstring": "Test mutual information based feature selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 80, "module": "tests.test_ml_features", "name": "test_mutual_info_feature_selection", "signature": "(self)", "symbol_type": "function"}], "test_mutual_information_continuous": [{"docstring": "Test continuous mutual information.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 368, "module": "tests.test_information_comprehensive", "name": "test_mutual_information_continuous", "signature": "(self)", "symbol_type": "function"}], "test_mutual_information_estimator": [{"docstring": "Test MI estimation with bias correction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 406, "module": "tests.test_information_comprehensive", "name": "test_mutual_information_estimator", "signature": "(self)", "symbol_type": "function"}], "test_mutual_information_independent": [{"docstring": "Test mutual information with independent variables.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 66, "module": "tests.test_information_comprehensive", "name": "test_mutual_information_independent", "signature": "(self)", "symbol_type": "function"}], "test_mutual_information_length_mismatch": [{"docstring": "Test mutual information with mismatched lengths.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 224, "module": "tests.test_information_comprehensive", "name": "test_mutual_information_length_mismatch", "signature": "(self)", "symbol_type": "function"}], "test_mutual_information_perfect_correlation": [{"docstring": "Test mutual information with perfect correlation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 59, "module": "tests.test_information_comprehensive", "name": "test_mutual_information_perfect_correlation", "signature": "(self)", "symbol_type": "function"}], "test_mutual_information_properties": [{"docstring": "Test properties of mutual information.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 281, "module": "tests.test_information_comprehensive", "name": "test_mutual_information_properties", "signature": "(self)", "symbol_type": "function"}], "test_narrow_sense_heritability_bounds": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_quantgen.py", "line_number": 6, "module": "tests.test_math_quantgen", "name": "test_narrow_sense_heritability_bounds", "signature": "()", "symbol_type": "function"}], "test_ncbi_datasets_optional_dependency_errors": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_ncbi.py", "line_number": 17, "module": "tests.test_dna_ncbi", "name": "test_ncbi_datasets_optional_dependency_errors", "signature": "()", "symbol_type": "function"}], "test_negative_growth": [{"docstring": "Test with negative growth rate (decline).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_demography.py", "line_number": 31, "module": "tests.test_math_demography", "name": "test_negative_growth", "signature": "(self)", "symbol_type": "function"}], "test_negative_values_ignored": [{"docstring": "Test that negative values are ignored.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 212, "module": "tests.test_math_utilities", "name": "test_negative_values_ignored", "signature": "(self)", "symbol_type": "function"}], "test_negative_weights_handling": [{"docstring": "Test handling of negative edge weights.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 320, "module": "tests.test_networks_community", "name": "test_negative_weights_handling", "signature": "(self)", "symbol_type": "function"}], "test_neighbor_joining_tree_from_kmer_distance": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_phylogeny_kmer.py", "line_number": 8, "module": "tests.test_dna_phylogeny_kmer", "name": "test_neighbor_joining_tree_from_kmer_distance", "signature": "() -> None", "symbol_type": "function"}], "test_neighbor_joining_tree_from_toy_fasta": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_phylogeny.py", "line_number": 8, "module": "tests.test_dna_phylogeny", "name": "test_neighbor_joining_tree_from_toy_fasta", "signature": "() -> None", "symbol_type": "function"}], "test_network_creation": [{"docstring": "Test creating empty network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 30, "module": "tests.test_networks_comprehensive", "name": "test_network_creation", "signature": "(self)", "symbol_type": "function"}], "test_network_density": [{"docstring": "Test network density calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 61, "module": "tests.test_networks_comprehensive", "name": "test_network_density", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test network density calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 89, "module": "tests.test_networks_graph", "name": "test_network_density", "signature": "(self)", "symbol_type": "function"}], "test_network_enrichment_basic": [{"docstring": "Test basic network enrichment analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 341, "module": "tests.test_networks_pathway", "name": "test_network_enrichment_basic", "signature": "(self)", "symbol_type": "function"}], "test_network_entropy": [{"docstring": "Test network entropy calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 263, "module": "tests.test_information_integration", "name": "test_network_entropy", "signature": "(self)", "symbol_type": "function"}], "test_network_initialization": [{"docstring": "Test network creation and basic properties.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 26, "module": "tests.test_networks_graph", "name": "test_network_initialization", "signature": "(self)", "symbol_type": "function"}], "test_network_metrics_basic": [{"docstring": "Test basic network metrics.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 84, "module": "tests.test_networks_comprehensive", "name": "test_network_metrics_basic", "signature": "(self)", "symbol_type": "function"}], "test_network_ml_integration": [{"docstring": "Test integration of network analysis with machine learning.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_integration_comprehensive.py", "line_number": 129, "module": "tests.test_integration_comprehensive", "name": "test_network_ml_integration", "signature": "(self)", "symbol_type": "function"}], "test_network_plot": [{"docstring": "Test network plot functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 516, "module": "tests.test_visualization_enhanced", "name": "test_network_plot", "signature": "(self)", "symbol_type": "function"}], "test_network_scalability": [{"docstring": "Test network analysis with moderately large networks.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_integration_comprehensive.py", "line_number": 487, "module": "tests.test_integration_comprehensive", "name": "test_network_scalability", "signature": "(self)", "symbol_type": "function"}], "test_network_similarity": [{"docstring": "Test network similarity calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 444, "module": "tests.test_networks_graph", "name": "test_network_similarity", "signature": "(self)", "symbol_type": "function"}], "test_network_union_intersection": [{"docstring": "Test network union and intersection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 494, "module": "tests.test_networks_graph", "name": "test_network_union_intersection", "signature": "(self)", "symbol_type": "function"}], "test_networks_cli_integration": [{"docstring": "Test networks CLI command.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 159, "module": "tests.test_orchestrators", "name": "test_networks_cli_integration", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_networks_orchestrator_help": [{"docstring": "Test networks orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 51, "module": "tests.test_orchestrators", "name": "test_networks_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_neutrality_summary_plot": [{"docstring": "Test neutrality test summary plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 173, "module": "tests.test_dna_population_viz", "name": "test_neutrality_summary_plot", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_no_association": [{"docstring": "Test no association (independent).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 160, "module": "tests.test_math_utilities", "name": "test_no_association", "signature": "(self)", "symbol_type": "function"}], "test_no_common_samples_error": [{"docstring": "Test error when no common samples exist.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 108, "module": "tests.test_multiomics_integration", "name": "test_no_common_samples_error", "signature": "(self)", "symbol_type": "function"}], "test_no_correlation": [{"docstring": "Test no correlation (r \u2248 0).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 43, "module": "tests.test_math_utilities", "name": "test_no_correlation", "signature": "(self)", "symbol_type": "function"}], "test_no_growth": [{"docstring": "Test with zero growth rate.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_demography.py", "line_number": 19, "module": "tests.test_math_demography", "name": "test_no_growth", "signature": "(self)", "symbol_type": "function"}], "test_no_matching_events": [{"docstring": "Test trait mapping with no matching events.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 256, "module": "tests.test_phenotype_life_course", "name": "test_no_matching_events", "signature": "(self)", "symbol_type": "function"}], "test_no_relationship": [{"docstring": "Test no linear relationship.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 100, "module": "tests.test_math_utilities", "name": "test_no_relationship", "signature": "(self)", "symbol_type": "function"}], "test_no_segregating_sites": [{"docstring": "Test with no segregating sites.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 132, "module": "tests.test_dna_population_comprehensive", "name": "test_no_segregating_sites", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test with no segregating sites.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 193, "module": "tests.test_dna_population_comprehensive", "name": "test_no_segregating_sites", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test with no segregating sites.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 221, "module": "tests.test_dna_population_comprehensive", "name": "test_no_segregating_sites", "signature": "(self)", "symbol_type": "function"}], "test_non_normalized_inputs": [{"docstring": "Test that non-normalized inputs are handled.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 205, "module": "tests.test_math_utilities", "name": "test_non_normalized_inputs", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test that non-normalized inputs are normalized.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 268, "module": "tests.test_math_utilities", "name": "test_non_normalized_inputs", "signature": "(self)", "symbol_type": "function"}], "test_none_sequence": [{"docstring": "Test that None sequence raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 97, "module": "tests.test_phenotype_life_course", "name": "test_none_sequence", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test that None sequence raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 239, "module": "tests.test_phenotype_life_course", "name": "test_none_sequence", "signature": "(self)", "symbol_type": "function"}], "test_nonexistent_file": [{"docstring": "Test handling of nonexistent file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 440, "module": "tests.test_quality_fastq", "name": "test_nonexistent_file", "signature": "(self)", "symbol_type": "function"}], "test_nonexistent_nodes": [{"docstring": "Test operations on nonexistent nodes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 361, "module": "tests.test_networks_graph", "name": "test_nonexistent_nodes", "signature": "(self)", "symbol_type": "function"}], "test_normalize_counts_basic": [{"docstring": "Test count normalization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 121, "module": "tests.test_singlecell_basic", "name": "test_normalize_counts_basic", "signature": "(self)", "symbol_type": "function"}], "test_normalize_counts_median": [{"docstring": "Test median normalization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 279, "module": "tests.test_singlecell_preprocessing", "name": "test_normalize_counts_median", "signature": "(self)", "symbol_type": "function"}], "test_normalize_counts_total_count": [{"docstring": "Test total count normalization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 260, "module": "tests.test_singlecell_preprocessing", "name": "test_normalize_counts_total_count", "signature": "(self)", "symbol_type": "function"}], "test_normalize_whitespace_basic": [{"docstring": "Test basic whitespace normalization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 75, "module": "tests.test_core_text", "name": "test_normalize_whitespace_basic", "signature": "(self) -> None", "symbol_type": "function"}], "test_normalize_whitespace_edge_cases": [{"docstring": "Test edge cases for whitespace normalization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 80, "module": "tests.test_core_text", "name": "test_normalize_whitespace_edge_cases", "signature": "(self) -> None", "symbol_type": "function"}], "test_normalize_whitespace_preserve_structure": [{"docstring": "Test that normalization preserves word order.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 111, "module": "tests.test_core_text", "name": "test_normalize_whitespace_preserve_structure", "signature": "(self) -> None", "symbol_type": "function"}], "test_normalize_whitespace_unicode": [{"docstring": "Test whitespace normalization with unicode characters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 97, "module": "tests.test_core_text", "name": "test_normalize_whitespace_unicode", "signature": "(self) -> None", "symbol_type": "function"}], "test_normalize_whitespace_very_long": [{"docstring": "Test normalization with very long strings.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 105, "module": "tests.test_core_text", "name": "test_normalize_whitespace_very_long", "signature": "(self) -> None", "symbol_type": "function"}], "test_normalized_mutual_information": [{"docstring": "Test normalized mutual information.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 336, "module": "tests.test_information_comprehensive", "name": "test_normalized_mutual_information", "signature": "(self)", "symbol_type": "function"}], "test_nucleotide_diversity_two_sequences": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_stats.py", "line_number": 6, "module": "tests.test_dna_population_stats", "name": "test_nucleotide_diversity_two_sequences", "signature": "() -> None", "symbol_type": "function"}], "test_numerical_stability": [{"docstring": "Test numerical stability of calculations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_enhanced.py", "line_number": 179, "module": "tests.test_math_enhanced", "name": "test_numerical_stability", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test numerical stability of calculations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_enhanced.py", "line_number": 144, "module": "tests.test_math_popgen_enhanced", "name": "test_numerical_stability", "signature": "(self)", "symbol_type": "function"}], "test_observed_heterozygosity": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_genetics.py", "line_number": 22, "module": "tests.test_dna_population_genetics", "name": "test_observed_heterozygosity", "signature": "() -> None", "symbol_type": "function"}], "test_odds_ratio_calculation": [{"docstring": "Test odds ratio calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 153, "module": "tests.test_math_utilities", "name": "test_odds_ratio_calculation", "signature": "(self)", "symbol_type": "function"}], "test_ontology_add_term_validation": [{"docstring": "Test add_term validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 132, "module": "tests.test_ontology_types", "name": "test_ontology_add_term_validation", "signature": "(self)", "symbol_type": "function"}], "test_ontology_children_of": [{"docstring": "Test children_of mapping.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 87, "module": "tests.test_ontology_types", "name": "test_ontology_children_of", "signature": "(self)", "symbol_type": "function"}], "test_ontology_cli_integration": [{"docstring": "Test ontology CLI command.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 125, "module": "tests.test_orchestrators", "name": "test_ontology_cli_integration", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_ontology_creation": [{"docstring": "Test creating ontology.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_comprehensive.py", "line_number": 35, "module": "tests.test_ontology_comprehensive", "name": "test_ontology_creation", "signature": "(self)", "symbol_type": "function"}], "test_ontology_creation_empty": [{"docstring": "Test creating empty ontology.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 56, "module": "tests.test_ontology_types", "name": "test_ontology_creation_empty", "signature": "(self)", "symbol_type": "function"}], "test_ontology_creation_with_terms": [{"docstring": "Test creating ontology with terms.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 63, "module": "tests.test_ontology_types", "name": "test_ontology_creation_with_terms", "signature": "(self)", "symbol_type": "function"}], "test_ontology_get_namespace": [{"docstring": "Test getting namespace for term.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 125, "module": "tests.test_ontology_types", "name": "test_ontology_get_namespace", "signature": "(self)", "symbol_type": "function"}], "test_ontology_get_relationships": [{"docstring": "Test get_relationships method.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 192, "module": "tests.test_ontology_types", "name": "test_ontology_get_relationships", "signature": "(self)", "symbol_type": "function"}], "test_ontology_get_relationships_missing_term": [{"docstring": "Test get_relationships with missing term.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 213, "module": "tests.test_ontology_types", "name": "test_ontology_get_relationships_missing_term", "signature": "(self)", "symbol_type": "function"}], "test_ontology_get_term": [{"docstring": "Test getting term by ID via dictionary access.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 97, "module": "tests.test_ontology_types", "name": "test_ontology_get_term", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test getting term by ID.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 117, "module": "tests.test_ontology_types", "name": "test_ontology_get_term", "signature": "(self)", "symbol_type": "function"}], "test_ontology_get_term_missing": [{"docstring": "Test getting non-existent term.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 104, "module": "tests.test_ontology_types", "name": "test_ontology_get_term_missing", "signature": "(self)", "symbol_type": "function"}], "test_ontology_go_dir_counts": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_domain_modules.py", "line_number": 33, "module": "tests.test_domain_modules", "name": "test_ontology_go_dir_counts", "signature": "()", "symbol_type": "function"}], "test_ontology_has_term": [{"docstring": "Test checking if term exists.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 110, "module": "tests.test_ontology_types", "name": "test_ontology_has_term", "signature": "(self)", "symbol_type": "function"}], "test_ontology_hierarchy": [{"docstring": "Test ontology parent-child relationships.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_comprehensive.py", "line_number": 46, "module": "tests.test_ontology_comprehensive", "name": "test_ontology_hierarchy", "signature": "(self)", "symbol_type": "function"}], "test_ontology_orchestrator_help": [{"docstring": "Test ontology orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 37, "module": "tests.test_orchestrators", "name": "test_ontology_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_ontology_parents_of": [{"docstring": "Test parents_of mapping.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 77, "module": "tests.test_ontology_types", "name": "test_ontology_parents_of", "signature": "(self)", "symbol_type": "function"}], "test_ontology_validate": [{"docstring": "Test ontology validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 151, "module": "tests.test_ontology_types", "name": "test_ontology_validate", "signature": "(self)", "symbol_type": "function"}], "test_open_text_auto_handles_gz": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io.py", "line_number": 48, "module": "tests.test_core_io", "name": "test_open_text_auto_handles_gz", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_optimize_resolution": [{"docstring": "Test resolution optimization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 426, "module": "tests.test_networks_community", "name": "test_optimize_resolution", "signature": "(self)", "symbol_type": "function"}], "test_orf_finding": [{"docstring": "Test ORF finding functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 106, "module": "tests.test_dna_sequences_enhanced", "name": "test_orf_finding", "signature": "(self)", "symbol_type": "function"}], "test_overrepresented_detection": [{"docstring": "Test detection of overrepresented sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 238, "module": "tests.test_quality_fastq", "name": "test_overrepresented_detection", "signature": "(self)", "symbol_type": "function"}], "test_p_distance_and_jc69": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_distances.py", "line_number": 6, "module": "tests.test_dna_distances", "name": "test_p_distance_and_jc69", "signature": "() -> None", "symbol_type": "function"}], "test_p_distance_calculation": [{"docstring": "Test p-distance calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 128, "module": "tests.test_dna_comprehensive", "name": "test_p_distance_calculation", "signature": "(self)", "symbol_type": "function"}], "test_pairwise_diversity": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_coalescent.py", "line_number": 25, "module": "tests.test_math_coalescent", "name": "test_pairwise_diversity", "signature": "()", "symbol_type": "function"}], "test_pairwise_identity_and_needleman_wunsch": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_identity_alignment.py", "line_number": 4, "module": "tests.test_protein_identity_alignment", "name": "test_pairwise_identity_and_needleman_wunsch", "signature": "()", "symbol_type": "function"}], "test_palindrome_finding": [{"docstring": "Test palindrome finding functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 208, "module": "tests.test_dna_sequences_enhanced", "name": "test_palindrome_finding", "signature": "(self)", "symbol_type": "function"}], "test_pandas_csv_operations": [{"docstring": "Test pandas CSV operations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io_enhanced.py", "line_number": 114, "module": "tests.test_core_io_enhanced", "name": "test_pandas_csv_operations", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_pandas_parquet_operations": [{"docstring": "Test pandas Parquet operations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io_enhanced.py", "line_number": 146, "module": "tests.test_core_io_enhanced", "name": "test_pandas_parquet_operations", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_parse_fasta_and_composition": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_sequences.py", "line_number": 6, "module": "tests.test_protein_sequences", "name": "test_parse_fasta_and_composition", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_parse_obo_minimal_fields": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_obo_parser.py", "line_number": 6, "module": "tests.test_ontology_obo_parser", "name": "test_parse_obo_minimal_fields", "signature": "() -> None", "symbol_type": "function"}], "test_parse_obo_with_alt_ids": [{"docstring": "Test parsing OBO with alternative IDs.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_comprehensive.py", "line_number": 160, "module": "tests.test_ontology_comprehensive", "name": "test_parse_obo_with_alt_ids", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_parse_simple_obo": [{"docstring": "Test parsing simple OBO file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_comprehensive.py", "line_number": 131, "module": "tests.test_ontology_comprehensive", "name": "test_parse_simple_obo", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_parse_vcf_full_basic": [{"docstring": "Test parsing VCF file with genotypes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_quality.py", "line_number": 12, "module": "tests.test_gwas_quality", "name": "test_parse_vcf_full_basic", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_parse_vcf_full_missing_genotypes": [{"docstring": "Test parsing VCF with missing genotypes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_quality.py", "line_number": 38, "module": "tests.test_gwas_quality", "name": "test_parse_vcf_full_missing_genotypes", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_parse_vcf_minimal": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_variants_vcf.py", "line_number": 8, "module": "tests.test_dna_variants_vcf", "name": "test_parse_vcf_minimal", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_path_expansion": [{"docstring": "Test path expansion and resolution.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 259, "module": "tests.test_core_comprehensive", "name": "test_path_expansion", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_path_operations": [{"docstring": "Test path utility functions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 100, "module": "tests.test_core_functionality", "name": "test_path_operations", "signature": "(self)", "symbol_type": "function"}], "test_path_to_root_no_parents": [{"docstring": "Test path to root for term with no parents.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 200, "module": "tests.test_ontology_query", "name": "test_path_to_root_no_parents", "signature": "(self)", "symbol_type": "function"}], "test_path_to_root_simple": [{"docstring": "Test finding path to root.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 185, "module": "tests.test_ontology_query", "name": "test_path_to_root_simple", "signature": "(self)", "symbol_type": "function"}], "test_path_validation": [{"docstring": "Test path validation and security.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 286, "module": "tests.test_core_comprehensive", "name": "test_path_validation", "signature": "(self)", "symbol_type": "function"}], "test_pathway_activity_score": [{"docstring": "Test pathway activity scoring.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 493, "module": "tests.test_networks_pathway", "name": "test_pathway_activity_score", "signature": "(self)", "symbol_type": "function"}], "test_pathway_enrichment": [{"docstring": "Test pathway enrichment analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 203, "module": "tests.test_networks_comprehensive", "name": "test_pathway_enrichment", "signature": "(self)", "symbol_type": "function"}], "test_pathway_enrichment_basic": [{"docstring": "Test basic pathway enrichment analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 247, "module": "tests.test_networks_pathway", "name": "test_pathway_enrichment_basic", "signature": "(self)", "symbol_type": "function"}], "test_pathway_enrichment_empty_gene_set": [{"docstring": "Test enrichment with empty gene set.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 297, "module": "tests.test_networks_pathway", "name": "test_pathway_enrichment_empty_gene_set", "signature": "(self)", "symbol_type": "function"}], "test_pathway_enrichment_no_overlap": [{"docstring": "Test enrichment when gene set has no overlap with pathways.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 283, "module": "tests.test_networks_pathway", "name": "test_pathway_enrichment_no_overlap", "signature": "(self)", "symbol_type": "function"}], "test_pathway_enrichment_significance": [{"docstring": "Test statistical significance of enrichment.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 270, "module": "tests.test_networks_pathway", "name": "test_pathway_enrichment_significance", "signature": "(self)", "symbol_type": "function"}], "test_pathway_network_creation": [{"docstring": "Test creating pathway network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 184, "module": "tests.test_networks_comprehensive", "name": "test_pathway_network_creation", "signature": "(self)", "symbol_type": "function"}], "test_pathway_network_initialization": [{"docstring": "Test PathwayNetwork initialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 47, "module": "tests.test_networks_pathway", "name": "test_pathway_network_initialization", "signature": "(self)", "symbol_type": "function"}], "test_pathway_overlap": [{"docstring": "Test pathway overlap calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 192, "module": "tests.test_networks_comprehensive", "name": "test_pathway_overlap", "signature": "(self)", "symbol_type": "function"}], "test_pathway_regulation_analysis_basic": [{"docstring": "Test basic pathway regulation analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 452, "module": "tests.test_networks_regulatory", "name": "test_pathway_regulation_analysis_basic", "signature": "(self)", "symbol_type": "function"}], "test_pathway_regulation_analysis_empty_pathway": [{"docstring": "Test analysis with empty pathway.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 492, "module": "tests.test_networks_regulatory", "name": "test_pathway_regulation_analysis_empty_pathway", "signature": "(self)", "symbol_type": "function"}], "test_pathway_regulation_analysis_enrichment": [{"docstring": "Test pathway regulation enrichment analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 475, "module": "tests.test_networks_regulatory", "name": "test_pathway_regulation_analysis_enrichment", "signature": "(self)", "symbol_type": "function"}], "test_pathway_similarity": [{"docstring": "Test pathway similarity calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 103, "module": "tests.test_networks_pathway", "name": "test_pathway_similarity", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test pathway similarity calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 476, "module": "tests.test_networks_pathway", "name": "test_pathway_similarity", "signature": "(self)", "symbol_type": "function"}], "test_pathway_similarity_and_activity": [{"docstring": "Test pathway similarity and activity scoring.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 399, "module": "tests.test_networks_comprehensive", "name": "test_pathway_similarity_and_activity", "signature": "(self)", "symbol_type": "function"}], "test_pbarbatus_config_parameters": [{"docstring": "Test that P. barbatus config has all required parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_config_pbarbatus.py", "line_number": 65, "module": "tests.test_gwas_config_pbarbatus", "name": "test_pbarbatus_config_parameters", "signature": "() -> None", "symbol_type": "function"}], "test_pbarbatus_config_validation": [{"docstring": "Test configuration validation for P. barbatus.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_config_pbarbatus.py", "line_number": 49, "module": "tests.test_gwas_config_pbarbatus", "name": "test_pbarbatus_config_validation", "signature": "() -> None", "symbol_type": "function"}], "test_pca_basic": [{"docstring": "Test basic PCA functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 327, "module": "tests.test_ml_comprehensive", "name": "test_pca_basic", "signature": "(self)", "symbol_type": "function"}], "test_pca_different_components": [{"docstring": "Test PCA with different numbers of components.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 343, "module": "tests.test_ml_comprehensive", "name": "test_pca_different_components", "signature": "(self)", "symbol_type": "function"}], "test_pca_plot": [{"docstring": "Test PCA plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 96, "module": "tests.test_dna_population_viz", "name": "test_pca_plot", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}, {"docstring": "Test PCA plot functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 308, "module": "tests.test_visualization_enhanced", "name": "test_pca_plot", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test PCA plot functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 434, "module": "tests.test_visualization_enhanced", "name": "test_pca_plot", "signature": "(self)", "symbol_type": "function"}], "test_pca_plot_failure": [{"docstring": "Test PCA plot with failed status.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 116, "module": "tests.test_dna_population_viz", "name": "test_pca_plot_failure", "signature": "(self)", "symbol_type": "function"}], "test_pca_standardization_effect": [{"docstring": "Test effect of standardization on PCA.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 354, "module": "tests.test_ml_comprehensive", "name": "test_pca_standardization_effect", "signature": "(self)", "symbol_type": "function"}], "test_pdb_download_cif_format_real_network": [{"docstring": "Test real PDB download in CIF format.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_uniprot_pdb.py", "line_number": 69, "module": "tests.test_protein_uniprot_pdb", "name": "test_pdb_download_cif_format_real_network", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_pdb_download_format_handling": [{"docstring": "Test PDB format parameter handling (no network required).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_uniprot_pdb.py", "line_number": 94, "module": "tests.test_protein_uniprot_pdb", "name": "test_pdb_download_format_handling", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_pdb_download_invalid_id_real_behavior": [{"docstring": "Test real behavior with invalid PDB ID.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_uniprot_pdb.py", "line_number": 84, "module": "tests.test_protein_uniprot_pdb", "name": "test_pdb_download_invalid_id_real_behavior", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_pdb_download_real_network": [{"docstring": "Test real PDB file download with actual HTTP requests.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_uniprot_pdb.py", "line_number": 54, "module": "tests.test_protein_uniprot_pdb", "name": "test_pdb_download_real_network", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_pdb_offline_behavior": [{"docstring": "Document real offline behavior for PDB downloads.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_uniprot_pdb.py", "line_number": 108, "module": "tests.test_protein_uniprot_pdb", "name": "test_pdb_offline_behavior", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_per_base_quality_calculation": [{"docstring": "Test per-base quality score calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 94, "module": "tests.test_quality_fastq", "name": "test_per_base_quality_calculation", "signature": "(self)", "symbol_type": "function"}], "test_per_base_quality_variable_lengths": [{"docstring": "Test per-base quality with variable read lengths.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 120, "module": "tests.test_quality_fastq", "name": "test_per_base_quality_variable_lengths", "signature": "(self)", "symbol_type": "function"}], "test_perfect_line": [{"docstring": "Test perfect linear relationship (y = 2x + 1).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 82, "module": "tests.test_math_utilities", "name": "test_perfect_line", "signature": "(self)", "symbol_type": "function"}], "test_perfect_line_through_origin": [{"docstring": "Test perfect line through origin (y = 2x).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 91, "module": "tests.test_math_utilities", "name": "test_perfect_line_through_origin", "signature": "(self)", "symbol_type": "function"}], "test_perfect_negative_correlation": [{"docstring": "Test perfect negative correlation (r = -1.0).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 36, "module": "tests.test_math_utilities", "name": "test_perfect_negative_correlation", "signature": "(self)", "symbol_type": "function"}], "test_perfect_positive_correlation": [{"docstring": "Test perfect positive correlation (r = 1.0).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 29, "module": "tests.test_math_utilities", "name": "test_perfect_positive_correlation", "signature": "(self)", "symbol_type": "function"}], "test_perfect_separation": [{"docstring": "Test feature selection when one feature perfectly separates classes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 592, "module": "tests.test_ml_features", "name": "test_perfect_separation", "signature": "(self)", "symbol_type": "function"}], "test_permutation_test": [{"docstring": "Test permutation test.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_stats.py", "line_number": 32, "module": "tests.test_math_popgen_stats", "name": "test_permutation_test", "signature": "()", "symbol_type": "function"}], "test_permutation_test_with_empty_groups": [{"docstring": "Test permutation test with empty groups.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_stats.py", "line_number": 114, "module": "tests.test_math_popgen_stats", "name": "test_permutation_test_with_empty_groups", "signature": "()", "symbol_type": "function"}], "test_phenotype_antwiki_json_loads": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_domain_modules.py", "line_number": 25, "module": "tests.test_domain_modules", "name": "test_phenotype_antwiki_json_loads", "signature": "()", "symbol_type": "function"}], "test_phenotype_cli_integration": [{"docstring": "Test phenotype CLI command.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 141, "module": "tests.test_orchestrators", "name": "test_phenotype_cli_integration", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_phenotype_orchestrator_help": [{"docstring": "Test phenotype orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 44, "module": "tests.test_orchestrators", "name": "test_phenotype_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_pi_theta_ratio": [{"docstring": "Test pi/theta ratio calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_analysis.py", "line_number": 140, "module": "tests.test_dna_population_analysis", "name": "test_pi_theta_ratio", "signature": "(self)", "symbol_type": "function"}], "test_pielou_evenness_no_evenness": [{"docstring": "Test Pielou evenness with no evenness.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 75, "module": "tests.test_ecology_basic", "name": "test_pielou_evenness_no_evenness", "signature": "(self)", "symbol_type": "function"}], "test_pielou_evenness_perfect_evenness": [{"docstring": "Test Pielou evenness with perfect evenness.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 65, "module": "tests.test_ecology_basic", "name": "test_pielou_evenness_perfect_evenness", "signature": "(self)", "symbol_type": "function"}], "test_pielou_evenness_zero_richness": [{"docstring": "Test Pielou evenness with zero richness.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 85, "module": "tests.test_ecology_basic", "name": "test_pielou_evenness_zero_richness", "signature": "(self)", "symbol_type": "function"}], "test_plan_workflow_orders_steps_and_inherits_common_params": [{"docstring": "Test that plan_workflow returns steps in correct order and inherits common parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_workflow.py", "line_number": 13, "module": "tests.test_rna_workflow", "name": "test_plan_workflow_orders_steps_and_inherits_common_params", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_plan_workflow_parameter_inheritance": [{"docstring": "Test that step-specific parameters override common parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_workflow.py", "line_number": 93, "module": "tests.test_rna_workflow", "name": "test_plan_workflow_parameter_inheritance", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_plan_workflow_step_dependencies": [{"docstring": "Test that workflow steps respect dependencies (e.g., quant requires getfastq).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_workflow.py", "line_number": 41, "module": "tests.test_rna_workflow", "name": "test_plan_workflow_step_dependencies", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_plan_workflow_with_params_merges_common_and_specific": [{"docstring": "Test that plan_workflow_with_params correctly merges common config with step-specific parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_configs.py", "line_number": 44, "module": "tests.test_rna_configs", "name": "test_plan_workflow_with_params_merges_common_and_specific", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_plan_workflow_with_specific_steps": [{"docstring": "Test that plan_workflow respects step filtering when specific steps are requested.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_workflow.py", "line_number": 68, "module": "tests.test_rna_workflow", "name": "test_plan_workflow_with_specific_steps", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_plot_allele_frequency_spectrum": [{"docstring": "Test allele frequency spectrum plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz_advanced.py", "line_number": 23, "module": "tests.test_dna_population_viz_advanced", "name": "test_plot_allele_frequency_spectrum", "signature": "()", "symbol_type": "function"}], "test_plot_attention_heatmap": [{"docstring": "Test attention heatmap plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization.py", "line_number": 87, "module": "tests.test_life_events_visualization", "name": "test_plot_attention_heatmap", "signature": "(tmp_path)", "symbol_type": "function"}], "test_plot_bootstrap_distribution": [{"docstring": "Test bootstrap distribution plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz_advanced.py", "line_number": 104, "module": "tests.test_dna_population_viz_advanced", "name": "test_plot_bootstrap_distribution", "signature": "()", "symbol_type": "function"}], "test_plot_data_types": [{"docstring": "Test that plots work with different data types.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 218, "module": "tests.test_visualization_enhanced", "name": "test_plot_data_types", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test that enhanced plots work with different data types.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 342, "module": "tests.test_visualization_enhanced", "name": "test_plot_data_types", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test that enhanced plots work with different data types.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 552, "module": "tests.test_visualization_enhanced", "name": "test_plot_data_types", "signature": "(self)", "symbol_type": "function"}], "test_plot_domain_distribution": [{"docstring": "Test domain distribution plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 48, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_domain_distribution", "signature": "(tmp_path, sample_sequences)", "symbol_type": "function"}], "test_plot_domain_timeline": [{"docstring": "Test domain timeline plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 126, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_domain_timeline", "signature": "(tmp_path, sample_sequences)", "symbol_type": "function"}], "test_plot_embedding_clusters": [{"docstring": "Test embedding clusters plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 203, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_embedding_clusters", "signature": "(tmp_path)", "symbol_type": "function"}], "test_plot_error_handling": [{"docstring": "Test error handling in plotting functions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 147, "module": "tests.test_visualization_enhanced", "name": "test_plot_error_handling", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test error handling in enhanced plotting functions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 328, "module": "tests.test_visualization_enhanced", "name": "test_plot_error_handling", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test error handling in enhanced plotting functions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 531, "module": "tests.test_visualization_enhanced", "name": "test_plot_error_handling", "signature": "(self)", "symbol_type": "function"}], "test_plot_event_cooccurrence": [{"docstring": "Test event co-occurrence plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 72, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_event_cooccurrence", "signature": "(tmp_path, sample_sequences)", "symbol_type": "function"}], "test_plot_event_embeddings": [{"docstring": "Test event embeddings plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization.py", "line_number": 36, "module": "tests.test_life_events_visualization", "name": "test_plot_event_embeddings", "signature": "(tmp_path)", "symbol_type": "function"}], "test_plot_event_embeddings_3d": [{"docstring": "Test 3D event embeddings plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization.py", "line_number": 62, "module": "tests.test_life_events_visualization", "name": "test_plot_event_embeddings_3d", "signature": "(tmp_path)", "symbol_type": "function"}], "test_plot_event_frequency_heatmap": [{"docstring": "Test event frequency heatmap plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 238, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_event_frequency_heatmap", "signature": "(tmp_path, sample_sequences)", "symbol_type": "function"}], "test_plot_event_timeline": [{"docstring": "Test event timeline plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization.py", "line_number": 14, "module": "tests.test_life_events_visualization", "name": "test_plot_event_timeline", "signature": "(tmp_path)", "symbol_type": "function"}], "test_plot_fst_matrix": [{"docstring": "Test Fst matrix plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz_advanced.py", "line_number": 71, "module": "tests.test_dna_population_viz_advanced", "name": "test_plot_fst_matrix", "signature": "()", "symbol_type": "function"}], "test_plot_hardy_weinberg_test": [{"docstring": "Test Hardy-Weinberg test plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz_advanced.py", "line_number": 91, "module": "tests.test_dna_population_viz_advanced", "name": "test_plot_hardy_weinberg_test", "signature": "()", "symbol_type": "function"}], "test_plot_heterozygosity_distribution": [{"docstring": "Test heterozygosity distribution plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz_advanced.py", "line_number": 31, "module": "tests.test_dna_population_viz_advanced", "name": "test_plot_heterozygosity_distribution", "signature": "()", "symbol_type": "function"}], "test_plot_intervention_effects": [{"docstring": "Test intervention effects plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 184, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_intervention_effects", "signature": "(tmp_path, sample_sequences)", "symbol_type": "function"}], "test_plot_neutrality_test_suite": [{"docstring": "Test neutrality test suite plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz_advanced.py", "line_number": 79, "module": "tests.test_dna_population_viz_advanced", "name": "test_plot_neutrality_test_suite", "signature": "()", "symbol_type": "function"}], "test_plot_outcome_distribution": [{"docstring": "Test outcome distribution plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 84, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_outcome_distribution", "signature": "(tmp_path)", "symbol_type": "function"}], "test_plot_outlier_detection": [{"docstring": "Test outlier detection plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz_advanced.py", "line_number": 121, "module": "tests.test_dna_population_viz_advanced", "name": "test_plot_outlier_detection", "signature": "()", "symbol_type": "function"}], "test_plot_permutation_test": [{"docstring": "Test permutation test plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz_advanced.py", "line_number": 112, "module": "tests.test_dna_population_viz_advanced", "name": "test_plot_permutation_test", "signature": "()", "symbol_type": "function"}], "test_plot_phylo_tree_smoke": [{"docstring": "Test that phylogenetic tree plotting works with basic tree structure.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_phylo.py", "line_number": 6, "module": "tests.test_visualization_phylo", "name": "test_plot_phylo_tree_smoke", "signature": "()", "symbol_type": "function"}], "test_plot_pi_vs_theta": [{"docstring": "Test \u03c0 vs \u03b8 plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz_advanced.py", "line_number": 50, "module": "tests.test_dna_population_viz_advanced", "name": "test_plot_pi_vs_theta", "signature": "()", "symbol_type": "function"}], "test_plot_population_comparison": [{"docstring": "Test population comparison plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 167, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_population_comparison", "signature": "(tmp_path, sample_sequences)", "symbol_type": "function"}], "test_plot_prediction_accuracy": [{"docstring": "Test prediction accuracy plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 138, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_prediction_accuracy", "signature": "(tmp_path)", "symbol_type": "function"}], "test_plot_prediction_importance": [{"docstring": "Test prediction importance plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization.py", "line_number": 113, "module": "tests.test_life_events_visualization", "name": "test_plot_prediction_importance", "signature": "(tmp_path)", "symbol_type": "function"}], "test_plot_prediction_importance_empty": [{"docstring": "Test prediction importance plotting with empty dict.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization.py", "line_number": 138, "module": "tests.test_life_events_visualization", "name": "test_plot_prediction_importance_empty", "signature": "()", "symbol_type": "function"}], "test_plot_return_values": [{"docstring": "Test that plot functions return the correct axes objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 192, "module": "tests.test_visualization_enhanced", "name": "test_plot_return_values", "signature": "(self)", "symbol_type": "function"}], "test_plot_sequence_length_distribution": [{"docstring": "Test sequence length distribution plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 227, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_sequence_length_distribution", "signature": "(tmp_path, sample_sequences)", "symbol_type": "function"}], "test_plot_sequence_similarity": [{"docstring": "Test sequence similarity plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 97, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_sequence_similarity", "signature": "(tmp_path, sample_sequences)", "symbol_type": "function"}], "test_plot_statistic_correlation_matrix": [{"docstring": "Test statistic correlation matrix plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz_advanced.py", "line_number": 59, "module": "tests.test_dna_population_viz_advanced", "name": "test_plot_statistic_correlation_matrix", "signature": "()", "symbol_type": "function"}], "test_plot_statistic_distribution": [{"docstring": "Test statistic distribution plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz_advanced.py", "line_number": 39, "module": "tests.test_dna_population_viz_advanced", "name": "test_plot_statistic_distribution", "signature": "()", "symbol_type": "function"}], "test_plot_temporal_density": [{"docstring": "Test temporal density plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 60, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_temporal_density", "signature": "(tmp_path, sample_sequences)", "symbol_type": "function"}], "test_plot_temporal_patterns": [{"docstring": "Test temporal patterns plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 154, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_temporal_patterns", "signature": "(tmp_path, sample_sequences)", "symbol_type": "function"}], "test_plot_transition_network": [{"docstring": "Test transition network plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_visualization_extended.py", "line_number": 111, "module": "tests.test_life_events_visualization_extended", "name": "test_plot_transition_network", "signature": "(tmp_path, sample_sequences)", "symbol_type": "function"}], "test_plot_with_matplotlib_backend": [{"docstring": "Test that plots work with different matplotlib backends.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 164, "module": "tests.test_visualization_enhanced", "name": "test_plot_with_matplotlib_backend", "signature": "(self)", "symbol_type": "function"}], "test_plot_without_saving": [{"docstring": "Test plotting without saving.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 44, "module": "tests.test_dna_population_viz", "name": "test_plot_without_saving", "signature": "(self)", "symbol_type": "function"}], "test_point_mutations_and_hamming": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_mutations.py", "line_number": 4, "module": "tests.test_dna_mutations", "name": "test_point_mutations_and_hamming", "signature": "() -> None", "symbol_type": "function"}], "test_population_contraction": [{"docstring": "Test population contraction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_demography.py", "line_number": 84, "module": "tests.test_math_demography", "name": "test_population_contraction", "signature": "(self)", "symbol_type": "function"}], "test_population_difference": [{"docstring": "Test for differences in a specific statistic between populations.\n\nCompares a single statistic value between two populations using\nappropriate statistical test.\n\nArgs:\n    population1_stats: Dictionary of statistics for population 1\n    population2_stats: Dictionary of statistics for population 2\n    statistic_name: Name of statistic to compare\n\nReturns:\n    Dictionary with test results\n    \nExamples:\n    >>> pop1 = {\"pi\": 0.01, \"theta\": 0.01}\n    >>> pop2 = {\"pi\": 0.02, \"theta\": 0.02}\n    >>> result = test_population_difference(pop1, pop2, \"pi\")\n    >>> \"p_value\" in result\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/popgen_stats.py", "line_number": 394, "module": "src.metainformant.math.popgen_stats", "name": "test_population_difference", "signature": "(population1_stats: dict[str, float], population2_stats: dict[str, float], statistic_name: str) -> dict[str, float]", "symbol_type": "function"}], "test_population_differentiation": [{"docstring": "Test that populations are differentiated.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 103, "module": "tests.test_simulation_popgen", "name": "test_population_differentiation", "signature": "(self)", "symbol_type": "function"}], "test_population_expansion": [{"docstring": "Test population expansion.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_demography.py", "line_number": 77, "module": "tests.test_math_demography", "name": "test_population_expansion", "signature": "(self)", "symbol_type": "function"}], "test_population_genetics_mathematical_modeling": [{"docstring": "Test integration of population genetics with mathematical models.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_integration_comprehensive.py", "line_number": 258, "module": "tests.test_integration_comprehensive", "name": "test_population_genetics_mathematical_modeling", "signature": "(self)", "symbol_type": "function"}], "test_population_plot": [{"docstring": "Test population-specific plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 135, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_population_plot", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_positive_correlation": [{"docstring": "Test positive correlation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 50, "module": "tests.test_math_utilities", "name": "test_positive_correlation", "signature": "(self)", "symbol_type": "function"}], "test_positive_growth": [{"docstring": "Test with positive growth rate.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_demography.py", "line_number": 24, "module": "tests.test_math_demography", "name": "test_positive_growth", "signature": "(self)", "symbol_type": "function"}], "test_positive_slope": [{"docstring": "Test positive slope.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 109, "module": "tests.test_math_utilities", "name": "test_positive_slope", "signature": "(self)", "symbol_type": "function"}], "test_predict_interactions_basic": [{"docstring": "Test basic interaction prediction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 290, "module": "tests.test_networks_ppi", "name": "test_predict_interactions_basic", "signature": "(self)", "symbol_type": "function"}], "test_predict_interactions_confidence_threshold": [{"docstring": "Test prediction with confidence threshold.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 331, "module": "tests.test_networks_ppi", "name": "test_predict_interactions_confidence_threshold", "signature": "(self)", "symbol_type": "function"}], "test_predict_interactions_correlation": [{"docstring": "Test interaction prediction from features.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 242, "module": "tests.test_networks_comprehensive", "name": "test_predict_interactions_correlation", "signature": "(self)", "symbol_type": "function"}], "test_predict_interactions_different_methods": [{"docstring": "Test interaction prediction with different methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 311, "module": "tests.test_networks_ppi", "name": "test_predict_interactions_different_methods", "signature": "(self)", "symbol_type": "function"}], "test_predict_interactions_empty_network": [{"docstring": "Test prediction with empty known network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 347, "module": "tests.test_networks_ppi", "name": "test_predict_interactions_empty_network", "signature": "(self)", "symbol_type": "function"}], "test_predict_with_missing_events_in_vocab": [{"docstring": "Test prediction with out-of-vocabulary events.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 336, "module": "tests.test_life_events_embeddings", "name": "test_predict_with_missing_events_in_vocab", "signature": "()", "symbol_type": "function"}], "test_prediction_before_fitting": [{"docstring": "Test error when predicting before fitting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 702, "module": "tests.test_ml_comprehensive", "name": "test_prediction_before_fitting", "signature": "(self)", "symbol_type": "function"}], "test_preflight_manifest_when_amalgkit_missing": [{"docstring": "Test that workflow creates preflight manifest when amalgkit CLI is not available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_preflight_manifest.py", "line_number": 11, "module": "tests.test_rna_preflight_manifest", "name": "test_preflight_manifest_when_amalgkit_missing", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_preprocessing_pipeline": [{"docstring": "Test complete preprocessing pipeline.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 169, "module": "tests.test_singlecell_basic", "name": "test_preprocessing_pipeline", "signature": "(self)", "symbol_type": "function"}], "test_price_equation_with_offspring": [{"docstring": "Test Price equation decomposition with offspring data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 41, "module": "tests.test_math_comprehensive", "name": "test_price_equation_with_offspring", "signature": "(self)", "symbol_type": "function"}], "test_price_equation_without_offspring": [{"docstring": "Test Price equation with only selection term.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 53, "module": "tests.test_math_comprehensive", "name": "test_price_equation_without_offspring", "signature": "(self)", "symbol_type": "function"}], "test_processing_with_no_downloads": [{"docstring": "Test processing with only processing steps (no downloads).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_processing.py", "line_number": 193, "module": "tests.test_core_processing", "name": "test_processing_with_no_downloads", "signature": "(self)", "symbol_type": "function"}], "test_protein_api_integration_real_world": [{"docstring": "Integration test combining UniProt and PDB with real APIs.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_uniprot_pdb.py", "line_number": 121, "module": "tests.test_protein_uniprot_pdb", "name": "test_protein_api_integration_real_world", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_protein_cli_comp": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_cli_comp.py", "line_number": 8, "module": "tests.test_protein_cli_comp", "name": "test_protein_cli_comp", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_protein_cli_rmsd_ca": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_cli_structure.py", "line_number": 8, "module": "tests.test_protein_cli_structure", "name": "test_protein_cli_rmsd_ca", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_protein_cli_taxon_ids": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_cli.py", "line_number": 8, "module": "tests.test_protein_cli", "name": "test_protein_cli_taxon_ids", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_protein_complex_detection": [{"docstring": "Test protein complex detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 375, "module": "tests.test_networks_comprehensive", "name": "test_protein_complex_detection", "signature": "(self)", "symbol_type": "function"}], "test_protein_network_creation": [{"docstring": "Test creating PPI network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 222, "module": "tests.test_networks_comprehensive", "name": "test_protein_network_creation", "signature": "(self)", "symbol_type": "function"}], "test_protein_network_initialization": [{"docstring": "Test ProteinNetwork initialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 55, "module": "tests.test_networks_ppi", "name": "test_protein_network_initialization", "signature": "(self)", "symbol_type": "function"}], "test_protein_orchestrator_help": [{"docstring": "Test protein orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 30, "module": "tests.test_orchestrators", "name": "test_protein_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_protein_similarity": [{"docstring": "Test protein similarity calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 623, "module": "tests.test_networks_ppi", "name": "test_protein_similarity", "signature": "(self)", "symbol_type": "function"}], "test_protein_taxon_ids_readable": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_domain_modules.py", "line_number": 17, "module": "tests.test_domain_modules", "name": "test_protein_taxon_ids_readable", "signature": "()", "symbol_type": "function"}], "test_pyproject_exists": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_repo_structure.py", "line_number": 26, "module": "tests.test_repo_structure", "name": "test_pyproject_exists", "signature": "()", "symbol_type": "function"}], "test_qq_plot": [{"docstring": "Test Q-Q plot functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 479, "module": "tests.test_visualization_enhanced", "name": "test_qq_plot", "signature": "(self)", "symbol_type": "function"}], "test_qq_plot_basic": [{"docstring": "Test generating Q-Q plot from p-values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization.py", "line_number": 50, "module": "tests.test_gwas_visualization", "name": "test_qq_plot_basic", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}, {"docstring": "Test basic Q-Q plot generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 50, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_qq_plot_basic", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_qq_plot_from_file": [{"docstring": "Test generating Q-Q plot from results file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization.py", "line_number": 68, "module": "tests.test_gwas_visualization", "name": "test_qq_plot_from_file", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_qq_plot_statistical": [{"docstring": "Test Q-Q plot from statistical module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 89, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_qq_plot_statistical", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_quality_cli_integration": [{"docstring": "Test quality CLI command.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 177, "module": "tests.test_orchestrators", "name": "test_quality_cli_integration", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_quality_distribution_calculation": [{"docstring": "Test quality score distribution calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 321, "module": "tests.test_quality_fastq", "name": "test_quality_distribution_calculation", "signature": "(self)", "symbol_type": "function"}], "test_quality_orchestrator_help": [{"docstring": "Test quality orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 72, "module": "tests.test_orchestrators", "name": "test_quality_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_quality_score_conversion": [{"docstring": "Test Phred quality score conversion.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 346, "module": "tests.test_dna_comprehensive", "name": "test_quality_score_conversion", "signature": "(self)", "symbol_type": "function"}], "test_quant_basic_execution": [{"docstring": "Test quant step can execute with minimal params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 289, "module": "tests.test_rna_amalgkit_steps", "name": "test_quant_basic_execution", "signature": "(self, tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_quant_function_exists": [{"docstring": "Verify quant runner function is exported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 275, "module": "tests.test_rna_amalgkit_steps", "name": "test_quant_function_exists", "signature": "(self)", "symbol_type": "function"}], "test_quant_in_amalgkit_module": [{"docstring": "Verify quant function exists in amalgkit module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 284, "module": "tests.test_rna_amalgkit_steps", "name": "test_quant_in_amalgkit_module", "signature": "(self)", "symbol_type": "function"}], "test_quant_in_step_runners": [{"docstring": "Verify quant is in STEP_RUNNERS.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 279, "module": "tests.test_rna_amalgkit_steps", "name": "test_quant_in_step_runners", "signature": "(self)", "symbol_type": "function"}], "test_quantification_results_exist": [{"docstring": "Verify quantification results from test run.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 117, "module": "tests.test_rna_ena_workflow", "name": "test_quantification_results_exist", "signature": "(self)", "symbol_type": "function"}], "test_random_dna_generation": [{"docstring": "Test random DNA sequence generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 231, "module": "tests.test_dna_comprehensive", "name": "test_random_dna_generation", "signature": "(self)", "symbol_type": "function"}], "test_random_dna_reproducibility": [{"docstring": "Test that random generation is reproducible with seeds.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 252, "module": "tests.test_dna_comprehensive", "name": "test_random_dna_reproducibility", "signature": "(self)", "symbol_type": "function"}], "test_random_functions_with_seed": [{"docstring": "Test that random functions are reproducible with seed.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 329, "module": "tests.test_core_functionality", "name": "test_random_functions_with_seed", "signature": "(self)", "symbol_type": "function"}], "test_random_mutate_reproducible": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_mutations.py", "line_number": 11, "module": "tests.test_dna_mutations", "name": "test_random_mutate_reproducible", "signature": "() -> None", "symbol_type": "function"}], "test_read_bedgraph_parses_minimal_file": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_epigenome.py", "line_number": 8, "module": "tests.test_epigenome", "name": "test_read_bedgraph_parses_minimal_file", "signature": "()", "symbol_type": "function"}], "test_read_fasta_parses_ids": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences.py", "line_number": 8, "module": "tests.test_dna_sequences", "name": "test_read_fasta_parses_ids", "signature": "() -> None", "symbol_type": "function"}], "test_read_pdb_ca_and_rmsd": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_structure_io_rmsd.py", "line_number": 8, "module": "tests.test_protein_structure_io_rmsd", "name": "test_read_pdb_ca_and_rmsd", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_realistic_biological_values": [{"docstring": "Test with realistic biological parameter values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_enhanced.py", "line_number": 161, "module": "tests.test_math_enhanced", "name": "test_realistic_biological_values", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test with realistic biological parameter values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_enhanced.py", "line_number": 124, "module": "tests.test_math_popgen_enhanced", "name": "test_realistic_biological_values", "signature": "(self)", "symbol_type": "function"}], "test_recursive_feature_elimination_basic": [{"docstring": "Test basic RFE functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 152, "module": "tests.test_ml_features", "name": "test_recursive_feature_elimination_basic", "signature": "(self)", "symbol_type": "function"}], "test_regional_plot": [{"docstring": "Test regional association plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 120, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_regional_plot", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_regional_plot_basic": [{"docstring": "Test generating regional association plot.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization.py", "line_number": 88, "module": "tests.test_gwas_visualization", "name": "test_regional_plot_basic", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_regional_plot_no_variants": [{"docstring": "Test regional plot with no variants in region.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization.py", "line_number": 107, "module": "tests.test_gwas_visualization", "name": "test_regional_plot_no_variants", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_regressor_different_algorithms": [{"docstring": "Test different regression algorithms.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 241, "module": "tests.test_ml_comprehensive", "name": "test_regressor_different_algorithms", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test different regression algorithms.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 280, "module": "tests.test_ml_comprehensive", "name": "test_regressor_different_algorithms", "signature": "(self)", "symbol_type": "function"}], "test_regressor_evaluation": [{"docstring": "Test regressor evaluation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 264, "module": "tests.test_ml_comprehensive", "name": "test_regressor_evaluation", "signature": "(self)", "symbol_type": "function"}], "test_regressor_fit_predict": [{"docstring": "Test regressor fitting and prediction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 217, "module": "tests.test_ml_comprehensive", "name": "test_regressor_fit_predict", "signature": "(self)", "symbol_type": "function"}], "test_regressor_initialization": [{"docstring": "Test BiologicalRegressor initialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 203, "module": "tests.test_ml_comprehensive", "name": "test_regressor_initialization", "signature": "(self)", "symbol_type": "function"}], "test_regulatory_cascade_detection": [{"docstring": "Test regulatory cascade detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 388, "module": "tests.test_networks_comprehensive", "name": "test_regulatory_cascade_detection", "signature": "(self)", "symbol_type": "function"}], "test_regulatory_motifs": [{"docstring": "Test regulatory motif detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 304, "module": "tests.test_networks_comprehensive", "name": "test_regulatory_motifs", "signature": "(self)", "symbol_type": "function"}], "test_regulatory_motifs_basic": [{"docstring": "Test basic regulatory motif identification.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 364, "module": "tests.test_networks_regulatory", "name": "test_regulatory_motifs_basic", "signature": "(self)", "symbol_type": "function"}], "test_regulatory_motifs_confidence_filtering": [{"docstring": "Test motif finding with confidence filtering.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 399, "module": "tests.test_networks_regulatory", "name": "test_regulatory_motifs_confidence_filtering", "signature": "(self)", "symbol_type": "function"}], "test_regulatory_motifs_empty_grn": [{"docstring": "Test motif finding on empty GRN.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 414, "module": "tests.test_networks_regulatory", "name": "test_regulatory_motifs_empty_grn", "signature": "(self)", "symbol_type": "function"}], "test_regulatory_motifs_types": [{"docstring": "Test identification of different motif types.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 381, "module": "tests.test_networks_regulatory", "name": "test_regulatory_motifs_types", "signature": "(self)", "symbol_type": "function"}], "test_remove_node_edge": [{"docstring": "Test node and edge removal.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 512, "module": "tests.test_networks_graph", "name": "test_remove_node_edge", "signature": "(self)", "symbol_type": "function"}], "test_renyi_entropy": [{"docstring": "Test R\u00e9nyi entropy calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 308, "module": "tests.test_information_comprehensive", "name": "test_renyi_entropy", "signature": "(self)", "symbol_type": "function"}], "test_repeat_finding": [{"docstring": "Test repeat finding functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 57, "module": "tests.test_dna_sequences_enhanced", "name": "test_repeat_finding", "signature": "(self)", "symbol_type": "function"}], "test_replicator_step_and_derivative": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_egt_epi_fst_ne.py", "line_number": 15, "module": "tests.test_math_egt_epi_fst_ne", "name": "test_replicator_step_and_derivative", "signature": "()", "symbol_type": "function"}], "test_reproducibility": [{"docstring": "Test that results are reproducible with seed.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 67, "module": "tests.test_simulation_popgen", "name": "test_reproducibility", "signature": "(self)", "symbol_type": "function"}], "test_requires_scipy": [{"docstring": "Test that function requires scipy.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 167, "module": "tests.test_math_utilities", "name": "test_requires_scipy", "signature": "(self)", "symbol_type": "function"}], "test_resolve_names_flag": [{"docstring": "Test resolve_names flag (v0.12.20 feature).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 573, "module": "tests.test_rna_amalgkit_steps", "name": "test_resolve_names_flag", "signature": "(self)", "symbol_type": "function"}], "test_reverse_complement_and_gc_content": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequence_utils.py", "line_number": 6, "module": "tests.test_dna_sequence_utils", "name": "test_reverse_complement_and_gc_content", "signature": "() -> None", "symbol_type": "function"}], "test_reverse_transcribe_rna_to_dna": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_transcription.py", "line_number": 13, "module": "tests.test_dna_transcription", "name": "test_reverse_transcribe_rna_to_dna", "signature": "() -> None", "symbol_type": "function"}], "test_rfe_different_estimators": [{"docstring": "Test RFE with different base estimators.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 170, "module": "tests.test_ml_features", "name": "test_rfe_different_estimators", "signature": "(self)", "symbol_type": "function"}], "test_rfe_invalid_estimator": [{"docstring": "Test error handling for invalid estimator.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 212, "module": "tests.test_ml_features", "name": "test_rfe_invalid_estimator", "signature": "(self)", "symbol_type": "function"}], "test_rfe_reproducibility": [{"docstring": "Test RFE reproducibility with fixed random state.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 202, "module": "tests.test_ml_features", "name": "test_rfe_reproducibility", "signature": "(self)", "symbol_type": "function"}], "test_rfe_step_size": [{"docstring": "Test RFE with different step sizes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 182, "module": "tests.test_ml_features", "name": "test_rfe_step_size", "signature": "(self)", "symbol_type": "function"}], "test_rna_curate_summary_apis_mellifera": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_domain_modules.py", "line_number": 9, "module": "tests.test_domain_modules", "name": "test_rna_curate_summary_apis_mellifera", "signature": "()", "symbol_type": "function"}], "test_rna_expression_entropy": [{"docstring": "Test entropy calculation with RNA expression data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 64, "module": "tests.test_information_integration", "name": "test_rna_expression_entropy", "signature": "(self)", "symbol_type": "function"}], "test_rna_integration": [{"docstring": "Test RNA integration.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 472, "module": "tests.test_information_comprehensive", "name": "test_rna_integration", "signature": "(self)", "symbol_type": "function"}], "test_rna_integration_function": [{"docstring": "Test RNA integration wrapper function.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 84, "module": "tests.test_information_integration", "name": "test_rna_integration_function", "signature": "(self)", "symbol_type": "function"}], "test_rna_mutual_information": [{"docstring": "Test MI calculation between genes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 91, "module": "tests.test_information_integration", "name": "test_rna_mutual_information", "signature": "(self)", "symbol_type": "function"}], "test_rna_plan_cli_lists_expected_steps": [{"docstring": "Test that 'rna plan' CLI command lists all expected workflow steps.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_cli.py", "line_number": 14, "module": "tests.test_rna_cli", "name": "test_rna_plan_cli_lists_expected_steps", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_rna_plan_species_cli_includes_species_and_tissue": [{"docstring": "Test that 'rna plan-species' CLI includes species and tissue parameters in output.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_cli.py", "line_number": 43, "module": "tests.test_rna_cli", "name": "test_rna_plan_species_cli_includes_species_and_tissue", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_round_trip_compatibility": [{"docstring": "Test that functions work well together in various orders.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 245, "module": "tests.test_core_text", "name": "test_round_trip_compatibility", "signature": "(self) -> None", "symbol_type": "function"}], "test_run_amalgkit_exists": [{"docstring": "Verify run_amalgkit function exists.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 476, "module": "tests.test_rna_amalgkit_steps", "name": "test_run_amalgkit_exists", "signature": "(self)", "symbol_type": "function"}], "test_run_amalgkit_writes_logs": [{"docstring": "Test that run_amalgkit writes log files for stdout and stderr.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_run_amalgkit_logging.py", "line_number": 11, "module": "tests.test_rna_run_amalgkit_logging", "name": "test_run_amalgkit_writes_logs", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_run_config_based_workflow": [{"docstring": "Test the main workflow function.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_processing.py", "line_number": 133, "module": "tests.test_core_processing", "name": "test_run_config_based_workflow", "signature": "(self)", "symbol_type": "function"}], "test_run_gwas_integration": [{"docstring": "Test full GWAS run with VCF and phenotype files.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_association.py", "line_number": 112, "module": "tests.test_gwas_association", "name": "test_run_gwas_integration", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_run_gwas_missing_trait": [{"docstring": "Test GWAS run with missing trait in phenotype file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_association.py", "line_number": 159, "module": "tests.test_gwas_association", "name": "test_run_gwas_missing_trait", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_run_pca_basic": [{"docstring": "Test PCA dimensionality reduction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 239, "module": "tests.test_singlecell_basic", "name": "test_run_pca_basic", "signature": "(self)", "symbol_type": "function"}], "test_run_tsne_basic": [{"docstring": "Test t-SNE dimensionality reduction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 260, "module": "tests.test_singlecell_basic", "name": "test_run_tsne_basic", "signature": "(self)", "symbol_type": "function"}], "test_run_umap_basic": [{"docstring": "Test UMAP dimensionality reduction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 279, "module": "tests.test_singlecell_basic", "name": "test_run_umap_basic", "signature": "(self)", "symbol_type": "function"}], "test_run_workflow_has_config_block": [{"docstring": "Test that run_workflow.py has proper structure and documentation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_orchestrators.py", "line_number": 15, "module": "tests.test_rna_orchestrators", "name": "test_run_workflow_has_config_block", "signature": "()", "symbol_type": "function"}], "test_run_workflow_has_docstring": [{"docstring": "Test that run_workflow.py has module docstring.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_orchestrators.py", "line_number": 27, "module": "tests.test_rna_orchestrators", "name": "test_run_workflow_has_docstring", "signature": "()", "symbol_type": "function"}], "test_run_workflow_has_main_guard": [{"docstring": "Test that run_workflow.py has if __name__ == '__main__' guard.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_orchestrators.py", "line_number": 76, "module": "tests.test_rna_orchestrators", "name": "test_run_workflow_has_main_guard", "signature": "()", "symbol_type": "function"}], "test_run_workflow_has_required_structure": [{"docstring": "Test that run_workflow.py has required structure (argparse, config loading, etc.).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_orchestrators.py", "line_number": 90, "module": "tests.test_rna_orchestrators", "name": "test_run_workflow_has_required_structure", "signature": "()", "symbol_type": "function"}], "test_run_workflow_imports_metainformant_modules": [{"docstring": "Test that run_workflow.py imports from metainformant.rna modules.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_orchestrators.py", "line_number": 62, "module": "tests.test_rna_orchestrators", "name": "test_run_workflow_imports_metainformant_modules", "signature": "()", "symbol_type": "function"}], "test_run_workflow_methods_have_docstrings": [{"docstring": "Test that key functions in run_workflow.py have docstrings.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_orchestrators.py", "line_number": 41, "module": "tests.test_rna_orchestrators", "name": "test_run_workflow_methods_have_docstrings", "signature": "()", "symbol_type": "function"}], "test_safe_connection_params": [{"docstring": "Test parameter sanitization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 133, "module": "tests.test_core_comprehensive", "name": "test_safe_connection_params", "signature": "(self)", "symbol_type": "function"}], "test_safe_filename_basic": [{"docstring": "Test basic safe filename functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 121, "module": "tests.test_core_text", "name": "test_safe_filename_basic", "signature": "(self) -> None", "symbol_type": "function"}], "test_safe_filename_dangerous_characters": [{"docstring": "Test removal of dangerous filesystem characters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 128, "module": "tests.test_core_text", "name": "test_safe_filename_dangerous_characters", "signature": "(self) -> None", "symbol_type": "function"}], "test_safe_filename_edge_cases": [{"docstring": "Test edge cases for safe filename generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 143, "module": "tests.test_core_text", "name": "test_safe_filename_edge_cases", "signature": "(self) -> None", "symbol_type": "function"}], "test_safe_filename_preserve_extension": [{"docstring": "Test that file extensions are preserved correctly.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 162, "module": "tests.test_core_text", "name": "test_safe_filename_preserve_extension", "signature": "(self) -> None", "symbol_type": "function"}], "test_safe_filename_reserved_names": [{"docstring": "Test handling of reserved filename patterns.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 177, "module": "tests.test_core_text", "name": "test_safe_filename_reserved_names", "signature": "(self) -> None", "symbol_type": "function"}], "test_safe_filename_unicode": [{"docstring": "Test handling of unicode characters in filenames.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 189, "module": "tests.test_core_text", "name": "test_safe_filename_unicode", "signature": "(self) -> None", "symbol_type": "function"}], "test_safe_filename_whitespace": [{"docstring": "Test handling of whitespace in filenames.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 198, "module": "tests.test_core_text", "name": "test_safe_filename_whitespace", "signature": "(self) -> None", "symbol_type": "function"}], "test_safe_path_creation": [{"docstring": "Test safe directory and file creation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 272, "module": "tests.test_core_comprehensive", "name": "test_safe_path_creation", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_sample_alignment": [{"docstring": "Test automatic sample alignment across layers.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 39, "module": "tests.test_multiomics_comprehensive", "name": "test_sample_alignment", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test automatic sample alignment across layers.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 85, "module": "tests.test_multiomics_integration", "name": "test_sample_alignment", "signature": "(self)", "symbol_type": "function"}], "test_sample_already_quantified_missing_dir": [{"docstring": "Test that _sample_already_quantified returns False when sample directory doesn't exist.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_skip.py", "line_number": 50, "module": "tests.test_rna_download_skip", "name": "test_sample_already_quantified_missing_dir", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_sample_already_quantified_returns_false": [{"docstring": "Test that _sample_already_quantified returns False when abundance.tsv doesn't exist.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_skip.py", "line_number": 37, "module": "tests.test_rna_download_skip", "name": "test_sample_already_quantified_returns_false", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_sample_already_quantified_returns_true": [{"docstring": "Test that _sample_already_quantified returns True when abundance.tsv exists.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_skip.py", "line_number": 21, "module": "tests.test_rna_download_skip", "name": "test_sample_already_quantified_returns_true", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_sanitize_connection_params": [{"docstring": "Test connection parameter sanitization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_db.py", "line_number": 28, "module": "tests.test_core_db", "name": "test_sanitize_connection_params", "signature": "(self)", "symbol_type": "function"}], "test_sanitize_connection_params_non_string": [{"docstring": "Test sanitization with non-string values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_db.py", "line_number": 47, "module": "tests.test_core_db", "name": "test_sanitize_connection_params_non_string", "signature": "(self)", "symbol_type": "function"}], "test_sanitize_connection_params_sql_keywords": [{"docstring": "Test sanitization removes SQL keywords from strings.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_db.py", "line_number": 55, "module": "tests.test_core_db", "name": "test_sanitize_connection_params_sql_keywords", "signature": "(self)", "symbol_type": "function"}], "test_sanity_basic_execution": [{"docstring": "Test sanity step can execute with minimal params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 440, "module": "tests.test_rna_amalgkit_steps", "name": "test_sanity_basic_execution", "signature": "(self, tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_sanity_function_exists": [{"docstring": "Verify sanity runner function is exported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 426, "module": "tests.test_rna_amalgkit_steps", "name": "test_sanity_function_exists", "signature": "(self)", "symbol_type": "function"}], "test_sanity_in_amalgkit_module": [{"docstring": "Verify sanity function exists in amalgkit module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 435, "module": "tests.test_rna_amalgkit_steps", "name": "test_sanity_in_amalgkit_module", "signature": "(self)", "symbol_type": "function"}], "test_sanity_in_step_runners": [{"docstring": "Verify sanity is in STEP_RUNNERS.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 430, "module": "tests.test_rna_amalgkit_steps", "name": "test_sanity_in_step_runners", "signature": "(self)", "symbol_type": "function"}], "test_sanity_runner": [{"docstring": "Test sanity step runner.\n\nUses ensure_amalgkit_available fixture to ensure amalgkit is available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 365, "module": "tests.test_rna_amalgkit_end_to_end", "name": "test_sanity_runner", "signature": "(self, ensure_amalgkit_available)", "symbol_type": "function"}], "test_save_and_load_ontology": [{"docstring": "Test saving and loading ontology.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_serialize.py", "line_number": 19, "module": "tests.test_ontology_serialize", "name": "test_save_and_load_ontology", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_save_invalid_ontology": [{"docstring": "Test saving empty ontology.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_serialize.py", "line_number": 92, "module": "tests.test_ontology_serialize", "name": "test_save_invalid_ontology", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_save_load_regression_model": [{"docstring": "Test save/load for regression model.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 378, "module": "tests.test_life_events_models", "name": "test_save_load_regression_model", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_save_load_roundtrip": [{"docstring": "Test round-trip serialization preserves structure.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_serialize.py", "line_number": 64, "module": "tests.test_ontology_serialize", "name": "test_save_load_roundtrip", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_save_model_embedding_classification": [{"docstring": "Test saving embedding model for classification.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 150, "module": "tests.test_life_events_models", "name": "test_save_model_embedding_classification", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_save_model_embedding_regression": [{"docstring": "Test saving embedding model for regression.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 184, "module": "tests.test_life_events_models", "name": "test_save_model_embedding_regression", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_save_model_simple_classification": [{"docstring": "Test saving simple model for classification.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 213, "module": "tests.test_life_events_models", "name": "test_save_model_simple_classification", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_save_unfitted_model_error": [{"docstring": "Test prevention of saving unfitted models.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models.py", "line_number": 329, "module": "tests.test_life_events_models", "name": "test_save_unfitted_model_error", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_scale_data": [{"docstring": "Test data scaling.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 308, "module": "tests.test_singlecell_preprocessing", "name": "test_scale_data", "signature": "(self)", "symbol_type": "function"}], "test_scatter_plot_functionality": [{"docstring": "Test enhanced scatter plot functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 11, "module": "tests.test_visualization_enhanced", "name": "test_scatter_plot_functionality", "signature": "(self)", "symbol_type": "function"}], "test_script_availability": [{"docstring": "Test that orchestrator scripts exist and are executable.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/validate_all_species_workflow.py", "line_number": 144, "module": "scripts.validate_all_species_workflow", "name": "test_script_availability", "signature": "() -> Tuple[bool, str]", "symbol_type": "function"}], "test_scripts_agents_mentions_ena": [{"docstring": "Verify scripts/rna/AGENTS.md documents ENA contributions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 147, "module": "tests.test_rna_ena_workflow", "name": "test_scripts_agents_mentions_ena", "signature": "(self)", "symbol_type": "function"}], "test_scripts_readme_mentions_ena_workflow": [{"docstring": "Verify scripts/rna/README.md documents the workflow (which includes ENA downloads).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 139, "module": "tests.test_rna_ena_workflow", "name": "test_scripts_readme_mentions_ena_workflow", "signature": "(self)", "symbol_type": "function"}], "test_search_sra_empty_results": [{"docstring": "Test search with organism that may have no results.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_sra_download.py", "line_number": 132, "module": "tests.test_gwas_sra_download", "name": "test_search_sra_empty_results", "signature": "(self)", "symbol_type": "function"}], "test_search_sra_for_organism_interface": [{"docstring": "Test search function interface.\n\nTests function structure - actual search requires network access.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_sra_download.py", "line_number": 114, "module": "tests.test_gwas_sra_download", "name": "test_search_sra_for_organism_interface", "signature": "(self)", "symbol_type": "function"}], "test_segregating_sites_and_watterson_theta": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_more.py", "line_number": 6, "module": "tests.test_dna_population_more", "name": "test_segregating_sites_and_watterson_theta", "signature": "() -> None", "symbol_type": "function"}], "test_seir_step_and_herd_immunity_threshold": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_epidemiology_extras.py", "line_number": 6, "module": "tests.test_math_epidemiology_extras", "name": "test_seir_step_and_herd_immunity_threshold", "signature": "()", "symbol_type": "function"}], "test_select_basic_execution": [{"docstring": "Test select step can execute with minimal params.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 209, "module": "tests.test_rna_amalgkit_steps", "name": "test_select_basic_execution", "signature": "(self, tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_select_function_exists": [{"docstring": "Verify select runner function is exported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 195, "module": "tests.test_rna_amalgkit_steps", "name": "test_select_function_exists", "signature": "(self)", "symbol_type": "function"}], "test_select_hvgs_cell_ranger_method": [{"docstring": "Test Cell Ranger method for HVG selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 105, "module": "tests.test_singlecell_dimensionality", "name": "test_select_hvgs_cell_ranger_method", "signature": "(self)", "symbol_type": "function"}], "test_select_hvgs_invalid_method": [{"docstring": "Test that invalid method raises error.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 113, "module": "tests.test_singlecell_dimensionality", "name": "test_select_hvgs_invalid_method", "signature": "(self)", "symbol_type": "function"}], "test_select_hvgs_seurat_method": [{"docstring": "Test Seurat method for HVG selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 68, "module": "tests.test_singlecell_dimensionality", "name": "test_select_hvgs_seurat_method", "signature": "(self)", "symbol_type": "function"}], "test_select_hvgs_variance_method": [{"docstring": "Test simple variance-based HVG selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 91, "module": "tests.test_singlecell_dimensionality", "name": "test_select_hvgs_variance_method", "signature": "(self)", "symbol_type": "function"}], "test_select_in_amalgkit_module": [{"docstring": "Verify select function exists in amalgkit module.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 204, "module": "tests.test_rna_amalgkit_steps", "name": "test_select_in_amalgkit_module", "signature": "(self)", "symbol_type": "function"}], "test_select_in_step_runners": [{"docstring": "Verify select is in STEP_RUNNERS.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 199, "module": "tests.test_rna_amalgkit_steps", "name": "test_select_in_step_runners", "signature": "(self)", "symbol_type": "function"}], "test_select_with_mark_missing_rank": [{"docstring": "Test select step with mark_missing_rank parameter (v0.12.20 feature).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 221, "module": "tests.test_rna_amalgkit_steps", "name": "test_select_with_mark_missing_rank", "signature": "(self, tmp_path: Path, ensure_amalgkit_available)", "symbol_type": "function"}], "test_selection_differential_positive_selection": [{"docstring": "Test selection differential with positive selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 63, "module": "tests.test_math_comprehensive", "name": "test_selection_differential_positive_selection", "signature": "(self)", "symbol_type": "function"}], "test_selection_gradient_standardization": [{"docstring": "Test selection gradient standardization by variance.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 72, "module": "tests.test_math_comprehensive", "name": "test_selection_gradient_standardization", "signature": "(self)", "symbol_type": "function"}], "test_selection_metrics_and_price_equation": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_price.py", "line_number": 65, "module": "tests.test_math_price", "name": "test_selection_metrics_and_price_equation", "signature": "()", "symbol_type": "function"}], "test_selection_replay_writes_outputs": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_selection_cli.py", "line_number": 8, "module": "tests.test_math_selection_cli", "name": "test_selection_replay_writes_outputs", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_selection_update_balancing_and_directional": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen.py", "line_number": 13, "module": "tests.test_math_popgen", "name": "test_selection_update_balancing_and_directional", "signature": "()", "symbol_type": "function"}], "test_selection_update_directional": [{"docstring": "Test selection update with directional selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 98, "module": "tests.test_math_comprehensive", "name": "test_selection_update_directional", "signature": "(self)", "symbol_type": "function"}], "test_selection_update_overdominance": [{"docstring": "Test selection update with heterozygote advantage.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 106, "module": "tests.test_math_comprehensive", "name": "test_selection_update_overdominance", "signature": "(self)", "symbol_type": "function"}], "test_self_interactions": [{"docstring": "Test handling of protein self-interactions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 559, "module": "tests.test_networks_ppi", "name": "test_self_interactions", "signature": "(self)", "symbol_type": "function"}], "test_self_loops_handling": [{"docstring": "Test handling of self-loops in network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 355, "module": "tests.test_networks_community", "name": "test_self_loops_handling", "signature": "(self)", "symbol_type": "function"}], "test_self_regulation": [{"docstring": "Test handling of self-regulatory loops.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 587, "module": "tests.test_networks_regulatory", "name": "test_self_regulation", "signature": "(self)", "symbol_type": "function"}], "test_semantic_entropy": [{"docstring": "Test semantic entropy calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 133, "module": "tests.test_information_comprehensive", "name": "test_semantic_entropy", "signature": "(self)", "symbol_type": "function"}], "test_semantic_similarity": [{"docstring": "Test semantic similarity calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 143, "module": "tests.test_information_comprehensive", "name": "test_semantic_similarity", "signature": "(self)", "symbol_type": "function"}], "test_semantic_similarity_identical": [{"docstring": "Test semantic similarity for identical terms.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 150, "module": "tests.test_information_comprehensive", "name": "test_semantic_similarity_identical", "signature": "(self)", "symbol_type": "function"}], "test_semantic_similarity_matrix": [{"docstring": "Test semantic similarity matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 156, "module": "tests.test_information_comprehensive", "name": "test_semantic_similarity_matrix", "signature": "(self)", "symbol_type": "function"}], "test_sequence_analysis_integration": [{"docstring": "Test integration between DNA and protein sequence analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_integration_comprehensive.py", "line_number": 405, "module": "tests.test_integration_comprehensive", "name": "test_sequence_analysis_integration", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_sequence_auto_sorts_by_time": [{"docstring": "Test that events are automatically sorted by timestamp.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 128, "module": "tests.test_life_events", "name": "test_sequence_auto_sorts_by_time", "signature": "(self)", "symbol_type": "function"}], "test_sequence_based_comparison": [{"docstring": "Test comparison using sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_analysis.py", "line_number": 61, "module": "tests.test_dna_population_analysis", "name": "test_sequence_based_comparison", "signature": "(self)", "symbol_type": "function"}], "test_sequence_based_statistics": [{"docstring": "Test calculation from sequence data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_analysis.py", "line_number": 17, "module": "tests.test_dna_population_analysis", "name": "test_sequence_based_statistics", "signature": "(self)", "symbol_type": "function"}], "test_sequence_bias_detection": [{"docstring": "Test sequence bias detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 138, "module": "tests.test_dna_sequences_enhanced", "name": "test_sequence_bias_detection", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test sequence bias detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 286, "module": "tests.test_dna_sequences_enhanced", "name": "test_sequence_bias_detection", "signature": "(self)", "symbol_type": "function"}], "test_sequence_complexity": [{"docstring": "Test sequence complexity calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 89, "module": "tests.test_dna_sequences_enhanced", "name": "test_sequence_complexity", "signature": "(self)", "symbol_type": "function"}], "test_sequence_complexity_calculation": [{"docstring": "Test sequence complexity calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 262, "module": "tests.test_dna_sequences_enhanced", "name": "test_sequence_complexity_calculation", "signature": "(self)", "symbol_type": "function"}], "test_sequence_creation_basic": [{"docstring": "Test basic sequence creation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 111, "module": "tests.test_life_events", "name": "test_sequence_creation_basic", "signature": "(self)", "symbol_type": "function"}], "test_sequence_distances": [{"docstring": "Test sequence distance calculations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 161, "module": "tests.test_core_functionality", "name": "test_sequence_distances", "signature": "(self)", "symbol_type": "function"}], "test_sequence_embeddings_empty_sequence": [{"docstring": "Test sequence embedding with empty sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 165, "module": "tests.test_life_events_embeddings", "name": "test_sequence_embeddings_empty_sequence", "signature": "()", "symbol_type": "function"}], "test_sequence_embeddings_max": [{"docstring": "Test sequence embedding with max pooling.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 141, "module": "tests.test_life_events_embeddings", "name": "test_sequence_embeddings_max", "signature": "()", "symbol_type": "function"}], "test_sequence_embeddings_mean": [{"docstring": "Test sequence embedding with mean pooling.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 85, "module": "tests.test_life_events_embeddings", "name": "test_sequence_embeddings_mean", "signature": "()", "symbol_type": "function"}], "test_sequence_embeddings_sum": [{"docstring": "Test sequence embedding with sum pooling.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 117, "module": "tests.test_life_events_embeddings", "name": "test_sequence_embeddings_sum", "signature": "()", "symbol_type": "function"}], "test_sequence_embeddings_temporal_weighting": [{"docstring": "Test sequence embedding with temporal weighting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 204, "module": "tests.test_life_events_embeddings", "name": "test_sequence_embeddings_temporal_weighting", "signature": "()", "symbol_type": "function"}], "test_sequence_embeddings_unknown_event": [{"docstring": "Test sequence embedding with unknown event.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 183, "module": "tests.test_life_events_embeddings", "name": "test_sequence_embeddings_unknown_event", "signature": "()", "symbol_type": "function"}], "test_sequence_entropy": [{"docstring": "Test sequence entropy calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 120, "module": "tests.test_dna_sequences_enhanced", "name": "test_sequence_entropy", "signature": "(self)", "symbol_type": "function"}], "test_sequence_entropy_calculation": [{"docstring": "Test sequence entropy calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 274, "module": "tests.test_dna_sequences_enhanced", "name": "test_sequence_entropy_calculation", "signature": "(self)", "symbol_type": "function"}], "test_sequence_filter_by_domain": [{"docstring": "Test filtering sequence by domain.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 138, "module": "tests.test_life_events", "name": "test_sequence_filter_by_domain", "signature": "(self)", "symbol_type": "function"}], "test_sequence_filter_by_time": [{"docstring": "Test filtering sequence by time range.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 151, "module": "tests.test_life_events", "name": "test_sequence_filter_by_time", "signature": "(self)", "symbol_type": "function"}], "test_sequence_filter_by_time_numeric": [{"docstring": "Test filtering with numeric timestamps.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 166, "module": "tests.test_life_events", "name": "test_sequence_filter_by_time_numeric", "signature": "(self)", "symbol_type": "function"}], "test_sequence_from_dict": [{"docstring": "Test sequence deserialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 230, "module": "tests.test_life_events", "name": "test_sequence_from_dict", "signature": "(self)", "symbol_type": "function"}], "test_sequence_generation": [{"docstring": "Test random sequence generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 224, "module": "tests.test_core_functionality", "name": "test_sequence_generation", "signature": "(self)", "symbol_type": "function"}], "test_sequence_get_domains": [{"docstring": "Test getting unique domains.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 190, "module": "tests.test_life_events", "name": "test_sequence_get_domains", "signature": "(self)", "symbol_type": "function"}], "test_sequence_get_event_types": [{"docstring": "Test getting unique event types.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 177, "module": "tests.test_life_events", "name": "test_sequence_get_event_types", "signature": "(self)", "symbol_type": "function"}], "test_sequence_length_calculation": [{"docstring": "Test sequence length calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 10, "module": "tests.test_dna_sequences_enhanced", "name": "test_sequence_length_calculation", "signature": "(self)", "symbol_type": "function"}], "test_sequence_motif_finding": [{"docstring": "Test simple motif finding.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 405, "module": "tests.test_dna_comprehensive", "name": "test_sequence_motif_finding", "signature": "(self)", "symbol_type": "function"}], "test_sequence_reversal_and_complement": [{"docstring": "Test sequence reversal and complement operations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 377, "module": "tests.test_dna_comprehensive", "name": "test_sequence_reversal_and_complement", "signature": "(self)", "symbol_type": "function"}], "test_sequence_source_identification": [{"docstring": "Test identification of sequence sources.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 271, "module": "tests.test_quality_fastq", "name": "test_sequence_source_identification", "signature": "(self)", "symbol_type": "function"}], "test_sequence_statistics": [{"docstring": "Test basic sequence statistics.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 422, "module": "tests.test_dna_comprehensive", "name": "test_sequence_statistics", "signature": "(self)", "symbol_type": "function"}], "test_sequence_to_dataframe": [{"docstring": "Test converting sequence to DataFrame.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 203, "module": "tests.test_life_events", "name": "test_sequence_to_dataframe", "signature": "(self)", "symbol_type": "function"}], "test_sequence_to_dict": [{"docstring": "Test sequence serialization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 219, "module": "tests.test_life_events", "name": "test_sequence_to_dict", "signature": "(self)", "symbol_type": "function"}], "test_sequence_translation_frames": [{"docstring": "Test reading frame analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 391, "module": "tests.test_dna_comprehensive", "name": "test_sequence_translation_frames", "signature": "(self)", "symbol_type": "function"}], "test_sequence_validation": [{"docstring": "Test sequence validation and error handling.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_comprehensive.py", "line_number": 271, "module": "tests.test_dna_comprehensive", "name": "test_sequence_validation", "signature": "(self)", "symbol_type": "function"}], "test_sequence_with_events": [{"docstring": "Test sequence with events.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events.py", "line_number": 118, "module": "tests.test_life_events", "name": "test_sequence_with_events", "signature": "(self)", "symbol_type": "function"}], "test_severe_bottleneck": [{"docstring": "Test severe bottleneck.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_demography.py", "line_number": 46, "module": "tests.test_math_demography", "name": "test_severe_bottleneck", "signature": "(self)", "symbol_type": "function"}], "test_sfs_counts_shape_and_values": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_coalescent.py", "line_number": 45, "module": "tests.test_math_coalescent", "name": "test_sfs_counts_shape_and_values", "signature": "()", "symbol_type": "function"}], "test_sfs_plot": [{"docstring": "Test SFS plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 156, "module": "tests.test_dna_population_viz", "name": "test_sfs_plot", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_sfs_rare_alleles": [{"docstring": "Test that SFS has more rare alleles.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 272, "module": "tests.test_simulation_popgen", "name": "test_sfs_rare_alleles", "signature": "(self)", "symbol_type": "function"}], "test_sha256_consistency": [{"docstring": "Test SHA256 hashing produces consistent results.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 147, "module": "tests.test_core_comprehensive", "name": "test_sha256_consistency", "signature": "(self)", "symbol_type": "function"}], "test_shannon_diversity_empty": [{"docstring": "Test Shannon diversity with empty abundances.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 11, "module": "tests.test_ecology_basic", "name": "test_shannon_diversity_empty", "signature": "(self)", "symbol_type": "function"}], "test_shannon_diversity_equal_abundances": [{"docstring": "Test Shannon diversity with equal abundances.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 21, "module": "tests.test_ecology_basic", "name": "test_shannon_diversity_equal_abundances", "signature": "(self)", "symbol_type": "function"}], "test_shannon_diversity_single_species": [{"docstring": "Test Shannon diversity with single species.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 16, "module": "tests.test_ecology_basic", "name": "test_shannon_diversity_single_species", "signature": "(self)", "symbol_type": "function"}], "test_shannon_diversity_unequal_abundances": [{"docstring": "Test Shannon diversity with unequal abundances.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 27, "module": "tests.test_ecology_basic", "name": "test_shannon_diversity_unequal_abundances", "signature": "(self)", "symbol_type": "function"}], "test_shannon_diversity_zero_abundances": [{"docstring": "Test Shannon diversity with zero total abundance.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 33, "module": "tests.test_ecology_basic", "name": "test_shannon_diversity_zero_abundances", "signature": "(self)", "symbol_type": "function"}], "test_shannon_entropy": [{"docstring": "Test Shannon entropy calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_enhanced.py", "line_number": 56, "module": "tests.test_math_enhanced", "name": "test_shannon_entropy", "signature": "(self)", "symbol_type": "function"}], "test_shannon_entropy_certainty": [{"docstring": "Test Shannon entropy with certain outcome.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 46, "module": "tests.test_information_comprehensive", "name": "test_shannon_entropy_certainty", "signature": "(self)", "symbol_type": "function"}], "test_shannon_entropy_empty": [{"docstring": "Test entropy with empty input.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 219, "module": "tests.test_information_comprehensive", "name": "test_shannon_entropy_empty", "signature": "(self)", "symbol_type": "function"}], "test_shannon_entropy_from_counts": [{"docstring": "Test entropy calculation from counts.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 52, "module": "tests.test_information_comprehensive", "name": "test_shannon_entropy_from_counts", "signature": "(self)", "symbol_type": "function"}], "test_shannon_entropy_from_counts_exported": [{"docstring": "Test that shannon_entropy_from_counts is accessible from main import.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 497, "module": "tests.test_information_comprehensive", "name": "test_shannon_entropy_from_counts_exported", "signature": "(self)", "symbol_type": "function"}], "test_shannon_entropy_uniform": [{"docstring": "Test Shannon entropy with uniform distribution.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 40, "module": "tests.test_information_comprehensive", "name": "test_shannon_entropy_uniform", "signature": "(self)", "symbol_type": "function"}], "test_shortest_paths": [{"docstring": "Test shortest path calculations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_comprehensive.py", "line_number": 118, "module": "tests.test_networks_comprehensive", "name": "test_shortest_paths", "signature": "(self)", "symbol_type": "function"}], "test_shortest_paths_disconnected": [{"docstring": "Test shortest paths with disconnected components.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 289, "module": "tests.test_networks_graph", "name": "test_shortest_paths_disconnected", "signature": "(self)", "symbol_type": "function"}], "test_shortest_paths_linear_network": [{"docstring": "Test shortest paths in linear network.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 276, "module": "tests.test_networks_graph", "name": "test_shortest_paths_linear_network", "signature": "(self)", "symbol_type": "function"}], "test_shortest_paths_single_node": [{"docstring": "Test shortest paths with single node.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 306, "module": "tests.test_networks_graph", "name": "test_shortest_paths_single_node", "signature": "(self)", "symbol_type": "function"}], "test_similar_distributions": [{"docstring": "Test similar distributions have small JS divergence.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 247, "module": "tests.test_math_utilities", "name": "test_similar_distributions", "signature": "(self)", "symbol_type": "function"}], "test_simple_json_cache": [{"docstring": "Test basic JSON caching operations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 30, "module": "tests.test_core_comprehensive", "name": "test_simple_json_cache", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_simple_secondary_structure_prediction_signature": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_structure_secondary.py", "line_number": 4, "module": "tests.test_protein_structure_secondary", "name": "test_simple_secondary_structure_prediction_signature", "signature": "()", "symbol_type": "function"}], "test_simpson_diversity_basic": [{"docstring": "Test Simpson diversity index calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 38, "module": "tests.test_ecology_basic", "name": "test_simpson_diversity_basic", "signature": "(self)", "symbol_type": "function"}], "test_simpson_diversity_empty": [{"docstring": "Test Simpson diversity with empty abundances.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 44, "module": "tests.test_ecology_basic", "name": "test_simpson_diversity_empty", "signature": "(self)", "symbol_type": "function"}], "test_simulate_counts_negative_binomial": [{"docstring": "Test negative binomial count simulation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 102, "module": "tests.test_simulation", "name": "test_simulate_counts_negative_binomial", "signature": "()", "symbol_type": "function"}], "test_simulate_counts_parameters": [{"docstring": "Test count simulation with different parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 125, "module": "tests.test_simulation", "name": "test_simulate_counts_parameters", "signature": "()", "symbol_type": "function"}], "test_simulate_counts_reproducible": [{"docstring": "Test count simulation reproducibility.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 116, "module": "tests.test_simulation", "name": "test_simulate_counts_reproducible", "signature": "()", "symbol_type": "function"}], "test_simulation_cli_integration": [{"docstring": "Test simulation CLI command.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 191, "module": "tests.test_orchestrators", "name": "test_simulation_cli_integration", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_simulation_ecology_integration": [{"docstring": "Test integration of simulation with ecological analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_integration_comprehensive.py", "line_number": 306, "module": "tests.test_integration_comprehensive", "name": "test_simulation_ecology_integration", "signature": "(self)", "symbol_type": "function"}], "test_simulation_integration": [{"docstring": "Integration test combining multiple simulation components.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation.py", "line_number": 214, "module": "tests.test_simulation", "name": "test_simulation_integration", "signature": "()", "symbol_type": "function"}], "test_simulation_orchestrator_help": [{"docstring": "Test simulation orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 79, "module": "tests.test_orchestrators", "name": "test_simulation_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_single_cell_handling": [{"docstring": "Test handling of single-cell datasets.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 557, "module": "tests.test_singlecell_dimensionality", "name": "test_single_cell_handling", "signature": "(self)", "symbol_type": "function"}], "test_single_cell_single_gene": [{"docstring": "Test handling of minimal data (1 cell, 1 gene).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_basic.py", "line_number": 485, "module": "tests.test_singlecell_basic", "name": "test_single_cell_single_gene", "signature": "(self)", "symbol_type": "function"}], "test_single_feature": [{"docstring": "Test feature selection with single feature.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 553, "module": "tests.test_ml_features", "name": "test_single_feature", "signature": "(self)", "symbol_type": "function"}], "test_single_individual": [{"docstring": "Test with single individual.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 29, "module": "tests.test_dna_population_comprehensive", "name": "test_single_individual", "signature": "(self)", "symbol_type": "function"}], "test_single_nonzero_gene": [{"docstring": "Test handling of data with only one expressing gene.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 423, "module": "tests.test_singlecell_preprocessing", "name": "test_single_nonzero_gene", "signature": "(self)", "symbol_type": "function"}], "test_single_read_analysis": [{"docstring": "Test analysis with single read.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_quality_fastq.py", "line_number": 445, "module": "tests.test_quality_fastq", "name": "test_single_read_analysis", "signature": "(self)", "symbol_type": "function"}], "test_single_sample": [{"docstring": "Test handling of single sample.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 671, "module": "tests.test_ml_comprehensive", "name": "test_single_sample", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test with single sample.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 481, "module": "tests.test_multiomics_integration", "name": "test_single_sample", "signature": "(self)", "symbol_type": "function"}], "test_single_sequence": [{"docstring": "Test with single sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 91, "module": "tests.test_dna_population_comprehensive", "name": "test_single_sequence", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test with single sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 138, "module": "tests.test_dna_population_comprehensive", "name": "test_single_sequence", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test with single sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 199, "module": "tests.test_dna_population_comprehensive", "name": "test_single_sequence", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test with single sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 227, "module": "tests.test_dna_population_comprehensive", "name": "test_single_sequence", "signature": "(self)", "symbol_type": "function"}], "test_single_value": [{"docstring": "Test single value (certainty).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 223, "module": "tests.test_math_utilities", "name": "test_single_value", "signature": "(self)", "symbol_type": "function"}], "test_singlecell_gene_entropy": [{"docstring": "Test gene entropy calculation in single-cell data.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 113, "module": "tests.test_information_integration", "name": "test_singlecell_gene_entropy", "signature": "(self)", "symbol_type": "function"}], "test_singlecell_integration": [{"docstring": "Test single-cell integration function.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_integration.py", "line_number": 102, "module": "tests.test_information_integration", "name": "test_singlecell_integration", "signature": "(self)", "symbol_type": "function"}], "test_singlecell_orchestrator_help": [{"docstring": "Test single-cell orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 65, "module": "tests.test_orchestrators", "name": "test_singlecell_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_singlecelldata_copy": [{"docstring": "Test copying SingleCellData objects.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 84, "module": "tests.test_singlecell_preprocessing", "name": "test_singlecelldata_copy", "signature": "(self)", "symbol_type": "function"}], "test_singlecelldata_initialization": [{"docstring": "Test basic initialization of SingleCellData.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 42, "module": "tests.test_singlecell_preprocessing", "name": "test_singlecelldata_initialization", "signature": "(self)", "symbol_type": "function"}], "test_singlecelldata_sparse_matrix": [{"docstring": "Test with sparse matrix input.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 73, "module": "tests.test_singlecell_preprocessing", "name": "test_singlecelldata_sparse_matrix", "signature": "(self)", "symbol_type": "function"}], "test_singlecelldata_with_metadata": [{"docstring": "Test initialization with metadata.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_preprocessing.py", "line_number": 55, "module": "tests.test_singlecell_preprocessing", "name": "test_singlecelldata_with_metadata", "signature": "(self)", "symbol_type": "function"}], "test_sir_and_r0": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_egt_epi_fst_ne.py", "line_number": 25, "module": "tests.test_math_egt_epi_fst_ne", "name": "test_sir_and_r0", "signature": "()", "symbol_type": "function"}], "test_sir_model_conservation": [{"docstring": "Test SIR model conserves total population.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 212, "module": "tests.test_math_comprehensive", "name": "test_sir_model_conservation", "signature": "(self)", "symbol_type": "function"}], "test_sis_step_and_effective_R": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_epidemiology_more.py", "line_number": 6, "module": "tests.test_math_epidemiology_more", "name": "test_sis_step_and_effective_R", "signature": "()", "symbol_type": "function"}], "test_skip_completed_false_processes_all": [{"docstring": "Test that skip_completed=False processes all samples even if quantified.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_skip.py", "line_number": 102, "module": "tests.test_rna_download_skip", "name": "test_skip_completed_false_processes_all", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_skip_completed_skips_quantified": [{"docstring": "Test that skip_completed=True skips already-quantified samples.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_skip.py", "line_number": 65, "module": "tests.test_rna_download_skip", "name": "test_skip_completed_skips_quantified", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_slugify_basic": [{"docstring": "Test basic slugification functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 11, "module": "tests.test_core_text", "name": "test_slugify_basic", "signature": "(self) -> None", "symbol_type": "function"}], "test_slugify_edge_cases": [{"docstring": "Test edge cases for slugification.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 16, "module": "tests.test_core_text", "name": "test_slugify_edge_cases", "signature": "(self) -> None", "symbol_type": "function"}], "test_slugify_non_string_input": [{"docstring": "Test error handling for non-string input.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 63, "module": "tests.test_core_text", "name": "test_slugify_non_string_input", "signature": "(self) -> None", "symbol_type": "function"}], "test_slugify_special_characters": [{"docstring": "Test handling of various special characters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 49, "module": "tests.test_core_text", "name": "test_slugify_special_characters", "signature": "(self) -> None", "symbol_type": "function"}], "test_slugify_very_long_input": [{"docstring": "Test slugification with very long input.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 40, "module": "tests.test_core_text", "name": "test_slugify_very_long_input", "signature": "(self) -> None", "symbol_type": "function"}], "test_small_dataset_handling": [{"docstring": "Test handling of very small datasets.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 542, "module": "tests.test_singlecell_dimensionality", "name": "test_small_dataset_handling", "signature": "(self)", "symbol_type": "function"}], "test_snp_allele_frequencies_basic": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_genetics.py", "line_number": 6, "module": "tests.test_dna_population_genetics", "name": "test_snp_allele_frequencies_basic", "signature": "() -> None", "symbol_type": "function"}], "test_special_characters_in_names": [{"docstring": "Test handling of special characters in pathway/gene names.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 454, "module": "tests.test_networks_pathway", "name": "test_special_characters_in_names", "signature": "(self)", "symbol_type": "function"}], "test_species_richness_all_zeros": [{"docstring": "Test species richness with all zero abundances.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 55, "module": "tests.test_ecology_basic", "name": "test_species_richness_all_zeros", "signature": "(self)", "symbol_type": "function"}], "test_species_richness_basic": [{"docstring": "Test species richness calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 49, "module": "tests.test_ecology_basic", "name": "test_species_richness_basic", "signature": "(self)", "symbol_type": "function"}], "test_species_richness_empty": [{"docstring": "Test species richness with empty list.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ecology_basic.py", "line_number": 60, "module": "tests.test_ecology_basic", "name": "test_species_richness_empty", "signature": "(self)", "symbol_type": "function"}], "test_stability_no_features_warning": [{"docstring": "Test warning when no features meet stability threshold.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 303, "module": "tests.test_ml_features", "name": "test_stability_no_features_warning", "signature": "(self)", "symbol_type": "function"}], "test_stability_reproducibility": [{"docstring": "Test reproducibility of stability selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 293, "module": "tests.test_ml_features", "name": "test_stability_reproducibility", "signature": "(self)", "symbol_type": "function"}], "test_stability_selection_basic": [{"docstring": "Test basic stability selection functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 236, "module": "tests.test_ml_features", "name": "test_stability_selection_basic", "signature": "(self)", "symbol_type": "function"}], "test_stability_selection_different_methods": [{"docstring": "Test stability selection with different base methods.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 261, "module": "tests.test_ml_features", "name": "test_stability_selection_different_methods", "signature": "(self)", "symbol_type": "function"}], "test_stability_threshold_effect": [{"docstring": "Test effect of stability threshold on feature selection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_features.py", "line_number": 278, "module": "tests.test_ml_features", "name": "test_stability_threshold_effect", "signature": "(self)", "symbol_type": "function"}], "test_start_codon_finding": [{"docstring": "Test start codon finding.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 247, "module": "tests.test_dna_sequences_enhanced", "name": "test_start_codon_finding", "signature": "(self)", "symbol_type": "function"}], "test_step_modules_importable": [{"docstring": "Test all step modules can be imported.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_steps_comprehensive.py", "line_number": 90, "module": "tests.test_rna_steps_comprehensive", "name": "test_step_modules_importable", "signature": "(self)", "symbol_type": "function"}], "test_step_runner_error_handling": [{"docstring": "Test error handling in step runners.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 494, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_step_runner_error_handling", "signature": "(self)", "symbol_type": "function"}], "test_step_runner_functions_exist": [{"docstring": "Test that step runner functions are available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_steps_comprehensive.py", "line_number": 113, "module": "tests.test_rna_steps_comprehensive", "name": "test_step_runner_functions_exist", "signature": "(self)", "symbol_type": "function"}], "test_step_runners_dict_completeness": [{"docstring": "Verify STEP_RUNNERS contains all expected steps.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_steps.py", "line_number": 38, "module": "tests.test_rna_amalgkit_steps", "name": "test_step_runners_dict_completeness", "signature": "(self)", "symbol_type": "function"}], "test_stop_codon_finding": [{"docstring": "Test stop codon finding.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_sequences_enhanced.py", "line_number": 255, "module": "tests.test_dna_sequences_enhanced", "name": "test_stop_codon_finding", "signature": "(self)", "symbol_type": "function"}], "test_strong_association": [{"docstring": "Test strong association in 2x2 table.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 146, "module": "tests.test_math_utilities", "name": "test_strong_association", "signature": "(self)", "symbol_type": "function"}], "test_structured_logging": [{"docstring": "Test structured logging with metadata.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 377, "module": "tests.test_core_comprehensive", "name": "test_structured_logging", "signature": "(self)", "symbol_type": "function"}], "test_subgraph_empty_seed": [{"docstring": "Test subgraph with empty seed set.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 148, "module": "tests.test_ontology_query", "name": "test_subgraph_empty_seed", "signature": "(self)", "symbol_type": "function"}], "test_subgraph_extraction": [{"docstring": "Test subgraph extraction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_comprehensive.py", "line_number": 104, "module": "tests.test_ontology_comprehensive", "name": "test_subgraph_extraction", "signature": "(self)", "symbol_type": "function"}], "test_subgraph_invalid_root": [{"docstring": "Test subgraph with invalid root raises ValueError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 154, "module": "tests.test_ontology_query", "name": "test_subgraph_invalid_root", "signature": "(self)", "symbol_type": "function"}], "test_subgraph_multiple_terms": [{"docstring": "Test extracting subgraph with multiple terms.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 131, "module": "tests.test_ontology_query", "name": "test_subgraph_multiple_terms", "signature": "(self)", "symbol_type": "function"}], "test_subgraph_single_term": [{"docstring": "Test extracting subgraph with single term.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_query.py", "line_number": 116, "module": "tests.test_ontology_query", "name": "test_subgraph_single_term", "signature": "(self)", "symbol_type": "function"}], "test_subset_features": [{"docstring": "Test subsetting features.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 82, "module": "tests.test_multiomics_comprehensive", "name": "test_subset_features", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test subsetting by features.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 158, "module": "tests.test_multiomics_integration", "name": "test_subset_features", "signature": "(self)", "symbol_type": "function"}], "test_subset_samples": [{"docstring": "Test subsetting samples.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_comprehensive.py", "line_number": 69, "module": "tests.test_multiomics_comprehensive", "name": "test_subset_samples", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test subsetting by samples.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_multiomics_integration.py", "line_number": 138, "module": "tests.test_multiomics_integration", "name": "test_subset_samples", "signature": "(self)", "symbol_type": "function"}], "test_suite_generation": [{"docstring": "Test generating a suite of visualizations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 207, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_suite_generation", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_summarize_empty_directory": [{"docstring": "Test summarizing empty directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_pipeline.py", "line_number": 34, "module": "tests.test_rna_pipeline", "name": "test_summarize_empty_directory", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_summarize_fastq": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_fastq.py", "line_number": 69, "module": "tests.test_dna_fastq", "name": "test_summarize_fastq", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_summarize_ignores_non_tsv": [{"docstring": "Test that non-TSV files are ignored.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_pipeline.py", "line_number": 67, "module": "tests.test_rna_pipeline", "name": "test_summarize_ignores_non_tsv", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_summarize_nonexistent_directory": [{"docstring": "Test summarizing non-existent directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_pipeline.py", "line_number": 41, "module": "tests.test_rna_pipeline", "name": "test_summarize_nonexistent_directory", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_summarize_with_tsv_files": [{"docstring": "Test summarizing directory with TSV files.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_pipeline.py", "line_number": 47, "module": "tests.test_rna_pipeline", "name": "test_summarize_with_tsv_files", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_summary_grid_plot": [{"docstring": "Test summary statistics grid plotting.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_viz.py", "line_number": 231, "module": "tests.test_dna_population_viz", "name": "test_summary_grid_plot", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_survival_predictor": [{"docstring": "Test survival predictor.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_models_advanced.py", "line_number": 90, "module": "tests.test_life_events_models_advanced", "name": "test_survival_predictor", "signature": "(tmp_path)", "symbol_type": "function"}], "test_symmetric_epochs": [{"docstring": "Test that expansion and contraction give same harmonic mean.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_demography.py", "line_number": 91, "module": "tests.test_math_demography", "name": "test_symmetric_epochs", "signature": "(self)", "symbol_type": "function"}], "test_symmetry": [{"docstring": "Test that JS divergence is symmetric.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 275, "module": "tests.test_math_utilities", "name": "test_symmetry", "signature": "(self)", "symbol_type": "function"}], "test_tajimas_D_neutral_expectation": [{"docstring": "Test Tajima's D calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 195, "module": "tests.test_math_comprehensive", "name": "test_tajimas_D_neutral_expectation", "signature": "(self)", "symbol_type": "function"}], "test_tajimas_D_zero_when_pi_matches_S_over_a1": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_coalescent_extras.py", "line_number": 16, "module": "tests.test_math_coalescent_extras", "name": "test_tajimas_D_zero_when_pi_matches_S_over_a1", "signature": "()", "symbol_type": "function"}], "test_tajimas_d_no_segregating_sites_is_zero": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_stats.py", "line_number": 12, "module": "tests.test_dna_population_stats", "name": "test_tajimas_d_no_segregating_sites_is_zero", "signature": "() -> None", "symbol_type": "function"}], "test_tajimas_d_outliers": [{"docstring": "Test Tajima's D outlier detection.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_stats.py", "line_number": 57, "module": "tests.test_math_popgen_stats", "name": "test_tajimas_d_outliers", "signature": "()", "symbol_type": "function"}], "test_temporal_aggregation": [{"docstring": "Test temporal information extraction.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 64, "module": "tests.test_phenotype_life_course", "name": "test_temporal_aggregation", "signature": "(self)", "symbol_type": "function"}], "test_temporal_patterns": [{"docstring": "Test temporal pattern analysis.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_interpretability.py", "line_number": 73, "module": "tests.test_life_events_interpretability", "name": "test_temporal_patterns", "signature": "()", "symbol_type": "function"}], "test_temporal_patterns_empty_sequences": [{"docstring": "Test temporal patterns with empty sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_interpretability.py", "line_number": 88, "module": "tests.test_life_events_interpretability", "name": "test_temporal_patterns_empty_sequences", "signature": "()", "symbol_type": "function"}], "test_temporal_patterns_length_mismatch": [{"docstring": "Test temporal patterns with length mismatch.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_interpretability.py", "line_number": 96, "module": "tests.test_life_events_interpretability", "name": "test_temporal_patterns_length_mismatch", "signature": "()", "symbol_type": "function"}], "test_term_creation": [{"docstring": "Test creating ontology term.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_comprehensive.py", "line_number": 21, "module": "tests.test_ontology_comprehensive", "name": "test_term_creation", "signature": "(self)", "symbol_type": "function"}], "test_term_creation_basic": [{"docstring": "Test basic term creation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 16, "module": "tests.test_ontology_types", "name": "test_term_creation_basic", "signature": "(self)", "symbol_type": "function"}], "test_term_creation_defaults": [{"docstring": "Test term creation with default values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 41, "module": "tests.test_ontology_types", "name": "test_term_creation_defaults", "signature": "(self)", "symbol_type": "function"}], "test_term_creation_with_optional_fields": [{"docstring": "Test term creation with optional fields.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 27, "module": "tests.test_ontology_types", "name": "test_term_creation_with_optional_fields", "signature": "(self)", "symbol_type": "function"}], "test_term_repr": [{"docstring": "Test Term __repr__.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 169, "module": "tests.test_ontology_types", "name": "test_term_repr", "signature": "(self)", "symbol_type": "function"}], "test_term_with_relationships": [{"docstring": "Test Term with relationships.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_types.py", "line_number": 177, "module": "tests.test_ontology_types", "name": "test_term_with_relationships", "signature": "(self)", "symbol_type": "function"}], "test_test_population_difference": [{"docstring": "Test population difference testing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_popgen_stats.py", "line_number": 80, "module": "tests.test_math_popgen_stats", "name": "test_test_population_difference", "signature": "()", "symbol_type": "function"}], "test_text_cleaning": [{"docstring": "Test text cleaning utilities.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 325, "module": "tests.test_core_comprehensive", "name": "test_text_cleaning", "signature": "(self)", "symbol_type": "function"}], "test_text_processing": [{"docstring": "Test text processing utilities.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_functionality.py", "line_number": 65, "module": "tests.test_core_functionality", "name": "test_text_processing", "signature": "(self)", "symbol_type": "function"}], "test_text_processing_pipeline": [{"docstring": "Test combining multiple text processing functions.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_text.py", "line_number": 212, "module": "tests.test_core_text", "name": "test_text_processing_pipeline", "signature": "(self) -> None", "symbol_type": "function"}], "test_thread_map_chunked": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_parallel.py", "line_number": 18, "module": "tests.test_core_parallel", "name": "test_thread_map_chunked", "signature": "() -> None", "symbol_type": "function"}], "test_thread_map_preserves_order": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_parallel.py", "line_number": 12, "module": "tests.test_core_parallel", "name": "test_thread_map_preserves_order", "signature": "() -> None", "symbol_type": "function"}], "test_three_sequences": [{"docstring": "Test with three sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 84, "module": "tests.test_dna_population_comprehensive", "name": "test_three_sequences", "signature": "(self)", "symbol_type": "function"}], "test_time_windows": [{"docstring": "Test time window creation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 150, "module": "tests.test_phenotype_life_course", "name": "test_time_windows", "signature": "(self)", "symbol_type": "function"}], "test_timestamps": [{"docstring": "Test that timestamps are included.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_life_course.py", "line_number": 227, "module": "tests.test_phenotype_life_course", "name": "test_timestamps", "signature": "(self)", "symbol_type": "function"}], "test_to_biological_network": [{"docstring": "Test conversion to BiologicalNetwork.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_ppi.py", "line_number": 162, "module": "tests.test_networks_ppi", "name": "test_to_biological_network", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test conversion to BiologicalNetwork.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 204, "module": "tests.test_networks_regulatory", "name": "test_to_biological_network", "signature": "(self)", "symbol_type": "function"}], "test_too_short_returns_zero": [{"docstring": "Test that lists with fewer than 2 elements return 0.0.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 64, "module": "tests.test_math_utilities", "name": "test_too_short_returns_zero", "signature": "(self)", "symbol_type": "function"}], "test_too_short_returns_zeros": [{"docstring": "Test that lists with fewer than 2 elements return (0, 0, 0).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 124, "module": "tests.test_math_utilities", "name": "test_too_short_returns_zeros", "signature": "(self)", "symbol_type": "function"}], "test_total_correlation": [{"docstring": "Test total correlation (multivariate mutual information).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 102, "module": "tests.test_information_comprehensive", "name": "test_total_correlation", "signature": "(self)", "symbol_type": "function"}], "test_total_correlation_single_variable": [{"docstring": "Test total correlation with single variable.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 253, "module": "tests.test_information_comprehensive", "name": "test_total_correlation_single_variable", "signature": "(self)", "symbol_type": "function"}], "test_train_test_split": [{"docstring": "Test train-test split functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ml_comprehensive.py", "line_number": 425, "module": "tests.test_ml_comprehensive", "name": "test_train_test_split", "signature": "(self)", "symbol_type": "function"}], "test_transcribe_dna_to_rna_basic": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_transcription.py", "line_number": 4, "module": "tests.test_dna_transcription", "name": "test_transcribe_dna_to_rna_basic", "signature": "() -> None", "symbol_type": "function"}], "test_transcribe_handles_lowercase_and_empty": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_transcription.py", "line_number": 8, "module": "tests.test_dna_transcription", "name": "test_transcribe_handles_lowercase_and_empty", "signature": "() -> None", "symbol_type": "function"}], "test_transfer_entropy": [{"docstring": "Test transfer entropy calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 109, "module": "tests.test_information_comprehensive", "name": "test_transfer_entropy", "signature": "(self)", "symbol_type": "function"}], "test_transfer_entropy_short_sequence": [{"docstring": "Test transfer entropy with short sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 246, "module": "tests.test_information_comprehensive", "name": "test_transfer_entropy_short_sequence", "signature": "(self)", "symbol_type": "function"}], "test_translate_basic": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_translation.py", "line_number": 6, "module": "tests.test_dna_translation", "name": "test_translate_basic", "signature": "() -> None", "symbol_type": "function"}], "test_tsallis_entropy": [{"docstring": "Test Tsallis entropy calculation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_information_comprehensive.py", "line_number": 322, "module": "tests.test_information_comprehensive", "name": "test_tsallis_entropy", "signature": "(self)", "symbol_type": "function"}], "test_tsv_operations": [{"docstring": "Test TSV (tab-separated values) operations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_comprehensive.py", "line_number": 235, "module": "tests.test_core_comprehensive", "name": "test_tsv_operations", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_tsv_roundtrip": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_io.py", "line_number": 40, "module": "tests.test_core_io", "name": "test_tsv_roundtrip", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_unfolded_sfs": [{"docstring": "Test unfolded SFS generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 262, "module": "tests.test_simulation_popgen", "name": "test_unfolded_sfs", "signature": "(self)", "symbol_type": "function"}], "test_unified_process_metadata_handling": [{"docstring": "Test unified process can handle metadata file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_steps_comprehensive.py", "line_number": 15, "module": "tests.test_rna_steps_comprehensive", "name": "test_unified_process_metadata_handling", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_unified_process_params_parallel": [{"docstring": "Test unified process parameter handling (parallel mode).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_steps_comprehensive.py", "line_number": 40, "module": "tests.test_rna_steps_comprehensive", "name": "test_unified_process_params_parallel", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_unified_process_params_sequential": [{"docstring": "Test unified process parameter handling (sequential mode).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_steps_comprehensive.py", "line_number": 26, "module": "tests.test_rna_steps_comprehensive", "name": "test_unified_process_params_sequential", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_uniprot_id_mapping_real_network": [{"docstring": "Test real UniProt ID mapping with actual API calls.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_uniprot_pdb.py", "line_number": 23, "module": "tests.test_protein_uniprot_pdb", "name": "test_uniprot_id_mapping_real_network", "signature": "()", "symbol_type": "function"}], "test_uniprot_mapping_empty_input": [{"docstring": "Test edge case: empty input list (no network required).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_uniprot_pdb.py", "line_number": 35, "module": "tests.test_protein_uniprot_pdb", "name": "test_uniprot_mapping_empty_input", "signature": "()", "symbol_type": "function"}], "test_uniprot_mapping_offline_behavior": [{"docstring": "Test behavior when UniProt API is unavailable.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_protein_uniprot_pdb.py", "line_number": 41, "module": "tests.test_protein_uniprot_pdb", "name": "test_uniprot_mapping_offline_behavior", "signature": "()", "symbol_type": "function"}], "test_validate_config_file": [{"docstring": "Test configuration file validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_processing.py", "line_number": 19, "module": "tests.test_core_processing", "name": "test_validate_config_file", "signature": "(self)", "symbol_type": "function"}], "test_validate_go_ontology": [{"docstring": "Test GO ontology validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_go_basic.py", "line_number": 42, "module": "tests.test_ontology_go_basic", "name": "test_validate_go_ontology", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_validate_json_schema_missing_package": [{"docstring": "Test that missing jsonschema package raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 217, "module": "tests.test_core_validation", "name": "test_validate_json_schema_missing_package", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_validate_not_empty_empty_dict": [{"docstring": "Test that empty dict raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 183, "module": "tests.test_core_validation", "name": "test_validate_not_empty_empty_dict", "signature": "(self)", "symbol_type": "function"}], "test_validate_not_empty_empty_list": [{"docstring": "Test that empty list raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 178, "module": "tests.test_core_validation", "name": "test_validate_not_empty_empty_list", "signature": "(self)", "symbol_type": "function"}], "test_validate_not_empty_empty_string": [{"docstring": "Test that empty string raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 173, "module": "tests.test_core_validation", "name": "test_validate_not_empty_empty_string", "signature": "(self)", "symbol_type": "function"}], "test_validate_not_empty_valid": [{"docstring": "Test validating non-empty values.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 166, "module": "tests.test_core_validation", "name": "test_validate_not_empty_valid", "signature": "(self)", "symbol_type": "function"}], "test_validate_not_none_none": [{"docstring": "Test that None raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 157, "module": "tests.test_core_validation", "name": "test_validate_not_none_none", "signature": "(self)", "symbol_type": "function"}], "test_validate_not_none_valid": [{"docstring": "Test validating non-None value.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 150, "module": "tests.test_core_validation", "name": "test_validate_not_none_valid", "signature": "(self)", "symbol_type": "function"}], "test_validate_path_exists": [{"docstring": "Test validating existing path.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 90, "module": "tests.test_core_validation", "name": "test_validate_path_exists", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_validate_path_exists_nonexistent": [{"docstring": "Test that nonexistent path raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 98, "module": "tests.test_core_validation", "name": "test_validate_path_exists_nonexistent", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_validate_path_is_dir": [{"docstring": "Test validating directory path.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 116, "module": "tests.test_core_validation", "name": "test_validate_path_is_dir", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_validate_path_is_dir_file": [{"docstring": "Test that file raises ValidationError when expecting directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 121, "module": "tests.test_core_validation", "name": "test_validate_path_is_dir_file", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_validate_path_is_file": [{"docstring": "Test validating file path.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 104, "module": "tests.test_core_validation", "name": "test_validate_path_is_file", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_validate_path_is_file_directory": [{"docstring": "Test that directory raises ValidationError when expecting file.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 111, "module": "tests.test_core_validation", "name": "test_validate_path_is_file_directory", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_validate_path_within": [{"docstring": "Test validating path within parent directory.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 128, "module": "tests.test_core_validation", "name": "test_validate_path_within", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_validate_path_within_outside": [{"docstring": "Test that path outside parent raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 137, "module": "tests.test_core_validation", "name": "test_validate_path_within_outside", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_validate_range_above_max": [{"docstring": "Test that value above maximum raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 81, "module": "tests.test_core_validation", "name": "test_validate_range_above_max", "signature": "(self)", "symbol_type": "function"}], "test_validate_range_below_min": [{"docstring": "Test that value below minimum raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 76, "module": "tests.test_core_validation", "name": "test_validate_range_below_min", "signature": "(self)", "symbol_type": "function"}], "test_validate_range_max_only": [{"docstring": "Test validating with only maximum.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 71, "module": "tests.test_core_validation", "name": "test_validate_range_max_only", "signature": "(self)", "symbol_type": "function"}], "test_validate_range_min_only": [{"docstring": "Test validating with only minimum.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 66, "module": "tests.test_core_validation", "name": "test_validate_range_min_only", "signature": "(self)", "symbol_type": "function"}], "test_validate_range_within": [{"docstring": "Test validating value within range.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 61, "module": "tests.test_core_validation", "name": "test_validate_range_within", "signature": "(self)", "symbol_type": "function"}], "test_validate_regulation": [{"docstring": "Test regulation validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_regulatory.py", "line_number": 701, "module": "tests.test_networks_regulatory", "name": "test_validate_regulation", "signature": "(self)", "symbol_type": "function"}], "test_validate_schema_missing_field": [{"docstring": "Test that missing field raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 199, "module": "tests.test_core_validation", "name": "test_validate_schema_missing_field", "signature": "(self)", "symbol_type": "function"}], "test_validate_schema_valid": [{"docstring": "Test validating data against schema.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 192, "module": "tests.test_core_validation", "name": "test_validate_schema_valid", "signature": "(self)", "symbol_type": "function"}], "test_validate_schema_wrong_type": [{"docstring": "Test that wrong type raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 206, "module": "tests.test_core_validation", "name": "test_validate_schema_wrong_type", "signature": "(self)", "symbol_type": "function"}], "test_validate_sequence_empty_person_id": [{"docstring": "Test validation of sequence with empty person_id.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_utils.py", "line_number": 92, "module": "tests.test_life_events_utils", "name": "test_validate_sequence_empty_person_id", "signature": "()", "symbol_type": "function"}], "test_validate_sequence_no_events": [{"docstring": "Test validation of sequence with no events.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_utils.py", "line_number": 104, "module": "tests.test_life_events_utils", "name": "test_validate_sequence_no_events", "signature": "()", "symbol_type": "function"}], "test_validate_sequence_valid": [{"docstring": "Test validation of valid sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_utils.py", "line_number": 80, "module": "tests.test_life_events_utils", "name": "test_validate_sequence_valid", "signature": "()", "symbol_type": "function"}], "test_validate_type_int": [{"docstring": "Test validating integer type.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 31, "module": "tests.test_core_validation", "name": "test_validate_type_int", "signature": "(self)", "symbol_type": "function"}], "test_validate_type_str": [{"docstring": "Test validating string type.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 36, "module": "tests.test_core_validation", "name": "test_validate_type_str", "signature": "(self)", "symbol_type": "function"}], "test_validate_type_tuple": [{"docstring": "Test validating against tuple of types.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 46, "module": "tests.test_core_validation", "name": "test_validate_type_tuple", "signature": "(self)", "symbol_type": "function"}], "test_validate_type_tuple_wrong": [{"docstring": "Test that type not in tuple raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 52, "module": "tests.test_core_validation", "name": "test_validate_type_tuple_wrong", "signature": "(self)", "symbol_type": "function"}], "test_validate_type_wrong_type": [{"docstring": "Test that wrong type raises ValidationError.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 41, "module": "tests.test_core_validation", "name": "test_validate_type_wrong_type", "signature": "(self)", "symbol_type": "function"}], "test_validation_checks_fastq_files": [{"docstring": "Test that validation correctly checks for FASTQ files.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_validation.py", "line_number": 82, "module": "tests.test_rna_download_validation", "name": "test_validation_checks_fastq_files", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_validation_checks_sra_files": [{"docstring": "Test that validation correctly checks for SRA files when no FASTQ.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_validation.py", "line_number": 101, "module": "tests.test_rna_download_validation", "name": "test_validation_checks_sra_files", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_validation_detects_empty_directories": [{"docstring": "Test that validation detects empty sample directories.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_validation.py", "line_number": 116, "module": "tests.test_rna_download_validation", "name": "test_validation_detects_empty_directories", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_validation_errors": [{"docstring": "Test validation errors for invalid data structures.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_phenotype_comprehensive.py", "line_number": 92, "module": "tests.test_phenotype_comprehensive", "name": "test_validation_errors", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_validation_handles_missing_directories": [{"docstring": "Test that validation handles missing sample directories gracefully.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_validation.py", "line_number": 134, "module": "tests.test_rna_download_validation", "name": "test_validation_handles_missing_directories", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_validation_path_resolution": [{"docstring": "Test that path resolution works correctly for validation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_download_validation.py", "line_number": 149, "module": "tests.test_rna_download_validation", "name": "test_validation_path_resolution", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_validator_decorator": [{"docstring": "Test validator decorator creates validator function.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 236, "module": "tests.test_core_validation", "name": "test_validator_decorator", "signature": "(self)", "symbol_type": "function"}], "test_validator_decorator_custom_name": [{"docstring": "Test validator with custom name parameter.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_core_validation.py", "line_number": 250, "module": "tests.test_core_validation", "name": "test_validator_decorator_custom_name", "signature": "(self)", "symbol_type": "function"}], "test_variant_plot": [{"docstring": "Test variant-specific visualization.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 150, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_variant_plot", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_very_large_network_performance": [{"docstring": "Test performance on larger networks.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 331, "module": "tests.test_networks_community", "name": "test_very_large_network_performance", "signature": "(self)", "symbol_type": "function"}], "test_very_large_pathway": [{"docstring": "Test handling of very large pathways.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_pathway.py", "line_number": 440, "module": "tests.test_networks_pathway", "name": "test_very_large_pathway", "signature": "(self)", "symbol_type": "function"}], "test_violin_plot_functionality": [{"docstring": "Test enhanced violin plot functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 113, "module": "tests.test_visualization_enhanced", "name": "test_violin_plot_functionality", "signature": "(self)", "symbol_type": "function"}], "test_visualization_empty_results": [{"docstring": "Test visualization functions with empty results.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization.py", "line_number": 122, "module": "tests.test_gwas_visualization", "name": "test_visualization_empty_results", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_visualization_orchestrator_help": [{"docstring": "Test visualization orchestrator shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_orchestrators.py", "line_number": 86, "module": "tests.test_orchestrators", "name": "test_visualization_orchestrator_help", "signature": "(self)", "symbol_type": "function"}], "test_volcano_plot": [{"docstring": "Test volcano plot functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 272, "module": "tests.test_visualization_enhanced", "name": "test_volcano_plot", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test volcano plot functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_visualization_enhanced.py", "line_number": 397, "module": "tests.test_visualization_enhanced", "name": "test_volcano_plot", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test volcano plot generation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_gwas_visualization_comprehensive.py", "line_number": 97, "module": "tests.test_gwas_visualization_comprehensive", "name": "test_volcano_plot", "signature": "(self, tmp_path)", "symbol_type": "function"}], "test_waiting_times_and_tajimas_D_stability": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_coalescent.py", "line_number": 55, "module": "tests.test_math_coalescent", "name": "test_waiting_times_and_tajimas_D_stability", "signature": "()", "symbol_type": "function"}], "test_watterson_and_expected_S": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_coalescent.py", "line_number": 30, "module": "tests.test_math_coalescent", "name": "test_watterson_and_expected_S", "signature": "()", "symbol_type": "function"}], "test_watterson_theta_calculation": [{"docstring": "Test Watterson's theta estimator.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 146, "module": "tests.test_math_comprehensive", "name": "test_watterson_theta_calculation", "signature": "(self)", "symbol_type": "function"}], "test_weighted_expectation": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_price.py", "line_number": 35, "module": "tests.test_math_price", "name": "test_weighted_expectation", "signature": "()", "symbol_type": "function"}], "test_wget_available": [{"docstring": "Verify wget is installed (required for downloads).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 166, "module": "tests.test_rna_ena_workflow", "name": "test_wget_available", "signature": "(self)", "symbol_type": "function"}], "test_wget_supports_continue": [{"docstring": "Verify wget supports --continue flag.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 186, "module": "tests.test_rna_ena_workflow", "name": "test_wget_supports_continue", "signature": "(self)", "symbol_type": "function"}], "test_with_allele_frequencies": [{"docstring": "Test generation with specified allele frequencies.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 145, "module": "tests.test_simulation_popgen", "name": "test_with_allele_frequencies", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test LD generation with specified frequencies.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 298, "module": "tests.test_simulation_popgen", "name": "test_with_allele_frequencies", "signature": "(self)", "symbol_type": "function"}], "test_with_nucleotide_diversity": [{"docstring": "Test generation with target nucleotide diversity.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 33, "module": "tests.test_simulation_popgen", "name": "test_with_nucleotide_diversity", "signature": "(self)", "symbol_type": "function"}], "test_with_reference_sequence": [{"docstring": "Test generation with provided reference sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 55, "module": "tests.test_simulation_popgen", "name": "test_with_reference_sequence", "signature": "(self)", "symbol_type": "function"}], "test_with_single_sample": [{"docstring": "Test getfastq with a single sample to verify fixes.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/rna/test_getfastq_fix.py", "line_number": 83, "module": "scripts.rna.test_getfastq_fix", "name": "test_with_single_sample", "signature": "()", "symbol_type": "function"}], "test_with_wattersons_theta": [{"docstring": "Test generation with target Watterson's theta.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_simulation_popgen.py", "line_number": 46, "module": "tests.test_simulation_popgen", "name": "test_with_wattersons_theta", "signature": "(self)", "symbol_type": "function"}], "test_workflow_config_loading": [{"docstring": "Test workflow configuration loading.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 113, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_workflow_config_loading", "signature": "(self)", "symbol_type": "function"}], "test_workflow_config_priority": [{"docstring": "Test that config_obj takes priority over config_path.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_life_events_embeddings.py", "line_number": 368, "module": "tests.test_life_events_embeddings", "name": "test_workflow_config_priority", "signature": "(tmp_path)", "symbol_type": "function"}], "test_workflow_continues_after_non_critical_failure": [{"docstring": "Test that workflow continues execution after non-critical step failure.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_workflow_error_handling.py", "line_number": 26, "module": "tests.test_rna_workflow_error_handling", "name": "test_workflow_continues_after_non_critical_failure", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_workflow_example_from_docs": [{"docstring": "Test the workflow example from the documentation.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 426, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_workflow_example_from_docs", "signature": "(self)", "symbol_type": "function"}], "test_workflow_execution_dry_run": [{"docstring": "Test workflow execution with dry run.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 169, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_workflow_execution_dry_run", "signature": "(self)", "symbol_type": "function"}], "test_workflow_help": [{"docstring": "Verify workflow script shows help.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 59, "module": "tests.test_rna_ena_workflow", "name": "test_workflow_help", "signature": "(self)", "symbol_type": "function"}], "test_workflow_planning": [{"docstring": "Test that workflow can be planned (not executed).", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/validate_all_species_workflow.py", "line_number": 120, "module": "scripts.validate_all_species_workflow", "name": "test_workflow_planning", "signature": "(config_path: Path) -> Tuple[bool, str]", "symbol_type": "function"}, {"docstring": "Test workflow planning functionality.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 139, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_workflow_planning", "signature": "(self)", "symbol_type": "function"}], "test_workflow_requires_config": [{"docstring": "Verify workflow requires --config argument.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 71, "module": "tests.test_rna_ena_workflow", "name": "test_workflow_requires_config", "signature": "(self)", "symbol_type": "function"}], "test_workflow_script_exists": [{"docstring": "Verify run_workflow.py exists and is executable.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 53, "module": "tests.test_rna_ena_workflow", "name": "test_workflow_script_exists", "signature": "(self)", "symbol_type": "function"}], "test_workflow_skips_steps_when_missing_deps": [{"docstring": "Test that workflow execution skips steps when required dependencies are missing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_workflow_deps.py", "line_number": 11, "module": "tests.test_rna_workflow_deps", "name": "test_workflow_skips_steps_when_missing_deps", "signature": "(tmp_path: Path)", "symbol_type": "function"}], "test_workflow_skips_steps_with_missing_dependencies": [{"docstring": "Test that workflow skips steps when dependencies are missing.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_workflow_error_handling.py", "line_number": 78, "module": "tests.test_rna_workflow_error_handling", "name": "test_workflow_skips_steps_with_missing_dependencies", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_workflow_step_sequence": [{"docstring": "Test that workflow steps execute in correct sequence.\n\nUses ensure_amalgkit_available fixture to ensure amalgkit is available.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_end_to_end.py", "line_number": 103, "module": "tests.test_rna_amalgkit_end_to_end", "name": "test_workflow_step_sequence", "signature": "(self, ensure_amalgkit_available)", "symbol_type": "function"}], "test_workflow_stops_on_critical_failure_with_check": [{"docstring": "Test that workflow stops on first failure when check=True.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_workflow_error_handling.py", "line_number": 56, "module": "tests.test_rna_workflow_error_handling", "name": "test_workflow_stops_on_critical_failure_with_check", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_workflow_supports_ena_downloads": [{"docstring": "Verify workflow supports ENA-based downloads via amalgkit.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_ena_workflow.py", "line_number": 37, "module": "tests.test_rna_ena_workflow", "name": "test_workflow_supports_ena_downloads", "signature": "(self)", "symbol_type": "function"}], "test_workflow_with_filters": [{"docstring": "Test workflow with filtering parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 394, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_workflow_with_filters", "signature": "(self)", "symbol_type": "function"}], "test_workflow_with_genome_config": [{"docstring": "Test workflow with genome configuration.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 312, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_workflow_with_genome_config", "signature": "(self)", "symbol_type": "function"}], "test_wrapper_with_invalid_params": [{"docstring": "Test wrapper with invalid parameters.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 483, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_wrapper_with_invalid_params", "signature": "(self)", "symbol_type": "function"}], "test_wrapper_with_missing_amalgkit": [{"docstring": "Test wrapper behavior when amalgkit is not available.\n\nUses real check_cli_available() implementation following NO_MOCKING_POLICY.\nTests actual behavior regardless of whether amalgkit is installed.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_rna_amalgkit_comprehensive.py", "line_number": 465, "module": "tests.test_rna_amalgkit_comprehensive", "name": "test_wrapper_with_missing_amalgkit", "signature": "(self)", "symbol_type": "function"}], "test_write_go_summary": [{"docstring": "Test writing GO summary.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_comprehensive.py", "line_number": 198, "module": "tests.test_ontology_comprehensive", "name": "test_write_go_summary", "signature": "(self, tmp_path: Path)", "symbol_type": "function"}], "test_write_go_summary_custom_path": [{"docstring": "Test writing GO summary to custom path.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_ontology_go_basic.py", "line_number": 57, "module": "tests.test_ontology_go_basic", "name": "test_write_go_summary_custom_path", "signature": "(tmp_path: Path) -> None", "symbol_type": "function"}], "test_zero_duration": [{"docstring": "Test with zero bottleneck duration.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_demography.py", "line_number": 68, "module": "tests.test_math_demography", "name": "test_zero_duration", "signature": "(self)", "symbol_type": "function"}], "test_zero_entropy": [{"docstring": "Test zero entropy (certainty).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 199, "module": "tests.test_math_utilities", "name": "test_zero_entropy", "signature": "(self)", "symbol_type": "function"}], "test_zero_generations": [{"docstring": "Test with zero generations.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_demography.py", "line_number": 37, "module": "tests.test_math_demography", "name": "test_zero_generations", "signature": "(self)", "symbol_type": "function"}], "test_zero_length_sequences": [{"docstring": "Test with zero-length sequences.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_dna_population_comprehensive.py", "line_number": 116, "module": "tests.test_dna_population_comprehensive", "name": "test_zero_length_sequences", "signature": "(self)", "symbol_type": "function"}], "test_zero_population_size": [{"docstring": "Test functions with zero population size.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_comprehensive.py", "line_number": 339, "module": "tests.test_math_comprehensive", "name": "test_zero_population_size", "signature": "(self)", "symbol_type": "function"}], "test_zero_sum_distribution": [{"docstring": "Test that zero-sum distribution returns 0.0.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 261, "module": "tests.test_math_utilities", "name": "test_zero_sum_distribution", "signature": "(self)", "symbol_type": "function"}], "test_zero_time": [{"docstring": "Test with zero time since change.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_demography.py", "line_number": 99, "module": "tests.test_math_demography", "name": "test_zero_time", "signature": "(self)", "symbol_type": "function"}], "test_zero_variance_genes": [{"docstring": "Test handling of zero-variance genes.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_singlecell_dimensionality.py", "line_number": 567, "module": "tests.test_singlecell_dimensionality", "name": "test_zero_variance_genes", "signature": "(self)", "symbol_type": "function"}], "test_zero_variance_returns_zero": [{"docstring": "Test that zero variance returns 0.0.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 71, "module": "tests.test_math_utilities", "name": "test_zero_variance_returns_zero", "signature": "(self)", "symbol_type": "function"}], "test_zero_variance_x_returns_zeros": [{"docstring": "Test that zero variance in x returns (0, 0, 0).", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_math_utilities.py", "line_number": 133, "module": "tests.test_math_utilities", "name": "test_zero_variance_x_returns_zeros", "signature": "(self)", "symbol_type": "function"}], "test_zero_weight_edges": [{"docstring": "Test handling of zero-weight edges.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_community.py", "line_number": 366, "module": "tests.test_networks_community", "name": "test_zero_weight_edges", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Test handling of zero-weight edges.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/test_networks_graph.py", "line_number": 374, "module": "tests.test_networks_graph", "name": "test_zero_weight_edges", "signature": "(self)", "symbol_type": "function"}], "theta": [{"docstring": "Calculate population mutation parameter \u03b8 = 4Ne\u03bc (diploid).\n\nReturns:\n    \u03b8 value in generations", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 797, "module": "src.metainformant.math.coalescent", "name": "theta", "signature": "(self) -> float", "symbol_type": "function"}], "thread_map": [{"docstring": "Map a function across items using threads, preserving order.\n\nArgs:\n    func: Function to apply to each item\n    items: Items to process (will be materialized if not a sequence)\n    max_workers: Maximum number of worker threads\n    chunk_size: Size of chunks for batch processing (None for auto)\n    timeout: Timeout in seconds for each task (None for no timeout)\n    ordered: Whether to preserve input order in results\n\nReturns:\n    List of results in the same order as input items\n\nIf items is not a sequence, it will be materialized to preserve order.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/parallel.py", "line_number": 11, "module": "src.metainformant.core.parallel", "name": "thread_map", "signature": "(func: Callable[[T], U], items: Sequence[T] | Iterable[T]) -> list[U]", "symbol_type": "function"}], "thread_map_unordered": [{"docstring": "Map a function across items using threads, without preserving order.\n\nArgs:\n    func: Function to apply to each item\n    items: Items to process\n    max_workers: Maximum number of worker threads\n    timeout: Timeout in seconds for each task (None for no timeout)\n\nReturns:\n    List of results (order not preserved for better performance)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/parallel.py", "line_number": 72, "module": "src.metainformant.core.parallel", "name": "thread_map_unordered", "signature": "(func: Callable[[T], U], items: Iterable[T]) -> list[U]", "symbol_type": "function"}], "three_to_index": [{"docstring": "Three letter code to index.\n\n>>> three_to_index('ALA')\n0\n>>> three_to_index('TYR')\n19", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Polypeptide.py", "line_number": 116, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Polypeptide", "name": "three_to_index", "signature": "(s)", "symbol_type": "function"}], "threshold_balanced": [{"docstring": "Approximate log-odds threshold making FNR equal to FPR times rate_proportion.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/thresholds.py", "line_number": 88, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.thresholds", "name": "threshold_balanced", "signature": "(self, rate_proportion = 1.0, return_rate = False)", "symbol_type": "function"}], "threshold_fnr": [{"docstring": "Approximate the log-odds threshold which makes the type II error (false negative rate).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/thresholds.py", "line_number": 79, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.thresholds", "name": "threshold_fnr", "signature": "(self, fnr)", "symbol_type": "function"}], "threshold_fpr": [{"docstring": "Approximate the log-odds threshold which makes the type I error (false positive rate).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/thresholds.py", "line_number": 70, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.thresholds", "name": "threshold_fpr", "signature": "(self, fpr)", "symbol_type": "function"}], "threshold_patser": [{"docstring": "Threshold selection mimicking the behaviour of patser (Hertz, Stormo 1999) software.\n\nIt selects such a threshold that the log(fpr)=-ic(M)\nnote: the actual patser software uses natural logarithms instead of log_2, so the numbers\nare not directly comparable.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/thresholds.py", "line_number": 102, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.thresholds", "name": "threshold_patser", "signature": "(self)", "symbol_type": "function"}], "time_series_plot": [{"docstring": "Create a time series plot.\n\nArgs:\n    time_points: Time points\n    values: Values at each time point\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    xlabel: X-axis label\n    ylabel: Y-axis label\n    **kwargs: Additional arguments for plot\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import time_series_plot\n    >>> import numpy as np\n    >>> time = np.arange(0, 10, 0.1)\n    >>> values = np.sin(time)\n    >>> ax = time_series_plot(time, values)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/timeseries.py", "line_number": 21, "module": "src.metainformant.visualization.timeseries", "name": "time_series_plot", "signature": "(time_points: Sequence[float], values: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "time_to_mrca": [{"docstring": "Calculate expected time to most recent common ancestor.\n\nReturns:\n    Expected TMRCA in generations", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 813, "module": "src.metainformant.math.coalescent", "name": "time_to_mrca", "signature": "(self) -> float", "symbol_type": "function"}], "timeout_handler": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/parallel.py", "line_number": 43, "module": "src.metainformant.core.parallel", "name": "timeout_handler", "signature": "(signum, frame)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/parallel.py", "line_number": 96, "module": "src.metainformant.core.parallel", "name": "timeout_handler", "signature": "(signum, frame)", "symbol_type": "function"}], "title": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 642, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "title", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 1024, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "title", "signature": "(self, content)", "symbol_type": "function"}], "tls": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 414, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "tls", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 894, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "tls", "signature": "(self, content)", "symbol_type": "function"}], "tname": [{"docstring": "Return the name of the table.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/DBUtils.py", "line_number": 26, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.DBUtils", "name": "tname", "signature": "(self, table)", "symbol_type": "function"}], "toClaRecord": [{"docstring": "Return a Cla.Record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 705, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "toClaRecord", "signature": "(self)", "symbol_type": "function"}], "toDesRecord": [{"docstring": "Return a Des.Record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 596, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "toDesRecord", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a Des.Record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 699, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "toDesRecord", "signature": "(self)", "symbol_type": "function"}], "toHieRecord": [{"docstring": "Return an Hie.Record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 584, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "toHieRecord", "signature": "(self)", "symbol_type": "function"}], "toMultipleSeqAlignment": [{"docstring": "Convert the CodonAlignment to a MultipleSeqAlignment.\n\nReturn a MultipleSeqAlignment containing all the\nSeqRecord in the CodonAlignment using Seq to store\nsequences", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonalignment.py", "line_number": 141, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonalignment", "name": "toMultipleSeqAlignment", "signature": "(self)", "symbol_type": "function"}], "toSeq": [{"docstring": "Convert DNA to seq object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 183, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "toSeq", "signature": "(self)", "symbol_type": "function"}], "to_alignment": [{"docstring": "Construct a MultipleSeqAlignment from the aligned sequences in this tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 247, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "to_alignment", "signature": "(self)", "symbol_type": "function"}], "to_ascii": [{"docstring": "Return an ASCII art representation of the tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/phylogeny.py", "line_number": 136, "module": "src.metainformant.dna.phylogeny", "name": "to_ascii", "signature": "(tree) -> str", "symbol_type": "function"}], "to_biological_network": [{"docstring": "Convert to BiologicalNetwork.\n\nArgs:\n    min_confidence: Minimum confidence for including interactions\n\nReturns:\n    BiologicalNetwork object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/ppi.py", "line_number": 265, "module": "src.metainformant.networks.ppi", "name": "to_biological_network", "signature": "(self, min_confidence: float = 0.0) -> BiologicalNetwork", "symbol_type": "function"}, {"docstring": "Convert to BiologicalNetwork (alias for create_network).\n\nArgs:\n    min_confidence: Minimum confidence for including regulations\n\nReturns:\n    BiologicalNetwork object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 352, "module": "src.metainformant.networks.regulatory", "name": "to_biological_network", "signature": "(self, min_confidence: float = 0.0) -> BiologicalNetwork", "symbol_type": "function"}], "to_circular": [{"docstring": "Make a new instance of sequence as circular.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 205, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "to_circular", "signature": "(self)", "symbol_type": "function"}], "to_common_params": [{"docstring": "Convert configuration to common parameters for all steps.\n\nReturns:\n    Dictionary of common parameters (threads, species-list)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/workflow.py", "line_number": 51, "module": "src.metainformant.rna.workflow", "name": "to_common_params", "signature": "(self) -> AmalgkitParams", "symbol_type": "function"}], "to_dataframe": [{"docstring": "Convert sequence to pandas DataFrame.\n\nReturns:\n    DataFrame with columns: person_id, event_type, timestamp, domain, attributes", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 181, "module": "src.metainformant.life_events.events", "name": "to_dataframe", "signature": "(self) -> pd.DataFrame", "symbol_type": "function"}, {"docstring": "Convert all sequences to single DataFrame.\n\nReturns:\n    Combined DataFrame of all sequences", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 306, "module": "src.metainformant.life_events.events", "name": "to_dataframe", "signature": "(self) -> pd.DataFrame", "symbol_type": "function"}], "to_debug_report": [{"docstring": "Gets the essential information for debugging.\n\n:return: The report for debugging.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/configuration.py", "line_number": 409, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.configuration", "name": "to_debug_report", "signature": "(self)", "symbol_type": "function"}], "to_dict": [{"docstring": "Convert event to dictionary representation.\n\nReturns:\n    Dictionary representation of event", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 44, "module": "src.metainformant.life_events.events", "name": "to_dict", "signature": "(self) -> Dict[str, Any]", "symbol_type": "function"}, {"docstring": "Convert sequence to dictionary representation.\n\nReturns:\n    Dictionary representation of sequence", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 200, "module": "src.metainformant.life_events.events", "name": "to_dict", "signature": "(self) -> Dict[str, Any]", "symbol_type": "function"}, {"docstring": "Convert database to dictionary representation.\n\nReturns:\n    Dictionary representation of database", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/events.py", "line_number": 317, "module": "src.metainformant.life_events.events", "name": "to_dict", "signature": "(self) -> Dict[str, Any]", "symbol_type": "function"}, {"docstring": "Returns the model properties as a dict", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 536, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "to_dict", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Returns the model properties as a dict", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 692, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "to_dict", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Turn a QueryResult iterator or list into a dictionary.\n\n - qresults     - Iterable returning QueryResult objects.\n - key_function - Optional callback function which when given a\n                  QueryResult object should return a unique key for the\n                  dictionary. Defaults to using .id of the result.\n\nThis function enables access of QueryResult objects from a single search\noutput file using its identifier.\n\n>>> from Bio import SearchIO\n>>> qresults = SearchIO.parse('Blast/wnts.xml', 'blast-xml')\n>>> search_dict = SearchIO.to_dict(qresults)\n>>> list(search_dict)\n['gi|195230749:301-1383', 'gi|325053704:108-1166', ..., 'gi|53729353:216-1313']\n>>> search_dict['gi|156630997:105-1160']\nQueryResult(id='gi|156630997:105-1160', 5 hits)\n\nBy default, the dictionary key is the QueryResult's string ID. This may be\nchanged by supplying a callback function that returns the desired identifier.\nHere is an example using a function that removes the 'gi|' part in the\nbeginning of the QueryResult ID.\n\n>>> from Bio import SearchIO\n>>> qresults = SearchIO.parse('Blast/wnts.xml', 'blast-xml')\n>>> key_func = lambda qresult: qresult.id.split('|')[1]\n>>> search_dict = SearchIO.to_dict(qresults, key_func)\n>>> list(search_dict)\n['195230749:301-1383', '325053704:108-1166', ..., '53729353:216-1313']\n>>> search_dict['156630997:105-1160']\nQueryResult(id='gi|156630997:105-1160', 5 hits)\n\nNote that the callback function does not change the QueryResult's ID value.\nIt only changes the key value used to retrieve the associated QueryResult.\n\nAs this function loads all QueryResult objects into memory, it may be\nunsuitable for dealing with files containing many queries. In that case, it\nis recommended that you use either ``index`` or ``index_db``.\n\nSince Python 3.7, the default dict class maintains key order, meaning\nthis dictionary will reflect the order of records given to it. For\nCPython and PyPy, this was already implemented for Python 3.6, so\neffectively you can always assume the record order is preserved.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/__init__.py", "line_number": 365, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.__init__", "name": "to_dict", "signature": "(qresults, key_function = None)", "symbol_type": "function"}, {"docstring": "Turn a sequence iterator or list into a dictionary.\n\nArguments:\n - sequences  - An iterator that returns SeqRecord objects,\n   or simply a list of SeqRecord objects.\n - key_function - Optional callback function which when given a\n   SeqRecord should return a unique key for the dictionary.\n\ne.g. key_function = lambda rec : rec.name\nor,  key_function = lambda rec : rec.description.split()[0]\n\nIf key_function is omitted then record.id is used, on the assumption\nthat the records objects returned are SeqRecords with a unique id.\n\nIf there are duplicate keys, an error is raised.\n\nSince Python 3.7, the default dict class maintains key order, meaning\nthis dictionary will reflect the order of records given to it. For\nCPython and PyPy, this was already implemented for Python 3.6, so\neffectively you can always assume the record order is preserved.\n\nExample usage, defaulting to using the record.id as key:\n\n>>> from Bio import SeqIO\n>>> filename = \"GenBank/cor6_6.gb\"\n>>> format = \"genbank\"\n>>> id_dict = SeqIO.to_dict(SeqIO.parse(filename, format))\n>>> print(list(id_dict))\n['X55053.1', 'X62281.1', 'M81224.1', 'AJ237582.1', 'L31939.1', 'AF297471.1']\n>>> print(id_dict[\"L31939.1\"].description)\nBrassica rapa (clone bif72) kin mRNA, complete cds\n\nA more complex example, using the key_function argument in order to\nuse a sequence checksum as the dictionary key:\n\n>>> from Bio import SeqIO\n>>> from Bio.SeqUtils.CheckSum import seguid\n>>> filename = \"GenBank/cor6_6.gb\"\n>>> format = \"genbank\"\n>>> seguid_dict = SeqIO.to_dict(SeqIO.parse(filename, format),\n...               key_function = lambda rec : seguid(rec.seq))\n>>> for key, record in sorted(seguid_dict.items()):\n...     print(\"%s %s\" % (key, record.id))\n/wQvmrl87QWcm9llO4/efg23Vgg AJ237582.1\nBUg6YxXSKWEcFFH0L08JzaLGhQs L31939.1\nSabZaA4V2eLE9/2Fm5FnyYy07J4 X55053.1\nTtWsXo45S3ZclIBy4X/WJc39+CY M81224.1\nl7gjJFE6W/S1jJn5+1ASrUKW/FA X62281.1\nuVEYeAQSV5EDQOnFoeMmVea+Oow AF297471.1\n\nThis approach is not suitable for very large sets of sequences, as all\nthe SeqRecord objects are held in memory. Instead, consider using the\nBio.SeqIO.index() function (if it supports your particular file format).\n\nThis dictionary will reflect the order of records given to it.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/__init__.py", "line_number": 732, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.__init__", "name": "to_dict", "signature": "(sequences, key_function = None)", "symbol_type": "function"}, {"docstring": "Return the list of matrices as a dictionary of matrices.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/jaspar/__init__.py", "line_number": 144, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.jaspar.__init__", "name": "to_dict", "signature": "(self)", "symbol_type": "function"}], "to_generic": [{"docstring": "Retrieve generic alignment object for the given alignment.\n\nInstead of the tuples, this returns a MultipleSeqAlignment object\nfrom Bio.Align, through which you can manipulate and query\nthe object.\n\nThanks to James Casbon for the code.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/NCBIXML.py", "line_number": 291, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.NCBIXML", "name": "to_generic", "signature": "(self)", "symbol_type": "function"}], "to_hex": [{"docstring": "Return a 24-bit hexadecimal RGB representation of this color.\n\nThe returned string is suitable for use in HTML/CSS, as a color\nparameter in matplotlib, and perhaps other situations.\n\nExamples\n--------\n>>> bc = BranchColor(12, 200, 100)\n>>> bc.to_hex()\n'#0cc864'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 1194, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "to_hex", "signature": "(self)", "symbol_type": "function"}], "to_igraph": [{"docstring": "Convert a Tree object to an igraph Graph.\n\nThe result is useful for graph-oriented analysis and interactive plotting\nwith matplotlib, Cairo, and plotly.\n\nRequires python-igraph version 0.10.0 or later.\n\n:Parameters:\n    vertex_attributes : sequence of strings\n        A sequence of strings containing the Clade properties that are to\n        be stored as vertex attributes, e.g. \"name\".\n    edge_attributes : sequence of strings\n        A sequence of strings containing the Clade properties that are to\n        be stored as edge attributes, e.g. \"color\" and \"width\".\n\nIn both cases, if a property is not found it will be ignored.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 85, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "to_igraph", "signature": "(tree, vertex_attributes = None, edge_attributes = ('color', 'width'))", "symbol_type": "function"}], "to_linear": [{"docstring": "Make a new instance of sequence as linear.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 199, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "to_linear", "signature": "(self)", "symbol_type": "function"}], "to_networkx": [{"docstring": "Convert a Tree object to a networkx graph.\n\nThe result is useful for graph-oriented analysis, and also interactive\nplotting with pylab, matplotlib or pygraphviz, though the resulting diagram\nis usually not ideal for displaying a phylogeny.\n\nRequires NetworkX version 0.99 or later.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_utils.py", "line_number": 19, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._utils", "name": "to_networkx", "signature": "(tree)", "symbol_type": "function"}], "to_newick": [{"docstring": "Convert phylogenetic tree to Newick format string.\n\nArgs:\n    tree: Bio.Phylo tree object\n    \nReturns:\n    Newick format string representation", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/phylogeny.py", "line_number": 52, "module": "src.metainformant.dna.phylogeny", "name": "to_newick", "signature": "(tree) -> str", "symbol_type": "function"}], "to_phylogeny": [{"docstring": "Create a new phylogeny containing just this clade.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 432, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "to_phylogeny", "signature": "(self, **kwargs)", "symbol_type": "function"}], "to_phyloxml_container": [{"docstring": "Create a new Phyloxml object containing just this phylogeny.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 243, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "to_phyloxml_container", "signature": "(self, **kwargs)", "symbol_type": "function"}], "to_rgb": [{"docstring": "Return a tuple of RGB values (0 to 255) representing this color.\n\nExamples\n--------\n>>> bc = BranchColor(255, 165, 0)\n>>> bc.to_rgb()\n(255, 165, 0)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 1209, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "to_rgb", "signature": "(self)", "symbol_type": "function"}], "to_seqfeature": [{"docstring": "Create a SeqFeature from the ProteinDomain Object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 1035, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "to_seqfeature", "signature": "(self)", "symbol_type": "function"}], "to_seqrecord": [{"docstring": "Create a SeqRecord object from this Sequence instance.\n\nThe seqrecord.annotations dictionary is packed like so::\n\n    { # Sequence attributes with no SeqRecord equivalent:\n      'id_ref': self.id_ref,\n      'id_source': self.id_source,\n      'location': self.location,\n      'uri': { 'value': self.uri.value,\n                      'desc': self.uri.desc,\n                      'type': self.uri.type },\n      # Sequence.annotations attribute (list of Annotations)\n      'annotations': [{'ref': ann.ref,\n                       'source': ann.source,\n                       'evidence': ann.evidence,\n                       'type': ann.type,\n                       'confidence': [ann.confidence.value,\n                                      ann.confidence.type],\n                       'properties': [{'value': prop.value,\n                                        'ref': prop.ref,\n                                        'applies_to': prop.applies_to,\n                                        'datatype': prop.datatype,\n                                        'unit': prop.unit,\n                                        'id_ref': prop.id_ref}\n                                       for prop in ann.properties],\n                      } for ann in self.annotations],\n    }", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 1190, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "to_seqrecord", "signature": "(self)", "symbol_type": "function"}], "to_str": [{"docstring": "Returns the string representation of the model", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 481, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "to_str", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Returns the string representation of the model", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 540, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "to_str", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Returns the string representation of the model", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 696, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "to_str", "signature": "(self)", "symbol_type": "function"}], "to_string": [{"docstring": "Return a formatted string with information about the set.\n\nArguments:\n - verbose: Boolean indicating whether a short (default) or\n   complete account of the set is required", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_FeatureSet.py", "line_number": 177, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._FeatureSet", "name": "to_string", "signature": "(self, verbose = 0)", "symbol_type": "function"}, {"docstring": "Return a formatted string with information about the set.\n\nArguments:\n    - verbose - Flag indicating whether a short or complete account\n      of the set is required", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_GraphSet.py", "line_number": 141, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._GraphSet", "name": "to_string", "signature": "(self, verbose = 0)", "symbol_type": "function"}, {"docstring": "Return a formatted string with information about the track.\n\nArguments:\n - verbose - Boolean indicating whether a short or complete\n   account of the track is required", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Track.py", "line_number": 259, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Track", "name": "to_string", "signature": "(self, verbose = 0)", "symbol_type": "function"}, {"docstring": "Return a paup compatible tree line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 655, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "to_string", "signature": "(self, support_as_branchlengths = False, branchlengths_only = False, plain = True, plain_newick = False, ladderize = None, ignore_comments = True)", "symbol_type": "function"}, {"docstring": "Turn a SeqRecord into a FASTA formatted string, and return it.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/FastaIO.py", "line_number": 539, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.FastaIO", "name": "to_string", "signature": "(cls, record)", "symbol_type": "function"}, {"docstring": "Return a string in FASTA format with the sequence as one line.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/FastaIO.py", "line_number": 633, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.FastaIO", "name": "to_string", "signature": "(cls, record)", "symbol_type": "function"}, {"docstring": "Format the record and return the string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/Interfaces.py", "line_number": 212, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.Interfaces", "name": "to_string", "signature": "(cls, record)", "symbol_type": "function"}, {"docstring": "Turn a SeqRecord into a Sanger FASTQ formatted string, and return it.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1627, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "to_string", "signature": "(cls, record)", "symbol_type": "function"}, {"docstring": "Turn a SeqRecord into a QUAL formatted string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1731, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "to_string", "signature": "(cls, record: SeqRecord) -> str", "symbol_type": "function"}, {"docstring": "Turn a SeqRecord into a Solexa FASTQ formatted string.\n\nThis is used internally by the SeqRecord's .format(\"fastq-solexa\")\nmethod and by the SeqIO.write(..., ..., \"fastq-solexa\") function.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1890, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "to_string", "signature": "(cls, record: SeqRecord) -> str", "symbol_type": "function"}, {"docstring": "Turn a SeqRecord into an Illumina FASTQ formatted string.\n\nThis is used internally by the SeqRecord's .format(\"fastq-illumina\")\nmethod and by the SeqIO.write(..., ..., \"fastq-illumina\") function.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1969, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "to_string", "signature": "(cls, record: SeqRecord) -> str", "symbol_type": "function"}, {"docstring": "Return record as tab separated (id(tab)seq) string.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/TabIO.py", "line_number": 118, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.TabIO", "name": "to_string", "signature": "(cls, record)", "symbol_type": "function"}], "to_strings": [{"docstring": "Return an iterable of PAUP-compatible tree lines.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NewickIO.py", "line_number": 272, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NewickIO", "name": "to_strings", "signature": "(self, confidence_as_branch_length = False, branch_length_only = False, plain = False, plain_newick = True, ladderize = None, max_confidence = 1.0, format_confidence = '%1.2f', format_branch_length = '%1.5f')", "symbol_type": "function"}], "to_yaml": [{"docstring": "Convert a Python object to a representation node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 384, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "to_yaml", "signature": "(cls, dumper, data)", "symbol_type": "function"}, {"docstring": "Convert a Python object to a representation node.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 384, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "to_yaml", "signature": "(cls, dumper, data)", "symbol_type": "function"}], "tofile": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1287, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "tofile", "signature": "(self, stream)", "symbol_type": "function"}], "topology": [{"docstring": "Validate and record sequence topology.\n\nThe topology argument should be \"linear\" or \"circular\" (string).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 341, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "topology", "signature": "(self, topology)", "symbol_type": "function"}, {"docstring": "Validate and record sequence topology.\n\nThe topology argument should be \"linear\" or \"circular\" (string).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 956, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "topology", "signature": "(self, topology)", "symbol_type": "function"}], "total_branch_length": [{"docstring": "Calculate expected total branch length of coalescent tree.\n\nReturns:\n    Expected total branch length in generations", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 805, "module": "src.metainformant.math.coalescent", "name": "total_branch_length", "signature": "(self) -> float", "symbol_type": "function"}, {"docstring": "Calculate the sum of all the branch lengths in this tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 574, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "total_branch_length", "signature": "(self)", "symbol_type": "function"}], "total_correlation": [{"docstring": "Calculate total correlation (multivariate mutual information).\n\nMeasures the total amount of dependence among multiple variables.\nAlso known as multi-information.\n\nArgs:\n    variables: List of sequences, each representing a variable\n    base: Logarithm base\n    \nReturns:\n    Total correlation. For n variables: TC = \u03a3 H(X_i) - H(X_1, ..., X_n)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 382, "module": "src.metainformant.information.syntactic", "name": "total_correlation", "signature": "(variables: list[Sequence[Any]], base: float = 2.0) -> float", "symbol_type": "function"}], "trace": [{"docstring": "Return a list of all node_ids between two nodes (excluding start, including end).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 114, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "trace", "signature": "(self, start, finish)", "symbol_type": "function"}, {"docstring": "List of all clade object between two targets in this tree.\n\nExcluding ``start``, including ``finish``.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 414, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "trace", "signature": "(self, start, finish)", "symbol_type": "function"}], "track_time": [{"docstring": "Track execution time for a test.", "file_path": "/media/q/ext6/github/MetaInformAnt/tests/conftest.py", "line_number": 296, "module": "tests.conftest", "name": "track_time", "signature": "(self, test_name: str, duration: float)", "symbol_type": "function"}], "train_ensemble_classifier": [{"docstring": "Train ensemble of classifiers.\n\nArgs:\n    X: Training feature matrix\n    y: Training labels\n    algorithms: List of algorithms to include in ensemble\n    random_state: Random seed\n\nReturns:\n    Dictionary of algorithm_name -> fitted_classifier", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/classification.py", "line_number": 384, "module": "src.metainformant.ml.classification", "name": "train_ensemble_classifier", "signature": "(X: np.ndarray, y: np.ndarray, algorithms: List[str] = None, random_state: Optional[int] = None) -> Dict[str, BiologicalClassifier]", "symbol_type": "function"}], "train_ensemble_regressor": [{"docstring": "Train ensemble of regressors.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/regression.py", "line_number": 107, "module": "src.metainformant.ml.regression", "name": "train_ensemble_regressor", "signature": "(X: np.ndarray, y: np.ndarray, algorithms: List[str] = None, random_state: Optional[int] = None) -> Dict[str, BiologicalRegressor]", "symbol_type": "function"}], "train_test_split": [{"docstring": "Split data into training and testing sets.\n\nArgs:\n    X: Feature matrix\n    y: Target vector\n    test_size: Fraction of data for testing\n    random_state: Random seed\n    stratify: Whether to stratify split by target\n\nReturns:\n    Tuple of (X_train, X_test, y_train, y_test)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ml/validation.py", "line_number": 11, "module": "src.metainformant.ml.validation", "name": "train_test_split", "signature": "(X: np.ndarray, y: np.ndarray, test_size: float = 0.2, random_state: Optional[int] = None, stratify: bool = False) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]", "symbol_type": "function"}], "trajectory_analysis": [{"docstring": "Analyze trajectory structure and branching.\n\nArgs:\n    data: SingleCellData with pseudotime\n    groupby: Column for trajectory groups (optional)\n    n_branches: Number of expected branches\n    method: Method for trajectory analysis ('mst', 'clustering')\n\nReturns:\n    Dictionary with trajectory analysis results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/trajectory.py", "line_number": 174, "module": "src.metainformant.singlecell.trajectory", "name": "trajectory_analysis", "signature": "(data: SingleCellData, groupby: Optional[str] = None, n_branches: int = 2, method: str = 'mst') -> Dict[str, Any]", "symbol_type": "function"}], "transcribe": [{"docstring": "Transcribe a DNA sequence into RNA.\n\nFollowing the usual convention, the sequence is interpreted as the\ncoding strand of the DNA double helix, not the template strand. This\nmeans we can get the RNA sequence just by switching T to U.\n\nIf given a string, returns a new string object.\n\nGiven a Seq or MutableSeq, returns a new Seq object.\n\ne.g.\n\n>>> transcribe(\"ACTGN\")\n'ACUGN'", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2692, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "transcribe", "signature": "(dna)", "symbol_type": "function"}, {"docstring": "Transcribe a DNA sequence into RNA and return the RNA sequence as a new Seq object.\n\nFollowing the usual convention, the sequence is interpreted as the\ncoding strand of the DNA double helix, not the template strand. This\nmeans we can get the RNA sequence just by switching T to U.\n\n>>> from Bio.Seq import Seq\n>>> coding_dna = Seq(\"ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG\")\n>>> coding_dna\nSeq('ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG')\n>>> coding_dna.transcribe()\nSeq('AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG')\n\nThe sequence is modified in-place and returned if inplace is True:\n\n>>> sequence = MutableSeq(\"ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG\")\n>>> sequence\nMutableSeq('ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG')\n>>> sequence.transcribe()\nMutableSeq('AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG')\n>>> sequence\nMutableSeq('ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG')\n\n>>> sequence.transcribe(inplace=True)\nMutableSeq('AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG')\n>>> sequence\nMutableSeq('AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if\n``transcribe`` is called on a ``Seq`` object with ``inplace=True``.\n\nTrying to transcribe an RNA sequence has no effect.\nIf you have a nucleotide sequence which might be DNA or RNA\n(or even a mixture), calling the transcribe method will ensure\nany T becomes U.\n\nTrying to transcribe a protein sequence will replace any\nT for Threonine with U for Selenocysteine, which has no\nbiologically plausible rational.\n\n>>> from Bio.Seq import Seq\n>>> my_protein = Seq(\"MAIVMGRT\")\n>>> my_protein.transcribe()\nSeq('MAIVMGRU')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1814, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "transcribe", "signature": "(self, inplace = False)", "symbol_type": "function"}], "transcribe_dna_to_rna": [{"docstring": "Transcribe DNA to RNA (T->U). Preserves case; non-ATGC characters pass through.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/transcription.py", "line_number": 30, "module": "src.metainformant.dna.transcription", "name": "transcribe_dna_to_rna", "signature": "(seq: str) -> str", "symbol_type": "function"}], "transfer_entropy": [{"docstring": "Calculate transfer entropy T(Y -> X).\n\nMeasures the information transferred from Y to X, accounting for\nX's own past. T(Y -> X) = H(X_t | X_{t-1}) - H(X_t | X_{t-1}, Y_{t-1})\n\nArgs:\n    x: Time series X\n    y: Time series Y (must have same length as x)\n    lag: Time lag for past values\n    base: Logarithm base\n    \nReturns:\n    Transfer entropy in bits\n    \nExamples:\n    >>> x = [0, 1, 0, 1, 0, 1]\n    >>> y = [0, 0, 1, 1, 0, 0]  # Y doesn't predict X\n    >>> te = transfer_entropy(x, y, lag=1)\n    >>> te < 0.5  # Should be low\n    True\n    \nReferences:\n    Schreiber, T. (2000). Measuring information transfer.\n    Physical Review Letters, 85(2), 461.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 433, "module": "src.metainformant.information.syntactic", "name": "transfer_entropy", "signature": "(x: Sequence[Any], y: Sequence[Any], lag: int = 1, base: float = 2.0) -> float", "symbol_type": "function"}], "transform": [{"docstring": "Apply rotation and translation to the atomic coordinates.\n\n:param rot: A right multiplying rotation matrix\n:type rot: 3x3 NumPy array\n\n:param tran: the translation vector\n:type tran: size 3 NumPy array\n\nExamples\n--------\nThis is an incomplete but illustrative example::\n\n    from numpy import pi, array\n    from Bio.PDB.vectors import Vector, rotmat\n    rotation = rotmat(pi, Vector(1, 0, 0))\n    translation = array((0, 0, 1), 'f')\n    atom.transform(rotation, translation)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 458, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "transform", "signature": "(self, rot: np.ndarray, tran: np.ndarray)", "symbol_type": "function"}, {"docstring": "Apply rotation and translation to all children.\n\nSee the documentation of Atom.transform for details.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Atom.py", "line_number": 596, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Atom", "name": "transform", "signature": "(self, rot: np.ndarray, tran: np.ndarray)", "symbol_type": "function"}, {"docstring": "Apply rotation and translation to the atomic coordinates.\n\n:param rot: A right multiplying rotation matrix\n:type rot: 3x3 NumPy array\n\n:param tran: the translation vector\n:type tran: size 3 NumPy array\n\nExamples\n--------\nThis is an incomplete but illustrative example::\n\n    from numpy import pi, array\n    from Bio.PDB.vectors import Vector, rotmat\n    rotation = rotmat(pi, Vector(1, 0, 0))\n    translation = array((0, 0, 1), 'f')\n    entity.transform(rotation, translation)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Entity.py", "line_number": 329, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Entity", "name": "transform", "signature": "(self, rot, tran)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 496, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "transform", "signature": "(assembly: dict) -> tuple[str, str]", "symbol_type": "function"}], "transformation": [{"docstring": "Calculate the transformation matrix.\n\nNormalizes the columns of the matrix of associations.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 210, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "transformation", "signature": "(self)", "symbol_type": "function"}], "transition_transversion_plot": [{"docstring": "Transition/transversion ratio plot.\n\nTs/Tv ratio is a quality metric for variant calling.\nExpected: ~2.0-2.1 for whole genome, higher for exomes.\n\nArgs:\n    results: Association results or path with REF/ALT alleles\n    output_path: Output path\n    title: Plot title\n\nReturns:\n    Plot metadata with Ts/Tv ratio", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_variants.py", "line_number": 386, "module": "src.metainformant.gwas.visualization_variants", "name": "transition_transversion_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "translate": [{"docstring": "Translate a nucleotide sequence into amino acids.\n\nIf given a string, returns a new string object. Given a Seq or\nMutableSeq, returns a Seq object.\n\nArguments:\n - table - Which codon table to use?  This can be either a name\n   (string), an NCBI identifier (integer), or a CodonTable object\n   (useful for non-standard genetic codes).  Defaults to the \"Standard\"\n   table.\n - stop_symbol - Single character string, what to use for any\n   terminators, defaults to the asterisk, \"*\".\n - to_stop - Boolean, defaults to False meaning do a full\n   translation continuing on past any stop codons\n   (translated as the specified stop_symbol).  If\n   True, translation is terminated at the first in\n   frame stop codon (and the stop_symbol is not\n   appended to the returned protein sequence).\n - cds - Boolean, indicates this is a complete CDS.  If True, this\n   checks the sequence starts with a valid alternative start\n   codon (which will be translated as methionine, M), that the\n   sequence length is a multiple of three, and that there is a\n   single in frame stop codon at the end (this will be excluded\n   from the protein sequence, regardless of the to_stop option).\n   If these tests fail, an exception is raised.\n - gap - Single character string to denote symbol used for gaps.\n   Defaults to None.\n\nA simple string example using the default (standard) genetic code:\n\n>>> coding_dna = \"GTGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG\"\n>>> translate(coding_dna)\n'VAIVMGR*KGAR*'\n>>> translate(coding_dna, stop_symbol=\"@\")\n'VAIVMGR@KGAR@'\n>>> translate(coding_dna, to_stop=True)\n'VAIVMGR'\n\nNow using NCBI table 2, where TGA is not a stop codon:\n\n>>> translate(coding_dna, table=2)\n'VAIVMGRWKGAR*'\n>>> translate(coding_dna, table=2, to_stop=True)\n'VAIVMGRWKGAR'\n\nIn fact this example uses an alternative start codon valid under NCBI\ntable 2, GTG, which means this example is a complete valid CDS which\nwhen translated should really start with methionine (not valine):\n\n>>> translate(coding_dna, table=2, cds=True)\n'MAIVMGRWKGAR'\n\nNote that if the sequence has no in-frame stop codon, then the to_stop\nargument has no effect:\n\n>>> coding_dna2 = \"GTGGCCATTGTAATGGGCCGC\"\n>>> translate(coding_dna2)\n'VAIVMGR'\n>>> translate(coding_dna2, to_stop=True)\n'VAIVMGR'\n\nNOTE - Ambiguous codons like \"TAN\" or \"NNN\" could be an amino acid\nor a stop codon.  These are translated as \"X\".  Any invalid codon\n(e.g. \"TA?\" or \"T-A\") will throw a TranslationError.\n\nIt will however translate either DNA or RNA.\n\nNOTE - Since version 1.71 Biopython contains codon tables with 'ambiguous\nstop codons'. These are stop codons with unambiguous sequence but which\nhave a context dependent coding as STOP or as amino acid. With these tables\n'to_stop' must be False (otherwise a ValueError is raised). The dual\ncoding codons will always be translated as amino acid, except for\n'cds=True', where the last codon will be translated as STOP.\n\n>>> coding_dna3 = \"ATGGCACGGAAGTGA\"\n>>> translate(coding_dna3)\n'MARK*'\n\n>>> translate(coding_dna3, table=27)  # Table 27: TGA -> STOP or W\n'MARKW'\n\nIt will however raise a BiopythonWarning (not shown).\n\n>>> translate(coding_dna3, table=27, cds=True)\n'MARK'\n\n>>> translate(coding_dna3, table=27, to_stop=True)\nTraceback (most recent call last):\n   ...\nValueError: You cannot use 'to_stop=True' with this table ...", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2915, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "translate", "signature": "(sequence, table = 'Standard', stop_symbol = '*', to_stop = False, cds = False, gap = None)", "symbol_type": "function"}, {"docstring": "Return a copy with each character mapped by the given translation table.\n\n  table\n    Translation table, which must be a bytes object of length 256.\n\nAll characters occurring in the optional argument delete are removed.\nThe remaining characters are mapped through the given translation table.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 331, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "translate", "signature": "(self, table, delete = b'')", "symbol_type": "function"}, {"docstring": "Turn a nucleotide sequence into a protein sequence by creating a new sequence object.\n\nThis method will translate DNA or RNA sequences. It should not\nbe used on protein sequences as any result will be biologically\nmeaningless.\n\nArguments:\n - table - Which codon table to use?  This can be either a name\n   (string), an NCBI identifier (integer), or a CodonTable\n   object (useful for non-standard genetic codes).  This\n   defaults to the \"Standard\" table.\n - stop_symbol - Single character string, what to use for\n   terminators.  This defaults to the asterisk, \"*\".\n - to_stop - Boolean, defaults to False meaning do a full\n   translation continuing on past any stop codons (translated as the\n   specified stop_symbol).  If True, translation is terminated at\n   the first in frame stop codon (and the stop_symbol is not\n   appended to the returned protein sequence).\n - cds - Boolean, indicates this is a complete CDS.  If True,\n   this checks the sequence starts with a valid alternative start\n   codon (which will be translated as methionine, M), that the\n   sequence length is a multiple of three, and that there is a\n   single in frame stop codon at the end (this will be excluded\n   from the protein sequence, regardless of the to_stop option).\n   If these tests fail, an exception is raised.\n - gap - Single character string to denote symbol used for gaps.\n   Defaults to the minus sign.\n\nA ``Seq`` object is returned if ``translate`` is called on a ``Seq``\nobject; a ``MutableSeq`` object is returned if ``translate`` is called\npn a ``MutableSeq`` object.\n\ne.g. Using the standard table:\n\n>>> coding_dna = Seq(\"GTGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG\")\n>>> coding_dna.translate()\nSeq('VAIVMGR*KGAR*')\n>>> coding_dna.translate(stop_symbol=\"@\")\nSeq('VAIVMGR@KGAR@')\n>>> coding_dna.translate(to_stop=True)\nSeq('VAIVMGR')\n\nNow using NCBI table 2, where TGA is not a stop codon:\n\n>>> coding_dna.translate(table=2)\nSeq('VAIVMGRWKGAR*')\n>>> coding_dna.translate(table=2, to_stop=True)\nSeq('VAIVMGRWKGAR')\n\nIn fact, GTG is an alternative start codon under NCBI table 2, meaning\nthis sequence could be a complete CDS:\n\n>>> coding_dna.translate(table=2, cds=True)\nSeq('MAIVMGRWKGAR')\n\nIt isn't a valid CDS under NCBI table 1, due to both the start codon\nand also the in frame stop codons:\n\n>>> coding_dna.translate(table=1, cds=True)\nTraceback (most recent call last):\n    ...\nBio.Data.CodonTable.TranslationError: First codon 'GTG' is not a start codon\n\nIf the sequence has no in-frame stop codon, then the to_stop argument\nhas no effect:\n\n>>> coding_dna2 = Seq(\"TTGGCCATTGTAATGGGCCGC\")\n>>> coding_dna2.translate()\nSeq('LAIVMGR')\n>>> coding_dna2.translate(to_stop=True)\nSeq('LAIVMGR')\n\nNOTE - Ambiguous codons like \"TAN\" or \"NNN\" could be an amino acid\nor a stop codon.  These are translated as \"X\".  Any invalid codon\n(e.g. \"TA?\" or \"T-A\") will throw a TranslationError.\n\nNOTE - This does NOT behave like the python string's translate\nmethod.  For that use str(my_seq).translate(...) instead", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1523, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "translate", "signature": "(self, table = 'Standard', stop_symbol = '*', to_stop = False, cds = False, gap = '-')", "symbol_type": "function"}, {"docstring": "Return a copy with each character mapped by the given translation table.\n\n  table\n    Translation table, which must be a bytes object of length 256.\n\nAll characters occurring in the optional argument delete are removed.\nThe remaining characters are mapped through the given translation table.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2645, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "translate", "signature": "(self, table, delete = b'')", "symbol_type": "function"}, {"docstring": "Get a translation of the feature's sequence.\n\nThis method is intended for CDS or other features that code proteins\nand is a shortcut that will both extract the feature and\ntranslate it, taking into account the codon_start and transl_table\nqualifiers, if they are present. If they are not present the\nvalue of the arguments \"table\" and \"start_offset\" are used.\n\nThe \"cds\" parameter is set to \"True\" if the feature is of type\n\"CDS\" but can be overridden by giving an explicit argument.\n\nThe arguments stop_symbol, to_stop and gap have the same meaning\nas Seq.translate, refer to that documentation for further information.\n\nArguments:\n - parent_sequence - A DNA or RNA sequence.\n - table - Which codon table to use if there is no transl_table\n   qualifier for this feature. This can be either a name\n   (string), an NCBI identifier (integer), or a CodonTable\n   object (useful for non-standard genetic codes).  This\n   defaults to the \"Standard\" table.\n - start_offset - offset at which the first complete codon of a\n   coding feature can be found, relative to the first base of\n   that feature. Has a valid value of 0, 1 or 2. NOTE: this\n   uses python's 0-based numbering whereas the codon_start\n   qualifier in files from NCBI use 1-based numbering.\n   Will override a codon_start qualifier\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqFeature import SeqFeature, SimpleLocation\n>>> seq = Seq(\"GGTTACACTTACCGATAATGTCTCTGATGA\")\n>>> f = SeqFeature(SimpleLocation(0, 30), type=\"CDS\")\n>>> f.qualifiers['transl_table'] = [11]\n\nNote that features of type CDS are subject to the usual\nchecks at translation. But you can override this behavior\nby giving explicit arguments:\n\n>>> f.translate(seq, cds=False)\nSeq('GYTYR*CL**')\n\nNow use the start_offset argument to change the frame. Note\nthis uses python 0-based numbering.\n\n>>> f.translate(seq, start_offset=1, cds=False)\nSeq('VTLTDNVSD')\n\nAlternatively use the codon_start qualifier to do the same\nthing. Note: this uses 1-based numbering, which is found\nin files from NCBI.\n\n>>> f.qualifiers['codon_start'] = [2]\n>>> f.translate(seq, cds=False)\nSeq('VTLTDNVSD')", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqFeature.py", "line_number": 331, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqFeature", "name": "translate", "signature": "(self, parent_sequence, table = 'Standard', start_offset = None, stop_symbol = '*', to_stop = False, cds = None, gap = None)", "symbol_type": "function"}, {"docstring": "Return new SeqRecord with translated sequence.\n\nThis calls the record's .seq.translate() method (which describes\nthe translation related arguments, like table for the genetic code),\n\nBy default the new record does NOT preserve the sequence identifier,\nname, description, general annotation or database cross-references -\nthese are unlikely to apply to the translated sequence.\n\nYou can specify the returned record's id, name and description as\nstrings, or True to keep that of the parent, or False for a default.\n\nYou can specify the returned record's features with a list of\nSeqFeature objects, or False (default) to omit them.\n\nYou can also specify both the returned record's annotations and\nletter_annotations as dictionaries, True to keep that of the parent\n(annotations only), or False (default) to omit them.\n\ne.g. Loading a FASTA gene and translating it,\n\n>>> from Bio import SeqIO\n>>> gene_record = SeqIO.read(\"Fasta/sweetpea.nu\", \"fasta\")\n>>> print(gene_record.format(\"fasta\"))\n>gi|3176602|gb|U78617.1|LOU78617 Lathyrus odoratus phytochrome A (PHYA) gene, partial cds\nCAGGCTGCGCGGTTTCTATTTATGAAGAACAAGGTCCGTATGATAGTTGATTGTCATGCA\nAAACATGTGAAGGTTCTTCAAGACGAAAAACTCCCATTTGATTTGACTCTGTGCGGTTCG\nACCTTAAGAGCTCCACATAGTTGCCATTTGCAGTACATGGCTAACATGGATTCAATTGCT\nTCATTGGTTATGGCAGTGGTCGTCAATGACAGCGATGAAGATGGAGATAGCCGTGACGCA\nGTTCTACCACAAAAGAAAAAGAGACTTTGGGGTTTGGTAGTTTGTCATAACACTACTCCG\nAGGTTTGTT\n<BLANKLINE>\n\nAnd now translating the record, specifying the new ID and description:\n\n>>> protein_record = gene_record.translate(table=11,\n...                                        id=\"phya\",\n...                                        description=\"translation\")\n>>> print(protein_record.format(\"fasta\"))\n>phya translation\nQAARFLFMKNKVRMIVDCHAKHVKVLQDEKLPFDLTLCGSTLRAPHSCHLQYMANMDSIA\nSLVMAVVVNDSDEDGDSRDAVLPQKKKRLWGLVVCHNTTPRFV\n<BLANKLINE>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 1421, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "translate", "signature": "(self, table: str = 'Standard', stop_symbol: str = '*', to_stop: bool = False, cds: bool = False, gap: str | None = None, id: bool = False, name: bool = False, description: bool = False, features: bool = False, annotations: bool = False, letter_annotations: bool = False, dbxrefs: bool = False) -> 'SeqRecord'", "symbol_type": "function"}, {"docstring": "Translate a color into a ReportLab Color object.\n\nArguments:\n - color - Color defined as an int, a tuple of three ints 0->255\n   or a tuple of three floats 0 -> 1, or a string giving\n   one of the named colors defined by ReportLab, or a\n   ReportLab color object (returned as is).\n - colour - Backwards compatible alias using UK spelling (which\n   will over-ride any color argument).\n\nReturns a colors.Color object, determined semi-intelligently\ndepending on the input values", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Colors.py", "line_number": 89, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Colors", "name": "translate", "signature": "(self, color = None, colour = None)", "symbol_type": "function"}, {"docstring": "Translate the CodonSeq based on the reading frame in rf_table.\n\nIt is possible for the user to specify\na rf_table at this point. If you want to include\ngaps in the translated sequence, this is the only\nway. ungap_seq should be set to true for this\npurpose.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 131, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "translate", "signature": "(self, codon_table = None, stop_symbol = '*', rf_table = None, ungap_seq = True)", "symbol_type": "function"}], "translate_dna": [{"docstring": "Translate DNA sequence to protein sequence.\n\nArgs:\n    seq: DNA sequence string\n    to_stop: Stop translation at first stop codon (default: False)\n    table: Genetic code table number (default: 1, standard)\n    \nReturns:\n    Protein sequence string", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/translation.py", "line_number": 9, "module": "src.metainformant.dna.translation", "name": "translate_dna", "signature": "(seq: str) -> str", "symbol_type": "function"}], "traverse": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1748, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "traverse", "signature": "(self)", "symbol_type": "function"}], "traverse_range": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1755, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "traverse_range", "signature": "(self, start, end)", "symbol_type": "function"}], "tree_annotation_plot": [{"docstring": "Plot a phylogenetic tree with annotations.\n\nArgs:\n    tree: Biopython Phylo tree object\n    annotations: Dictionary mapping node names to annotation text\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import tree_annotation_plot\n    >>> from Bio import Phylo\n    >>> tree = Phylo.read(\"tree.nwk\", \"newick\")\n    >>> annotations = {'leaf1': 'Important', 'leaf2': 'Reference'}\n    >>> ax = tree_annotation_plot(tree, annotations)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/trees.py", "line_number": 172, "module": "src.metainformant.visualization.trees", "name": "tree_annotation_plot", "signature": "(tree: Any, annotations: dict[str, str] | None = None, **kwargs) -> plt.Axes", "symbol_type": "function"}], "tree_comparison_plot": [{"docstring": "Plot multiple trees side by side for comparison.\n\nArgs:\n    trees: List of Biopython Phylo tree objects\n    labels: Optional labels for each tree\n    ncols: Number of columns in subplot grid\n    figsize: Figure size tuple\n\nReturns:\n    Tuple of (figure, axes array)\n\nExample:\n    >>> from metainformant.visualization import tree_comparison_plot\n    >>> from Bio import Phylo\n    >>> tree1 = Phylo.read(\"tree1.nwk\", \"newick\")\n    >>> tree2 = Phylo.read(\"tree2.nwk\", \"newick\")\n    >>> fig, axes = tree_comparison_plot([tree1, tree2], labels=['Tree 1', 'Tree 2'])", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/trees.py", "line_number": 110, "module": "src.metainformant.visualization.trees", "name": "tree_comparison_plot", "signature": "(trees: list[Any], labels: list[str] | None = None) -> tuple[plt.Figure, np.ndarray]", "symbol_type": "function"}], "treecluster": [{"docstring": "Perform hierarchical clustering, and return a Tree object.\n\nThis function implements the pairwise single, complete, centroid, and\naverage linkage hierarchical clustering methods.\n\nKeyword arguments:\n - data: nrows x ncolumns array containing the data values.\n - mask: nrows x ncolumns array of integers, showing which data are\n   missing. If mask[i][j]==0, then data[i][j] is missing.\n - weight: the weights to be used when calculating distances.\n - transpose:\n   - if False, rows are clustered;\n   - if True, columns are clustered.\n - dist: specifies the distance function to be used:\n   - dist == 'e': Euclidean distance\n   - dist == 'b': City Block distance\n   - dist == 'c': Pearson correlation\n   - dist == 'a': absolute value of the correlation\n   - dist == 'u': uncentered correlation\n   - dist == 'x': absolute uncentered correlation\n   - dist == 's': Spearman's rank correlation\n   - dist == 'k': Kendall's tau\n - method: specifies which linkage method is used:\n   - method == 's': Single pairwise linkage\n   - method == 'm': Complete (maximum) pairwise linkage (default)\n   - method == 'c': Centroid linkage\n   - method == 'a': Average pairwise linkage\n - distancematrix:  The distance matrix between the items. There are\n   three ways in which you can pass a distance matrix:\n   1. a 2D NumPy array (in which only the left-lower part of the array\n   will be accessed);\n   2. a 1D NumPy array containing the distances consecutively;\n   3. a list of rows containing the lower-triangular part of\n   the distance matrix.\n\n   Examples are:\n\n       >>> from numpy import array\n       >>> # option 1:\n       >>> distance = array([[0.0, 1.1, 2.3],\n       ...                   [1.1, 0.0, 4.5],\n       ...                   [2.3, 4.5, 0.0]])\n       >>> # option 2:\n       >>> distance = array([1.1, 2.3, 4.5])\n       >>> # option 3:\n       >>> distance = [array([]),\n       ...             array([1.1]),\n       ...             array([2.3, 4.5])]\n\n   These three correspond to the same distance matrix.\n\n   PLEASE NOTE:\n   As the treecluster routine may shuffle the values in the\n   distance matrix as part of the clustering algorithm, be sure\n   to save this array in a different variable before calling\n   treecluster if you need it later.\n\nEither data or distancematrix should be None. If distancematrix is None,\nthe hierarchical clustering solution is calculated from the values stored\nin the argument data. If data is None, the hierarchical clustering solution\nis instead calculated from the distance matrix. Pairwise centroid-linkage\nclustering can be performed only from the data values and not from the\ndistance matrix. Pairwise single-, maximum-, and average-linkage clustering\ncan be calculated from the data values or from the distance matrix.\n\nReturn value:\ntreecluster returns a Tree object describing the hierarchical clustering\nresult. See the description of the Tree class for more information.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 243, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "treecluster", "signature": "(data, mask = None, weight = None, transpose = False, method = 'm', dist = 'e', distancematrix = None)", "symbol_type": "function"}, {"docstring": "Apply hierarchical clustering and return a Tree object.\n\nThe pairwise single, complete, centroid, and average linkage\nhierarchical clustering methods are available.\n\nKeyword arguments:\n - transpose: if False: rows are clustered;\n              if True: columns are clustered.\n - dist: specifies the distance function to be used:\n   - dist == 'e': Euclidean distance\n   - dist == 'b': City Block distance\n   - dist == 'c': Pearson correlation\n   - dist == 'a': absolute value of the correlation\n   - dist == 'u': uncentered correlation\n   - dist == 'x': absolute uncentered correlation\n   - dist == 's': Spearman's rank correlation\n   - dist == 'k': Kendall's tau\n - method: specifies which linkage method is used:\n   - method == 's': Single pairwise linkage\n   - method == 'm': Complete (maximum) pairwise linkage (default)\n   - method == 'c': Centroid linkage\n   - method == 'a': Average pairwise linkage\n\nSee the description of the Tree class for more information about\nthe Tree object returned by this method.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Cluster/__init__.py", "line_number": 740, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Cluster.__init__", "name": "treecluster", "signature": "(self, transpose = False, method = 'm', dist = 'e')", "symbol_type": "function"}], "trend_plot": [{"docstring": "Create a trend plot with trend line.\n\nArgs:\n    time_points: Time points\n    values: Values at each time point\n    trend_type: Type of trend ('linear', 'polynomial')\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import trend_plot\n    >>> import numpy as np\n    >>> time = np.arange(0, 10)\n    >>> values = 0.5 * time + np.random.normal(0, 0.1, 10)\n    >>> ax = trend_plot(time, values, trend_type='linear')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/timeseries.py", "line_number": 276, "module": "src.metainformant.visualization.timeseries", "name": "trend_plot", "signature": "(time_points: Sequence[float], values: Sequence[float], **kwargs) -> plt.Axes", "symbol_type": "function"}], "truncate_text": [{"docstring": "Truncate text to maximum length with optional suffix.\n\nArgs:\n    text: Text to truncate\n    max_length: Maximum length including suffix\n    suffix: Suffix to add when truncating\n\nReturns:\n    Truncated text", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/text.py", "line_number": 131, "module": "src.metainformant.core.text", "name": "truncate_text", "signature": "(text: str, max_length: int, suffix: str = '...') -> str", "symbol_type": "function"}], "tsa": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 417, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "tsa", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 897, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "tsa", "signature": "(self, content)", "symbol_type": "function"}], "tsallis_entropy": [{"docstring": "Calculate Tsallis entropy (non-extensive entropy).\n\nTsallis entropy is a generalization of Shannon entropy used in\nnon-extensive statistical mechanics. When q=1, it equals Shannon entropy.\n\nArgs:\n    probs: Probability distribution\n    q: Entropic index (q > 0, q \u2260 1). q=1 uses Shannon entropy.\n    base: Logarithm base (for normalization)\n    \nReturns:\n    Tsallis entropy. Formula: S_q = (1/(q-1)) \u00d7 (1 - \u03a3 p_i^q)\n    \nExamples:\n    >>> probs = [0.5, 0.5]\n    >>> tsallis_entropy(probs, q=2.0)\n    0.5  # For q=2, S_2 = 1 - \u03a3 p_i^2\n    >>> abs(tsallis_entropy(probs, q=1.0) - shannon_entropy(probs)) < 1e-10\n    True  # q=1 equals Shannon entropy\n    \nReferences:\n    Tsallis, C. (1988). Possible generalization of Boltzmann-Gibbs statistics.\n    Journal of Statistical Physics, 52(1-2), 479-487.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/information/syntactic.py", "line_number": 608, "module": "src.metainformant.information.syntactic", "name": "tsallis_entropy", "signature": "(probs: Sequence[float], q: float = 2.0, base: float = 2.0) -> float", "symbol_type": "function"}], "tsne_plot": [{"docstring": "Create a t-SNE visualization plot.\n\nArgs:\n    data: DataFrame or array with t-SNE coordinates\n    x_col: Column name or index for x-axis\n    y_col: Column name or index for y-axis\n    hue: Column name or array to color points by\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments for scatter\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import tsne_plot\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> data = pd.DataFrame({\n    ...     'tSNE1': np.random.normal(0, 1, 100),\n    ...     'tSNE2': np.random.normal(0, 1, 100),\n    ...     'group': ['A'] * 50 + ['B'] * 50\n    ... })\n    >>> ax = tsne_plot(data, x_col='tSNE1', y_col='tSNE2', hue='group')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/dimred.py", "line_number": 168, "module": "src.metainformant.visualization.dimred", "name": "tsne_plot", "signature": "(data: pd.DataFrame | np.ndarray, **kwargs) -> plt.Axes", "symbol_type": "function"}], "two_epoch_effective_size": [{"docstring": "Calculate effective population size for two-epoch model.\n\nModels a population that changed size at some point in the past.\nThe effective size is the harmonic mean of the two sizes, weighted\nby the time spent at each size.\n\nArgs:\n    ancient_size: Population size before change (N_ancient)\n    current_size: Population size after change (N_current)\n    time_since_change: Number of generations since size change\n\nReturns:\n    Effective population size (harmonic mean)\n    \nExamples:\n    >>> # Population expansion: 1000 \u2192 10000, 50 generations ago\n    >>> two_epoch_effective_size(1000, 10000, 50)\n    1960...\n    \n    >>> # Population contraction: 10000 \u2192 1000, 50 generations ago\n    >>> two_epoch_effective_size(10000, 1000, 50)\n    1960...  # Same harmonic mean (symmetric)\n    \nReferences:\n    Slatkin, M., & Hudson, R. R. (1991). Pairwise comparisons of\n    mitochondrial DNA sequences in stable and exponentially growing\n    populations. Genetics, 129(2), 555-562.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/demography.py", "line_number": 136, "module": "src.metainformant.math.demography", "name": "two_epoch_effective_size", "signature": "(ancient_size: int, current_size: int, time_since_change: int) -> float", "symbol_type": "function"}], "type_error_message": [{"docstring": "Keyword Args:\n    var_value (any): the variable which has the type_error\n    var_name (str): the name of the variable which has the typ error\n    valid_classes (tuple): the accepted classes for current_item's\n                              value\n    key_type (bool): False if our value is a value in a dict\n                     True if it is a key in a dict\n                     False if our item is an item in a list", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1719, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "type_error_message", "signature": "(var_value = None, var_name = None, valid_classes = None, key_type = None)", "symbol_type": "function"}], "umap_plot": [{"docstring": "Create a UMAP visualization plot.\n\nArgs:\n    data: DataFrame or array with UMAP coordinates\n    x_col: Column name or index for x-axis\n    y_col: Column name or index for y-axis\n    hue: Column name or array to color points by\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments for scatter\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import umap_plot\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> data = pd.DataFrame({\n    ...     'UMAP1': np.random.normal(0, 1, 100),\n    ...     'UMAP2': np.random.normal(0, 1, 100),\n    ...     'group': ['A'] * 50 + ['B'] * 50\n    ... })\n    >>> ax = umap_plot(data, x_col='UMAP1', y_col='UMAP2', hue='group')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/dimred.py", "line_number": 95, "module": "src.metainformant.visualization.dimred", "name": "umap_plot", "signature": "(data: pd.DataFrame | np.ndarray, **kwargs) -> plt.Axes", "symbol_type": "function"}], "unfold_entities": [{"docstring": "Unfold entities list to a child level (e.g. residues in chain).\n\nUnfold a list of entities to a list of entities of another\nlevel.  E.g.:\n\nlist of atoms -> list of residues\nlist of modules -> list of atoms\nlist of residues -> list of chains\n\n- entity_list - list of entities or a single entity\n- target_level - char (A, R, C, M, S)\n\nNote that if entity_list is an empty list, you get an empty list back:\n\n>>> unfold_entities([], \"A\")\n[]", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Selection.py", "line_number": 33, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Selection", "name": "unfold_entities", "signature": "(entity_list, target_level)", "symbol_type": "function"}], "ungap": [{"docstring": "Return a copy of the sequence without the gap character(s).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/codonalign/codonseq.py", "line_number": 238, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.codonalign.codonseq", "name": "ungap", "signature": "(self, gap = '-')", "symbol_type": "function"}], "uniqueify": [{"docstring": "Return a list of the unique items in the given iterable.\n\nOrder is NOT preserved.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/Selection.py", "line_number": 19, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.Selection", "name": "uniqueify", "signature": "(items)", "symbol_type": "function"}], "unlink": [{"docstring": "Disconnect node from his predecessor.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nodes.py", "line_number": 81, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nodes", "name": "unlink", "signature": "(self, id)", "symbol_type": "function"}], "unregister_thread": [{"docstring": "Unregister a download thread (download complete).\n\nArgs:\n    thread_id: Thread identifier to unregister\n    success: Whether download succeeded", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/download_progress.py", "line_number": 288, "module": "src.metainformant.rna.steps.download_progress", "name": "unregister_thread", "signature": "(self, thread_id: int, success: bool = True) -> None", "symbol_type": "function"}], "unroot": [{"docstring": "Define a unrooted Tree structure, using data of a rooted Tree.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Trees.py", "line_number": 759, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Trees", "name": "unroot", "signature": "(self)", "symbol_type": "function"}], "unrooted_tree_plot": [{"docstring": "Plot an unrooted phylogenetic tree.\n\nArgs:\n    tree: Biopython Phylo tree object\n    ax: Matplotlib axes (creates new if None)\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import unrooted_tree_plot\n    >>> from Bio import Phylo\n    >>> tree = Phylo.read(\"tree.nwk\", \"newick\")\n    >>> ax = unrooted_tree_plot(tree)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/trees.py", "line_number": 82, "module": "src.metainformant.visualization.trees", "name": "unrooted_tree_plot", "signature": "(tree: Any) -> plt.Axes", "symbol_type": "function"}], "unsafe_load": [{"docstring": "Parse the first YAML document in a stream\nand produce the corresponding Python object.\n\nResolve all tags, even those known to be\nunsafe on untrusted input.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 137, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "unsafe_load", "signature": "(stream)", "symbol_type": "function"}, {"docstring": "Parse the first YAML document in a stream\nand produce the corresponding Python object.\n\nResolve all tags, even those known to be\nunsafe on untrusted input.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 137, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "unsafe_load", "signature": "(stream)", "symbol_type": "function"}], "unsafe_load_all": [{"docstring": "Parse all YAML documents in a stream\nand produce corresponding Python objects.\n\nResolve all tags, even those known to be\nunsafe on untrusted input.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 147, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "unsafe_load_all", "signature": "(stream)", "symbol_type": "function"}, {"docstring": "Parse all YAML documents in a stream\nand produce corresponding Python objects.\n\nResolve all tags, even those known to be\nunsafe on untrusted input.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 147, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "unsafe_load_all", "signature": "(stream)", "symbol_type": "function"}], "unwind_indent": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/scanner.py", "line_number": 325, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.scanner", "name": "unwind_indent", "signature": "(self, column)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/scanner.py", "line_number": 325, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.scanner", "name": "unwind_indent", "signature": "(self, column)", "symbol_type": "function"}], "update": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/progress.py", "line_number": 98, "module": "src.metainformant.core.progress", "name": "update", "signature": "(self, n: int = 1)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/progress.py", "line_number": 45, "module": "src.metainformant.core.progress", "name": "update", "signature": "(self, n = 1)", "symbol_type": "function"}, {"docstring": "Update size tracking and calculate rate.\n\nReturns:\n    Tuple of (current_size_bytes, size_delta_bytes, rate_mbps)\n    rate_mbps is 0.0 if not enough time has passed or size decreased", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/download_progress.py", "line_number": 67, "module": "src.metainformant.rna.steps.download_progress", "name": "update", "signature": "(self) -> tuple[int, float, float]", "symbol_type": "function"}, {"docstring": "Update progress tracking.\n\nReturns:\n    Dictionary with current progress state:\n    - size_bytes: Current total size in bytes\n    - size_mb: Current total size in MB\n    - rate_mbps: Current download rate in MB/s\n    - elapsed_seconds: Time elapsed since start\n    - is_complete: Whether download is complete", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/download_progress.py", "line_number": 141, "module": "src.metainformant.rna.steps.download_progress", "name": "update", "signature": "(self) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 64, "module": "src.metainformant.visualization.animations", "name": "update", "signature": "(frame_idx: int)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 129, "module": "src.metainformant.visualization.animations", "name": "update", "signature": "(frame_idx: int)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 202, "module": "src.metainformant.visualization.animations", "name": "update", "signature": "(frame_idx: int)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 268, "module": "src.metainformant.visualization.animations", "name": "update", "signature": "(frame_idx: int)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/animations.py", "line_number": 348, "module": "src.metainformant.visualization.animations", "name": "update", "signature": "(frame_idx: int)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/reader.py", "line_number": 146, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.reader", "name": "update", "signature": "(self, length)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/reader.py", "line_number": 146, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.reader", "name": "update", "signature": "(self, length)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 108, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "update", "signature": "(self, new_dict)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1413, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "update", "signature": "(self, size, val)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1467, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "update", "signature": "(self, overlap, val)", "symbol_type": "function"}, {"docstring": "Update the array from dict/iterable E and F.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/substitution_matrices/__init__.py", "line_number": 311, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.substitution_matrices.__init__", "name": "update", "signature": "(self, E = None, **F)", "symbol_type": "function"}], "updateMaxFieldSize": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1244, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "updateMaxFieldSize", "signature": "(self, alignment)", "symbol_type": "function"}], "update_dCoordSpace": [{"docstring": "Compute/update coordinate space transforms for chain dihedra.\n\nRequires all atoms updated so calls :meth:`.assemble_residues`\n(returns immediately if all atoms already assembled).\n\n:param [bool] workSelector:\n    Optional mask to select dihedra for update", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/internal_coords.py", "line_number": 1483, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.internal_coords", "name": "update_dCoordSpace", "signature": "(self, workSelector: np.ndarray | None = None) -> None", "symbol_type": "function"}], "update_dashboard": [{"docstring": "Update the dashboard file and PNG visualization with current state.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/progress_tracker.py", "line_number": 430, "module": "src.metainformant.rna.progress_tracker", "name": "update_dashboard", "signature": "(self) -> None", "symbol_type": "function"}], "update_depths": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/BaseTree.py", "line_number": 476, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.BaseTree", "name": "update_depths", "signature": "(node, curr_depth)", "symbol_type": "function"}], "update_params_for_auth": [{"docstring": "Updates header and query params based on authentication setting.\n\n:param headers: Header parameters dict to be updated.\n:param queries: Query parameters tuple list to be updated.\n:param auth_settings: Authentication setting identifiers list.\n:param resource_path: A string representation of the HTTP request resource path.\n:param method: A string representation of the HTTP request method.\n:param body: A object representing the body of the HTTP request.\n    The object type is the return value of _encoder.default().", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 591, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "update_params_for_auth", "signature": "(self, headers, queries, auth_settings, resource_path, method, body)", "symbol_type": "function"}], "update_pdb": [{"docstring": "Update your local copy of the PDB files.\n\nI guess this is the 'most wanted' function from this module.\nIt gets the weekly lists of new and modified pdb entries and\nautomatically downloads the according PDB files.\nYou can call this module as a weekly cron job.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PDBList.py", "line_number": 352, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PDBList", "name": "update_pdb", "signature": "(self, file_format = None, with_assemblies = False)", "symbol_type": "function"}], "update_raw": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/reader.py", "line_number": 177, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.reader", "name": "update_raw", "signature": "(self, size = 4096)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/reader.py", "line_number": 177, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.reader", "name": "update_raw", "signature": "(self, size = 4096)", "symbol_type": "function"}], "update_thread": [{"docstring": "Update progress for a specific thread.\n\nArgs:\n    thread_id: Thread identifier\n    \nReturns:\n    Current progress state dict, or None if thread not found", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/steps/download_progress.py", "line_number": 308, "module": "src.metainformant.rna.steps.download_progress", "name": "update_thread", "signature": "(self, thread_id: int) -> dict[str, Any] | None", "symbol_type": "function"}], "upgma": [{"docstring": "Construct and return an UPGMA tree.\n\nConstructs and returns an Unweighted Pair Group Method\nwith Arithmetic mean (UPGMA) tree.\n\n:Parameters:\n    distance_matrix : DistanceMatrix\n        The distance matrix for tree construction.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/TreeConstruction.py", "line_number": 708, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.TreeConstruction", "name": "upgma", "signature": "(self, distance_matrix)", "symbol_type": "function"}], "upgma_tree": [{"docstring": "Build UPGMA (Unweighted Pair Group Method with Arithmetic Mean) phylogenetic tree.\n\nArgs:\n    id_to_seq: Dictionary mapping sequence IDs to DNA sequences\n    \nReturns:\n    Bio.Phylo tree object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/phylogeny.py", "line_number": 34, "module": "src.metainformant.dna.phylogeny", "name": "upgma_tree", "signature": "(id_to_seq: Dict[str, str]) -> Tree", "symbol_type": "function"}, {"docstring": "Build UPGMA tree from sequences (alternative implementation).\n\nArgs:\n    id_to_seq: Dictionary mapping sequence IDs to DNA sequences\n    \nReturns:\n    Bio.Phylo tree object", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/phylogeny.py", "line_number": 68, "module": "src.metainformant.dna.phylogeny", "name": "upgma_tree", "signature": "(id_to_seq: Dict[str, str]) -> Tree", "symbol_type": "function"}], "upper": [{"docstring": "Return a copy of data with all ASCII characters converted to uppercase.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 305, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "upper", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return the sequence in upper case.\n\nAn upper-case copy of the sequence is returned if inplace is False,\nthe default value:\n\n>>> from Bio.Seq import Seq, MutableSeq\n>>> my_seq = Seq(\"VHLTPeeK*\")\n>>> my_seq\nSeq('VHLTPeeK*')\n>>> my_seq.lower()\nSeq('vhltpeek*')\n>>> my_seq.upper()\nSeq('VHLTPEEK*')\n>>> my_seq\nSeq('VHLTPeeK*')\n\nThe sequence is modified in-place and returned if inplace is True:\n\n>>> my_seq = MutableSeq(\"VHLTPeeK*\")\n>>> my_seq\nMutableSeq('VHLTPeeK*')\n>>> my_seq.lower()\nMutableSeq('vhltpeek*')\n>>> my_seq.upper()\nMutableSeq('VHLTPEEK*')\n>>> my_seq\nMutableSeq('VHLTPeeK*')\n\n>>> my_seq.lower(inplace=True)\nMutableSeq('vhltpeek*')\n>>> my_seq\nMutableSeq('vhltpeek*')\n>>> my_seq.upper(inplace=True)\nMutableSeq('VHLTPEEK*')\n>>> my_seq\nMutableSeq('VHLTPEEK*')\n\nAs ``Seq`` objects are immutable, a ``TypeError`` is raised if\n``upper`` is called on a ``Seq`` object with ``inplace=True``.\n\nSee also the ``lower`` method.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 1405, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "upper", "signature": "(self, inplace = False)", "symbol_type": "function"}, {"docstring": "Return an upper case copy of the sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2411, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "upper", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return an upper case copy of the sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Seq.py", "line_number": 2619, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Seq", "name": "upper", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return a copy of the record with an upper case sequence.\n\nAll the annotation is preserved unchanged. e.g.\n\n>>> from Bio.Seq import Seq\n>>> from Bio.SeqRecord import SeqRecord\n>>> record = SeqRecord(Seq(\"acgtACGT\"), id=\"Test\",\n...                    description = \"Made up for this example\")\n>>> record.letter_annotations[\"phred_quality\"] = [1, 2, 3, 4, 5, 6, 7, 8]\n>>> print(record.upper().format(\"fastq\"))\n@Test Made up for this example\nACGTACGT\n+\n\"#$%&'()\n<BLANKLINE>\n\nNaturally, there is a matching lower method:\n\n>>> print(record.lower().format(\"fastq\"))\n@Test Made up for this example\nacgtacgt\n+\n\"#$%&'()\n<BLANKLINE>", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqRecord.py", "line_number": 1092, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqRecord", "name": "upper", "signature": "(self) -> 'SeqRecord'", "symbol_type": "function"}, {"docstring": "Remove the sequence mask.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/TwoBitIO.py", "line_number": 155, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.TwoBitIO", "name": "upper", "signature": "(self)", "symbol_type": "function"}], "uri": [{"docstring": "Create uri object, expected to be a url.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 640, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "uri", "signature": "(self, elem)", "symbol_type": "function"}], "user_agent": [{"docstring": "User agent for this API client", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 106, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "user_agent", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api_client.py", "line_number": 111, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api_client", "name": "user_agent", "signature": "(self, value)", "symbol_type": "function"}], "validate": [{"docstring": "Validate ontology integrity (check for cycles, orphaned terms).\n\nChecks for:\n- Cycles in parent-child relationships\n- Orphaned terms (terms referenced as parents but not in ontology)\n- Terms with invalid parent references\n\nReturns:\n    Tuple of (is_valid, list_of_errors)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/types.py", "line_number": 208, "module": "src.metainformant.ontology.types", "name": "validate", "signature": "(self) -> tuple[bool, List[str]]", "symbol_type": "function"}], "validate_and_convert_types": [{"docstring": "Raises a TypeError is there is a problem, otherwise returns value\n\nArgs:\n    input_value (any): the data to validate/convert\n    required_types_mixed (list/dict/tuple): A list of\n        valid classes, or a list tuples of valid classes, or a dict where\n        the value is a tuple of value classes\n    path_to_item: (list) the path to the data being validated\n        this stores a list of keys or indices to get to the data being\n        validated\n    spec_property_naming (bool): True if the variable names in the input\n        data are serialized names as specified in the OpenAPI document.\n        False if the variables names in the input data are python\n        variable names in PEP-8 snake case.\n    _check_type: (boolean) if true, type will be checked and conversion\n        will be attempted.\n    configuration: (Configuration): the configuration class to use\n        when converting file_type items.\n        If passed, conversion will be attempted when possible\n        If not passed, no conversions will be attempted and\n        exceptions will be raised\n\nReturns:\n    the correctly typed value\n\nRaises:\n    ApiTypeError", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1531, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "validate_and_convert_types", "signature": "(input_value, required_types_mixed, path_to_item, spec_property_naming, _check_type, configuration = None)", "symbol_type": "function"}], "validate_config_file": [{"docstring": "Validate a configuration file.", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/validate_all_species_workflow.py", "line_number": 65, "module": "scripts.validate_all_species_workflow", "name": "validate_config_file", "signature": "(config_path: Path) -> Tuple[bool, str, dict]", "symbol_type": "function"}, {"docstring": "Validate a configuration file for processing.\n\nArgs:\n    config_path: Path to configuration file\n    \nReturns:\n    Tuple of (is_valid, list_of_errors)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/workflow.py", "line_number": 123, "module": "src.metainformant.core.workflow", "name": "validate_config_file", "signature": "(config_path: str | Path) -> tuple[bool, list[str]]", "symbol_type": "function"}], "validate_dna_sequence": [{"docstring": "Validate that a string contains only valid DNA characters (ACGTacgtNn-).\n\nArgs:\n    seq: DNA sequence to validate\n\nReturns:\n    True if sequence contains only valid DNA characters", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/sequences.py", "line_number": 85, "module": "src.metainformant.dna.sequences", "name": "validate_dna_sequence", "signature": "(seq: str) -> bool", "symbol_type": "function"}], "validate_environment": [{"docstring": "Comprehensive environment validation.\n\nReturns:\n    Dictionary with validation results:\n    - all_passed: bool\n    - dependencies: dict mapping name -> (is_available, message)\n    - recommendations: list of strings with recommendations", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/environment.py", "line_number": 178, "module": "src.metainformant.rna.environment", "name": "validate_environment", "signature": "() -> dict[str, Any]", "symbol_type": "function"}], "validate_float_range": [{"docstring": "Validate that a float is in a specified range.\n\nArgs:\n    value: Value to validate\n    name: Parameter name for error messages\n    min_val: Minimum allowed value\n    max_val: Maximum allowed value\n    \nRaises:\n    ValidationError: If value is invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/_common.py", "line_number": 36, "module": "scripts.simulation._common", "name": "validate_float_range", "signature": "(value: float, name: str, min_val: float = 0.0, max_val: float = 1.0) -> None", "symbol_type": "function"}], "validate_get_composed_info": [{"docstring": "For composed schemas, generate schema instances for\nall schemas in the oneOf/anyOf/allOf definition. If additional\nproperties are allowed, also assign those properties on\nall matched schemas that contain additionalProperties.\nOpenapi schemas are python classes.\n\nExceptions are raised if:\n- 0 or > 1 oneOf schema matches the model_args input data\n- no anyOf schema matches the model_args input data\n- any of the allOf schemas do not match the model_args input data\n\nArgs:\n    constant_args (dict): these are the args that every model requires\n    model_args (dict): these are the required and optional spec args that\n        were passed in to make this model\n    self (class): the class that we are instantiating\n        This class contains self._composed_schemas\n\nReturns:\n    composed_info (list): length three\n        composed_instances (list): the composed instances which are not\n            self\n        var_name_to_model_instances (dict): a dict going from var_name\n            to the model_instance which holds that var_name\n            the model_instance may be self or an instance of one of the\n            classes in self.composed_instances()\n        additional_properties_model_instances (list): a list of the\n            model instances which have the property\n            additional_properties_type. This list can include self", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 1954, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "validate_get_composed_info", "signature": "(constant_args, model_args, self)", "symbol_type": "function"}], "validate_go_ontology": [{"docstring": "Validate Gene Ontology structure and integrity.\n\nChecks for common issues in GO ontologies:\n- Cycles in relationships\n- Orphaned terms\n- Missing required fields\n- Namespace consistency\n\nArgs:\n    onto: Ontology object to validate\n    \nReturns:\n    Tuple of (is_valid, list_of_errors)\n    \nExamples:\n    >>> onto = load_go_obo(\"go.obo\")\n    >>> is_valid, errors = validate_go_ontology(onto)\n    >>> is_valid\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/go.py", "line_number": 131, "module": "src.metainformant.ontology.go", "name": "validate_go_ontology", "signature": "(onto: Ontology) -> tuple[bool, List[str]]", "symbol_type": "function"}], "validate_json_schema": [{"docstring": "Validate data against a JSON Schema file.\n\nArgs:\n    data: Data dictionary to validate\n    schema_path: Path to JSON Schema file\n\nRaises:\n    ValidationError: If data does not match schema\n    FileNotFoundError: If schema file does not exist\n\nExample:\n    validate_json_schema(config, \"config/schema.json\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/validation.py", "line_number": 214, "module": "src.metainformant.core.validation", "name": "validate_json_schema", "signature": "(data: dict[str, Any], schema_path: str | Path) -> None", "symbol_type": "function"}], "validate_not_empty": [{"docstring": "Validate that a value is not empty.\n\nArgs:\n    value: Value to validate (string, list, or dict)\n    name: Name of value for error message\n\nRaises:\n    ValidationError: If value is empty\n\nExample:\n    validate_not_empty(items, \"items\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/validation.py", "line_number": 173, "module": "src.metainformant.core.validation", "name": "validate_not_empty", "signature": "(value: str | list | dict, name: str = 'value') -> None", "symbol_type": "function"}], "validate_not_none": [{"docstring": "Validate that a value is not None.\n\nArgs:\n    value: Value to validate\n    name: Name of value for error message\n\nRaises:\n    ValidationError: If value is None", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/errors.py", "line_number": 199, "module": "src.metainformant.core.errors", "name": "validate_not_none", "signature": "(value: Any, name: str = 'value') -> None", "symbol_type": "function"}, {"docstring": "Validate that a value is not None.\n\nArgs:\n    value: Value to validate\n    name: Name of value for error message\n\nRaises:\n    ValidationError: If value is None\n\nExample:\n    validate_not_none(config, \"config\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/validation.py", "line_number": 156, "module": "src.metainformant.core.validation", "name": "validate_not_none", "signature": "(value: Any, name: str = 'value') -> None", "symbol_type": "function"}], "validate_output_dir": [{"docstring": "Validate and ensure output directory exists.\n\nArgs:\n    output: Output directory path\n    \nReturns:\n    Validated and created output directory\n    \nRaises:\n    ValidationError: If path is invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/_common.py", "line_number": 52, "module": "scripts.simulation._common", "name": "validate_output_dir", "signature": "(output: Path) -> Path", "symbol_type": "function"}], "validate_path_exists": [{"docstring": "Validate that a path exists.\n\nArgs:\n    path: Path to validate\n    name: Name of path for error message\n\nReturns:\n    Resolved Path object\n\nRaises:\n    ValidationError: If path does not exist\n\nExample:\n    file_path = validate_path_exists(\"data/file.txt\", \"input_file\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/validation.py", "line_number": 65, "module": "src.metainformant.core.validation", "name": "validate_path_exists", "signature": "(path: str | Path, name: str = 'path') -> Path", "symbol_type": "function"}], "validate_path_is_dir": [{"docstring": "Validate that a path exists and is a directory.\n\nArgs:\n    path: Path to validate\n    name: Name of path for error message\n\nReturns:\n    Resolved Path object\n\nRaises:\n    ValidationError: If path does not exist or is not a directory\n\nExample:\n    dir_path = validate_path_is_dir(\"output/\", \"output_dir\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/validation.py", "line_number": 109, "module": "src.metainformant.core.validation", "name": "validate_path_is_dir", "signature": "(path: str | Path, name: str = 'path') -> Path", "symbol_type": "function"}], "validate_path_is_file": [{"docstring": "Validate that a path exists and is a file.\n\nArgs:\n    path: Path to validate\n    name: Name of path for error message\n\nReturns:\n    Resolved Path object\n\nRaises:\n    ValidationError: If path does not exist or is not a file\n\nExample:\n    file_path = validate_path_is_file(\"data/file.txt\", \"input_file\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/validation.py", "line_number": 87, "module": "src.metainformant.core.validation", "name": "validate_path_is_file", "signature": "(path: str | Path, name: str = 'path') -> Path", "symbol_type": "function"}], "validate_path_within": [{"docstring": "Validate that a path is within a parent directory (security check).\n\nArgs:\n    parent: Parent directory path\n    path: Path to validate\n    name: Name of path for error message\n\nReturns:\n    Resolved Path object\n\nRaises:\n    ValidationError: If path is not within parent directory\n\nExample:\n    safe_path = validate_path_within(\"/allowed/dir\", user_path, \"user_path\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/validation.py", "line_number": 131, "module": "src.metainformant.core.validation", "name": "validate_path_within", "signature": "(parent: str | Path, path: str | Path, name: str = 'path') -> Path", "symbol_type": "function"}], "validate_positive_int": [{"docstring": "Validate that an integer is positive.\n\nArgs:\n    value: Value to validate\n    name: Parameter name for error messages\n    min_val: Minimum allowed value\n    \nRaises:\n    ValidationError: If value is invalid", "file_path": "/media/q/ext6/github/MetaInformAnt/scripts/simulation/_common.py", "line_number": 21, "module": "scripts.simulation._common", "name": "validate_positive_int", "signature": "(value: int, name: str, min_val: int = 1) -> None", "symbol_type": "function"}], "validate_range": [{"docstring": "Validate that a numeric value is within a range.\n\nArgs:\n    value: Numeric value to validate\n    min_val: Minimum allowed value (None for no minimum)\n    max_val: Maximum allowed value (None for no maximum)\n    name: Name of value for error message\n\nRaises:\n    ValidationError: If value is outside range\n\nExample:\n    validate_range(0.5, min_val=0.0, max_val=1.0, name=\"probability\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/validation.py", "line_number": 39, "module": "src.metainformant.core.validation", "name": "validate_range", "signature": "(value: float | int, min_val: float | int | None = None, max_val: float | int | None = None, name: str = 'value') -> None", "symbol_type": "function"}], "validate_regulation": [{"docstring": "Validate a regulatory interaction and provide evidence.\n\nChecks if a regulation exists and provides validation metrics\nincluding confidence, evidence types, and network context.\n\nArgs:\n    grn: Gene regulatory network\n    regulator: Regulator identifier\n    target: Target gene identifier\n    min_confidence: Minimum confidence threshold\n    \nReturns:\n    Dictionary containing:\n    - exists: Whether regulation exists\n    - confidence: Confidence score if exists\n    - regulation_type: Type of regulation (activation/repression)\n    - strength: Regulatory strength\n    - evidence: List of evidence types\n    - network_support: Whether supported by network structure\n    \nExamples:\n    >>> grn = GeneRegulatoryNetwork()\n    >>> grn.add_regulation(\"TF1\", \"GENE1\", confidence=0.8)\n    >>> validation = validate_regulation(grn, \"TF1\", \"GENE1\")\n    >>> validation[\"exists\"]\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/networks/regulatory.py", "line_number": 1076, "module": "src.metainformant.networks.regulatory", "name": "validate_regulation", "signature": "(grn: GeneRegulatoryNetwork, regulator: str, target: str, min_confidence: float = 0.5) -> Dict[str, Any]", "symbol_type": "function"}], "validate_schema": [{"docstring": "Validate data against a simple schema.\n\nArgs:\n    data: Data dictionary to validate\n    schema: Schema dictionary defining expected structure\n    name: Name of data for error message\n\nRaises:\n    ValidationError: If data does not match schema\n\nExample:\n    schema = {\"name\": str, \"age\": int, \"email\": str}\n    validate_schema({\"name\": \"John\", \"age\": 30, \"email\": \"john@example.com\"}, schema)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/validation.py", "line_number": 190, "module": "src.metainformant.core.validation", "name": "validate_schema", "signature": "(data: dict[str, Any], schema: dict[str, Any], name: str = 'data') -> None", "symbol_type": "function"}], "validate_sequence": [{"docstring": "Validate event sequence for common issues.\n\nArgs:\n    sequence: EventSequence to validate\n    \nReturns:\n    Tuple of (is_valid, list_of_errors)\n    \nExamples:\n    >>> seq = EventSequence(\"p1\", [Event(\"degree\", datetime(2010, 1, 1), \"education\")])\n    >>> is_valid, errors = validate_sequence(seq)\n    >>> is_valid\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/life_events/utils.py", "line_number": 71, "module": "src.metainformant.life_events.utils", "name": "validate_sequence", "signature": "(sequence: EventSequence) -> tuple[bool, List[str]]", "symbol_type": "function"}], "validate_type": [{"docstring": "Validate that a value is of expected type.\n\nArgs:\n    value: Value to validate\n    expected_type: Expected type or tuple of types\n    name: Name of value for error message\n\nRaises:\n    ValidationError: If value is not of expected type", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/errors.py", "line_number": 213, "module": "src.metainformant.core.errors", "name": "validate_type", "signature": "(value: Any, expected_type: type | tuple[type, ...], name: str = 'value') -> None", "symbol_type": "function"}, {"docstring": "Validate that a value is of expected type.\n\nArgs:\n    value: Value to validate\n    expected_type: Expected type or tuple of types\n    name: Name of value for error message\n\nRaises:\n    ValidationError: If value is not of expected type\n\nExample:\n    validate_type(42, int, \"age\")", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/validation.py", "line_number": 17, "module": "src.metainformant.core.validation", "name": "validate_type", "signature": "(value: Any, expected_type: type | tuple[type, ...], name: str = 'value') -> None", "symbol_type": "function"}], "validator": [{"docstring": "Decorator to create a validator function from a predicate.\n\nArgs:\n    func: Function that returns True if value is valid\n\nReturns:\n    Validator function that raises ValidationError on invalid input\n\nExample:\n    @validator\n    def is_positive(x):\n        return x > 0\n\n    is_positive(5)  # OK\n    is_positive(-1)  # Raises ValidationError", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/validation.py", "line_number": 242, "module": "src.metainformant.core.validation", "name": "validator", "signature": "(func: Callable[[Any], bool]) -> Callable[[Any], None]", "symbol_type": "function"}], "value": [{"docstring": "Return the float value of the Confidence object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 662, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "value", "signature": "(self)", "symbol_type": "function"}], "values": [{"docstring": "Return a tuple with the values stored in the array.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/substitution_matrices/__init__.py", "line_number": 295, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.substitution_matrices.__init__", "name": "values", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Return values from a key-value pair in an Events dict.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXML.py", "line_number": 785, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXML", "name": "values", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Iterate over BioSeqDatabase objects in the database.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 219, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "values", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Iterate over DBSeqRecord objects in the namespace (sub database).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/BioSQL/BioSeqDatabase.py", "line_number": 758, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.BioSQL.BioSeqDatabase", "name": "values", "signature": "(self)", "symbol_type": "function"}], "variance": [{"docstring": "Population variance of a sequence (dividing by n).\n\nReturns 0.0 for empty input.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 60, "module": "src.metainformant.math.price", "name": "variance", "signature": "(values: Sequence[float]) -> float", "symbol_type": "function"}, {"docstring": "Calculate population variance.\n\nArgs:\n    xs: Sequence of numeric values\n    \nReturns:\n    Variance (mean squared deviation from mean)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/selection.py", "line_number": 78, "module": "src.metainformant.math.selection", "name": "variance", "signature": "(xs: Sequence[float]) -> float", "symbol_type": "function"}], "variant_density_plot": [{"docstring": "SNP density across genome.\n\nShows variant count per window, useful for identifying regions\nwith high/low variant density (e.g., centromeres, genes).\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    window_size: Window size in bp (default 1 Mb)\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_variants.py", "line_number": 134, "module": "src.metainformant.gwas.visualization_variants", "name": "variant_density_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}], "variant_plot": [{"docstring": "Create a variant visualization plot.\n\nArgs:\n    positions: Genomic positions\n    ref_alleles: Reference alleles\n    alt_alleles: Alternative alleles\n    frequencies: Optional allele frequencies\n    ax: Matplotlib axes (creates new if None)\n    title: Plot title\n    **kwargs: Additional arguments\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import variant_plot\n    >>> ax = variant_plot(\n    ...     [1000, 2000, 3000],\n    ...     ['A', 'T', 'G'],\n    ...     ['G', 'C', 'A'],\n    ...     [0.1, 0.2, 0.05]\n    ... )", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/genomics.py", "line_number": 474, "module": "src.metainformant.visualization.genomics", "name": "variant_plot", "signature": "(positions: Sequence[int], ref_alleles: Sequence[str], alt_alleles: Sequence[str], frequencies: Sequence[float] | None = None, **kwargs) -> plt.Axes", "symbol_type": "function"}], "vector_to_axis": [{"docstring": "Vector to axis method.\n\nReturn the vector between a point and\nthe closest point on a line (ie. the perpendicular\nprojection of the point on the line).\n\n:type line: L{Vector}\n:param line: vector defining a line\n\n:type point: L{Vector}\n:param point: vector defining the point", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/vectors.py", "line_number": 82, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.vectors", "name": "vector_to_axis", "signature": "(line, point)", "symbol_type": "function"}], "verify_file_integrity": [{"docstring": "Verify file integrity against expected hash.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/hash.py", "line_number": 65, "module": "src.metainformant.core.hash", "name": "verify_file_integrity", "signature": "(file_path: str | Path, expected_hash: str) -> bool", "symbol_type": "function"}], "verify_genome_status": [{"docstring": "Verify genome and index status for a species.\n\nArgs:\n    config_path: Path to species config file\n    repo_root: Repository root directory (optional)\n\nReturns:\n    Dictionary with verification results", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/rna/genome_prep.py", "line_number": 713, "module": "src.metainformant.rna.genome_prep", "name": "verify_genome_status", "signature": "(config_path: Path) -> dict[str, Any]", "symbol_type": "function"}], "version": [{"docstring": "Retrieve service version  # noqa: E501\n\nRetrieve the latest version of the Datasets services.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.version(async_req=True)\n>>> result = thread.get()\n\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1VersionReply\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/version_api.py", "line_number": 84, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.version_api", "name": "version", "signature": "(self, **kwargs)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 432, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "version", "signature": "(self, version_id)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 974, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "version", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": "Parse semantic version scheme for easy comparison.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/DSSP.py", "line_number": 114, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.DSSP", "name": "version", "signature": "(version_string)", "symbol_type": "function"}, {"docstring": "Return the JASPAR matrix version.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/jaspar/__init__.py", "line_number": 68, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.jaspar.__init__", "name": "version", "signature": "(self)", "symbol_type": "function"}], "version_suffix": [{"docstring": "Set the version to overwrite the id.\n\nSince the version provides the same information as the accession\nnumber, plus some extra info, we set this as the id if we have\na version.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 497, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "version_suffix", "signature": "(self, version)", "symbol_type": "function"}], "violin_plot": [{"docstring": "Create a violin plot.\n\nArgs:\n    data: Data to plot (single array or list of arrays)\n    ax: Matplotlib axes (creates new if None)\n    positions: Violin positions\n    labels: Violin labels\n    xlabel: X-axis label\n    ylabel: Y-axis label\n    title: Plot title\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import violin_plot\n    >>> import numpy as np\n    >>> data = [np.random.normal(0, 1, 100) for _ in range(3)]\n    >>> ax = violin_plot(data, labels=[\"A\", \"B\", \"C\"])", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/statistical.py", "line_number": 123, "module": "src.metainformant.visualization.statistical", "name": "violin_plot", "signature": "(data: Sequence[float] | Sequence[Sequence[float]]) -> plt.Axes", "symbol_type": "function"}], "virus_accession_availability": [{"docstring": "Check available viruses by accession GET  # noqa: E501\n\nCheck available viruses GET  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.virus_accession_availability(accessions, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    accessions ([str]): virus sequence accessions\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1VirusAvailability\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 1609, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "virus_accession_availability", "signature": "(self, accessions, **kwargs)", "symbol_type": "function"}], "virus_accession_availability_post": [{"docstring": "Check available viruses by accession POST  # noqa: E501\n\nCheck available viruses POST  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.virus_accession_availability_post(v1_virus_availability_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_virus_availability_request (V1VirusAvailabilityRequest):\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1VirusAvailability\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 1684, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "virus_accession_availability_post", "signature": "(self, v1_virus_availability_request, **kwargs)", "symbol_type": "function"}], "virus_genome_download": [{"docstring": "Download a coronavirus genome dataset by taxon  # noqa: E501\n\nDownload a coronavirus genome dataset by taxon  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.virus_genome_download(taxon, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    taxon (str): NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank\n\nKeyword Args:\n    refseq_only (bool): If true, limit results to RefSeq genomes.. [optional] if omitted the server will use the default value of False\n    annotated_only (bool): If true, limit results to annotated genomes.. [optional] if omitted the server will use the default value of False\n    released_since (datetime): If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'. [optional]\n    updated_since (datetime): [optional]\n    host (str): If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default. [optional]\n    pangolin_classification (str): If set, limit results to genomes classified to this lineage by the PangoLearn tool.. [optional]\n    geo_location (str): Assemblies from this location (country and state, or continent). [optional]\n    complete_only (bool): only include complete genomes.. [optional] if omitted the server will use the default value of False\n    exclude_sequence (bool): Set to true to omit the genomic sequence.. [optional] if omitted the server will use the default value of False\n    include_annotation_type ([V1AnnotationForVirusType]): Select additional types of annotation to include in the data package.  If unset, no annotation is provided.. [optional]\n    filename (str): Output file name.. [optional] if omitted the server will use the default value of \"ncbi_dataset.zip\"\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    file_type\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 1759, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "virus_genome_download", "signature": "(self, taxon, **kwargs)", "symbol_type": "function"}], "virus_genome_download_accession": [{"docstring": "Download a coronavirus genome dataset by accession  # noqa: E501\n\nDownload a coronavirus genome dataset by accession  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.virus_genome_download_accession(accessions, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    accessions ([str]): Accessions accessions = 16;\n\nKeyword Args:\n    refseq_only (bool): If true, limit results to RefSeq genomes.. [optional] if omitted the server will use the default value of False\n    annotated_only (bool): If true, limit results to annotated genomes.. [optional] if omitted the server will use the default value of False\n    released_since (datetime): If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'. [optional]\n    updated_since (datetime): [optional]\n    host (str): If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default. [optional]\n    pangolin_classification (str): If set, limit results to genomes classified to this lineage by the PangoLearn tool.. [optional]\n    geo_location (str): Assemblies from this location (country and state, or continent). [optional]\n    complete_only (bool): only include complete genomes.. [optional] if omitted the server will use the default value of False\n    exclude_sequence (bool): Set to true to omit the genomic sequence.. [optional] if omitted the server will use the default value of False\n    include_annotation_type ([V1AnnotationForVirusType]): Select additional types of annotation to include in the data package.  If unset, no annotation is provided.. [optional]\n    filename (str): Output file name.. [optional] if omitted the server will use the default value of \"ncbi_dataset.zip\"\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    file_type\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 1845, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "virus_genome_download_accession", "signature": "(self, accessions, **kwargs)", "symbol_type": "function"}], "virus_genome_download_post": [{"docstring": "Get a coronavirus genome dataset by post  # noqa: E501\n\nThe 'GET' version of download is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.virus_genome_download_post(v1_virus_dataset_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_virus_dataset_request (V1VirusDatasetRequest):\n\nKeyword Args:\n    filename (str): Output file name.. [optional] if omitted the server will use the default value of \"ncbi_dataset.zip\"\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    file_type\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 1931, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "virus_genome_download_post", "signature": "(self, v1_virus_dataset_request, **kwargs)", "symbol_type": "function"}], "virus_genome_summary": [{"docstring": "Get summary data for Coronaviridae genomes by taxon  # noqa: E501\n\nGet summary data and download by command line instructions for Coronaviridae genomes by taxon.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.virus_genome_summary(taxon, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    taxon (str): NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank\n\nKeyword Args:\n    refseq_only (bool): If true, limit results to RefSeq genomes.. [optional] if omitted the server will use the default value of False\n    annotated_only (bool): If true, limit results to annotated genomes.. [optional] if omitted the server will use the default value of False\n    released_since (datetime): If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'. [optional]\n    updated_since (datetime): [optional]\n    host (str): If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default. [optional]\n    pangolin_classification (str): If set, limit results to genomes classified to this lineage by the PangoLearn tool.. [optional]\n    geo_location (str): Assemblies from this location (country and state, or continent). [optional]\n    complete_only (bool): only include complete genomes.. [optional] if omitted the server will use the default value of False\n    exclude_sequence (bool): Set to true to omit the genomic sequence.. [optional] if omitted the server will use the default value of False\n    include_annotation_type ([V1AnnotationForVirusType]): Select additional types of annotation to include in the data package.  If unset, no annotation is provided.. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1DownloadSummary\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 2007, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "virus_genome_summary", "signature": "(self, taxon, **kwargs)", "symbol_type": "function"}], "virus_genome_summary_accession": [{"docstring": "Get summary data for Coronaviridae genomes by accession  # noqa: E501\n\nGet summary data for Coronaviridae genomes by accession  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.virus_genome_summary_accession(accessions, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    accessions ([str]): Accessions accessions = 16;\n\nKeyword Args:\n    refseq_only (bool): If true, limit results to RefSeq genomes.. [optional] if omitted the server will use the default value of False\n    annotated_only (bool): If true, limit results to annotated genomes.. [optional] if omitted the server will use the default value of False\n    released_since (datetime): If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'. [optional]\n    updated_since (datetime): [optional]\n    host (str): If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default. [optional]\n    pangolin_classification (str): If set, limit results to genomes classified to this lineage by the PangoLearn tool.. [optional]\n    geo_location (str): Assemblies from this location (country and state, or continent). [optional]\n    complete_only (bool): only include complete genomes.. [optional] if omitted the server will use the default value of False\n    exclude_sequence (bool): Set to true to omit the genomic sequence.. [optional] if omitted the server will use the default value of False\n    include_annotation_type ([V1AnnotationForVirusType]): Select additional types of annotation to include in the data package.  If unset, no annotation is provided.. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1DownloadSummary\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 2092, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "virus_genome_summary_accession", "signature": "(self, accessions, **kwargs)", "symbol_type": "function"}], "virus_genome_summary_post": [{"docstring": "Get summary data for Coronaviridae genomes by post  # noqa: E501\n\nThe 'GET' version is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.virus_genome_summary_post(v1_virus_dataset_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_virus_dataset_request (V1VirusDatasetRequest):\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1DownloadSummary\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 2177, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "virus_genome_summary_post", "signature": "(self, v1_virus_dataset_request, **kwargs)", "symbol_type": "function"}], "virus_genome_table": [{"docstring": "Get viral genomic metadata in a tabular format.  # noqa: E501\n\nGet viral genomic metadata in tabular format for Coronaviridae genomes by taxon.  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.virus_genome_table(taxon, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    taxon (str): NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank\n\nKeyword Args:\n    refseq_only (bool): If true, limit results to RefSeq genomes.. [optional] if omitted the server will use the default value of False\n    annotated_only (bool): If true, limit results to annotated genomes.. [optional] if omitted the server will use the default value of False\n    released_since (datetime): If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'. [optional]\n    updated_since (datetime): [optional]\n    host (str): If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default. [optional]\n    pangolin_classification (str): If set, limit results to genomes classified to this lineage by the PangoLearn tool.. [optional]\n    geo_location (str): Assemblies from this location (country and state, or continent). [optional]\n    complete_only (bool): only include complete genomes.. [optional] if omitted the server will use the default value of False\n    table_fields ([V1VirusTableField]): Specify which fields to include in the tabular report. [optional]\n    format (V1TableFormat): Choose download format (tsv, csv or jsonl). [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1TabularOutput\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 2252, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "virus_genome_table", "signature": "(self, taxon, **kwargs)", "symbol_type": "function"}], "virus_reports_by_acessions": [{"docstring": "Get virus metadata by accession  # noqa: E501\n\nGet virus metadata by accesion. By default, in paged JSON format, but also available as tabular (accept: x-tabular) or json-lines (accept: x-jsonlines)  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.virus_reports_by_acessions(accessions, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    accessions ([str]): genome sequence accessions\n\nKeyword Args:\n    filter_refseq_only (bool): If true, limit results to RefSeq genomes.. [optional] if omitted the server will use the default value of False\n    filter_annotated_only (bool): If true, limit results to annotated genomes.. [optional] if omitted the server will use the default value of False\n    filter_released_since (datetime): If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'. [optional]\n    filter_updated_since (datetime): [optional]\n    filter_host (str): If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default. [optional]\n    filter_pangolin_classification (str): If set, limit results to genomes classified to this lineage by the PangoLearn tool.. [optional]\n    filter_geo_location (str): Assemblies from this location (country and state, or continent). [optional]\n    filter_complete_only (bool): only include complete genomes.. [optional] if omitted the server will use the default value of False\n    returned_content (V1VirusDataReportRequestContentType): Return either virus genome accessions, or complete virus metadata. [optional]\n    table_fields ([str]): Specify which fields to include in the tabular report. [optional]\n    page_size (int): The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.. [optional] if omitted the server will use the default value of 20\n    page_token (str): A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1reportsVirusDataReportPage\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 2337, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "virus_reports_by_acessions", "signature": "(self, accessions, **kwargs)", "symbol_type": "function"}], "virus_reports_by_post": [{"docstring": "Get virus metadata by POST  # noqa: E501\n\nGet virus metadata. By default, in paged JSON format, but also available as tabular (accept: x-tabular) or json-lines (accept: x-jsonlines)  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.virus_reports_by_post(v1_virus_data_report_request, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    v1_virus_data_report_request (V1VirusDataReportRequest):\n\nKeyword Args:\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1reportsVirusDataReportPage\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 2424, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "virus_reports_by_post", "signature": "(self, v1_virus_data_report_request, **kwargs)", "symbol_type": "function"}], "virus_reports_by_taxon": [{"docstring": "Get virus metadata by taxon  # noqa: E501\n\nGet virus metadata by taxon. By default, in paged JSON format, but also available as tabular (accept: x-tabular) or json-lines (accept: x-jsonlines)  # noqa: E501\nThis method makes a synchronous HTTP request by default. To make an\nasynchronous HTTP request, please pass async_req=True\n\n>>> thread = api.virus_reports_by_taxon(taxon, async_req=True)\n>>> result = thread.get()\n\nArgs:\n    taxon (str): NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank\n\nKeyword Args:\n    filter_refseq_only (bool): If true, limit results to RefSeq genomes.. [optional] if omitted the server will use the default value of False\n    filter_annotated_only (bool): If true, limit results to annotated genomes.. [optional] if omitted the server will use the default value of False\n    filter_released_since (datetime): If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'. [optional]\n    filter_updated_since (datetime): [optional]\n    filter_host (str): If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default. [optional]\n    filter_pangolin_classification (str): If set, limit results to genomes classified to this lineage by the PangoLearn tool.. [optional]\n    filter_geo_location (str): Assemblies from this location (country and state, or continent). [optional]\n    filter_complete_only (bool): only include complete genomes.. [optional] if omitted the server will use the default value of False\n    returned_content (V1VirusDataReportRequestContentType): Return either virus genome accessions, or complete virus metadata. [optional]\n    table_fields ([str]): Specify which fields to include in the tabular report. [optional]\n    page_size (int): The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results.. [optional] if omitted the server will use the default value of 20\n    page_token (str): A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.. [optional]\n    _return_http_data_only (bool): response data without head status\n        code and headers. Default is True.\n    _preload_content (bool): if False, the urllib3.HTTPResponse object\n        will be returned without reading/decoding response data.\n        Default is True.\n    _request_timeout (int/float/tuple): timeout setting for this request. If\n        one number provided, it will be total request timeout. It can also\n        be a pair (tuple) of (connection, read) timeouts.\n        Default is None.\n    _check_input_type (bool): specifies if type checking\n        should be done one the data sent to the server.\n        Default is True.\n    _check_return_type (bool): specifies if type checking\n        should be done one the data received from the server.\n        Default is True.\n    _host_index (int/None): specifies the index of the server\n        that we want to use.\n        Default is read from the configuration.\n    async_req (bool): execute request asynchronously\n\nReturns:\n    V1reportsVirusDataReportPage\n        If the method is called asynchronously, returns the request\n        thread.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/api/virus_api.py", "line_number": 2499, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.api.virus_api", "name": "virus_reports_by_taxon", "signature": "(self, taxon, **kwargs)", "symbol_type": "function"}], "visit_Call": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/discovery.py", "line_number": 408, "module": "src.metainformant.core.discovery", "name": "visit_Call", "signature": "(self, node: ast.Call)", "symbol_type": "function"}], "visit_FunctionDef": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/discovery.py", "line_number": 402, "module": "src.metainformant.core.discovery", "name": "visit_FunctionDef", "signature": "(self, node: ast.FunctionDef)", "symbol_type": "function"}], "visit_Name": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/discovery.py", "line_number": 453, "module": "src.metainformant.core.discovery", "name": "visit_Name", "signature": "(self, node: ast.Name)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/symbols.py", "line_number": 409, "module": "src.metainformant.core.symbols", "name": "visit_Name", "signature": "(self, node: ast.Name)", "symbol_type": "function"}], "volcano_plot": [{"docstring": "Volcano plot: effect size vs significance.\n\nVisualizes both statistical significance and effect size magnitude.\nHighlights variants with large effects and strong significance.\n\nArgs:\n    results: Association results or path\n    output_path: Output path\n    significance_threshold: P-value threshold\n    effect_threshold: Absolute effect size threshold\n    title: Plot title\n\nReturns:\n    Plot metadata", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/visualization_statistical.py", "line_number": 403, "module": "src.metainformant.gwas.visualization_statistical", "name": "volcano_plot", "signature": "(results: list[dict[str, Any]] | Path, output_path: str | Path) -> dict[str, Any]", "symbol_type": "function"}, {"docstring": "Create a volcano plot for differential expression analysis.\n\nArgs:\n    data: DataFrame with log fold change and p-value columns\n    x_col: Column name for x-axis (usually log fold change)\n    y_col: Column name for y-axis (usually -log10(p-value))\n    p_threshold: P-value threshold for significance\n    fc_threshold: Fold change threshold\n    ax: Matplotlib axes (creates new if None)\n    **kwargs: Additional arguments for scatter\n\nReturns:\n    Matplotlib axes object\n\nExample:\n    >>> from metainformant.visualization import volcano_plot\n    >>> import pandas as pd\n    >>> data = pd.DataFrame({\n    ...     'log2fc': [-2, 1, 0.5, -1.5],\n    ...     'pvalue': [0.001, 0.01, 0.5, 0.001]\n    ... })\n    >>> data['neg_log10_p'] = -np.log10(data['pvalue'])\n    >>> ax = volcano_plot(data, 'log2fc', 'neg_log10_p')", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/visualization/genomics.py", "line_number": 112, "module": "src.metainformant.visualization.genomics", "name": "volcano_plot", "signature": "(data: pd.DataFrame, x_col: str, y_col: str, **kwargs) -> plt.Axes", "symbol_type": "function"}], "warnings": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/__init__.py", "line_number": 24, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.__init__", "name": "warnings", "signature": "(settings = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/__init__.py", "line_number": 24, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.__init__", "name": "warnings", "signature": "(settings = None)", "symbol_type": "function"}], "watterson_theta": [{"docstring": "Calculate Watterson's estimator of population mutation parameter \u03b8.\n\nBased on the number of segregating sites rather than pairwise diversity.\nProvides an alternative estimate of \u03b8 = 4Ne\u03bc (diploid) that can be compared\nwith \u03c0-based estimates in tests for selection.\n\nArgs:\n    num_segregating_sites: Number of segregating (polymorphic) sites (S)\n    sample_size: Number of sampled sequences (n)\n    sequence_length: Optional sequence length L for per-site normalization.\n        If provided, returns \u03b8_W / L. If None, returns total \u03b8_W.\n        \nReturns:\n    Watterson's \u03b8 estimate. Formula: \u03b8_W = S / a\u2081 where a\u2081 = \u03a3\u1d62\u208c\u2081\u207f\u207b\u00b9 1/i.\n    If sequence_length is provided, returns \u03b8_W / L (per-site estimate).\n    Returns 0.0 if sample_size < 2 or S <= 0.\n    \nExamples:\n    >>> watterson_theta(num_segregating_sites=10, sample_size=10)\n    4.08...\n    >>> watterson_theta(num_segregating_sites=100, sample_size=50, sequence_length=1000)\n    0.249...\n    \nReferences:\n    Watterson, G. A. (1975). On the number of segregating sites in genetical\n    models without recombination. Theoretical Population Biology, 7(2), 256-276.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 596, "module": "src.metainformant.math.coalescent", "name": "watterson_theta", "signature": "(num_segregating_sites: int, sample_size: int) -> float", "symbol_type": "function"}], "wattersons_theta": [{"docstring": "Watterson's theta per site: \u03b8_W = S / (a\u2081 \u00d7 L).\n\nCalculates Watterson's estimator of the population mutation parameter \u03b8\nbased on the number of segregating sites rather than pairwise diversity.\n\nArgs:\n    seqs: Sequence of DNA sequences (strings)\n\nReturns:\n    Watterson's theta estimate per site (float). Returns 0.0 if:\n    - Less than 2 sequences provided\n    - Sequences have zero length\n    - No segregating sites\n\nFormula:\n    \u03b8_W = S / (a\u2081 \u00d7 L) where:\n    - S = number of segregating sites\n    - a\u2081 = \u03a3\u1d62\u208c\u2081\u207f\u207b\u00b9 1/i (harmonic sum)\n    - L = sequence length\n\nExamples:\n    >>> seqs = [\"AAAA\", \"AAAT\", \"AATT\"]\n    >>> wattersons_theta(seqs)\n    0.5...  # Depends on number of segregating sites\n\nReferences:\n    Watterson, G. A. (1975). On the number of segregating sites in genetical\n    models without recombination. *Theoretical Population Biology*, 7(2), 256-276.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/population.py", "line_number": 529, "module": "src.metainformant.dna.population", "name": "wattersons_theta", "signature": "(seqs: Sequence[str]) -> float", "symbol_type": "function"}, {"docstring": "Calculate Watterson's estimator \u03b8_W (convenience alias).\n\nThis is an alias for watterson_theta() with default parameters.\nSee watterson_theta() for full documentation.\n\nArgs:\n    num_segregating_sites: Number of segregating sites (S)\n    sample_size: Number of sampled sequences (n)\n    \nReturns:\n    Watterson's \u03b8 estimate: \u03b8_W = S / a\u2081\n    \nExamples:\n    >>> wattersons_theta(num_segregating_sites=10, sample_size=10)\n    4.08...", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/coalescent.py", "line_number": 833, "module": "src.metainformant.math.coalescent", "name": "wattersons_theta", "signature": "(num_segregating_sites: int, sample_size: int) -> float", "symbol_type": "function"}], "weblogo": [{"docstring": "Download and save a weblogo using the Berkeley weblogo service.\n\nRequires an internet connection.\n\nThe parameters from ``**kwds`` are passed directly to the weblogo server.\n\nCurrently, this method uses WebLogo version 3.3.\nThese are the arguments and their default values passed to\nWebLogo 3.3; see their website at http://weblogo.threeplusone.com\nfor more information::\n\n    'stack_width' : 'medium',\n    'stacks_per_line' : '40',\n    'alphabet' : 'alphabet_dna',\n    'ignore_lower_case' : True,\n    'unit_name' : \"bits\",\n    'first_index' : '1',\n    'logo_start' : '1',\n    'logo_end': str(self.length),\n    'composition' : \"comp_auto\",\n    'percentCG' : '',\n    'scale_width' : True,\n    'show_errorbars' : True,\n    'logo_title' : '',\n    'logo_label' : '',\n    'show_xaxis': True,\n    'xaxis_label': '',\n    'show_yaxis': True,\n    'yaxis_label': '',\n    'yaxis_scale': 'auto',\n    'yaxis_tic_interval' : '1.0',\n    'show_ends' : True,\n    'show_fineprint' : True,\n    'color_scheme': 'color_auto',\n    'symbols0': '',\n    'symbols1': '',\n    'symbols2': '',\n    'symbols3': '',\n    'symbols4': '',\n    'color0': '',\n    'color1': '',\n    'color2': '',\n    'color3': '',\n    'color4': '',", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/__init__.py", "line_number": 468, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.__init__", "name": "weblogo", "signature": "(self, fname, fmt = 'PNG', **kwds)", "symbol_type": "function"}], "weighted_correlation": [{"docstring": "Weighted Pearson correlation based on weighted population moments.\n\nReturns 0.0 if either weighted variance is 0 or inputs invalid.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 122, "module": "src.metainformant.math.price", "name": "weighted_correlation", "signature": "(x: Sequence[float], y: Sequence[float], weights: Sequence[float]) -> float", "symbol_type": "function"}], "weighted_covariance": [{"docstring": "Weighted population covariance with weights normalized to sum to 1.\n\nIf total weight is 0 or inputs are empty/mismatched, returns 0.0.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 106, "module": "src.metainformant.math.price", "name": "weighted_covariance", "signature": "(x: Sequence[float], y: Sequence[float], weights: Sequence[float]) -> float", "symbol_type": "function"}], "weighted_stepmatrix": [{"docstring": "Calculate a stepmatrix for weighted parsimony.\n\nSee Wheeler (1990), Cladistics 6:269-275 and\nFelsenstein (1981), Biol. J. Linn. Soc. 16:183-196", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 1896, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "weighted_stepmatrix", "signature": "(self, name = 'your_name_here', exclude = (), delete = ())", "symbol_type": "function"}], "weighted_variance": [{"docstring": "Weighted population variance with weights normalized to sum to 1.\n\nIf total weight is 0 or inputs are empty/mismatched, returns 0.0.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/math/price.py", "line_number": 91, "module": "src.metainformant.math.price", "name": "weighted_variance", "signature": "(values: Sequence[float], weights: Sequence[float]) -> float", "symbol_type": "function"}], "weighting": [{"docstring": "Calculate the Phylogenetic weight matrix.\n\nConstructed from the logarithmic transformation of the\ntransformation matrix.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 221, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "weighting", "signature": "(self)", "symbol_type": "function"}], "wgs": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 420, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "wgs", "signature": "(self, content)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/GenBank/__init__.py", "line_number": 900, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.GenBank.__init__", "name": "wgs", "signature": "(self, content)", "symbol_type": "function"}], "with_N_sites": [{"docstring": "Return only results from enzymes that cut the sequence N times.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2422, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "with_N_sites", "signature": "(self, N, dct = None)", "symbol_type": "function"}], "with_name": [{"docstring": "Return only results from enzymes which names are listed.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2434, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "with_name", "signature": "(self, names, dct = None)", "symbol_type": "function"}], "with_number_list": [{"docstring": "Return only results from enzymes that cut (x,y,z,...) times.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2428, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "with_number_list", "signature": "(self, list, dct = None)", "symbol_type": "function"}], "with_site_size": [{"docstring": "Return only results form enzymes with a given site size.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2444, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "with_site_size", "signature": "(self, site_size, dct = None)", "symbol_type": "function"}], "with_sites": [{"docstring": "Return only results from enzyme with at least one cut.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2410, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "with_sites", "signature": "(self, dct = None)", "symbol_type": "function"}], "without_site": [{"docstring": "Return only results from enzymes that don't cut the sequence.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Restriction/Restriction.py", "line_number": 2416, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Restriction.Restriction", "name": "without_site", "signature": "(self, dct = None)", "symbol_type": "function"}], "wrapped": [{"docstring": "Wrap nodes and subnodes as elements.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 676, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "wrapped", "signature": "(self, obj)", "symbol_type": "function"}, {"docstring": "Wrap node as element.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 700, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "wrapped", "signature": "(self, obj)", "symbol_type": "function"}], "wrapped_init": [{"docstring": "An attribute named `self` received from the api will conflicts with the reserved `self`\nparameter of a class method. During generation, `self` attributes are mapped\nto `_self` in models. Here, we name `_self` instead of `self` to avoid conflicts.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/sdists-v9/pypi/ncbi-datasets-pylib/16.6.1/DTTnjhGltZSWISoyFbRJI/src/src/ncbi/datasets/openapi/model_utils.py", "line_number": 36, "module": ".uv-cache.sdists-v9.pypi.ncbi-datasets-pylib.16.6.1.DTTnjhGltZSWISoyFbRJI.src.src.ncbi.datasets.openapi.model_utils", "name": "wrapped_init", "signature": "(_self, *args, **kwargs)", "symbol_type": "function"}], "wrapper": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/errors.py", "line_number": 130, "module": "src.metainformant.core.errors", "name": "wrapper", "signature": "(*args: Any, **kwargs: Any) -> T", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/validation.py", "line_number": 259, "module": "src.metainformant.core.validation", "name": "wrapper", "signature": "(value: Any, name: str = 'value') -> None", "symbol_type": "function"}], "write": [{"docstring": "Write method for the class.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/bgzf.py", "line_number": 858, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.bgzf", "name": "write", "signature": "(self, data)", "symbol_type": "function"}, {"docstring": "Write alignments to a file.\n\nArguments:\n - alignments - An Alignments object, an iterator of Alignment objects, or\n   a single Alignment.\n - target     - File or file-like object to write to, or filename as string.\n - fmt        - String describing the file format (case-insensitive).\n\nNote if providing a file or file-like object, your code should close the\ntarget after calling this function, or call .flush(), to ensure the data\ngets flushed to disk.\n\nReturns the number of alignments written (as an integer).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/__init__.py", "line_number": 4854, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.__init__", "name": "write", "signature": "(alignments, target, fmt, *args, **kwargs)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1101, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "write", "signature": "(self, item)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 1117, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "write", "signature": "(self, item)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 2076, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "write", "signature": "(self, items, blockSize, itemsPerSlot, endFileOffset, output)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 2191, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "write", "signature": "(self, items, blockSize, output)", "symbol_type": "function"}, {"docstring": "Write a file with the alignments, and return the number of alignments.\n\nalignments - A list or iterator returning Alignment objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/interfaces.py", "line_number": 332, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.interfaces", "name": "write", "signature": "(self, alignments)", "symbol_type": "function"}, {"docstring": "Write complete set of alignments to a file.\n\nArguments:\n - alignments - A list (or iterator) of MultipleSeqAlignment objects,\n   or a single alignment object.\n - handle    - File handle object to write to, or filename as string\n   (note older versions of Biopython only took a handle).\n - format    - lower case string describing the file format to write.\n\nYou should close the handle after calling this function.\n\nReturns the number of alignments written (as an integer).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/__init__.py", "line_number": 183, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.__init__", "name": "write", "signature": "(alignments, handle, format)", "symbol_type": "function"}, {"docstring": "Write BLAST records as an XML file, and return the number of records.\n\nArguments:\n - records     - A ``Bio.Blast.Records`` object.\n - destination - File or file-like object to write to, or filename as\n                 string.\n                 The File object must have been opened for writing in\n                 binary mode, and must be closed (or flushed) by the caller\n                 after this function returns to ensure that all records are\n                 written.\n - fmt         - string describing the file format to write\n                 (case-insensitive).\n                 Currently, only \"XML\" and \"XML2\" are accepted.\n\nReturns the number of records written (as an integer).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/__init__.py", "line_number": 967, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast.__init__", "name": "write", "signature": "(records, destination, fmt = 'XML')", "symbol_type": "function"}, {"docstring": "Write the records.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Blast/_writers.py", "line_number": 28, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Blast._writers", "name": "write", "signature": "(self, records)", "symbol_type": "function"}, {"docstring": "Write the drawn diagram to a specified file, in a specified format.\n\nArguments:\n    - filename   - a string indicating the name of the output file,\n      or a handle to write to.\n    - output     - a string indicating output format, one of PS, PDF,\n      SVG, or provided the ReportLab renderPM module is installed, one\n      of the bitmap formats JPG, BMP, GIF, PNG, TIFF or TIFF.  The\n      format can be given in upper or lower case.\n    - dpi        - an integer. Resolution (dots per inch) for bitmap formats.\n\nReturns:\n    No return value.\n\nwrite(self, filename='test1.ps', output='PS', dpi=72)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Diagram.py", "line_number": 226, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Diagram", "name": "write", "signature": "(self, filename = 'test1.ps', output = 'PS', dpi = 72)", "symbol_type": "function"}, {"docstring": "Write a trees in CDAO format to the given file handle.\n\n:returns: number of trees written.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 82, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "write", "signature": "(trees, handle, plain = False, **kwargs)", "symbol_type": "function"}, {"docstring": "Write this instance's trees to a file handle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/CDAOIO.py", "line_number": 274, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.CDAOIO", "name": "write", "signature": "(self, handle, tree_uri = '', record_complete_ancestry = False, rooted = False, **kwargs)", "symbol_type": "function"}, {"docstring": "Write a trees in NeXML format to the given file handle.\n\n:returns: number of trees written.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NeXMLIO.py", "line_number": 78, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NeXMLIO", "name": "write", "signature": "(trees, handle, plain = False, **kwargs)", "symbol_type": "function"}, {"docstring": "Write this instance's trees to a file handle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NeXMLIO.py", "line_number": 227, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NeXMLIO", "name": "write", "signature": "(self, handle, cdao_to_obo = True, **kwargs)", "symbol_type": "function"}, {"docstring": "Write a trees in Newick format to the given file handle.\n\n:returns: number of trees written.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NewickIO.py", "line_number": 53, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NewickIO", "name": "write", "signature": "(trees, handle, plain = False, **kwargs)", "symbol_type": "function"}, {"docstring": "Write this instance's trees to a file handle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NewickIO.py", "line_number": 264, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NewickIO", "name": "write", "signature": "(self, handle, **kwargs)", "symbol_type": "function"}, {"docstring": "Write a new Nexus file containing the given trees.\n\nUses a simple Nexus template and the NewickIO writer to serialize just the\ntrees and minimal supporting info needed for a valid Nexus file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/NexusIO.py", "line_number": 62, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.NexusIO", "name": "write", "signature": "(obj, handle, **kwargs)", "symbol_type": "function"}, {"docstring": "Write a phyloXML file.\n\n:Parameters:\n    obj\n        an instance of ``Phyloxml``, ``Phylogeny`` or ``BaseTree.Tree``,\n        or an iterable of either of the latter two. The object will be\n        converted to a Phyloxml object before serialization.\n    file\n        either an open handle or a file name.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 76, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "write", "signature": "(obj, file, encoding = DEFAULT_ENCODING, indent = True)", "symbol_type": "function"}, {"docstring": "Write PhyloXML to a file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PhyloXMLIO.py", "line_number": 718, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PhyloXMLIO", "name": "write", "signature": "(self, file, encoding = DEFAULT_ENCODING, indent = True)", "symbol_type": "function"}, {"docstring": "Write a sequence of trees to file in the given format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/_io.py", "line_number": 74, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo._io", "name": "write", "signature": "(trees, file, format, **kwargs)", "symbol_type": "function"}, {"docstring": "Write QueryResult objects to a file in the given format.\n\n - qresults - An iterator returning QueryResult objects or a single\n              QueryResult object.\n - handle   - Handle to the file, or the filename as a string.\n - format   - Lower case string denoting one of the supported formats.\n - kwargs   - Format-specific keyword arguments.\n\nThe ``write`` function writes QueryResult object(s) into the given output\nhandle / filename. You can supply it with a single QueryResult object or an\niterable returning one or more QueryResult objects. In both cases, the\nfunction will return a tuple of four values: the number of QueryResult, Hit,\nHSP, and HSPFragment objects it writes to the output file::\n\n    from Bio import SearchIO\n    qresults = SearchIO.parse('Blast/mirna.xml', 'blast-xml')\n    SearchIO.write(qresults, 'results.tab', 'blast-tab')\n    <stdout> (3, 239, 277, 277)\n\nThe output of different formats may be adjusted using the format-specific\nkeyword arguments. Here is an example that writes BLAT PSL output file with\na header::\n\n    from Bio import SearchIO\n    qresults = SearchIO.parse('Blat/psl_34_001.psl', 'blat-psl')\n    SearchIO.write(qresults, 'results.tab', 'blat-psl', header=True)\n    <stdout> (2, 13, 22, 26)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/__init__.py", "line_number": 578, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.__init__", "name": "write", "signature": "(qresults, handle, format = None, **kwargs)", "symbol_type": "function"}, {"docstring": "Write complete set of sequences to a file.\n\nArguments:\n - sequences - A list (or iterator) of SeqRecord objects, or a single\n   SeqRecord.\n - handle    - File handle object to write to, or filename as string.\n - format    - lower case string describing the file format to write.\n\nNote if providing a file handle, your code should close the handle\nafter calling this function (to ensure the data gets flushed to disk).\n\nReturns the number of records written (as an integer).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/__init__.py", "line_number": 568, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.__init__", "name": "write", "signature": "(sequences: Iterable[SeqRecord] | SeqRecord, handle: _TextIOSource, format: str) -> int", "symbol_type": "function"}, {"docstring": "Return a string representation of motifs in the given format.\n\nCurrently supported formats (case is ignored):\n - clusterbuster: Cluster Buster position frequency matrix format\n - pfm : JASPAR simple single Position Frequency Matrix\n - jaspar : JASPAR multiple PFM format\n - transfac : TRANSFAC like files", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/__init__.py", "line_number": 616, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.__init__", "name": "write", "signature": "(motifs, fmt, **kwargs)", "symbol_type": "function"}, {"docstring": "Return the representation of motifs in Cluster Buster position frequency matrix format.\n\nBy default (`precision=0`) Cluster Buster position frequency matrices will be written\nwith integer values.\nIf a higher precision value is set, Cluster Buster position frequency matrices will be\nwritten as floats with `x` decimal places.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/clusterbuster.py", "line_number": 80, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.clusterbuster", "name": "write", "signature": "(motifs, precision = 0)", "symbol_type": "function"}, {"docstring": "Return the representation of motifs in Cluster Buster position frequency matrix format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/pfm.py", "line_number": 409, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.pfm", "name": "write", "signature": "(motifs)", "symbol_type": "function"}, {"docstring": "Write the representation of a motif in TRANSFAC format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/transfac.py", "line_number": 228, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.transfac", "name": "write", "signature": "(motifs)", "symbol_type": "function"}, {"docstring": "Return the representation of motifs in \"pfm\" or \"jaspar\" format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/motifs/jaspar/__init__.py", "line_number": 172, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.motifs.jaspar.__init__", "name": "write", "signature": "(motifs, format)", "symbol_type": "function"}, {"docstring": "Write complete set of PlateRecords to a file.\n\n - plates    - A list (or iterator) of PlateRecord objects.\n - handle    - File handle object to write to, or filename as string\n               (note older versions of Biopython only took a handle).\n - format    - lower case string describing the file format to write.\n\nYou should close the handle after calling this function.\n\nReturns the number of records written (as an integer).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/__init__.py", "line_number": 110, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.__init__", "name": "write", "signature": "(plates, handle, format)", "symbol_type": "function"}, {"docstring": "Write this instance's plates to a file handle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/phenotype/phen_micro.py", "line_number": 1192, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.phenotype.phen_micro", "name": "write", "signature": "(self, handle)", "symbol_type": "function"}], "writeToSQL": [{"docstring": "Write the ASTRAL database to a MYSQL database.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 886, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "writeToSQL", "signature": "(self, db_handle)", "symbol_type": "function"}], "write_PDB": [{"docstring": "Write PDB file with HEADER and TITLE if available.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/ic_rebuild.py", "line_number": 477, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.ic_rebuild", "name": "write_PDB", "signature": "(entity: Structure, file: str, pdbid: str = None, chainid: str = None) -> None", "symbol_type": "function"}], "write_PIC": [{"docstring": "Write Protein Internal Coordinates (PIC) to file.\n\nSee :func:`read_PIC` for file format.\nSee :data:`IC_Residue.pic_accuracy` to vary numeric accuracy.\nRecurses to lower entity levels (M, C, R).\n\n:param Entity entity: Biopython PDB Entity object: S, M, C or R\n:param Bio.File file: :func:`.as_handle` file name or handle\n:param str pdbid: PDB idcode, read from entity if not supplied\n:param char chainid: PDB Chain ID, set from C level entity.id if needed\n:param int picFlags: boolean flags controlling output, defined in\n    :data:`Bio.PDB.internal_coords.IC_Residue.pic_flags`\n\n    * \"psi\",\n    * \"omg\",\n    * \"phi\",\n    * \"tau\",  # tau hedron (N-Ca-C)\n    * \"chi1\",\n    * \"chi2\",\n    * \"chi3\",\n    * \"chi4\",\n    * \"chi5\",\n    * \"pomg\",  # proline omega\n    * \"chi\",   # chi1 through chi5\n    * \"classic_b\",  # psi | phi | tau | pomg\n    * \"classic\",    # classic_b | chi\n    * \"hedra\",      # all hedra including bond lengths\n    * \"primary\",    # all primary dihedra\n    * \"secondary\",  # all secondary dihedra (fixed angle from primary dihedra)\n    * \"all\",        # hedra | primary | secondary\n    * \"initAtoms\",  # XYZ coordinates of initial Tau (N-Ca-C)\n    * \"bFactors\"\n\n    default is everything::\n\n        picFlagsDefault = (\n            pic_flags.all | pic_flags.initAtoms | pic_flags.bFactors\n        )\n\n    Usage in your code::\n\n        # just primary dihedra and all hedra\n        picFlags = (\n            IC_Residue.pic_flags.primary | IC_Residue.pic_flags.hedra\n        )\n\n        # no B-factors:\n        picFlags = IC_Residue.picFlagsDefault\n        picFlags &= ~IC_Residue.pic_flags.bFactors\n\n    :func:`read_PIC` with `(defaults=True)` will use default values for\n    anything left out\n\n:param float hCut: default None\n    only write hedra with ref db angle std dev greater than this value\n:param float pCut: default None\n    only write primary dihedra with ref db angle std dev greater than this\n    value\n\n**Default values**:\n\nData averaged from Sep 2019 Dunbrack cullpdb_pc20_res2.2_R1.0.\n\nPlease see\n\n`PISCES: A Protein Sequence Culling Server <https://dunbrack.fccc.edu/pisces/>`_\n\n'G. Wang and R. L. Dunbrack, Jr. PISCES: a protein sequence culling\nserver. Bioinformatics, 19:1589-1591, 2003.'\n\n'primary' and 'secondary' dihedra are defined in ic_data.py.  Specifically,\nsecondary dihedra can be determined as a fixed rotation from another known\nangle, for example N-Ca-C-O can be estimated from N-Ca-C-N (psi).\n\nStandard deviations are listed in\n<biopython distribution>/Bio/PDB/ic_data.py for default values, and can be\nused to limit which hedra and dihedra are defaulted vs. output exact\nmeasurements from structure (see hCut and pCut above).  Default values for\nprimary dihedra (psi, phi, omega, chi1, etc.) are chosen as the most common\ninteger value, not an average.\n\n:raises PDBException: if entity level is A (Atom)\n:raises Exception: if entity does not have .level attribute", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/PICIO.py", "line_number": 945, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.PICIO", "name": "write_PIC", "signature": "(entity, file, pdbid = None, chainid = None, picFlags: int = IC_Residue.picFlagsDefault, hCut: float | None = None, pCut: float | None = None)", "symbol_type": "function"}], "write_SCAD": [{"docstring": "Write hedron assembly to file as OpenSCAD matrices.\n\nThis routine calls both :meth:`.IC_Chain.internal_to_atom_coordinates` and\n:meth:`.IC_Chain.atom_to_internal_coordinates` due to requirements for\nscaling, explicit bonds around rings, and setting the coordinate space of\nthe output model.\n\nOutput data format is primarily:\n\n- matrix for each hedron:\n    len1, angle2, len3, atom covalent bond class, flags to indicate\n    atom/bond represented in previous hedron (OpenSCAD very slow with\n    redundant overlapping elements), flags for bond features\n- transform matrices to assemble each hedron into residue dihedra sets\n- transform matrices for each residue to position in chain\n\nOpenSCAD software is included in this Python file to process these\nmatrices into a model suitable for a 3D printing project.\n\n:param entity: Biopython PDB :class:`.Structure` entity\n    structure data to export\n:param file: Bipoython :func:`.as_handle` filename or open file pointer\n    file to write data to\n:param float scale:\n    units (usually mm) per angstrom for STL output, written in output\n:param str pdbid:\n    PDB idcode, written in output. Defaults to '0PDB' if not supplied\n    and no 'idcode' set in entity\n:param bool backboneOnly: default False.\n    Do not output side chain data past Cbeta if True\n:param bool includeCode: default True.\n    Include OpenSCAD software (inline below) so output file can be loaded\n    into OpenSCAD; if False, output data matrices only\n:param float maxPeptideBond: Optional default None.\n    Override the cut-off in IC_Chain class (default 1.4) for detecting\n    chain breaks.  If your target has chain breaks, pass a large number\n    here to create a very long 'bond' spanning the break.\n:param int start,fin: default None\n    Parameters for internal_to_atom_coords() to limit chain segment.\n:param str handle: default 'protein'\n    name for top level of generated OpenSCAD matrix structure\n\nSee :meth:`.IC_Residue.set_flexible` to set flags for specific residues to\nhave rotatable bonds, and :meth:`.IC_Residue.set_hbond` to include cavities\nfor small magnets to work as hydrogen bonds.\nSee <https://www.thingiverse.com/thing:3957471> for implementation example.\n\nThe OpenSCAD code explicitly creates spheres and cylinders to\nrepresent atoms and bonds in a 3D model.  Options are available\nto support rotatable bonds and magnetic hydrogen bonds.\n\nMatrices are written to link, enumerate and describe residues,\ndihedra, hedra, and chains, mirroring contents of the relevant IC_*\ndata structures.\n\nThe OpenSCAD matrix of hedra has additional information as follows:\n\n* the atom and bond state (single, double, resonance) are logged\n    so that covalent radii may be used for atom spheres in the 3D models\n\n* bonds and atoms are tracked so that each is only created once\n\n* bond options for rotation and magnet holders for hydrogen bonds\n    may be specified (see :meth:`.IC_Residue.set_flexible` and\n    :meth:`.IC_Residue.set_hbond` )\n\nNote the application of :data:`Bio.PDB.internal_coords.IC_Chain.MaxPeptideBond`\n:  missing residues may be linked (joining chain segments with arbitrarily\nlong bonds) by setting this to a large value.\n\nNote this uses the serial assembly per residue, placing each residue at\nthe origin and supplying the coordinate space transform to OpenaSCAD\n\nAll ALTLOC (disordered) residues and atoms are written to the output\nmodel.  (see :data:`Bio.PDB.internal_coords.IC_Residue.no_altloc`)", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/PDB/SCADIO.py", "line_number": 65, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.PDB.SCADIO", "name": "write_SCAD", "signature": "(entity, file, scale = None, pdbid = None, backboneOnly = False, includeCode = True, maxPeptideBond = None, start = None, fin = None, handle = 'protein')", "symbol_type": "function"}], "write_alignment": [{"docstring": "Write a single alignment to the output file.\n\n- alignment  - An Alignment object\n- stream     - output stream\n- interleave - if None (default): interleave if columns > 1000\n               if True: use interleaved format\n               if False: do not use interleaved format", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/nexus.py", "line_number": 78, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.nexus", "name": "write_alignment", "signature": "(self, alignment, stream, interleave = None)", "symbol_type": "function"}, {"docstring": "Use this to write (another) single alignment to an open file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/ClustalIO.py", "line_number": 23, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.ClustalIO", "name": "write_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Use this to write a single alignment.\n\nThis method should be replaced by any derived class to do something\nuseful.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/Interfaces.py", "line_number": 148, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.Interfaces", "name": "write_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Write a complete alignment to a MAF block.\n\nWrites every SeqRecord in a MultipleSeqAlignment object to its own\nMAF block (beginning with an 'a' line, containing 's' lines).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/MafIO.py", "line_number": 85, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.MafIO", "name": "write_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Use this to write (another) single alignment to an open file.\n\nNote that sequences and their annotation are recorded\ntogether (rather than having a block of annotation followed\nby a block of aligned sequences).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/MauveIO.py", "line_number": 115, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.MauveIO", "name": "write_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Write an alignment to file.\n\nCreates an empty Nexus object, adds the sequences\nand then gets Nexus to prepare the output.\nDefault interleave behaviour: Interleave if columns > 1000\n--> Override with interleave=[True/False]", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/NexusIO.py", "line_number": 119, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.NexusIO", "name": "write_alignment", "signature": "(self, alignment, interleave = None)", "symbol_type": "function"}, {"docstring": "Use this to write (another) single alignment to an open file.\n\nThis code will write interlaced alignments (when the sequences are\nlonger than 50 characters).\n\nNote that record identifiers are strictly truncated to id_width,\ndefaulting to the value required to comply with the PHYLIP standard.\n\nFor more information on the file format, please see:\nhttp://evolution.genetics.washington.edu/phylip/doc/sequence.html\nhttp://evolution.genetics.washington.edu/phylip/doc/main.html#inputfiles", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/PhylipIO.py", "line_number": 54, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.PhylipIO", "name": "write_alignment", "signature": "(self, alignment, id_width = _PHYLIP_ID_WIDTH)", "symbol_type": "function"}, {"docstring": "Write a relaxed phylip alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/PhylipIO.py", "line_number": 273, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.PhylipIO", "name": "write_alignment", "signature": "(self, alignment)", "symbol_type": "function"}, {"docstring": "Write a Phylip alignment to the handle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/PhylipIO.py", "line_number": 309, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.PhylipIO", "name": "write_alignment", "signature": "(self, alignment, id_width = _PHYLIP_ID_WIDTH)", "symbol_type": "function"}, {"docstring": "Use this to write (another) single alignment to an open file.\n\nNote that sequences and their annotation are recorded\ntogether (rather than having a block of annotation followed\nby a block of aligned sequences).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/StockholmIO.py", "line_number": 183, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.StockholmIO", "name": "write_alignment", "signature": "(self, alignment)", "symbol_type": "function"}], "write_alignments": [{"docstring": "Write alignments to the output file, and return the number of alignments.\n\nalignments - A list or iterator returning Alignment objects\nstream     - Output file stream.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 601, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "write_alignments", "signature": "(self, alignments, output, reductions, extra_indices)", "symbol_type": "function"}, {"docstring": "Write alignments to the output file, and return the number of alignments.\n\nalignments - A list or iterator returning Alignment objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/nexus.py", "line_number": 116, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.nexus", "name": "write_alignments", "signature": "(self, stream, alignments)", "symbol_type": "function"}], "write_cla": [{"docstring": "Build a CLA SCOP parsable file from this object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 337, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "write_cla", "signature": "(self, handle)", "symbol_type": "function"}], "write_cla_sql": [{"docstring": "Write CLA data to SQL database.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 498, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "write_cla_sql", "signature": "(self, handle)", "symbol_type": "function"}], "write_csv": [{"docstring": "Write CSV file using pandas if available, fallback to native implementation.\n\nArgs:\n    data: pandas DataFrame or dict-like data to write\n    path: Output file path\n    **kwargs: Additional arguments passed to pandas DataFrame.to_csv if pandas available", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 289, "module": "src.metainformant.core.io", "name": "write_csv", "signature": "(data: Any, path: str | Path, **kwargs) -> None", "symbol_type": "function"}], "write_ctl_file": [{"docstring": "Write control file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/_paml.py", "line_number": 37, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML._paml", "name": "write_ctl_file", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Dynamically build a BASEML control file from the options.\n\nThe control file is written to the location specified by the\nctl_file property of the Baseml class.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/baseml.py", "line_number": 68, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.baseml", "name": "write_ctl_file", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Dynamically build a CODEML control file from the options.\n\nThe control file is written to the location specified by the\nctl_file property of the Codeml class.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/codeml.py", "line_number": 73, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.codeml", "name": "write_ctl_file", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Dynamically build a YN00 control file from the options.\n\nThe control file is written to the location specified by the\nctl_file property of the Yn00 class.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Phylo/PAML/yn00.py", "line_number": 44, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Phylo.PAML.yn00", "name": "write_ctl_file", "signature": "(self)", "symbol_type": "function"}], "write_delimited": [{"docstring": "Write rows to delimited text file (CSV/TSV).\n\nArgs:\n    rows: Iterable of dictionaries to write\n    path: Output file path\n    delimiter: Field delimiter (default: comma for CSV, use \"\\t\" for TSV)\n    atomic: If True, write to temp file then rename (prevents corruption)\n\nRaises:\n    IOError: If file write fails", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 206, "module": "src.metainformant.core.io", "name": "write_delimited", "signature": "(rows: Iterable[Mapping[str, Any]], path: str | Path) -> None", "symbol_type": "function"}], "write_des": [{"docstring": "Build a DES SCOP parsable file from this object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 330, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "write_des", "signature": "(self, handle)", "symbol_type": "function"}], "write_des_sql": [{"docstring": "Write DES data to SQL database.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 529, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "write_des_sql", "signature": "(self, handle)", "symbol_type": "function"}], "write_double_quoted": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 926, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "write_double_quoted", "signature": "(self, text, split = True)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 926, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "write_double_quoted", "signature": "(self, text, split = True)", "symbol_type": "function"}], "write_file": [{"docstring": "Write the alignments to the file stream, and return the number of alignments.\n\nalignments - A list or iterator returning Alignment objects\nstream     - Output file stream.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigbed.py", "line_number": 280, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigbed", "name": "write_file", "signature": "(self, stream, alignments)", "symbol_type": "function"}, {"docstring": "Write the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigmaf.py", "line_number": 110, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigmaf", "name": "write_file", "signature": "(self, stream, alignments)", "symbol_type": "function"}, {"docstring": "Write the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/bigpsl.py", "line_number": 234, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.bigpsl", "name": "write_file", "signature": "(self, stream, alignments)", "symbol_type": "function"}, {"docstring": "Write the alignments to the file stream, and return the number of alignments.\n\nalignments - A list or iterator returning Alignment objects\nstream     - Output file stream.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/interfaces.py", "line_number": 321, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.interfaces", "name": "write_file", "signature": "(self, stream, alignments)", "symbol_type": "function"}, {"docstring": "Write a file with the alignments, and return the number of alignments.\n\nalignments - A Bio.Align.mauve.AlignmentIterator object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/mauve.py", "line_number": 73, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.mauve", "name": "write_file", "signature": "(self, stream, alignments)", "symbol_type": "function"}, {"docstring": "Write a file with the alignments, and return the number of alignments.\n\nalignments - A list or iterator returning Alignment objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/nexus.py", "line_number": 52, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.nexus", "name": "write_file", "signature": "(self, stream, alignments)", "symbol_type": "function"}, {"docstring": "Use this to write an entire file containing the given alignments.\n\nArguments:\n - alignments - A list or iterator returning MultipleSeqAlignment objects\n\nIn general, this method can only be called once per file.\n\nThis method should be replaced by any derived class to do something\nuseful.  It should return the number of alignments..", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/Interfaces.py", "line_number": 84, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.Interfaces", "name": "write_file", "signature": "(self, alignments)", "symbol_type": "function"}, {"docstring": "Use this to write an entire file containing the given alignments.\n\nArguments:\n - alignments - A list or iterator returning MultipleSeqAlignment objects\n\nIn general, this method can only be called once per file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/Interfaces.py", "line_number": 118, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.Interfaces", "name": "write_file", "signature": "(self, alignments)", "symbol_type": "function"}, {"docstring": "Use this to write an entire file containing the given alignments.\n\nArguments:\n - alignments - A list or iterator returning MultipleSeqAlignment objects.\n   This should hold ONE and only one alignment.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/NexusIO.py", "line_number": 93, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.NexusIO", "name": "write_file", "signature": "(self, alignments)", "symbol_type": "function"}, {"docstring": "Write query results to file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlatIO.py", "line_number": 636, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlatIO", "name": "write_file", "signature": "(self, qresults)", "symbol_type": "function"}, {"docstring": "Write to the handle, return how many QueryResult objects were written.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlastIO/blast_tab.py", "line_number": 691, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlastIO.blast_tab", "name": "write_file", "signature": "(self, qresults)", "symbol_type": "function"}, {"docstring": "Write the XML contents to the output handle.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/BlastIO/blast_xml.py", "line_number": 757, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.BlastIO.blast_xml", "name": "write_file", "signature": "(self, qresults)", "symbol_type": "function"}, {"docstring": "Write to the handle.\n\nReturns a tuple of how many QueryResult, Hit, and HSP objects were written.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HmmerIO/hmmer3_domtab.py", "line_number": 222, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HmmerIO.hmmer3_domtab", "name": "write_file", "signature": "(self, qresults)", "symbol_type": "function"}, {"docstring": "Write to the handle.\n\nReturns a tuple of how many QueryResult, Hit, and HSP objects were written.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SearchIO/HmmerIO/hmmer3_tab.py", "line_number": 224, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SearchIO.HmmerIO.hmmer3_tab", "name": "write_file", "signature": "(self, qresults)", "symbol_type": "function"}, {"docstring": "Write a complete file with the records, and return the number of records.\n\nrecords - A list or iterator returning SeqRecord objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/Interfaces.py", "line_number": 237, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.Interfaces", "name": "write_file", "signature": "(self, records)", "symbol_type": "function"}], "write_filtered_vcf": [{"docstring": "Write filtered VCF file with only passing variants.\n\nWrites a VCF file containing only variants that passed QC filters,\npreserving the original VCF format and metadata.\n\nArgs:\n    vcf_data: Parsed VCF data from parse_vcf_full()\n    passing_indices: List of variant indices to include in output\n    output_path: Path to output VCF file (supports .gz extension)\n\nRaises:\n    ValueError: If vcf_data is missing required fields\n    IOError: If file writing fails", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/gwas/quality.py", "line_number": 442, "module": "src.metainformant.gwas.quality", "name": "write_filtered_vcf", "signature": "(vcf_data: dict[str, Any], passing_indices: list[int], output_path: Path) -> None", "symbol_type": "function"}], "write_folded": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 991, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "write_folded", "signature": "(self, text)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 991, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "write_folded", "signature": "(self, text)", "symbol_type": "function"}], "write_footer": [{"docstring": "Write the footer.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/exonerate.py", "line_number": 78, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.exonerate", "name": "write_footer", "signature": "(self, stream)", "symbol_type": "function"}, {"docstring": "Write the file footer to the output file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/interfaces.py", "line_number": 269, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.interfaces", "name": "write_footer", "signature": "(self, stream)", "symbol_type": "function"}, {"docstring": "Use this to write any footer.\n\nThis method should be replaced by any derived class to do something\nuseful.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/Interfaces.py", "line_number": 141, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.Interfaces", "name": "write_footer", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Close the root node and finish the XML document.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 609, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "write_footer", "signature": "(self)", "symbol_type": "function"}], "write_go_summary": [{"docstring": "Write a JSON summary of Gene Ontology statistics to file.\n\nCreates a summary document containing ontology metrics such as number\nof terms, namespaces, root terms, and depth information. Writes to\noutput/ontology/go_summary.json by default.\n\nArgs:\n    onto: Ontology object to summarize\n    dest: Optional destination path for summary file. If None, writes\n        to output/ontology/go_summary.json\n        \nReturns:\n    Path to the created summary file\n    \nExamples:\n    >>> onto = load_go_obo(\"go-basic.obo\")\n    >>> summary_path = write_go_summary(onto)\n    >>> summary_path.exists()\n    True\n    >>> import json\n    >>> data = json.loads(summary_path.read_text())\n    >>> \"num_terms\" in data\n    True\n    >>> \"namespaces\" in data\n    True", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/ontology/go.py", "line_number": 64, "module": "src.metainformant.ontology.go", "name": "write_go_summary", "signature": "(onto: Ontology, dest: str | Path | None = None) -> Path", "symbol_type": "function"}], "write_header": [{"docstring": "Use this to write the file header.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/clustal.py", "line_number": 25, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.clustal", "name": "write_header", "signature": "(self, stream, alignments)", "symbol_type": "function"}, {"docstring": "Write the header.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/exonerate.py", "line_number": 65, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.exonerate", "name": "write_header", "signature": "(self, stream, alignments)", "symbol_type": "function"}, {"docstring": "Write the file header to the output file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/interfaces.py", "line_number": 261, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.interfaces", "name": "write_header", "signature": "(self, stream, alignments)", "symbol_type": "function"}, {"docstring": "Write the MAF header.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/maf.py", "line_number": 70, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.maf", "name": "write_header", "signature": "(self, stream, alignments)", "symbol_type": "function"}, {"docstring": "Write the file header to the output file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/mauve.py", "line_number": 41, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.mauve", "name": "write_header", "signature": "(self, stream, alignments)", "symbol_type": "function"}, {"docstring": "Write the PSL header.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/psl.py", "line_number": 84, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.psl", "name": "write_header", "signature": "(self, stream, alignments)", "symbol_type": "function"}, {"docstring": "Write the SAM header.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/sam.py", "line_number": 55, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.sam", "name": "write_header", "signature": "(self, stream, alignments)", "symbol_type": "function"}, {"docstring": "Use this to write any header.\n\nThis method should be replaced by any derived class to do something\nuseful.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/Interfaces.py", "line_number": 134, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.Interfaces", "name": "write_header", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Write the MAF header.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/AlignIO/MafIO.py", "line_number": 56, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.AlignIO.MafIO", "name": "write_header", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Write header lines from input file to handle ``outfn``.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/NMR/xpktools.py", "line_number": 167, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.NMR.xpktools", "name": "write_header", "signature": "(self, outfn)", "symbol_type": "function"}, {"docstring": "Write the file header.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/NibIO.py", "line_number": 127, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.NibIO", "name": "write_header", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Write root node with document metadata.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 560, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "write_header", "signature": "(self)", "symbol_type": "function"}, {"docstring": "Write the SFF file header.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SffIO.py", "line_number": 1298, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SffIO", "name": "write_header", "signature": "(self)", "symbol_type": "function"}], "write_hie": [{"docstring": "Build an HIE SCOP parsable file from this object.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 324, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "write_hie", "signature": "(self, handle)", "symbol_type": "function"}], "write_hie_sql": [{"docstring": "Write HIE data to SQL database.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SCOP/__init__.py", "line_number": 484, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SCOP.__init__", "name": "write_hie_sql", "signature": "(self, handle)", "symbol_type": "function"}], "write_indent": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 814, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "write_indent", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 814, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "write_indent", "signature": "(self)", "symbol_type": "function"}], "write_indicator": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 800, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "write_indicator", "signature": "(self, indicator, need_whitespace, whitespace = False, indention = False)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 800, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "write_indicator", "signature": "(self, indicator, need_whitespace, whitespace = False, indention = False)", "symbol_type": "function"}], "write_jsonl": [{"docstring": "Write rows as JSON Lines format (one JSON object per line).\n\nArgs:\n    rows: Iterable of dictionaries to write\n    path: Output file path\n    atomic: If True, write to temp file then rename (prevents corruption)\n\nRaises:\n    IOError: If file write fails", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 143, "module": "src.metainformant.core.io", "name": "write_jsonl", "signature": "(rows: Iterable[Mapping[str, Any]], path: str | Path) -> None", "symbol_type": "function"}], "write_line_break": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 827, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "write_line_break", "signature": "(self, data = None)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 827, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "write_line_break", "signature": "(self, data = None)", "symbol_type": "function"}], "write_literal": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 1045, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "write_literal", "signature": "(self, text)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 1045, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "write_literal", "signature": "(self, text)", "symbol_type": "function"}], "write_multiple_alignments": [{"docstring": "Write alignments to the output file, and return the number of alignments.\n\nalignments - A list or iterator returning Alignment objects\nstream     - Output file stream.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/interfaces.py", "line_number": 306, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.interfaces", "name": "write_multiple_alignments", "signature": "(self, stream, alignments)", "symbol_type": "function"}], "write_nexus_data": [{"docstring": "Write a nexus file with data and sets block to a file or handle.\n\nCharacter sets and partitions are appended by default, and are\nadjusted according to excluded characters (i.e. character sets\nstill point to the same sites (not necessarily same positions),\nwithout including the deleted characters.\n\n- filename - Either a filename as a string (which will be opened,\n  written to and closed), or a handle object (which will\n  be written to but NOT closed).\n- interleave_by_partition - Optional name of partition (string)\n- omit_NEXUS - Boolean.  If true, the '#NEXUS' line normally at the\n  start of the file is omitted.\n\nReturns the filename/handle used to write the data.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 1500, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "write_nexus_data", "signature": "(self, filename = None, matrix = None, exclude = (), delete = (), blocksize = None, interleave = False, interleave_by_partition = False, comment = None, omit_NEXUS = False, append_sets = True, mrbayes = False, codons_block = True)", "symbol_type": "function"}], "write_nexus_data_partitions": [{"docstring": "Write a nexus file for each partition in charpartition.\n\nOnly non-excluded characters and non-deleted taxa are included,\njust the data block is written.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Nexus/Nexus.py", "line_number": 1435, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Nexus.Nexus", "name": "write_nexus_data_partitions", "signature": "(self, matrix = None, filename = None, blocksize = None, interleave = False, exclude = (), delete = (), charpartition = None, comment = '', mrbayes = False)", "symbol_type": "function"}], "write_parquet": [{"docstring": "Write DataFrame to Parquet file.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 115, "module": "src.metainformant.core.io", "name": "write_parquet", "signature": "(df: Any, path: str | Path, **kwargs) -> None", "symbol_type": "function"}], "write_plain": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 1080, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "write_plain", "signature": "(self, text, split = True)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 1080, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "write_plain", "signature": "(self, text, split = True)", "symbol_type": "function"}], "write_progress": [{"docstring": "Write download progress information.\n\nArgs:\n    done: Bytes downloaded so far\n    total: Total bytes expected (None if unknown)", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/dna/ncbi.py", "line_number": 249, "module": "src.metainformant.dna.ncbi", "name": "write_progress", "signature": "(done: int, total: int | None) -> None", "symbol_type": "function"}], "write_record": [{"docstring": "Write a single Fasta record to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/FastaIO.py", "line_number": 562, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.FastaIO", "name": "write_record", "signature": "(self, record)", "symbol_type": "function"}, {"docstring": "Write a single record to the output file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/InsdcIO.py", "line_number": 1039, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.InsdcIO", "name": "write_record", "signature": "(self, record)", "symbol_type": "function"}, {"docstring": "Write a single record to the output file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/InsdcIO.py", "line_number": 1456, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.InsdcIO", "name": "write_record", "signature": "(self, record)", "symbol_type": "function"}, {"docstring": "Write a single record to the output file.\n\nrecord - a SeqRecord object", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/Interfaces.py", "line_number": 220, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.Interfaces", "name": "write_record", "signature": "(self, record)", "symbol_type": "function"}, {"docstring": "Write a single record to the output file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/NibIO.py", "line_number": 139, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.NibIO", "name": "write_record", "signature": "(self, record)", "symbol_type": "function"}, {"docstring": "Write a single Phd record to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/PhdIO.py", "line_number": 118, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.PhdIO", "name": "write_record", "signature": "(self, record)", "symbol_type": "function"}, {"docstring": "Write a single PIR record to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/PirIO.py", "line_number": 236, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.PirIO", "name": "write_record", "signature": "(self, record)", "symbol_type": "function"}, {"docstring": "Write a single FASTQ record to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1647, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "write_record", "signature": "(self, record: SeqRecord) -> None", "symbol_type": "function"}, {"docstring": "Write a single QUAL record to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1762, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "write_record", "signature": "(self, record: SeqRecord) -> None", "symbol_type": "function"}, {"docstring": "Write a single FASTQ record to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1915, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "write_record", "signature": "(self, record: SeqRecord) -> None", "symbol_type": "function"}, {"docstring": "Write a single FASTQ record to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/QualityIO.py", "line_number": 1993, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.QualityIO", "name": "write_record", "signature": "(self, record: SeqRecord) -> None", "symbol_type": "function"}, {"docstring": "Write one record.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 583, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "write_record", "signature": "(self, record)", "symbol_type": "function"}, {"docstring": "Write a single additional record to the output file.\n\nThis assumes the header has been done.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SffIO.py", "line_number": 1344, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SffIO", "name": "write_record", "signature": "(self, record)", "symbol_type": "function"}, {"docstring": "Write a single tab line to the file.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/TabIO.py", "line_number": 130, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.TabIO", "name": "write_record", "signature": "(self, record)", "symbol_type": "function"}], "write_records": [{"docstring": "Write records to the output file, and return the number of records.\n\nrecords - A list or iterator returning SeqRecord objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/Interfaces.py", "line_number": 226, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.Interfaces", "name": "write_records", "signature": "(self, records)", "symbol_type": "function"}, {"docstring": "Write records to the output file, and return the number of records.\n\nrecords - A list or iterator returning SeqRecord objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/NibIO.py", "line_number": 155, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.NibIO", "name": "write_records", "signature": "(self, records)", "symbol_type": "function"}, {"docstring": "Write records to the output file, and return the number of records.\n\nrecords - A list or iterator returning SeqRecord objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SeqXmlIO.py", "line_number": 550, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SeqXmlIO", "name": "write_records", "signature": "(self, records)", "symbol_type": "function"}, {"docstring": "Write records to the output file, and return the number of records.\n\nrecords - A list or iterator returning SeqRecord objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/SffIO.py", "line_number": 1144, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.SffIO", "name": "write_records", "signature": "(self, records)", "symbol_type": "function"}, {"docstring": "Write the specified record to a Xdna file.\n\nNote that the function expects a list (or iterable) of records\nas per the SequenceWriter interface, but the list should contain\nonly one record as the Xdna format is a mono-record format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/XdnaIO.py", "line_number": 229, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.XdnaIO", "name": "write_records", "signature": "(self, records)", "symbol_type": "function"}, {"docstring": "Write records to the output file, and return the number of records.\n\nrecords - A list or iterator returning SeqRecord objects", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqIO/__init__.py", "line_number": 535, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqIO.__init__", "name": "write_records", "signature": "(self, records)", "symbol_type": "function"}], "write_select_outputs": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/select.py", "line_number": 5, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.select", "name": "write_select_outputs", "signature": "(path_metadata_original, path_metadata_table, metadata_dir, metadata)", "symbol_type": "function"}], "write_single_alignment": [{"docstring": "Write a single alignment to the output file, and return 1.\n\nalignments - A list or iterator returning Alignment objects\nstream     - Output file stream.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Align/interfaces.py", "line_number": 289, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Align.interfaces", "name": "write_single_alignment", "signature": "(self, stream, alignments)", "symbol_type": "function"}], "write_single_quoted": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 854, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "write_single_quoted", "signature": "(self, text, split = True)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 854, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "write_single_quoted", "signature": "(self, text, split = True)", "symbol_type": "function"}], "write_stream_end": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 797, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "write_stream_end", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 797, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "write_stream_end", "signature": "(self)", "symbol_type": "function"}], "write_stream_start": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 792, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "write_stream_start", "signature": "(self)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 792, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "write_stream_start", "signature": "(self)", "symbol_type": "function"}], "write_tag_directive": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 845, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "write_tag_directive", "signature": "(self, handle_text, prefix_text)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 845, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "write_tag_directive", "signature": "(self, handle_text, prefix_text)", "symbol_type": "function"}], "write_to_string": [{"docstring": "Return a byte string containing the diagram in the requested format.\n\nArguments:\n    - output    - a string indicating output format, one of PS, PDF,\n      SVG, JPG, BMP, GIF, PNG, TIFF or TIFF (as specified for the write\n      method).\n    - dpi       - Resolution (dots per inch) for bitmap formats.\n\nReturns:\n    Return the completed drawing as a bytes string in a prescribed\n    format.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Graphics/GenomeDiagram/_Diagram.py", "line_number": 246, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Graphics.GenomeDiagram._Diagram", "name": "write_to_string", "signature": "(self, output = 'PS', dpi = 72)", "symbol_type": "function"}], "write_tsv": [{"docstring": "Write TSV file.", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/core/io.py", "line_number": 338, "module": "src.metainformant.core.io", "name": "write_tsv", "signature": "(data, path: str | Path) -> None", "symbol_type": "function"}], "write_updated_metadata": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/git-v0/checkouts/8da03bf3a2159615/9815ee7/amalgkit/util.py", "line_number": 509, "module": ".uv-cache.git-v0.checkouts.8da03bf3a2159615.9815ee7.amalgkit.util", "name": "write_updated_metadata", "signature": "(metadata, outpath, args)", "symbol_type": "function"}], "write_version_directive": [{"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/-h4nFSA4E3DZHST-KpWQb/yaml/emitter.py", "line_number": 838, "module": ".uv-cache.archive-v0.-h4nFSA4E3DZHST-KpWQb.yaml.emitter", "name": "write_version_directive", "signature": "(self, version_text)", "symbol_type": "function"}, {"docstring": null, "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/kaqbtu2rSqsFYUxXDp0Y-/yaml/emitter.py", "line_number": 838, "module": ".uv-cache.archive-v0.kaqbtu2rSqsFYUxXDp0Y-.yaml.emitter", "name": "write_version_directive", "signature": "(self, version_text)", "symbol_type": "function"}], "writebyproteinrec": [{"docstring": "Write a list of GAF records to an output stream.\n\nCaller should know the  format version. Default: gaf-2.0\nIf header has a value, then it is assumed this is the first record,\na header is written. Typically the list is the one read by fafbyproteinrec, which\ncontains all consecutive lines with the same DB_Object_ID", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/UniProt/GOA.py", "line_number": 475, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.UniProt.GOA", "name": "writebyproteinrec", "signature": "(outprotrec, handle, fields = GAF20FIELDS)", "symbol_type": "function"}], "writerec": [{"docstring": "Write a single UniProt-GOA record to an output stream.\n\nCaller should know the  format version. Default: gaf-2.0\nIf header has a value, then it is assumed this is the first record,\na header is written.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/UniProt/GOA.py", "line_number": 456, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.UniProt.GOA", "name": "writerec", "signature": "(outrec, handle, fields = GAF20FIELDS)", "symbol_type": "function"}], "xGC_skew": [{"docstring": "Calculate and plot normal and accumulated GC skew (GRAPHICS !!!).", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/SeqUtils/__init__.py", "line_number": 216, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.SeqUtils.__init__", "name": "xGC_skew", "signature": "(seq, window = 1000, zoom = 100, r = 300, px = 100, py = 100)", "symbol_type": "function"}], "xmlDeclHandler": [{"docstring": "Set XML handlers when an XML declaration is found.", "file_path": "/media/q/ext6/github/MetaInformAnt/.uv-cache/archive-v0/NeUn6mn0L1Gm2WthJr7f5/Bio/Entrez/Parser.py", "line_number": 526, "module": ".uv-cache.archive-v0.NeUn6mn0L1Gm2WthJr7f5.Bio.Entrez.Parser", "name": "xmlDeclHandler", "signature": "(self, version, encoding, standalone)", "symbol_type": "function"}], "zscore": [{"docstring": "Z-score normalization (requires scipy).\n\nRaises:\n    ImportError: If scipy is not available", "file_path": "/media/q/ext6/github/MetaInformAnt/src/metainformant/singlecell/preprocessing.py", "line_number": 26, "module": "src.metainformant.singlecell.preprocessing", "name": "zscore", "signature": "(*args, **kwargs)", "symbol_type": "function"}]}