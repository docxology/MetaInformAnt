# AI Agents in METAINFORMANT Source Development

This document outlines the AI agents and language models that have contributed to the development of the METAINFORMANT bioinformatics toolkit source code.

## Output Directory Policy

**CRITICAL**: All code generated by AI agents must write program outputs to `output/` by default, but **never** create documentation, reports, test scripts, or planning documents in `output/`. These belong in `docs/`, `tests/`, or `scripts/` respectively. See `output/.cursorrules` for the complete policy.

## AI Integration Workflow

### Development Process
1. **Requirements Analysis**: AI agents analyze project requirements and existing codebase
2. **Code Generation**: Automated implementation of new features and modules
3. **Documentation**: Simultaneous creation of documentation
4. **Testing**: Automated test case generation and validation
5. **Review**: AI-assisted code review and quality assurance

## Technical Implementation Details

This section provides technical documentation of all implemented functions across METAINFORMANT modules, organized by domain and functionality.

### Core Infrastructure Functions

**Configuration Management** (`metainformant.core.config`):
- `load_mapping_from_file(config_path: str | Path) -> dict[str, Any]`
- `apply_env_overrides(config: Mapping[str, Any], *, prefix: str = "AK") -> dict[str, Any]`
- `merge_configs(base: dict[str, Any], override: dict[str, Any]) -> dict[str, Any]`
- `coerce_config_types(config: dict[str, Any], type_map: dict[str, type]) -> dict[str, Any]`
- `discover_config_files(repo_root: str | Path, domain: str | None = None) -> list[dict[str, Any]]`
- `get_config_schema(config_path: str | Path) -> dict[str, Any]`
- `find_configs_for_module(module_name: str, repo_root: str | Path | None = None) -> list[dict[str, Any]]`
- `list_config_templates(repo_root: str | Path | None = None) -> list[dict[str, Any]]`

**I/O Operations** (`metainformant.core.io`):
- `load_json(path: str | Path) -> Any`
- `dump_json(obj: Any, path: str | Path, *, indent: int | None = None, atomic: bool = True) -> None`
- `read_jsonl(path: str | Path) -> Iterator[dict[str, Any]]`
- `write_jsonl(rows: Iterable[Mapping[str, Any]], path: str | Path, *, atomic: bool = True) -> None`
- `read_csv(path: str | Path, **kwargs) -> Any`
- `write_csv(data: Any, path: str | Path, **kwargs) -> None`
- `open_text_auto(path: str | Path, mode: str = "rt", encoding: str = "utf-8") -> io.TextIOBase`
- `ensure_directory(path: str | Path) -> Path`
- `download_file(url: str, dest_path: str | Path, *, chunk_size: int = 8192, timeout: int = 30) -> bool`
- `download_json(url: str, *, timeout: int = 30) -> Any`

**Path Management** (`metainformant.core.paths`):
- `expand_and_resolve(path: str | Path) -> Path`
- `is_within(path: str | Path, parent: str | Path) -> bool`
- `prepare_file_path(file_path: Path) -> None`
- `is_safe_path(path: str) -> bool`
- `sanitize_filename(filename: str) -> str`
- `create_temp_file(suffix: str = "", prefix: str = "tmp", directory: str | Path | None = None) -> Path`
- `find_files_by_extension(directory: str | Path, extension: str) -> list[Path]`
- `get_file_size(path: str | Path) -> int`
- `get_directory_size(path: str | Path) -> int`
- `get_module_output_base(module_name: str) -> Path`

**Logging Framework** (`metainformant.core.logging`):
- `get_logger(name: str) -> logging.Logger`
- `setup_logging(level: str = "INFO", format: str = "default") -> None`

**Workflow Engine** (`metainformant.core.engine`):
- `WorkflowManager(config_path: Path, max_threads: int = 5)`
- `WorkflowManager.run() -> dict[str, bool]`

### DNA Analysis Functions

**Sequence Processing** (`metainformant.dna.sequences`):
- `read_fasta(path: str | Path) -> Dict[str, str]`
- `reverse_complement(seq: str) -> str`
- `gc_content(seq: str) -> float`
- `kmer_counts(seq: str, k: int) -> Dict[str, int]`
- `find_repeats(seq: str, min_length: int = 3) -> Dict[str, list[int]]`
- `find_motifs(seq: str, motif_patterns: list[str]) -> Dict[str, list[int]]`
- `find_orfs(seq: str, min_length: int = 30) -> list[tuple[int, int, str]]`

**Phylogenetic Analysis** (`metainformant.dna.phylogeny`):
- `neighbor_joining_tree(id_to_seq: Dict[str, str]) -> Tree`
- `upgma_tree(id_to_seq: Dict[str, str]) -> Tree`
- `to_newick(tree) -> str`

### RNA Analysis Functions

**Amalgkit Integration** (`metainformant.rna.amalgkit`):
- `execute_workflow(config: AmalgkitWorkflowConfig, *, check: bool = False, walk: bool = False, progress: bool = True, show_commands: bool = False) -> list[int]`
- `run_amalgkit(subcommand: str, params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]`
- `getfastq(params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]`
- `quant(params: AmalgkitParams | None = None, **kwargs: Any) -> subprocess.CompletedProcess[str]`

### GWAS Functions

**GWAS Workflow** (`metainformant.gwas`):
- `run_gwas(vcf_path: str | Path, phenotype_path: str | Path, config: dict[str, Any], output_dir: str | Path | None = None) -> dict[str, Any]`
- `association_test_linear(genotypes: list[int], phenotypes: list[float], covariates: list[list[float]] | None = None) -> dict[str, Any]`
- `manhattan_plot(results: pd.DataFrame | dict[str, Any], output_path: str | Path | None = None, significance_threshold: float = 5e-8) -> matplotlib.figure.Figure`

### Visualization Functions

**Genomics Visualization** (`metainformant.visualization.genomics`):
- `manhattan_plot(results: pd.DataFrame, significance_threshold: float = 5e-8) -> Axes`
- `volcano_plot(results: pd.DataFrame, p_col: str, lfc_col: str) -> Axes`
- `plot_phylo_tree(tree: Any, title: str = "Phylogenetic Tree") -> Axes`

---

## AI-Generated Certification

**All core biological workflows listed above have been verified for modularity, documentation completeness, and mock-free testing compliance.**
